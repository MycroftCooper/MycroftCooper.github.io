<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spine速通手册</title>
    <link href="/2025/03/18/Spine%E9%80%9F%E9%80%9A%E6%89%8B%E5%86%8C/"/>
    <url>/2025/03/18/Spine%E9%80%9F%E9%80%9A%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Spine动画概念"><a href="#Spine动画概念" class="headerlink" title="Spine动画概念"></a>Spine动画概念</h1><h2 id="按结构划分"><a href="#按结构划分" class="headerlink" title="按结构划分"></a>按结构划分</h2><p>在 Spine 中，附件（Attachments）、槽位（Slots）、骨骼（Bones）和 GameObject 是构成动画的核心元素，它们之间的关系及作用如下：</p><h3 id="骨架（Skeleton）"><a href="#骨架（Skeleton）" class="headerlink" title="骨架（Skeleton）"></a>骨架（Skeleton）</h3><h3 id="皮肤（Skins）"><a href="#皮肤（Skins）" class="headerlink" title="皮肤（Skins）"></a>皮肤（Skins）</h3><p>皮肤允许动画师为角色创建不同的外观，比如不同的装备或服装。</p><p>皮肤是一组可以替换的附件（如图像、网格等）集合，它们定义了角色或对象的不同外观。皮肤可以包含多个替换的图像，这些图像可以分配给同一个槽位，以表示不同的装备或服装选项。</p><p>皮肤不是放在槽位里，而是可以被应用到整个骨架上，换句话说，一个皮肤可以影响骨架上多个槽位的外观。</p><p>在游戏中，你可以动态切换皮肤来更改角色的外观。</p><p>当你在运行时改变皮肤时，Spine 会查找当前皮肤定义中对应各个槽位的附件，并更新槽位以显示新的附件。如果某个槽位在新皮肤中没有对应的附件，则该槽位可能显示为空或保持之前的附件。</p><h3 id="骨骼（Bones）"><a href="#骨骼（Bones）" class="headerlink" title="骨骼（Bones）"></a>骨骼（Bones）</h3><p>骨骼是动画的基础，它们用于构建角色或对象的骨架。骨骼负责定义动画中的运动和变形。</p><p>骨骼形成了一个层级结构，槽位和附件附加到骨骼上，随着骨骼的动作而动作。在 Unity 中，骨骼的信息由 <code>SkeletonAnimation</code> 或 <code>SkeletonRenderer</code> 组件管理。</p><h3 id="槽位（Slots）"><a href="#槽位（Slots）" class="headerlink" title="槽位（Slots）"></a>槽位（Slots）</h3><p>槽位是骨骼的一部分，它们充当容器的角色，用于持有和管理附件。槽位还控制附件的渲染顺序（哪个在上面，哪个在下面）。<br>槽位被分配给骨骼，它决定附件在骨骼上的位置以及如何随着骨骼移动。</p><p><strong>定义</strong>：<br>插槽是骨骼动画中的容器，用于持有和管理图像（通常称为“附件”）的显示和排序。它们是分配给特定骨骼的，并且定义了如何以及何时显示与骨骼相关联的图形元素。</p><p><strong>附件</strong>：<br>附件通常是图像，但也可以是其他类型的对象，如网格、空白图像（用于占位或隐藏）等。附件可以在运行时动态更换，这使得例如换装或道具替换成为可能。</p><p><strong>层级和排序</strong>：<br>在 Spine 动画中，插槽有一个特定的顺序，这决定了图像在视觉上的层级关系。例如，一个角色的衣服可以放在身体的插槽之上，以确保衣服覆盖身体。</p><p><strong>与骨骼的关系</strong>：<br>插槽被分配给特定的骨骼，它们随着骨骼的移动和变换而移动。这意味着，如果一个插槽分配给了手臂的骨骼，那么插槽中的图像会随着手臂的动作而动。</p><p><strong>使用场景：</strong></p><p><strong>换装功能</strong>：<br>通过在运行时更换附件，可以实现角色的换装功能。例如，你可以为角色更换不同的头盔、衣服或武器。</p><p><strong>动画控制</strong>：<br>插槽可以用来控制动画中的图像的显示和隐藏，例如，当一个角色需要拿起或放下一个物品时。</p><p><strong>渲染控制</strong>：<br>通过编程控制插槽，可以实现例如图像的透明度变化或颜色变化等效果。</p><p><strong>如何在 Unity 中使用 Spine 插槽</strong></p><p>在 Unity 的 Spine-Unity 运行时插件中，你可以通过脚本访问和控制插槽。以下是一段示例代码，展示如何在 Unity 中找到并控制插槽：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">SkeletonAnimation skeletonAnimation = GetComponent&lt;SkeletonAnimation&gt;();<br>Skeleton skeleton = skeletonAnimation.Skeleton; <span class="hljs-comment">// 获取骨骼</span><br><br>Slot slot = skeleton.FindSlot(<span class="hljs-string">&quot;weapon&quot;</span>); <span class="hljs-comment">// 假设有一个名为&quot;weapon&quot;的插槽</span><br>slot.Attachment = skeleton.GetAttachment(<span class="hljs-string">&quot;weapon&quot;</span>, <span class="hljs-string">&quot;sword&quot;</span>); <span class="hljs-comment">// 将&quot;weapon&quot;插槽的附件更换为&quot;sword&quot;</span><br></code></pre></td></tr></table></figure><p>上面的代码段演示了如何找到一个名为 “weapon” 的插槽，并将其附件更换为名为 “sword” 的图像。<br>这样的操作通常用于实现换装或道具更换的游戏逻辑。</p><p>理解和掌握插槽的使用，对于深入利用 Spine 动画系统来说是非常重要的。通过插槽，开发者能够创建更加动态和灵活的动画，为游戏角色和物体提供丰富的视觉效果。</p><h3 id="附件（Attachments）"><a href="#附件（Attachments）" class="headerlink" title="附件（Attachments）"></a>附件（Attachments）</h3><p>附件通常是指分配给槽位的图像或者其他可视对象，如网格、边界框（bounding box）、点（point）等。<br>附件被附加到槽位上，它们通过槽位与特定的骨骼关联起来。</p><h3 id="它们之间的交互"><a href="#它们之间的交互" class="headerlink" title="它们之间的交互"></a>它们之间的交互</h3><ul><li><strong>附件附着到槽位</strong>：每个附件被分配到一个槽位，这定义了附件的渲染和排序方式。</li><li><strong>槽位随骨骼移动</strong>：槽位绑定到骨骼上，所以附件随着骨骼的移动和动画而移动。</li><li><strong>骨骼驱动动画</strong>：骨骼是动画的驱动力，它们之间的父子关系和动作定义了整体的动画效果。</li><li><strong>GameObject 作为容器</strong>：在 Unity 中，Spine 动画通过附加到 GameObject 上的组件（如 <code>SkeletonAnimation</code>）来播放。GameObject 提供了上下文，使得 Spine 动画能够在 Unity 的世界中与其他对象和脚本交互。</li></ul><p>总之，骨骼提供动画的结构，槽位和附件提供可视化的内容，而 GameObject 则是将这一切整合到 Unity 环境中的容器。通过这种方式，Spine 动画能够以一种灵活且高效的方式被整合和控制，为游戏或应用程序带来丰富的视觉效果。</p><h1 id="Spine实例化方式"><a href="#Spine实例化方式" class="headerlink" title="Spine实例化方式"></a>Spine实例化方式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>三种实例化 Spine skeleton 的方法各自的优缺点和使用场景如下：</p><h3 id="SkeletonAnimation"><a href="#SkeletonAnimation" class="headerlink" title="SkeletonAnimation"></a>SkeletonAnimation</h3><p><strong>优点</strong>:</p><ul><li><strong>高度可定制</strong>：提供了对 Spine 动画系统的完整访问，包括高级特性如皮肤、事件、附件和约束。</li><li><strong>MeshRenderer 渲染</strong>：使用 MeshRenderer 进行渲染，可以享受到 Unity Mesh 的所有优势，如遮罩交互和灵活的材质选项。</li><li><strong>支持 SpriteMask</strong>：可以与 Unity 的 SpriteMask 和其他遮罩类型交互，便于集成到现有的 2D 环境中。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>性能开销</strong>：对于复杂的动画，可能比 Unity 内置的动画系统使用更多资源。</li><li><strong>学习曲线</strong>：需要对 Spine 的动画系统有深入了解，可能需要额外学习时间。</li></ul><p><strong>使用场景</strong>:</p><ul><li>推荐在需要高度定制动画或使用 Spine 提供的特殊特性时使用。</li><li>当你需要 Spine 动画与 Unity 的 SpriteMask 等遮罩交互时。</li><li>如果你的项目是以 Spine 为主的动画工作流。</li></ul><h3 id="SkeletonGraphic-UI"><a href="#SkeletonGraphic-UI" class="headerlink" title="SkeletonGraphic (UI)"></a>SkeletonGraphic (UI)</h3><p><strong>优点</strong>:</p><ul><li><strong>UI 集成</strong>：专为与 Unity 的 Canvas UI 系统一起工作而设计，适用于 UI 元素的动画。</li><li><strong>UI 遮罩兼容</strong>：与 Unity UI Mask 和 RectMask2D 兼容，适合在 UI 中使用动画。</li><li><strong>Canvas 渲染</strong>：作为 Canvas 渲染的一部分，可以利用 Canvas 的渲染优化。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>灵活性降低</strong>：与 MeshRenderer 相比，UI 系统可能不支持某些材质和渲染特性。</li><li><strong>性能考量</strong>：Canvas 系统的渲染性能与 MeshRenderer 不同，可能需要优化。</li></ul><p><strong>使用场景</strong>:</p><ul><li>当你需要在 Unity 的 UI 系统中使用 Spine 动画，例如在菜单、HUD 或其他屏幕元素中。</li><li>如果你的动画作为 UI 的一部分，需要和其他 UI 元素如按钮或滑块一起工作。</li></ul><h3 id="SkeletonMecanim"><a href="#SkeletonMecanim" class="headerlink" title="SkeletonMecanim"></a>SkeletonMecanim</h3><p><strong>优点</strong>:</p><ul><li><strong>Mecanim 集成</strong>：与 Unity 的 Animator 控制器和动画状态机（Mecanim）集成，可以利用 Unity 动画系统的功能，如状态转换和混合树。</li><li><strong>Unity 动画工作流</strong>：适合那些已经熟悉 Unity Mecanim 系统的团队和项目。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>功能限制</strong>：与 Spine 的完整动画系统相比，Mecanim 的某些高级特性可能不可用。</li><li><strong>动画预览差异</strong>：在 Spine Editor 中预览的动画效果可能无法完全一致地在 Unity 中重现。</li></ul><p><strong>使用场景</strong>:</p><ul><li>如果你更喜欢使用 Unity 的 Mecanim 系统，或者项目中已经广泛使用了 Mecanim 动画。</li><li>当项目需要整合 Spine 动画与 Unity 原生动画，并且不需要 Spine 的所有高级特性时。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每种方法都有其特定的用例和优势。选择哪种方法取决于你的项目需求、团队的熟悉度以及你是否需要 Spine 提供的特定功能。通常情况下，如果你需要 Spine 的高级特性和最好的可定制性，<code>SkeletonAnimation</code> 是首选。而如果你在制作一个 UI 重的应用或游戏，并且动画是 UI 的一部分，那么 <code>SkeletonGraphic</code> 是更好的选择。最后，如果你希望将 Spine 动画集</p><h2 id="SkeletonAnimation组件"><a href="#SkeletonAnimation组件" class="headerlink" title="SkeletonAnimation组件"></a>SkeletonAnimation组件</h2><p> <code>SkeletonAnimation</code> 组件，这是最常用的 Spine 组件， 它是 Spine 在 Unity 中最核心的组件之一，用于控制和播放 Spine 动画。通过它可以控制动画的播放、暂停、停止，以及切换不同的动画。</p><h3 id="Inspector参数"><a href="#Inspector参数" class="headerlink" title="Inspector参数"></a>Inspector参数</h3><ul><li><p><strong>SkeletonData Asset</strong><br>指定 Spine 动画数据的来源，即你导入的 <code>.skel</code> 或 <code>.json</code> 文件。<br>当你需要为 GameObject 指定动画时使用。</p></li><li><p><strong>Initial Skin</strong><br>选择初始应用于骨骼的皮肤。<br>如果你的 Spine 动画有多个皮肤变体，你可以在这里选择一个作为默认显示。</p></li><li><p><strong>Sorting Layer / Order in Layer</strong><br>决定渲染顺序，类似于 Unity 中的其他渲染组件。<br>在有多个动画或其他渲染对象叠加的场景中，调整这些值以获得正确的层次顺序。</p></li><li><p><strong>Mask Interaction</strong><br>定义如何与 Sprite Mask 交互。<br>当你需要动画与 UI 遮罩或场景中的其他遮罩元素互动时。</p></li><li><p><strong>Advanced</strong></p><p>这个部分包含一系列高级选项，通常默认设置就足够，但可以根据特定需求进行调整。</p><ul><li><strong>Renderer and Update Settings</strong><br>控制渲染和更新行为。<br>调整动画的渲染和更新方式，如需要在对象不可见时更新动画，或优化渲染性能。<ul><li><strong>Animation Update</strong><br>更新动画的时机<ul><li><strong>In Update</strong>:<br>这意味着动画的更新将在 Unity 的标准更新循环中进行，也就是每个帧的 <code>Update()</code> 调用时。</li></ul></li><li><strong>Update When Invisible</strong>：<br>不可见时也更新动画</li><li><strong>Use Single Submesh</strong><br>如果勾选，所有的图形都会被绘制在一个单独的子网格中。这在某些情况下可以提高渲染效率。</li><li><strong>Fix Draw Order</strong><br>当启用时，如果动画中的绘制顺序发生了错误，这个选项可以修复它。</li><li><strong>Immutable Triangles</strong><br>如果勾选，意味着三角形数据是不可变的。这对于性能优化有好处，因为不需要重新计算三角形数据，但这限制了在运行时更改图形拓扑的能力。</li><li><strong>Clear State On Disable</strong><br>当 GameObject 被禁用时，如果勾选，将会清除动画状态。<br>这意味着当 GameObject 重新启用时，动画会从初始状态开始。</li></ul></li><li><strong>Fix Prefab Overr. MeshFilter</strong><br>当您使用预制件并且对 MeshFilter 进行了重写时，这个选项可以保证这些重写被正确地应用。</li><li><strong>Separator Slot Names</strong><br>它允许你将骨骼动画的某些部分分离到不同的渲染层或网格中。<br>这可以用来解决渲染排序问题，或者是为了在特定的插槽上实现特殊的效果。</li><li><strong>Z Spacing</strong><br>在渲染时给每个部分添加的空间量，有助于解决 Z-fighting 问题。<br>当元素在同一平面上但需要给出层次感时使用。</li><li><strong>Vertex Data</strong><br>包含有关顶点信息的选项，如颜色和法线。<br>特别是在使用灯光或需要精确控制渲染效果时。<ul><li>**PMA Vertex Colors **<br>PMA 代表预乘 Alpha，这是一种处理透明度和颜色混合的技术。</li><li><strong>Tint Black</strong><br>（或称为 “Two Color Tint”）允许 Spine 在渲染时使用额外的颜色通道来实现更复杂的着色效果，尤其是对于阴影和光照的模拟。<br>当你的 Spine 动画在 Spine 编辑器中使用了黑色色调或其他高级着色效果，需要在 Unity 中重现这些效果时启用此选项。</li><li><strong>Add Normals</strong><br>此选项会为网格顶点数据添加法线信息。法线是影响光照和着色的重要因素，特别是当场景中有光源影响动画对象时。<br>如果你在场景中使用了光源，并且希望 Spine 动画受到光照影响，就需要启用这个选项。</li><li><strong>Solve Tangents</strong><br>为网格顶点数据计算切线。切线通常与法线一起使用，用于正确渲染具有法线贴图的材料，以模拟更复杂的光照效果，如凹凸贴图。<br>如果你的材质使用了法线贴图，需要切线信息来确保贴图正确显示，这时就需要启用此选项。</li></ul></li></ul></li><li><p><strong>Animation Name</strong><br>选择要播放的动画。<br>在运行时或在场景开始时指定默认播放的动画。</p></li><li><p><strong>Loop</strong><br>决定当前选择的动画是否循环播放。<br>对于循环进行的动画（如行走、跑步）设置为循环，对于一次性动作（如攻击、跳跃）则不循环。</p></li><li><p><strong>Time Scale</strong><br>控制动画播放的速度。<br>当你想加速或减慢动画时调整这个值。</p></li><li><p><strong>Unscaled Time</strong><br>如果勾选，动画时间将不受时间缩放的影响（即 <code>Time.timeScale</code>）。<br>在游戏暂停或全局时间缩放时，如果你仍然希望动画正常播放，使用这个选项。</p></li><li><p><strong>Root Motion</strong><br>Root Motion 通常用于将动画中的某个对象（如角色的“根”骨骼）的移动应用到 GameObject 的实际位置和旋转上。这样，动画本身就可以驱动角色的移动，而不仅仅是视觉上的。<br>如果动画包含了角色位置的改变，你可以通过启用 Root Motion 来将这些位置变化应用到 Unity GameObject 的移动上。这对于那些动画中包含实际移动（如走路、跳跃）的情况特别有用。<br>它会给当前GameObject添加一个SkeletonRootMotion组件来实现以上功能。</p></li></ul><p><strong>额外说明：</strong></p><p>这些参数大多数在初始设置时配置一次，之后在游戏运行时通过代码进行控制。<br>例如，你可能会在游戏中根据用户输入或其他游戏事件来改变动画（通过更改 <code>AnimationName</code>），或调整动画速度（通过更改 <code>Time Scale</code>）。<br>对于大部分游戏项目，除非你有特殊的需求，否则很多参数可以保持默认设置。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>在 Unity 中使用 Spine 提供的 <code>SkeletonAnimation</code> 组件时，可以通过 C# 脚本访问和控制各种动画功能。<br>这些 API 提供了丰富的动画控制能力，包括但不限于播放、停止、暂停动画，以及监听动画事件等。<br>以下是一些关键的 API 和它们的用法：</p><p><strong>AnimationName</strong><br>获取或设置当前播放的动画名称。<br>示例：<code>skeletonAnimation.AnimationName = &quot;run&quot;;</code></p><h4 id="生命周期相关"><a href="#生命周期相关" class="headerlink" title="生命周期相关"></a>生命周期相关</h4><p>在 <a href="https://zh.esotericsoftware.com/spine-unity#SkeletonAnimation%E7%BB%84%E4%BB%B6">SkeletonAnimation</a> 组件中, AnimationState保存了所有当前播放的和队列中的动画状态.<br>每一次 <code>Update</code>, AnimationState都会被更新,从而使动画在时间上向前推进. 然后, 新一帧作为一个新的pose被应用于Skeleton上.</p><p>你的脚本可以在SkeletonAnimation的 <code>Update</code> 之前或之后运行. 如果你的代码在SkeletonAnimation的更新之前获取Skeleton或骨骼的值, 你的代码会读取上一帧而不是当前帧的值.</p><p>该组件将事件回调委托暴露为属性, 这样就能在计算所有骨骼的世界transforms之前和之后介入该生命周期. 你可以绑定这些委托来修改骨骼的位置和其他方面, 而无需关注角色和组件的更新顺序.</p><p><strong>SkeletonAnimation Update 回调:</strong></p><ul><li><code>SkeletonAnimation.BeforeApply</code><br>在应用该帧动画之前被引发. 当你想在动画应用到skeleton上之前改变skeleton的状态时, 请使用这个回调.</li><li><code>SkeletonAnimation.UpdateLocal</code><br>在该帧动画更新完成并应用于skeleton的局部值之后被引发. 如果你需要读取或修改骨骼的局部值, 请使用它.</li><li><code>SkeletonAnimation.UpdateComplete</code><br>在计算完Skeleton中所有骨骼的世界值后被引发. SkeletonAnimation在这之后不会在Update中做进一步的操作. 如果你只需要读取骨骼的世界值, 就使用它. 如果有代码在SkeletonAnimation的Update之后修改了这些值, 这些值可能仍会发生变化.</li><li><code>SkeletonAnimation.UpdateWorld</code><br>是在计算了Skeleton中所有骨骼的世界值后引发的. 若订阅了该事件则将二次调用</li><li><code>skeleton.UpdateWorldTransform</code><br>如果你的skeleton复杂或正在执行其他计算, 那这将是多余甚至是浪费的行为. 如果需要根据骨骼的世界值来修改骨骼的局部值, 请使用该事件. 它在Unity代码中实现自定义约束很有用.</li><li><code>OnMeshAndMaterialsUpdated</code><br>在 <code>LateUpdate()</code> 结束后,在网格和所有materials都被更新后引发.</li></ul><h4 id="动画状态相关"><a href="#动画状态相关" class="headerlink" title="动画状态相关"></a>动画状态相关</h4><p><code>state</code> 属性提供了对 <code>AnimationState</code> 对象的引用，这是动画播放的核心类。</p><ul><li><p><strong>SetAnimation</strong><br>在指定的轨道上播放一个动画，并可选择是否循环。<br>示例：<code>skeletonAnimation.state.SetAnimation(0, &quot;jump&quot;, false);</code></p></li><li><p><strong>TimeScale</strong><br>设置动画播放速度<br><code>skeletonAnimation.state.TimeScale = 0.5f;</code></p></li><li><p><strong>AddAnimation</strong><br>在当前动画之后添加一个动画到播放队列。<br>示例：<code>skeletonAnimation.state.AddAnimation(0, &quot;run&quot;, true, 0);</code></p></li><li><p><strong>SetEmptyAnimation</strong><br>清空指定轨道上的当前动画，可选择淡出时间。<br>示例：<code>skeletonAnimation.state.SetEmptyAnimation(0, 0.5f);</code></p></li><li><p><strong>ClearTrack</strong> 和 <strong>ClearTracks</strong><br>清除指定轨道上的所有动画或清除所有轨道上的动画。<br>示例：<br><code>skeletonAnimation.state.ClearTrack(0);</code><br><code>skeletonAnimation.state.ClearTracks();</code></p></li></ul><p><strong>事件监听相关：</strong></p><ul><li><strong>Start, Interrupt, End, Dispose</strong><br>添加监听器以响应动画的开始、中断、结束和释放事件。<br>示例：<code>skeletonAnimation.state.Start += OnAnimationStart;</code></li><li><strong>Complete</strong><br>添加监听器以响应动画播放完成事件。<br>示例：<code>skeletonAnimation.state.Complete += OnAnimationComplete;</code></li><li><strong>Event</strong><br>添加监听器以响应动画中定义的特定事件。<br>示例：<code>skeletonAnimation.state.Event += OnEventReceived;</code></li></ul><h4 id="控制骨骼和插槽"><a href="#控制骨骼和插槽" class="headerlink" title="控制骨骼和插槽"></a>控制骨骼和插槽</h4><p><strong>Skeleton</strong><br>获取当前的 <code>Skeleton</code> 对象，它包含了所有骨骼、插槽和当前附件的状态。<br>通过Skeleton可以设置皮肤、附件、重置骨骼为setup pose、比例以及翻转整个skeleton.</p><ul><li><p><strong>FindBone</strong><br>在 Skeleton 中查找并返回具有指定名称的骨骼。<br>示例：<code>Bone head = skeletonAnimation.Skeleton.FindBone(&quot;head&quot;);</code></p></li><li><p><strong>FindSlot</strong><br>查找并返回具有指定名称的插槽。<br>示例：<code>Slot weaponSlot = skeletonAnimation.Skeleton.FindSlot(&quot;weapon&quot;);</code></p></li><li><p><strong>SetAttachment</strong><br>更改插槽上的附件（图像）。<br>示例：<code>skeletonAnimation.Skeleton.SetAttachment(&quot;weapon&quot;, &quot;sword&quot;);</code><br>参数：(插槽名称，附件名称)</p></li><li><p><strong>SetToSetupPose</strong><br>将 Skeleton 的状态重置为“初始设置姿势”。</p><ul><li>重置整个骨架<code>skeleton.SetToSetupPose();</code></li><li>重置全部骨骼<code>skeleton.SetBonesToSetupPose();</code></li><li>重置全部插槽<code>skeleton.SetSlotsToSetupPose();</code></li></ul></li><li><p><strong>SetSkin</strong><br>设置骨架皮肤<br><code>bool  success = skeletonAnimation.Skeleton.SetSkin(&quot;skinName&quot;);</code><br>也可以从多个皮肤中抽取部分来组合成新皮肤：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> skeleton = skeletonAnimation.Skeleton;<br><span class="hljs-keyword">var</span> skeletonData = skeleton.Data;<br><span class="hljs-keyword">var</span> mixAndMatchSkin = <span class="hljs-keyword">new</span> Skin(<span class="hljs-string">&quot;custom-girl&quot;</span>);<br>mixAndMatchSkin.AddSkin(skeletonData.FindSkin(<span class="hljs-string">&quot;skin-base&quot;</span>));<br>mixAndMatchSkin.AddSkin(skeletonData.FindSkin(<span class="hljs-string">&quot;nose/short&quot;</span>));<br>mixAndMatchSkin.AddSkin(skeletonData.FindSkin(<span class="hljs-string">&quot;eyelids/girly&quot;</span>));<br>skeleton.SetSkin(mixAndMatchSkin);<br>skeleton.SetSlotsToSetupPose();<br>skeletonAnimation.AnimationState.Apply(skeletonAnimation.Skeleton); <span class="hljs-comment">// skeletonMecanim.Update() for SkeletonMecanim</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Spine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spine</tag>
      
      <tag>动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热更概述</title>
    <link href="/2025/03/18/%E7%83%AD%E6%9B%B4%E6%A6%82%E8%BF%B0/"/>
    <url>/2025/03/18/%E7%83%AD%E6%9B%B4%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是热更新？"><a href="#1-什么是热更新？" class="headerlink" title="1. 什么是热更新？"></a>1. 什么是热更新？</h1><p><strong>热更新</strong>（Hot Update）是一种在<strong>不重新发布完整客户端</strong>的情况下，对游戏进行内容或逻辑更新的方法。热更新可以分为 <strong>资源热更新</strong> 和 <strong>代码热更新</strong> 两种：</p><ul><li><strong>资源热更新</strong>：用于更新游戏中的美术、音效、地图、模型等静态资源。</li><li><strong>代码热更新</strong>：用于更新游戏逻辑，如脚本、功能、Bug 修复等，避免重新提交新版本。</li></ul><h1 id="2-资源热更新的三种方式"><a href="#2-资源热更新的三种方式" class="headerlink" title="2. 资源热更新的三种方式"></a>2. 资源热更新的三种方式</h1><p>资源热更新可以分为 <strong>整包更新、补丁更新、增量更新</strong> 三种方式。</p><h2 id="2-1-整包更新（Full-Package-Update）"><a href="#2-1-整包更新（Full-Package-Update）" class="headerlink" title="2.1 整包更新（Full Package Update）"></a><strong>2.1 整包更新（Full Package Update）</strong></h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>将<strong>所有资源</strong>重新打包成一个完整的新版本，上传到服务器，客户端下载后替换旧资源。</li><li>适用于<strong>资源变动较大的更新</strong>，如版本大更新。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p>✅ <strong>简单易维护</strong>，不需要维护多个资源版本。 </p><p>✅ <strong>不会产生版本碎片化</strong>，所有玩家资源一致。 </p><p>❌ <strong>更新流量大</strong>，即使只修改了少量资源，也需要下载整个包。 </p><p>❌ <strong>下载时间长</strong>，可能影响玩家体验。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul><li>游戏初期或大版本更新（如新赛季、新资料片）。</li><li>资源变更较大，不适合增量更新的情况。</li></ul><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a><strong>操作流程</strong></h3><ol><li>重新打包所有游戏资源。</li><li>将新资源包上传至 CDN 服务器。</li><li>客户端检测版本变化，下载并替换旧资源。</li><li>启动游戏，加载新资源。</li></ol><h2 id="2-2-补丁更新（Patch-Update）"><a href="#2-2-补丁更新（Patch-Update）" class="headerlink" title="2.2 补丁更新（Patch Update）"></a><strong>2.2 补丁更新（Patch Update）</strong></h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>版本级别更新</strong>：客户端需要按照 Patch 版本升级，不能跳版本（除非提供合成 Patch）。</li><li><strong>维护多个版本的补丁</strong>：服务器需要存储多个补丁包，如 V1 → V2，V2 → V3。</li><li><strong>支持回滚</strong>：如果某个版本更新后有问题，可以回退到上一个版本。</li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p>✅ <strong>版本一致性强</strong>，所有玩家的游戏版本完全相同，避免兼容性问题。如电竞、竞技类游戏，对版本一致性要求高。<br>✅ <strong>支持回滚</strong>，如果最新版本有 bug，可以快速回退到上一个稳定版本。</p><p>❌ <strong>客户端需要依次更新多个 Patch</strong>，更新步骤可能较复杂。 </p><p>❌ <strong>服务器存储压力大</strong>，需要维护多个版本的补丁。</p><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul><li>适用于<strong>端游、主机游戏、电竞游戏</strong>，保证版本稳定性。</li><li>适用于<strong>对平衡性要求高的游戏</strong>，如 FPS、MOBA 竞技游戏（如《英雄联盟》《CS:GO》）。</li><li>适用于<strong>需要支持历史版本的游戏</strong>，如单机游戏 DLC 需要支持老玩家升级到新版本。</li></ul><h3 id="操作流程-1"><a href="#操作流程-1" class="headerlink" title="操作流程"></a><strong>操作流程</strong></h3><ol><li>计算旧版本与新版本的资源差异，生成 Patch 文件。</li><li>服务器存储多个版本的 Patch（如 V1→V2、V2→V3）。</li><li>客户端根据当前版本<strong>逐步下载并应用 Patch</strong>。</li><li>版本更新完成，进入游戏。</li></ol><h3 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a><strong>典型案例</strong></h3><ul><li><strong>《英雄联盟》</strong>：使用 <strong>版本 Patch 更新</strong>，每次新赛季推出时，必须更新完整 Patch，保证所有玩家版本一致。</li><li><strong>《魔兽世界》</strong>：暴雪战网提供<strong>补丁更新机制</strong>，玩家必须下载完整 Patch 进行版本更新。</li></ul><h2 id="2-3-增量更新（Incremental-Update）"><a href="#2-3-增量更新（Incremental-Update）" class="headerlink" title="2.3 增量更新（Incremental Update）"></a><strong>2.3 增量更新（Incremental Update）</strong></h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><p><strong>文件级别更新</strong>：只更新变化的资源，不关心版本。</p></li><li><p><strong>实时检查资源差异</strong>：客户端比对本地资源的 Hash，与服务器上的最新资源进行对比，决定是否下载新的资源。</p><p><strong>资源可单独下载和替换</strong>：无需整体替换或补丁合成。</p></li></ul><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p>✅ <strong>下载量最小</strong>，只获取必要的资源。 </p><p>✅ <strong>更新速度快</strong>，无需多次下载 Patch。 </p><p>✅ <strong>维护成本低</strong>，服务器端只存最新的资源文件。</p><p>❌ <strong>无法回滚</strong>，如果出现问题，通常需要完整重新下载资源或回退整个客户端。</p><p>❌ <strong>版本管理复杂</strong>，不同客户端可能有不同资源版本，需要服务器维护资源版本列表。 </p><p>❌ <strong>可能产生资源碎片</strong>，需要定期清理无用资源。</p><h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ul><li>适用于<strong>更新频繁、但资源变更较少的游戏</strong>（如每周更新少量新地图或角色皮肤）。</li><li>适用于<strong>CDN 分发的游戏</strong>，可以按需加载不同资源，减少初始安装包大小。</li><li><strong>手游</strong>（如《原神》《王者荣耀》），减少下载量。</li><li><strong>开放世界、MMORPG</strong>，如《GTA Online》长期运营的多人在线游戏，支持动态扩展内容。</li></ul><h3 id="典型案例-1"><a href="#典型案例-1" class="headerlink" title="典型案例"></a><strong>典型案例</strong></h3><ul><li><strong>《原神》</strong>：使用 <strong>远程资源 + AssetBundle</strong> 实现增量更新，玩家只下载新增或修改的场景、角色等数据。</li><li><strong>《王者荣耀》</strong>：使用<strong>增量更新 + 资源校验</strong>，每个版本仅下载新增或修改的皮肤、英雄数据。</li></ul><h3 id="操作流程-2"><a href="#操作流程-2" class="headerlink" title="操作流程"></a><strong>操作流程</strong></h3><ol><li>服务器提供资源版本索引（Hash 校验）。</li><li>客户端检查本地资源，计算需要更新的资源。</li><li>仅下载有变化的资源文件，并替换旧文件。</li><li>资源更新完成，进入游戏。</li></ol><h2 id="2-4-资源热更总结"><a href="#2-4-资源热更总结" class="headerlink" title="2.4 资源热更总结"></a><strong>2.4 资源热更总结</strong></h2><h3 id="什么时候选整包更新？"><a href="#什么时候选整包更新？" class="headerlink" title="什么时候选整包更新？"></a><strong>什么时候选整包更新？</strong></h3><ul><li><strong>游戏初期或大版本更新</strong>（如新赛季、新资料片），所有玩家需要统一的完整资源。</li><li><strong>资源大规模变更</strong>（如 UI 重制、游戏引擎升级、角色模型大改动）。</li><li><strong>开发阶段的重大调整</strong>，如更换核心美术资源或大规模优化性能。</li><li><strong>玩家网络条件允许时</strong>，例如<strong>主机/PC 端游</strong>，整包更新不会对玩家体验造成过大影响。</li></ul><h3 id="什么时候选增量更新？"><a href="#什么时候选增量更新？" class="headerlink" title="什么时候选增量更新？"></a><strong>什么时候选增量更新？</strong></h3><ul><li>游戏资源变化小，但更新频繁（如手游、开放世界游戏）。</li><li>需要<strong>降低下载流量</strong>，避免大版本更新（如王者荣耀、原神）。</li><li>采用<strong>CDN 分发资源</strong>，支持按需加载。</li></ul><h3 id="什么时候选补丁更新？"><a href="#什么时候选补丁更新？" class="headerlink" title="什么时候选补丁更新？"></a><strong>什么时候选补丁更新？</strong></h3><ul><li>需要<strong>保证版本一致性</strong>，防止玩家因资源不同导致问题（如电竞游戏）。</li><li>需要<strong>支持回滚</strong>，方便修复问题（如 PC 端游）。</li><li>适用于<strong>大型游戏</strong>，特别是 PC/主机平台。</li></ul><h3 id="有时游戏需要兼顾三种方案"><a href="#有时游戏需要兼顾三种方案" class="headerlink" title="有时游戏需要兼顾三种方案"></a><strong>有时游戏需要兼顾三种方案</strong></h3><p>一些游戏会结合<strong>增量更新、补丁更新、整包更新</strong>三种方案：</p><ul><li><strong>手游（王者荣耀、原神）</strong>：主要使用<strong>增量更新</strong>，但关键版本更新时结合<strong>补丁更新</strong>，在重大更新时采用<strong>整包更新</strong>。</li><li><strong>端游（魔兽世界、英雄联盟）</strong>：通常使用<strong>补丁更新</strong>，但小型资源（如皮肤、DLC）可能使用<strong>增量更新</strong>，在引擎大改或资料片更新时使用<strong>整包更新</strong>。</li><li><strong>大型主机/开放世界游戏（如《赛博朋克 2077》《荒野大镖客2》）</strong>：大版本时采用<strong>整包更新</strong>，定期小更新采用<strong>补丁更新</strong>，DLC 资源可能使用<strong>增量更新</strong>。</li></ul><p>选择合适的组合方案，可以平衡更新效率、资源管理和玩家体验！</p><h3 id="三种资源热更新对比总结表"><a href="#三种资源热更新对比总结表" class="headerlink" title="三种资源热更新对比总结表"></a>三种资源热更新对比总结表</h3><table><thead><tr><th>对比项</th><th><strong>增量更新（Incremental Update）</strong></th><th><strong>补丁更新（Patch Update）</strong></th><th><strong>整包更新（Full Package Update）</strong></th></tr></thead><tbody><tr><td><strong>更新方式</strong></td><td>直接更新变更的单个资源（文件级别）</td><td>生成新旧版本之间的差异补丁</td><td>生成完整资源包，覆盖原有资源</td></tr><tr><td><strong>更新策略</strong></td><td>仅下载最新的有变更资源，不关心版本</td><td>客户端必须按版本顺序或跳跃合成进行更新</td><td>客户端下载完整资源包，直接覆盖</td></tr><tr><td><strong>文件组织方式</strong></td><td>资源文件通常按<strong>独立文件</strong> 形式存放（如 AssetBundles、Pak、单个文件等）</td><td>资源文件被封装成 Patch 包，客户端按版本升级</td><td>所有资源整合到一个大文件或多个大资源包</td></tr><tr><td><strong>资源管理</strong></td><td>需要维护资源文件列表（通常带有版本号、Hash 校验）</td><td>需要维护多个版本的 Patch（从 V1 → V2、V2 → V3）</td><td>只需维护最新的完整资源包，不关注历史版本</td></tr><tr><td><strong>服务器存储</strong></td><td>仅存储最新的资源，无需保留旧版本</td><td>需要存储多个补丁文件，以支持不同版本的升级路径</td><td>只存储最新完整包，空间占用较大</td></tr><tr><td><strong>客户端存储</strong></td><td>只保留最新资源，不会留下旧文件</td><td>可能需要保留部分旧资源，以便逐步升级</td><td>只保留最新完整资源包，存储空间占用大</td></tr><tr><td><strong>网络流量</strong></td><td>只下载变化的资源，流量消耗低</td><td>需要下载完整的 Patch，可能包含部分冗余资源</td><td>下载完整资源包，流量消耗最大</td></tr><tr><td><strong>更新速度</strong></td><td><strong>更快</strong>（下载少量文件，通常是资源级别）</td><td><strong>较慢</strong>（如果需要多次下载 Patch，累计下载量可能较大）</td><td><strong>最慢</strong>（需要下载完整资源包）</td></tr><tr><td><strong>回滚机制</strong></td><td><strong>较难实现</strong>（需要重新下载旧版本资源）</td><td><strong>更容易</strong>（可以下载旧版本 Patch 进行回退）</td><td><strong>无回滚</strong>（需要重新下载旧版本完整包）</td></tr><tr><td><strong>维护难度</strong></td><td><strong>低</strong>，服务器端存储较少，只需提供最新资源</td><td><strong>高</strong>，需要维护多个 Patch 版本，并确保客户端能够正确应用</td><td><strong>低</strong>，只需维护最新完整资源包</td></tr><tr><td><strong>适用场景</strong></td><td><strong>开放世界游戏</strong>（如《原神》）- <strong>多人在线游戏（MMORPG）</strong>- <strong>长期运营游戏（如手游）</strong>- <strong>内容扩展频繁的游戏（如 DLC）</strong></td><td><strong>大型端游/主机游戏（如 Steam 游戏）</strong>- <strong>有版本依赖的游戏（如 FPS、RPG）</strong>- <strong>对版本一致性要求高的游戏（如电竞游戏）</strong></td><td><strong>游戏初期或大版本更新</strong>（如赛季更新、资料片）- <strong>资源大改动</strong>（如 UI、建模重制）</td></tr><tr><td><strong>典型案例</strong></td><td>Unity 的 AssetBundle，Unreal Engine 的 Pak System</td><td>Steam、战网的 Patching System，PC 端游更新系统</td><td>传统 PC 端游、手游大版本更新</td></tr></tbody></table><h1 id="3-代码热更新"><a href="#3-代码热更新" class="headerlink" title="3. 代码热更新"></a>3. 代码热更新</h1>]]></content>
    
    
    <categories>
      
      <category>系统开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言二周目速通手册</title>
    <link href="/2024/02/17/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E5%91%A8%E7%9B%AE%E9%80%9F%E9%80%9A%E6%89%8B%E5%86%8C/"/>
    <url>/2024/02/17/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E5%91%A8%E7%9B%AE%E9%80%9F%E9%80%9A%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="0-速通计划"><a href="#0-速通计划" class="headerlink" title="0. 速通计划"></a>0. 速通计划</h1><ol><li><p><strong>基本语法</strong></p><ul><li>变量声明和定义</li><li>数据类型 (整数、浮点数、字符等)</li><li>控制流语句 (if、else、switch)</li><li>循环语句 (for、while)</li></ul></li><li><p><strong>指针和引用</strong></p><ul><li>熟练使用指针操作，包括指针算术和指针的数组和函数</li><li>了解引用和指针的区别，以及何时使用它们</li></ul></li><li><p><strong>函数</strong></p></li><li><p><strong>常用数据结构</strong></p><ul><li>学习常用容器，如vector、list、map</li><li>迭代器的使用</li></ul></li><li><p><strong>面向对象编程 (OOP)</strong></p><ul><li>类和对象</li><li>封装、继承、多态的概念</li></ul></li><li><p><strong>异常处理</strong></p><ul><li>try、catch、throw的使用</li></ul></li><li><p><strong>文件操作</strong></p><ul><li>文件的读取和写入</li></ul></li><li><p><strong>内存管理</strong></p><ul><li><p>new 和 delete 操作符的使用</p></li><li><p>智能指针的基础概念</p></li></ul></li><li><p><strong>模板编程</strong></p><ul><li>函数模板和类模板的定义和使用</li></ul></li><li><p><strong>多线程编程</strong></p><ul><li>基础的线程创建和同步</li></ul></li></ol><h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h1><h2 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h2><h3 id="1-1-1-数据类型一览表"><a href="#1-1-1-数据类型一览表" class="headerlink" title="1.1.1 数据类型一览表"></a>1.1.1 数据类型一览表</h3><table><thead><tr><th>分类</th><th>名称</th><th>功能</th><th>大小</th><th>声明方式</th><th>默认值</th><th>值类型/引用类型</th></tr></thead><tbody><tr><td>整数类型</td><td>int</td><td>表示整数值</td><td>32位(4字节)</td><td>int variable;</td><td>未初始化的值不确定</td><td>值</td></tr><tr><td>整数类型</td><td>short</td><td>表示较小范围的整数</td><td>16位(2字节)</td><td>short variable;</td><td>未初始化的值不确定</td><td>值</td></tr><tr><td>整数类型</td><td>long</td><td>表示较大范围的整数</td><td>32位或64位</td><td>long variable;</td><td>未初始化的值不确定</td><td>值</td></tr><tr><td>整数类型</td><td>long long</td><td>表示更大范围的整数</td><td>64位(8字节)</td><td>long long variable;</td><td>未初始化的值不确定</td><td>值</td></tr><tr><td>浮点数类型</td><td>float</td><td>表示单精度浮点数</td><td>32位(4字节)</td><td>float variable;</td><td>0.0</td><td>值</td></tr><tr><td>浮点数类型</td><td>double</td><td>表示双精度浮点数</td><td>64位</td><td>double variable;</td><td>0.0</td><td>值</td></tr><tr><td>浮点数类型</td><td>long double</td><td>表示更高精度的浮点数</td><td>取决于编译器和系统</td><td>long double variable;</td><td>0.0</td><td>值</td></tr><tr><td>字符类型</td><td>char</td><td>表示单个字符</td><td>8位(1字节)</td><td>char character;</td><td>未初始化的值不确定</td><td>值</td></tr><tr><td>字符类型</td><td>bool</td><td>表示布尔值，只有两个可能的值：true 或 false</td><td>1字节</td><td>bool flag;</td><td>false</td><td>值</td></tr><tr><td>数组类型</td><td>Array</td><td>存储相同类型的多个元素</td><td>取决于数组元素个数和类型</td><td>type arrayName[size];</td><td>元素的默认值取决于数据类型</td><td>值</td></tr><tr><td>字符串类型</td><td>String</td><td>表示文本数据，实际上是字符数组的一种封装</td><td>取决于字符串长度</td><td>std::string str = “Hello, World!”;</td><td>空字符串 “”</td><td>值</td></tr><tr><td>枚举类型</td><td>Enum</td><td>用户定义的枚举类型，为一组命名的整数值提供有意义的名称</td><td>取决于枚举的大小</td><td>enum EnumName { value1, value2, … };</td><td>0(第一个值)</td><td>值</td></tr><tr><td>指针类型</td><td>Pointer</td><td>存储变量的内存地址</td><td>4字节或8字节</td><td>type* pointerName;</td><td>未初始化的值不确定</td><td>引用</td></tr></tbody></table><h3 id="1-1-2-值类型与引用类型"><a href="#1-1-2-值类型与引用类型" class="headerlink" title="1.1.2 值类型与引用类型"></a>1.1.2 值类型与引用类型</h3><ul><li><p><strong>值类型（Value Types）：</strong><br>  值类型直接包含数据的实际值，变量存储的是数据本身。</p><ul><li><p><strong>传递方式：</strong><br>  当将值类型传递给函数或赋值给其他变量时，会发生值的复制，即新的变量会得到原始值的拷贝。</p></li><li><p><strong>存储：</strong><br>  值类型的变量通常直接存储在栈上，而不是在堆上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;  <span class="hljs-comment">// x是一个值类型变量，存储整数值 5</span><br><span class="hljs-keyword">int</span> y = x;  <span class="hljs-comment">// y得到了x的值的拷贝</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用类型（Reference Types）：</strong><br>引用类型是对已存在变量的引用，相当于该变量的别名。引用在声明时必须初始化，且不能更改引用的目标。<strong>传递方式：</strong> 当引用类型传递给函数或赋值给其他引用时，实际上操作的是同一块内存，没有发生值的复制。<strong>存储：</strong> 引用类型的变量存储的是变量的地址，实际数据通常存储在堆上。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;     <span class="hljs-comment">// a是一个值类型变量</span><br><span class="hljs-keyword">int</span>&amp; refA = a;  <span class="hljs-comment">// refA是对a的引用，相当于a的别名</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>C++ 与 C# 的区别：</strong></p><h4 id="1-指针的存在："><a href="#1-指针的存在：" class="headerlink" title="1. 指针的存在："></a>1. <strong>指针的存在：</strong></h4><ul><li>C++ 中引入了指针，可以直接操作内存地址，使得引用类型与指针有更直接的关系。</li><li>C# 中不存在显式指针的概念，引用类型通常与类、接口等高级结构相关。</li></ul><h4 id="2-传统数组的区别："><a href="#2-传统数组的区别：" class="headerlink" title="2. 传统数组的区别："></a>2. <strong>传统数组的区别：</strong></h4><ul><li>C++ 的数组是值类型，传递给函数时会发生值的复制。</li><li>C# 的数组是引用类型，传递给函数时实际上是传递的引用。</li></ul><h4 id="3-内存管理："><a href="#3-内存管理：" class="headerlink" title="3. 内存管理："></a>3. <strong>内存管理：</strong></h4><ul><li>C++ 中需要手动管理内存，使用 <code>new</code> 和 <code>delete</code> 操作符，包括指针和动态分配内存。</li><li>C# 中具有垃圾回收机制，自动管理内存，避免了内存泄漏问题。</li></ul><h4 id="4-null-的使用："><a href="#4-null-的使用：" class="headerlink" title="4. null 的使用："></a>4. <strong>null 的使用：</strong></h4><ul><li>在 C++ 中，null 通常表示空指针，用于表示指针不指向任何有效的内存地址。</li><li>在 C# 中，null 可以用于引用类型和可空值类型，表示未初始化的引用或值。</li></ul><p>尽管 C++ 和 C# 在值类型和引用类型的概念上有一些相似之处，但由于语言设计和用途的不同，它们之间存在一些重要的区别，特别是在内存管理和指针的处理上。</p><h2 id="1-2-关键字"><a href="#1-2-关键字" class="headerlink" title="1.2 关键字"></a>1.2 关键字</h2><h3 id="1-2-1-关键字一览表"><a href="#1-2-1-关键字一览表" class="headerlink" title="1.2.1 关键字一览表"></a>1.2.1 关键字一览表</h3><table><thead><tr><th>关键字</th><th>用途</th></tr></thead><tbody><tr><td>auto</td><td>用于自动推断变量的类型。</td></tr><tr><td>break</td><td>用于跳出循环或 switch 语句。</td></tr><tr><td>case</td><td>在 switch 语句中标签一个分支。</td></tr><tr><td>char</td><td>表示字符数据类型。</td></tr><tr><td>const</td><td>用于定义常量或修饰变量，表示其值不可修改。</td></tr><tr><td>continue</td><td>用于终止当前循环的迭代，跳到下一次迭代。</td></tr><tr><td>default</td><td>在 switch 语句中标识默认分支。</td></tr><tr><td>do</td><td>用于创建 do-while 循环。</td></tr><tr><td>double</td><td>表示双精度浮点数数据类型。</td></tr><tr><td>else</td><td>在条件语句中标识一个分支，如果条件不成立执行该分支。</td></tr><tr><td>enum</td><td>用于定义枚举类型。</td></tr><tr><td>extern</td><td>用于声明一个全局变量或函数是在其他文件中定义的。</td></tr><tr><td>false</td><td>表示布尔类型的假值。</td></tr><tr><td>float</td><td>表示单精度浮点数数据类型。</td></tr><tr><td>for</td><td>用于创建循环。</td></tr><tr><td>goto</td><td>用于无条件跳转到程序的指定位置。</td></tr><tr><td>if</td><td>用于创建条件语句。</td></tr><tr><td>int</td><td>表示整数数据类型。</td></tr><tr><td>long</td><td>表示长整数数据类型。</td></tr><tr><td>namespace</td><td>用于定义命名空间，以组织代码。</td></tr><tr><td>new</td><td>用于动态分配内存，返回指向新分配的内存的指针。</td></tr><tr><td>nullptr</td><td>用于表示空指针常量。</td></tr><tr><td>operator</td><td>用于定义运算符重载。</td></tr><tr><td>return</td><td>用于从函数中返回值。</td></tr><tr><td>short</td><td>表示短整数数据类型。</td></tr><tr><td>signed</td><td>用于声明有符号整数类型。</td></tr><tr><td>sizeof</td><td>用于返回对象或类型的大小。</td></tr><tr><td>static</td><td>用于声明静态变量或函数，静态成员在类的所有对象中是共享的。</td></tr><tr><td>struct</td><td>用于定义结构体。</td></tr><tr><td>switch</td><td>用于创建 switch 语句。</td></tr><tr><td>template</td><td>用于实现泛型编程。</td></tr><tr><td>this</td><td>用于指向当前对象的指针。</td></tr><tr><td>throw</td><td>用于抛出异常。</td></tr><tr><td>true</td><td>表示布尔类型的真值。</td></tr><tr><td>try</td><td>用于捕获异常。</td></tr><tr><td>typedef</td><td>用于定义类型别名。</td></tr><tr><td>typeid</td><td>用于获取表达式的类型信息。</td></tr><tr><td>typename</td><td>用于指定模板参数中的类型。</td></tr><tr><td>union</td><td>用于定义联合体。</td></tr><tr><td>unsigned</td><td>用于声明无符号整数类型。</td></tr><tr><td>using</td><td>用于引入命名空间或声明别名。</td></tr><tr><td>virtual</td><td>用于声明虚函数或实现多态。</td></tr><tr><td>void</td><td>表示无返回值或无参数的函数。</td></tr><tr><td>volatile</td><td>用于声明一个变量可能被某些未被编译器检测到的因素更改，例如硬件中断。</td></tr><tr><td>while</td><td>用于创建循环。</td></tr><tr><td>xor</td><td>位运算异或操作。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习书签</title>
    <link href="/2024/02/15/UGF%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/"/>
    <url>/2024/02/15/UGF%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<p>gitee:<br><a href="https://gitee.com/jiangyin/UnityGameFramework">https://gitee.com/jiangyin/UnityGameFramework</a></p><p>官方教程：<br><a href="https://gameframework.cn/tutorial/tutorial-001/">https://gameframework.cn/tutorial/tutorial-001/</a></p><p>综合作业:<br><a href="https://blog.csdn.net/qq_32821435/category_7753219.html">https://blog.csdn.net/qq_32821435/category_7753219.html</a></p><p>API文档：<br><a href="https://gameframework.cn/api/">https://gameframework.cn/api/</a></p><p>比较全的教程：<br><a href="https://blog.csdn.net/qq_15020543/category_9278835.html?spm=1001.2014.3001.5482">https://blog.csdn.net/qq_15020543/category_9278835.html?spm=1001.2014.3001.5482</a><br><a href="https://blog.csdn.net/weixin_38239050/category_10485189.html">https://blog.csdn.net/weixin_38239050/category_10485189.html</a></p><p>大佬的博客：<br><a href="https://www.lfzxb.top/">https://www.lfzxb.top/</a><br>Unity交流群：959572557</p><p><a href="https://www.codeleading.com/tag/%23+GameFramework/">https://www.codeleading.com/tag/%23+GameFramework/</a></p><p><a href="https://blog.csdn.net/yupu56/category_9953722.html">https://blog.csdn.net/yupu56/category_9953722.html</a></p><p><a href="https://blog.csdn.net/qq_15020543/article/details/86766583">https://blog.csdn.net/qq_15020543/article/details/86766583</a></p><p><a href="https://blog.csdn.net/qq_32821435/category_7753219.html">https://blog.csdn.net/qq_32821435/category_7753219.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习7-有限状态自动机</title>
    <link href="/2024/02/15/UGF%E5%AD%A6%E4%B9%A07-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <url>/2024/02/15/UGF%E5%AD%A6%E4%B9%A07-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<ul><li>有限状态自动机入门|<br><a href="https://zhuanlan.zhihu.com/p/22976065">https://zhuanlan.zhihu.com/p/22976065</a></li><li>UGF有限状态自动机<br><a href="https://gameframework.cn/document/fsm/">https://gameframework.cn/document/fsm/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习6-导表</title>
    <link href="/2024/02/15/UGF%E5%AD%A6%E4%B9%A06-%E5%AF%BC%E8%A1%A8/"/>
    <url>/2024/02/15/UGF%E5%AD%A6%E4%B9%A06-%E5%AF%BC%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h1><h2 id="什么是数据表"><a href="#什么是数据表" class="headerlink" title="什么是数据表"></a>什么是数据表</h2><p>excel-&gt;text-&gt;UGF</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>编写Excel数据表格</li><li>将Excel数据表格保存为UTF-8编码的txt文本文件</li><li>编写数据表的解析类，该类需要继承 DataRowBase 类</li><li>在UGF的预加载流程中读取数据表txt文本文件，完成框架的解析</li><li>在编程时通过行号取得数据表数据</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="加载数据表"><a href="#加载数据表" class="headerlink" title="加载数据表"></a>加载数据表</h4><ol><li>实例化数据表对象<br><code>IDataTable&lt;数据类&gt; dataTable = GameEntry.DataTable.CreateDataTable&lt;数据类&gt;();</code></li><li>将自定义的数据表对象装箱为数据表基类  DataTableBase<br><code>DataTableBase dataTableBase = dataTable as DataTableBase;</code></li><li>将数据加载如数据表<br><code>dataTableBase.ReadData(&quot;数据表txt文件路径&quot;, this);</code>             </li></ol><p><strong>代码案例如下:</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> GameFramework.DataTable;<br><span class="hljs-keyword">using</span> GameFramework.Event;<br><span class="hljs-keyword">using</span> UnityGameFramework.Runtime;<br><span class="hljs-keyword">using</span> ProcedureOwner = GameFramework.Fsm.IFsm&lt;GameFramework.Procedure.IProcedureManager&gt;;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo5_ProcedureLaunch</span> : <span class="hljs-title">ProcedureBase</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnter</span>(<span class="hljs-params">ProcedureOwner procedureOwner</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">base</span>.OnEnter(procedureOwner);<br>        <span class="hljs-comment">// 订阅加载成功事件</span><br>        GameEntry.Event.Subscribe(LoadDataTableSuccessEventArgs.EventId, OnLoadDataTableSuccess);<br>        <span class="hljs-comment">// 订阅加载失败事件</span><br>        GameEntry.Event.Subscribe(LoadDataTableFailureEventArgs.EventId, OnLoadDataTableFailure);<br>        <span class="hljs-comment">// 加载配置表</span><br>        IDataTable&lt;DRScene&gt; dataTable = GameEntry.DataTable.CreateDataTable&lt;DRScene&gt;();<br>        DataTableBase dataTableBase = dataTable <span class="hljs-keyword">as</span> DataTableBase;<br>        dataTableBase.ReadData(<span class="hljs-string">&quot;Assets/GameMain/DataTables/Scene.txt&quot;</span>, <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">// 加载失败响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadDataTableFailure</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Log.Debug(<span class="hljs-string">&quot;失败&quot;</span>);<br>    &#125;<br> <span class="hljs-comment">// 加载成功响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadDataTableSuccess</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        LoadDataTableSuccessEventArgs ne = e <span class="hljs-keyword">as</span> LoadDataTableSuccessEventArgs;<br>        <span class="hljs-keyword">if</span> (ne.UserData != <span class="hljs-keyword">this</span>)<br>            <span class="hljs-keyword">return</span>;<br>        Log.Debug(<span class="hljs-string">&quot;加载成功!    &quot;</span> + ne.DataTableAssetName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><ul><li><p>获取数据表对象<br><code>IDataTable&lt;数据类&gt; 数据表对象 = DataTable.GetDataTable&lt;数据类&gt;();</code></p></li><li><p>获取所有数据行，返回数据行数组<br><code>数据类[] 数据表对象.GetAllDataRows();</code></p></li><li><p>获取指定数据行<br><code>数据表对象.GetDataRow(行号);</code></p><blockquote><p>不存在此行时返回空</p></blockquote></li><li><p>获取所有满足条件的数据行<br><code>数据表对象.GetDataRows((x) =&gt; &#123; return x.Id &gt; 0; &#125;);</code></p></li><li><p>获取满足条件的第一个数据行<br><code>数据表对象.GetDataRow((x) =&gt; &#123; return x.AssetName == &quot;Land&quot;; &#125;);</code></p></li></ul><p><strong>案例代码如下:</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadDataTableSuccess</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 获取数据表对象</span><br>    IDataTable&lt;DRScene&gt; dataTable = GameEntry.DataTable.GetDataTable&lt;DRScene&gt;();<br>    <span class="hljs-comment">//使用方法1：获得所有的行，并转化为数组（不转换带表格开头带#的）</span><br>    DRScene[] allData = dataTable.GetAllDataRows();<br>    Log.Debug(<span class="hljs-string">&quot;allData行数 : &quot;</span> + allData.Length);<br> <br>    <span class="hljs-comment">//使用方法2：获取的第x行的数据</span><br>    DRScene first = dataTable.GetDataRow(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-comment">// 此行存在，可以获取内容了</span><br>        Log.Debug(first.Id + <span class="hljs-string">&quot;    &quot;</span> + first.AssetName + <span class="hljs-string">&quot;    &quot;</span> + first.AssetValue);<br>    &#125;<br> <br>    <span class="hljs-comment">//使用方法3：获取所有满足条件的行</span><br>    DRScene[] usefulRows = dataTable.GetDataRows((x) =&gt; &#123; <span class="hljs-keyword">return</span> x.Id &gt; <span class="hljs-number">0</span>; &#125;);<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> drScene <span class="hljs-keyword">in</span> usefulRows)<br>    &#123;<br>        Log.Debug(<span class="hljs-string">&quot;usefulRows :&quot;</span> + drScene);<br>    &#125;<br> <br>    <span class="hljs-comment">//使用方法4：获得满足条件的第一行</span><br>    DRScene usefulRow = dataTable.GetDataRow((x) =&gt; &#123; <span class="hljs-keyword">return</span> x.AssetName == <span class="hljs-string">&quot;Land&quot;</span>; &#125;);<br>    Log.Debug(<span class="hljs-string">&quot;usefulRow:&quot;</span> + usefulRow);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>以场景数据表为例：</p><ol><li><p>编写Excel数据表格<br><img src="/images/UGF%E5%AD%A6%E4%B9%A06-%E5%AF%BC%E8%A1%A8/image-20211020164005473.png" srcset="/img/loading.gif"></p></li><li><p>将Excel数据表格保存为UTF-8编码的txt文本文件<br><img src="/images/UGF%E5%AD%A6%E4%B9%A06-%E5%AF%BC%E8%A1%A8/image-20211020140336732.png" srcset="/img/loading.gif"><br><img src="/images/UGF%E5%AD%A6%E4%B9%A06-%E5%AF%BC%E8%A1%A8/image-20211020164036097.png" srcset="/img/loading.gif"></p></li><li><p>编写数据表的解析类，该类需要继承 DataRowBase 类</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityGameFramework.Runtime;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SceneConfig</span> : <span class="hljs-title">DataRowBase</span><br>&#123;<br>    <span class="hljs-comment">// 数据表行号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_Id;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> Id =&gt; m_Id;<br>    <span class="hljs-comment">// 场景名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> SceneName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-comment">// 场景路径</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> ScenePath &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-comment">// 场景描述</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> SceneInfo &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-comment">// 字符流逐行解析</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ParseDataRow</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> dataRowString, <span class="hljs-built_in">object</span> userData</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//输入的是每一行字符串，</span><br>        <span class="hljs-built_in">string</span>[] columnStrings = dataRowString.Split(<span class="hljs-string">&#x27;\t&#x27;</span>);<br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">1</span>;<br>        m_Id = <span class="hljs-built_in">int</span>.Parse(columnStrings[index++]);<br>        SceneName = columnStrings[index++];<br>        ScenePath = columnStrings[index++];<br>        SceneInfo = columnStrings[index++];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在UGF的预加载流程中读取数据表txt文本文件，完成框架的解析</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> GameFramework.DataTable;<br><span class="hljs-keyword">using</span> GameFramework.Event;<br><span class="hljs-keyword">using</span> GameFramework.Procedure;<br><span class="hljs-keyword">using</span> UnityGameFramework.Runtime;<br><span class="hljs-keyword">using</span> ProcedureOwner = GameFramework.Fsm.IFsm&lt;GameFramework.Procedure.IProcedureManager&gt;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LaunchProcedure</span> : <span class="hljs-title">ProcedureBase</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnter</span>(<span class="hljs-params">ProcedureOwner procedureOwner</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">base</span>.OnEnter(procedureOwner);<br>        GameEntry.InitBuiltinComponents();<br><br>        <span class="hljs-comment">// 订阅加载成功事件</span><br>        GameEntry.Event.Subscribe(LoadDataTableSuccessEventArgs.EventId, OnLoadDataTableSuccess);<br>        <span class="hljs-comment">// 订阅加载失败事件</span><br>        GameEntry.Event.Subscribe(LoadDataTableFailureEventArgs.EventId, OnLoadDataTableFailure);<br>        <span class="hljs-comment">// 加载配置表</span><br>        IDataTable&lt;SceneConfig&gt; dataTable = GameEntry.DataTable.CreateDataTable&lt;SceneConfig&gt;();<br>        DataTableBase dataTableBase = dataTable <span class="hljs-keyword">as</span> DataTableBase;<br>        dataTableBase.ReadData(<span class="hljs-string">&quot;Assets/GameMain/Configs/SceneConfigs.txt&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>        ChangeState&lt;MenuProcedure&gt;(procedureOwner);<br>    &#125;<br><br>    <span class="hljs-comment">// 加载失败响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadDataTableFailure</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Log.Debug(<span class="hljs-string">&quot;场景数据表加载失败!&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 加载成功响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadDataTableSuccess</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        LoadDataTableSuccessEventArgs ne = e <span class="hljs-keyword">as</span> LoadDataTableSuccessEventArgs;<br>        <span class="hljs-keyword">if</span> (ne.UserData != <span class="hljs-keyword">this</span>)<br>            <span class="hljs-keyword">return</span>;<br>        Log.Debug(<span class="hljs-string">&quot;场景数据表加载成功!    &quot;</span> + ne.DataTableAssetName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>在编程时通过行号取得数据表数据</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainGameProcedure</span> : <span class="hljs-title">ProcedureBase</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnter</span>(<span class="hljs-params">ProcedureOwner procedureOwner</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">base</span>.OnEnter(procedureOwner);<br>        Log.Debug(<span class="hljs-string">&quot;进入游戏主流程&quot;</span>);<br>        IDataTable&lt;SceneConfig&gt; dataTable = GameEntry.DataTable.GetDataTable&lt;SceneConfig&gt;();<br>        SceneConfig usefulRow = dataTable.GetDataRow((x) =&gt; &#123; <span class="hljs-keyword">return</span> x.SceneName == <span class="hljs-string">&quot;MainScenes&quot;</span>; &#125;);<br>        GameEntry.Scene.LoadScene(usefulRow.ScenePath, <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="程序化生成"><a href="#程序化生成" class="headerlink" title="程序化生成"></a>程序化生成</h2><p><a href="https://blog.csdn.net/qq_35179648/article/details/112300863">https://blog.csdn.net/qq_35179648/article/details/112300863</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="DataRowBase接口"><a href="#DataRowBase接口" class="headerlink" title="DataRowBase接口"></a>DataRowBase接口</h3><ul><li><p>行号<br><code>int Id</code><br>抽象属性，需要重写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 数据表行号</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_Id;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> Id =&gt; m_Id;<br></code></pre></td></tr></table></figure></li><li><p>逐行解析</p><ul><li>字符流<br><code>bool ParseDataRow(string dataRowString, object userData)</code></li><li>字节流<br><code>bool ParseDataRow(byte[] dataRowBytes, int startIndex, int length, object userData)</code></li></ul></li></ul><p>实现案例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 字符流逐行解析</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ParseDataRow</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> dataRowString, <span class="hljs-built_in">object</span> userData</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//输入的是每一行字符串，</span><br>        <span class="hljs-built_in">string</span>[] columnStrings = dataRowString.Split(<span class="hljs-string">&#x27;\t&#x27;</span>);<br><br>        <span class="hljs-built_in">int</span> index = <span class="hljs-number">1</span>;<br>        m_Id = <span class="hljs-built_in">int</span>.Parse(columnStrings[index++]);<br><br>        SceneID = <span class="hljs-built_in">int</span>.Parse(columnStrings[index++]);<br>        SceneName = columnStrings[index++];<br>        SceneInfo = columnStrings[index++];<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="全局配置表"><a href="#全局配置表" class="headerlink" title="全局配置表"></a>全局配置表</h1><p>全局配置表用于存储一些全局只读的游戏配置。</p><h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><p>全局配置表使用方法如下：</p><ol><li><p>书写全局配置文档(方法同数据表)</p></li><li><p>预加载流程中读取配置文档<br><code>string configAssetName = AssetUtility.GetConfigAsset(configName, false);</code></p></li><li><p>解析文档到框架<br>编写解析脚本(方法同数据表)<br>将解析脚本挂到Config对象上<br><img src="/images/UGF%E5%AD%A6%E4%B9%A06-%E5%AF%BC%E8%A1%A8/image-20211020164727389.png" srcset="/img/loading.gif"></p><p>使用<code>GameEntry.Config.ReadData(configAssetName, this);</code>方法解析配置文档</p></li><li><p>通过全局配置组件使用配置表内容</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习5-实体</title>
    <link href="/2024/02/15/UGF%E5%AD%A6%E4%B9%A05-%E5%AE%9E%E4%BD%93/"/>
    <url>/2024/02/15/UGF%E5%AD%A6%E4%B9%A05-%E5%AE%9E%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是实体"><a href="#1-什么是实体" class="headerlink" title="1. 什么是实体"></a>1. 什么是实体</h1><p>我们将游戏场景中，动态创建的一切物体定义为实体。</p><p>此模块提供管理实体和实体组的功能，如显示隐藏实体、挂接实体（如挂接武器、坐骑，或者抓起另一个实体）等。</p><p>实体使用结束后可以不立刻销毁，从而等待下一次重新使用。</p><p>在GF里，实体有以下几个特性：</p><ul><li>所有的游戏物体都被当做实体</li><li>实体（Entity）与实体逻辑（EntityLogic）分离<br>实体逻辑通过组件的形式组装到实体身上。</li><li>实体逻辑是创造实体的时候动态添加的。</li></ul><h1 id="实体组件的用法"><a href="#实体组件的用法" class="headerlink" title="实体组件的用法"></a>实体组件的用法</h1><h2 id="EntityComponent的使用"><a href="#EntityComponent的使用" class="headerlink" title="EntityComponent的使用"></a>EntityComponent的使用</h2><ul><li><p>打开实体<br><code>ShowEntity&lt;自定义实体逻辑脚本&gt;(int id, string path, string groupName);</code></p><ul><li>id: 实体ID</li><li>path:实体预制体路径</li><li>groupName:实体组名</li></ul><blockquote><p>注意：<br>若id不同，会生成并打开新实体<br>若id相同，会打开旧实体并数据不变</p></blockquote></li><li><p>隐藏实体</p><ul><li><p><code>HideEntity(int id);</code><br>id: 实体ID</p></li><li><p><code>HideEntity(实体对象);</code><br>可以是this</p><blockquote><p>该对象必须为继承了Entity的类的实例 </p></blockquote></li><li><p><code>HideAllLoadingEntities();</code><br>隐藏所有加载中的实体</p></li><li><p><code>HideAllLoadedEntities();</code><br>隐藏所有加载完成的实体</p></li></ul><blockquote><p>一旦实体被隐藏，该实体的行为就不确定了，可能会被GC(销毁)</p></blockquote></li><li><p>获取已激活的实体对象<br><code>GetEntity(int id);</code><br>ID：实体ID</p><blockquote><p>无法获得已经隐藏的实体</p></blockquote></li><li><p>将实体挂到其他游戏物体上成为子物体</p></li></ul><h2 id="EntityBase"><a href="#EntityBase" class="headerlink" title="EntityBase"></a>EntityBase</h2><p>当你为实体写逻辑代码时，逻辑代码需要继承自EntityLogic类。</p><p>以下方法都可以重写在继承了EntityLogic的实体逻辑类中</p><p>该类实体的生存周期如下：</p><ul><li>实体初始化<br><code>void OnInit(object userData)</code></li><li>实体显示<br><code>void OnShow(object userData)</code></li><li>每帧轮询<br><code>void OnUpdate(float elapseSeconds, float realElapseSeconds)</code></li><li>实体隐藏<br><code>void OnHide(bool isShutdown, object userData)</code></li><li>实体回收<br><code>void OnRecycle()</code></li><li>实体附加子实体<ul><li><code>void OnAttached(EntityLogic childEntity, Transform parentTransform, object userData)</code><br>当前实体为父物体，传入实体为子物体</li><li><code>void OnAttachTo(EntityLogic parentEntity, Transform parentTransform, object userData)</code><br>当前实体为子物体，传入实体为父物体</li></ul></li><li>实体解除子实体<ul><li><code>void OnDetached(EntityLogic childEntity, object userData)</code><br>当前实体为父物体，传入实体为子物体</li><li><code>void OnDetachFrom(EntityLogic parentEntity, object userData)</code><br>当前实体为子物体，传入实体为父物体</li></ul></li></ul><h1 id="实体组件的原理"><a href="#实体组件的原理" class="headerlink" title="实体组件的原理"></a>实体组件的原理</h1><ul><li><p>实体基类:EntityBase</p></li><li><p>数据存储基类:EntityData</p></li><li><p>实体扩展类:EntityExtension</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习4-UI</title>
    <link href="/2024/02/15/UGF%E5%AD%A6%E4%B9%A04-UI/"/>
    <url>/2024/02/15/UGF%E5%AD%A6%E4%B9%A04-UI/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_37920739/article/details/104089605">https://blog.csdn.net/m0_37920739/article/details/104089605</a></p><p><a href="https://blog.csdn.net/weixin_42066580/article/details/117691546?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-10.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-10.no_search_link">https://blog.csdn.net/weixin_42066580/article/details/117691546?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-10.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-10.no_search_link</a></p><p><a href="https://www.jianshu.com/p/b75718ac2f1f">https://www.jianshu.com/p/b75718ac2f1f</a></p><h1 id="UI组件结构"><a href="#UI组件结构" class="headerlink" title="UI组件结构"></a>UI组件结构</h1><p><img src="/images/UGF%E5%AD%A6%E4%B9%A04-UI/UGF-3-2.png" srcset="/img/loading.gif"></p><p><strong>UI五大事件:</strong></p><ul><li>界面打开成功事件<br><code>OpenUIFormSuccessEventArgs</code></li><li>打开界面失败事件<br><code>OpenUIFormFailureEventArgs</code></li><li>打开界面时加载依赖资源事件<br><code>OpenUIFormDependencyAssetEventArgs</code></li><li>打开界面更新事件<br><code>OpenUIFormUpdateEventArgs</code></li><li>关闭界面完成事件<br><code>CloseUIFormCompleteEventArgs</code></li></ul><p><strong>UIManager:</strong><br>里面一个字典是用来保存已经加载的视图资源，打开界面时会从对象池里面获取到资源。<br>如果获取不到将实例化这个资源然后保存到对象池里，然后对用数据结构进行界面资源信息的增删改查更新。<br>这个脚本主要是提供给使用框架的我们重要的接口。</p><p><strong>UIForm：</strong><br>是打开界面的时候会实例化界面信息然后挂载到界面上的<br>底层框架的UIManager将需要使用此脚本的函数<br>这个脚本与我们使用框架的人没有任何关系</p><p><strong>UIGroup：</strong><br>由UIManager调用，我们调用UIManager的函数就可以了。</p><p><strong>UGuiGroupHelper：</strong><br>界面组辅助器，就是控制界面组的一些API，目前只有深度的控制的函数。</p><p><strong>DefaultUIFormHelper：</strong><br>界面辅助器，就是控制界面的一些API，比如界面的创建和释放等等。</p><p><strong>UIComponent：</strong><br>实际挂载到物体上并且来控制界面的，主要是对UIManager的一层封装，调整参数对这个模块可能进行裁剪。<br>比如是否需要打开界面成功的事件，实例化界面资源的优先级，界面组初始化的个数等。</p><p>UIComponent在Start的时候主要是对UIManager进行初始化。<br>一般开发的使用我们的界面组可以定义4个叫</p><ul><li>NormalGroup(基本界面组)</li><li>PopupGroup(弹窗界面组)</li><li>HintGroup(提示界面组)</li><li>ToppestGroup(最高深度组)</li></ul><p><img src="/images/UGF%E5%AD%A6%E4%B9%A04-UI/UGF-3-1.png" srcset="/img/loading.gif"></p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="/images/UGF%E5%AD%A6%E4%B9%A04-UI/UGF-3-3.png" srcset="/img/loading.gif"></p><h1 id="UI组件的使用"><a href="#UI组件的使用" class="headerlink" title="UI组件的使用"></a>UI组件的使用</h1><h2 id="UIComponent的使用"><a href="#UIComponent的使用" class="headerlink" title="UIComponent的使用"></a>UIComponent的使用</h2><p>UIComponent 是对 UIManger的封装，没有特殊需求时使用 UIComponent 即可。</p><p><strong>常用方法：</strong></p><ul><li><p>AddUIGroup<br>增加界面组<br><code>bool ADDUIGroup(string uiGroupName, int depth)</code></p><ul><li>uiGroupName:<br>界面组名称</li><li>depth:<br>界面组层级(在哪个图层)</li><li>返回是否成功增加界面组</li></ul></li><li><p>OpenUIForm<br>打开界面<br><code>int OpenUIForm(string uiFormAssetName, string uiGroupName)</code></p><ul><li>uiFormAssetName:<br>界面名称</li><li>uiGroupName:<br>界面组名称</li><li>返回打开的界面ID</li></ul></li><li><p>CloseUIForm<br>关闭界面<br><code>void CloseUIForm(UIForm uiFrom)</code></p><ul><li>uiFrom:<br>要关闭的界面对象</li></ul></li><li><p>RefocusUIForm<br>激活界面</p><ul><li><code>void RefocusUIForm(UIForm uiForm)</code></li><li><code>void RefocusUIForm(UIForm uiForm, object userData)</code><ul><li>userData:<br>用户自定义数据</li></ul></li></ul></li></ul><blockquote><p>UI打开时是异步的</p><p>更多AIP见<br><a href="https://gameframework.cn/api/class_unity_game_framework_1_1_runtime_1_1_u_i_component.html">https://gameframework.cn/api/class_unity_game_framework_1_1_runtime_1_1_u_i_component.html</a></p></blockquote><h2 id="UIGroup的使用"><a href="#UIGroup的使用" class="headerlink" title="UIGroup的使用"></a>UIGroup的使用</h2><p>UIGroup 实际上是将同一Layer层级(图层)上的UI界面打包成一组(可以理解为深度)。</p><p>一般情况下可以将一个游戏的UI界面分为以下几个层级</p><ol><li>Background层<br>最底层UI</li><li>Scene层</li><li>Normal层<br>用户点开的多级UI</li><li>Info层<br>广播，消息弹窗</li><li>Tip层<br>错误提示</li><li>Top层</li></ol><h2 id="UIForm的使用"><a href="#UIForm的使用" class="headerlink" title="UIForm的使用"></a>UIForm的使用</h2><p>每个独立的UI界面就是一个UIForm对象。<br>它应该只是窗口，相关的逻辑内容应该写在UIFormLogic中。</p><p>以下方法都可以重写在继承了UIFormLogic的UI逻辑类中</p><p>自定义UIForm的方法：</p><p>常用方法：</p><ul><li><p>界面初始化<br><code>void OnInit(object userData)</code></p></li><li><p>界面打开<br><code>void OnOpen(object userData)</code></p></li><li><p>界面关闭<br><code>void OnClose(bool isShutdown, object userData)</code></p></li><li><p>界面暂停</p></li><li><p>界面暂停恢复</p></li><li><p>界面遮挡</p></li><li><p>界面遮挡恢复</p></li><li><p>界面激活</p></li><li><p>界面轮询</p></li><li><p>界面深度改变(更改所在层级)</p></li></ul><h1 id="UI组件拓展接口"><a href="#UI组件拓展接口" class="headerlink" title="UI组件拓展接口"></a>UI组件拓展接口</h1><p>UIExtension类进行扩展接口的查阅，它是静态拓展UIComponent类，具体实现在StarForce工程中，可以CV到UnityGameframework中进行使用，具体接口表格如下： </p><table><thead><tr><th>接口名称</th><th>作用</th></tr></thead><tbody><tr><td>FadeToAlpha</td><td>界面的透明度渐变的协程</td></tr><tr><td>SmoothValue</td><td>进度条的逐渐达到目标点的协程</td></tr><tr><td>HasUIForm</td><td>是否存在此界面的id</td></tr><tr><td>GetUIForm</td><td>获取挂载到此界面的UGuiForm</td></tr><tr><td>CloseUIForm</td><td>把此界面的UGuiForm脚本作为参数关闭界面</td></tr><tr><td>OpenUIForm</td><td>通过界面的枚举id去打开界面</td></tr><tr><td>OpenDialog</td><td>打开自定义的提示界面</td></tr><tr><td>OpenNativeDialog</td><td>打开原生态的提示界面</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习3-场景</title>
    <link href="/2024/02/15/UGF%E5%AD%A6%E4%B9%A03-%E5%9C%BA%E6%99%AF/"/>
    <url>/2024/02/15/UGF%E5%AD%A6%E4%B9%A03-%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="场景组件的常用方法"><a href="#场景组件的常用方法" class="headerlink" title="场景组件的常用方法"></a>场景组件的常用方法</h1><ul><li><p>得到场景组件<br><code>SceneComponent sceneComponent = GameEntry.GetComponent&lt;SceneComponent&gt;();</code></p></li><li><p>加载场景</p><ul><li><code>void LoadScene(string &quot;路径名&quot;, int 加载优先级)</code></li><li><code>void LoadScene(string &quot;路径名&quot;, int 加载优先级, object 用户数据)</code></li><li><code>void LoadScene(string &quot;路径名&quot;)</code></li><li><code>void LoadScene(string &quot;路径名&quot;, object 用户数据)</code></li></ul></li><li><p>卸载场景<br><code>UnloadScene(&quot;场景名称&quot;);</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-comment">// 卸载所有场景()</span><br><span class="hljs-built_in">string</span>[] loadedSceneAssetNames = Scene.GetLoadedSceneAssetNames();<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; loadedSceneAssetNames.Length; i++)<br>&#123;<br>    Scene.UnloadScene(loadedSceneAssetNames[i]);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>并不会卸载掉 GameFramework 启动场景</p></blockquote></li><li><p>场景回调</p><ul><li>方法一：<br>订阅场景加载事件后回调(常用)<br>常用场景加载事件：<br><a href="https://gameframework.cn/api/namespace_game_framework_1_1_scene.html">有关场景的事件API</a><ul><li><strong>LoadSceneDependencyAssetEventArgs</strong><br>加载场景时加载依赖资源事件</li><li><strong>LoadSceneFailureEventArgs</strong><br>加载场景失败事件</li><li><strong>LoadSceneSuccessEventArgs</strong><br>加载场景成功事件</li><li><strong>LoadSceneUpdateEventArgs</strong><br>加载场景更新事件</li><li><strong>UnloadSceneFailureEventArgs</strong><br>卸载场景失败事件</li><li><strong>UnloadSceneSuccessEventArgs</strong><br>卸载场景成功事件</li></ul></li><li>方法二：<br>使用 <strong>LoadSceneCallbacks</strong> (场景加载回调函数类)回调(不常用)<br><a href="https://gameframework.cn/api/class_game_framework_1_1_resource_1_1_load_scene_callbacks.html">LoadSceneCallbacks 介绍</a></li></ul></li></ul><h1 id="场景组件机制"><a href="#场景组件机制" class="headerlink" title="场景组件机制"></a>场景组件机制</h1><p>UGF在加载新场景时会将新场景叠加在原场景之上。<br>当多场景加载时会变得越来越乱，所以建议在加载新场景前先卸载所有场景，在加载。<br>卸载场景并不会卸载掉UGF的启动场景，可放心使用。</p><h1 id="流程与场景的结合"><a href="#流程与场景的结合" class="headerlink" title="流程与场景的结合"></a>流程与场景的结合</h1><p>在项目中一般会有专门的场景切换 <strong>流程</strong> 和记录场景数据的 <strong>数据表</strong> 来控制 <strong>场景</strong> 的切换。<br> <strong>流程</strong> 代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> GameFramework.DataTable;<br><span class="hljs-keyword">using</span> GameFramework.Event;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityGameFramework.Runtime;<br><span class="hljs-keyword">using</span> ProcedureOwner = GameFramework.Fsm.IFsm&lt;GameFramework.Procedure.IProcedureManager&gt;;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">YouProject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProcedureChangeScene</span> : <span class="hljs-title">ProcedureBase</span> <br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MenuSceneId = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsSceneLoadComplete = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_BackgroundMusicId = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> sceneId = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 流程开始响应函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnter</span>(<span class="hljs-params">ProcedureOwner procedureOwner</span>) </span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">base</span>.OnEnter(procedureOwner);<br><br>            m_IsSceneLoadComplete = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-comment">// 订阅 场景加载成功事件 并绑定响应函数 OnLoadSceneSuccess</span><br>            GameEntry.Event.Subscribe(LoadSceneSuccessEventArgs.EventId, OnLoadSceneSuccess);<br>            <span class="hljs-comment">// 订阅 场景加载失败事件 并绑定响应函数 OnLoadSceneFailure</span><br>            GameEntry.Event.Subscribe(LoadSceneFailureEventArgs.EventId, OnLoadSceneFailure);<br>            <span class="hljs-comment">// 订阅 初始化加载场景更新事件 并绑定响应函数 OnLoadSceneUpdate</span><br>            GameEntry.Event.Subscribe(LoadSceneUpdateEventArgs.EventId, OnLoadSceneUpdate);<br><br>            <span class="hljs-comment">// 停止所有声音</span><br>            GameEntry.Sound.StopAllLoadingSounds();<br>            GameEntry.Sound.StopAllLoadedSounds();<br><br>            <span class="hljs-comment">// 隐藏所有实体</span><br>            GameEntry.Entity.HideAllLoadingEntities();<br>            GameEntry.Entity.HideAllLoadedEntities();<br><br>            <span class="hljs-comment">// 卸载所有场景</span><br>            <span class="hljs-built_in">string</span>[] loadedSceneAssetNames = GameEntry.Scene.GetLoadedSceneAssetNames();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; loadedSceneAssetNames.Length; i++) <br>            &#123;<br>                Debug.Log(<span class="hljs-string">&quot;loadedSceneAssetNames: &quot;</span> + loadedSceneAssetNames[i]);<br>                GameEntry.Scene.UnloadScene(loadedSceneAssetNames[i]);<br>            &#125;<br><br>            <span class="hljs-comment">// 还原游戏速度</span><br>            GameEntry.Base.ResetNormalGameSpeed();<br><span class="hljs-comment">// 从数据表中获取下个加载场景的ID</span><br>            sceneId = procedureOwner.GetData&lt;VarInt&gt;(<span class="hljs-string">&quot;NextSceneId&quot;</span>);<br>            IDataTable&lt;DRScene&gt; dtScene = GameEntry.DataTable.GetDataTable&lt;DRScene&gt;();<br>            DRScene drScene = dtScene.GetDataRow(sceneId);<br>            <span class="hljs-keyword">if</span> (drScene == <span class="hljs-literal">null</span>) <br>            &#123;<br>                Log.Warning(<span class="hljs-string">&quot;Can not load scene &#x27;&#123;0&#125;&#x27; from data table.&quot;</span>, sceneId.ToString());<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 加载对应的场景</span><br>            GameEntry.Scene.LoadScene(AssetUtility.GetSceneAsset(drScene.AssetName), Constant.AssetPriority.SceneAsset, <span class="hljs-keyword">this</span>);<br>            m_BackgroundMusicId = drScene.BackgroundMusicId;<br>        &#125;<br><br>        <span class="hljs-comment">// 流程结束响应函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLeave</span>(<span class="hljs-params">ProcedureOwner procedureOwner, <span class="hljs-built_in">bool</span> isShutdown</span>)</span> &#123;<br>            GameEntry.Event.Unsubscribe(LoadSceneSuccessEventArgs.EventId, OnLoadSceneSuccess);<br>            GameEntry.Event.Unsubscribe(LoadSceneFailureEventArgs.EventId, OnLoadSceneFailure);<br>            GameEntry.Event.Unsubscribe(LoadSceneUpdateEventArgs.EventId, OnLoadSceneUpdate);<br>            GameEntry.Event.Unsubscribe(LoadSceneDependencyAssetEventArgs.EventId, OnLoadSceneDependencyAsset);<br><br>            <span class="hljs-keyword">base</span>.OnLeave(procedureOwner, isShutdown);<br>        &#125;<br><br>        <span class="hljs-comment">// 流程轮询函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params">ProcedureOwner procedureOwner, <span class="hljs-built_in">float</span> elapseSeconds, <span class="hljs-built_in">float</span> realElapseSeconds</span>) </span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">base</span>.OnUpdate(procedureOwner, elapseSeconds, realElapseSeconds);<br><br>            <span class="hljs-comment">// 判断场景是否异步加载完成</span><br>            <span class="hljs-keyword">if</span> (!m_IsSceneLoadComplete)<br>                <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-comment">// 在这里根据切换到的场景编号进行对应的流程切换</span><br>            <span class="hljs-keyword">switch</span> (sceneId) <br>            &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    ChangeState&lt;ProcedureLogin&gt;(procedureOwner);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    ChangeState&lt;ProcedureMain&gt;(procedureOwner);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    ChangeState&lt;ProcedureBattle&gt;(procedureOwner);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-literal">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 场景加载成功事件响应函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadSceneSuccess</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>) </span><br><span class="hljs-function"></span>        &#123;<br>            LoadSceneSuccessEventArgs ne = (LoadSceneSuccessEventArgs)e;<br>            <span class="hljs-comment">// 若非本流程切换场景，不执行剩余操作</span><br>            <span class="hljs-keyword">if</span> (ne.UserData != <span class="hljs-keyword">this</span>) <br>                <span class="hljs-keyword">return</span>;<br><br>            Log.Info(<span class="hljs-string">&quot;Load scene &#x27;&#123;0&#125;&#x27; OK.&quot;</span>, ne.SceneAssetName);<br><br>            <span class="hljs-comment">// 播放对应场景BGM</span><br>            <span class="hljs-keyword">if</span> (m_BackgroundMusicId &gt; <span class="hljs-number">0</span>)<br>                GameEntry.Sound.PlayMusic(m_BackgroundMusicId);<br><br>            <span class="hljs-comment">// 设置场景加载完成标志位为真</span><br>            m_IsChangeSceneComplete = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 场景加载失败事件响应函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadSceneFailure</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>) </span><br><span class="hljs-function"></span>        &#123;<br>            LoadSceneFailureEventArgs ne = (LoadSceneFailureEventArgs)e;<br>            <span class="hljs-keyword">if</span> (ne.UserData != <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span>;<br>            Log.Error(<span class="hljs-string">&quot;Load scene &#x27;&#123;0&#125;&#x27; failure, error message &#x27;&#123;1&#125;&#x27;.&quot;</span>, ne.SceneAssetName, ne.ErrorMessage);<br>        &#125;<br><br>        <span class="hljs-comment">// 场景加载使用资源更新事件响应函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadSceneUpdate</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>) </span><br><span class="hljs-function"></span>        &#123;<br>            LoadSceneUpdateEventArgs ne = (LoadSceneUpdateEventArgs)e;<br>            <span class="hljs-keyword">if</span> (ne.UserData != <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span>;<br>            Log.Info(<span class="hljs-string">&quot;Load scene &#x27;&#123;0&#125;&#x27; update, progress &#x27;&#123;1&#125;&#x27;.&quot;</span>, ne.SceneAssetName, ne.Progress.ToString(<span class="hljs-string">&quot;P2&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-comment">// 场景加载依赖资源事件响应函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadSceneDependencyAsset</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>) </span><br><span class="hljs-function"></span>        &#123;<br>            LoadSceneDependencyAssetEventArgs ne = (LoadSceneDependencyAssetEventArgs)e;<br>            <span class="hljs-keyword">if</span> (ne.UserData != <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span>;<br>            Log.Info(<span class="hljs-string">&quot;Load scene &#x27;&#123;0&#125;&#x27; dependency asset &#x27;&#123;1&#125;&#x27;, count &#x27;&#123;2&#125;/&#123;3&#125;&#x27;.&quot;</span>, ne.SceneAssetName, ne.DependencyAssetName, ne.LoadedCount.ToString(), ne.TotalCount.ToString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的场景数据表<br><img src="/images/UGF%E5%AD%A6%E4%B9%A03-%E5%9C%BA%E6%99%AF/image-20211026111054048.png" srcset="/img/loading.gif"></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习2-事件</title>
    <link href="/2024/02/15/UGF%E5%AD%A6%E4%B9%A02-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2024/02/15/UGF%E5%AD%A6%E4%B9%A02-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://gameframework.cn/document/event/">https://gameframework.cn/document/event/</a></p><p>事件是游戏逻辑监听、抛出事件的机制。</p><p>Game Framework 中的很多模块在完成操作后都会抛出内置事件，监听这些事件将大大解除游戏逻辑之间的耦合。</p><p>除了 Game Framework 内置事件外，使用者也可以定义自己的游戏逻辑事件，游戏中所有事件均派生自 GameEventArgs 类，事件对象使用了引用池技术，以避免使用事件过程中频繁的内存分配。</p><h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><ul><li><p>获取事件组件<br><code>EventComponent eventComponent = GameEntry.GetComponent&lt;EventComponent&gt;();</code></p></li><li><p>订阅事件<br><code>void Subscribe(int eventID, function);</code></p><ul><li>eventID<br>事件ID</li><li>function<br>事件响应函数</li></ul></li><li><p>取消订阅事件<br><code>void Unsubscribe(int eventID, function);</code></p></li><li><p>检查是否订阅事件<br><code>bool Check(int eventID, function);</code></p></li><li><p>广播事件</p><ul><li><code>void Fire(object sender, GameEventArgs e);</code><br>可保证线程安全，即使不在主线程中抛出，也可保证在主线程中回调事件处理函数，但事件会在抛出后的下一帧分发。<ul><li>sender：<br>广播发起人(通常为this)</li><li>e:<br>进行广播的事件</li></ul></li><li><code>void FireNow (object sender, GameEventArgs e)</code><br>立即广播，线程不安全</li></ul></li><li><p>获取某个事件的事件处理函数数量<br><code>int Count(int EventId);</code></p></li><li><p>获取待处理事件数量<br><code>EventCount</code><br>这是 EventComponent 的属性</p></li></ul><h1 id="事件响应函数的实现"><a href="#事件响应函数的实现" class="headerlink" title="事件响应函数的实现"></a>事件响应函数的实现</h1><p>实现方法如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> 事件响应函数名(<span class="hljs-built_in">object</span> sender, GameEventArgs e)<br>&#123;<br>    <span class="hljs-comment">// 事件响应内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中参数为：</p><ul><li>object sender<br>事件发送者</li><li>GameEventArgs e<br>事件</li></ul><p>案例:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 加载数据表成功事件处理函数。</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sender&quot;&gt;</span>事件发送者。<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span>事件。<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLoadDataTableSuccess</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>)</span><br><span class="hljs-function"></span>&#123;<br>    LoadDataTableSuccessEventArgs ne = (LoadDataTableSuccessEventArgs)e;<br>    Log.Info(<span class="hljs-string">&quot;数据表 &#x27;&#123;0&#125;&#x27; 加载成功。&quot;</span>, ne.DataTableName);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>设置默认事件响应函数</strong></p><p>定义并设置默认事件处理函数，当任意事件被抛出且不存在任何事件处理函数时，默认事件处理函数将被调用。<br><code>void SetDefaultHandler(function);</code></p></blockquote><h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>自定义事件需要继承 GameEventArgs</p><p>案例如下：<br><strong>自定义事件类：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 玩家名字改变事件。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerNameChangedEventArgs</span> : <span class="hljs-title">GameEventArgs</span><br>&#123;<br>    <span class="hljs-comment">// 玩家名字改变事件编号。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> EventId = <span class="hljs-keyword">typeof</span>(PlayerNameChangedEventArgs).GetHashCode();<br> <br>    <span class="hljs-comment">// 初始化玩家名字改变事件的新实例。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PlayerNameChangedEventArgs</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        NewPlayerName = <span class="hljs-literal">null</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 获取玩家名字改变事件编号。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> Id<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> EventId;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// 获取新的玩家名字。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> NewPlayerName<br>    &#123;<br>        <span class="hljs-keyword">get</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">// 创建玩家名字改变事件。</span><br>    <span class="hljs-comment">// &lt;param name=&quot;e&quot;&gt;内部事件。&lt;/param&gt;</span><br>    <span class="hljs-comment">// &lt;returns&gt;创建的玩家名字改变事件。&lt;/returns&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PlayerNameChangedEventArgs <span class="hljs-title">Create</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> newPlayerName</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 使用引用池技术，避免频繁内存分配</span><br>        PlayerNameChangedEventArgs e = ReferencePool.Acquire&lt;PlayerNameChangedEventArgs&gt;();<br>        e.NewPlayerName = newPlayerName;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br> <br>    <span class="hljs-comment">// 清理玩家名字改变事件。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Clear</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">// 使用引用池技术，注意清理事件实例</span><br>        NewPlayerName = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义事件处理函数：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPlayerNameChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>)</span><br><span class="hljs-function"></span>&#123;<br>    PlayerNameChangedEventArgs ne = (PlayerNameChangedEventArgs)e;<br>    Log.Info(<span class="hljs-string">&quot;新的玩家名字是 &#x27;&#123;0&#125;&#x27;.&quot;</span>, ne.NewPlayerName);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>订阅自定义事件：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">eventComponent.Subscribe(PlayerNameChangedEventArgs.EventId, OnPlayerNameChanged);<br></code></pre></td></tr></table></figure><p><strong>广播自定义事件:</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">eventComponent.Fire(<span class="hljs-keyword">this</span>, PlayerNameChangedEventArgs.Create(<span class="hljs-string">&quot;Ellan&quot;</span>));<br></code></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="提取-EventHandler-降低内存分配"><a href="#提取-EventHandler-降低内存分配" class="headerlink" title="提取 EventHandler 降低内存分配"></a>提取 EventHandler 降低内存分配</h2><p>由于将方法转换为 EventHandler 时会有内存分配，所以建议将 EventHandler 预定义为临时变量甚至所在类的成员变量，来降低内存开销。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">EventHandler&lt;GameEventArgs&gt; loadDataTableSuccess = OnLoadDataTableSuccess;<br>eventComponent.Subscribe(LoadDataTableSuccessEventArgs.EventId, loadDataTableSuccess);<br>eventComponent.Unsubscribe(LoadDataTableSuccessEventArgs.EventId, loadDataTableSuccess);<br></code></pre></td></tr></table></figure><h2 id="事件订阅与取消订阅不匹配"><a href="#事件订阅与取消订阅不匹配" class="headerlink" title="事件订阅与取消订阅不匹配"></a>事件订阅与取消订阅不匹配</h2><p>事件的订阅与取消订阅在使用生命周期内，应当成对出现。比如实体显示时订阅、隐藏时取消订阅，界面打开时订阅、关闭时取消订阅。</p><p>Game Framework 会严格检查事件订阅的匹配情况，不允许出现重复订阅，也不允许出现重复取消订阅或取消订阅尚未订阅的事件处理函数，如果出现这些情况，将会抛出异常。</p><p>有时，使用者在对象生命期结束前，的确写有取消订阅的代码，但非预期的逻辑导致逻辑块提前跳出，取消订阅的代码最终未被调用，进而下一次订阅时出现重复订阅。</p><h2 id="错误地缓存了事件实例"><a href="#错误地缓存了事件实例" class="headerlink" title="错误地缓存了事件实例"></a>错误地缓存了事件实例</h2><p>事件处理函数处理事件时，不应该缓存 GameEventArgs 实例，GameEventArgs 实例的有效生命周期，仅限于事件处理函数内。</p><p>Game Framework 为了降低内存分配，事件实例使用了引用池技术。一个事件被其所有事件处理函数处理完成后，事件实例会被立刻清理并回收（调用 GameEventArgs 中的 Clear 方法）。后续逻辑访问缓存的事件实例时，将无法访问到任何有效数据，甚至访问到此实例被复用后的数据。</p><p>因此，缓存事件实例是完全错误的，这将导致难以追踪的 BUG。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 这是一个错误的示例！</span><br><span class="hljs-keyword">private</span> PlayerNameChangedEventArgs m_CachedPlayerNameChangedEventArgs = <span class="hljs-literal">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPlayerNameChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, GameEventArgs e</span>)</span><br><span class="hljs-function"></span>&#123;<br>    m_CachedPlayerNameChangedEventArgs = (PlayerNameChangedEventArgs)e;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义事件类的-Clear-方法实现不完整"><a href="#自定义事件类的-Clear-方法实现不完整" class="headerlink" title="自定义事件类的 Clear 方法实现不完整"></a>自定义事件类的 Clear 方法实现不完整</h2><p>自定义事件类使用了引用池技术，事件实例是会被复用的。当回收某个事件实例时，不完整的 Clear 实现无法清理干净事件实例中的数据，进而将脏数据带到下一次复用事件实例的逻辑中去，这可能导致难以追踪的 BUG。</p><h2 id="手误导致的事件处理函数不生效"><a href="#手误导致的事件处理函数不生效" class="headerlink" title="手误导致的事件处理函数不生效"></a>手误导致的事件处理函数不生效</h2><p>订阅成功事件时，同时订阅相匹配的失败事件是一个好习惯，但有时复制粘贴代码会惹祸，如以下示例。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">eventComponent.Subscribe(LoadDataTableSuccessEventArgs.EventId, OnLoadDataTableSuccess);<br><span class="hljs-comment">// 忘记将事件名中的 Success 修改为 Failure</span><br>eventComponent.Subscribe(LoadDataTableSuccessEventArgs.EventId, OnLoadDataTableFailure);<br></code></pre></td></tr></table></figure><h2 id="事件模块不工作"><a href="#事件模块不工作" class="headerlink" title="事件模块不工作"></a>事件模块不工作</h2><p>事件模块需要被轮询才能正常调用事件处理函数，请确认正确初始化了 Game Framework。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习1-流程</title>
    <link href="/2024/02/15/UGF%E5%AD%A6%E4%B9%A01-%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/02/15/UGF%E5%AD%A6%E4%B9%A01-%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Procedure-流程"><a href="#1-什么是Procedure-流程" class="headerlink" title="1. 什么是Procedure(流程)"></a>1. 什么是Procedure(流程)</h1><p>流程是贯穿游戏运行时整个生命周期的有限状态机。<br>通过流程，将不同的游戏状态进行解耦将是一个非常好的习惯。</p><p>例如:</p><ul><li>对于网络游戏<br>你可能需要如检查资源流程、更新资源流程、检查服务器列表流程、选择服务器流程、登录服务器流程、创建角色流程等流程</li><li>对于单机游戏<br>你可能需要在游戏选择菜单流程和游戏实际玩法流程之间做切换。</li></ul><p>如果想增加流程，只要派生自 <a href="http://gameframework.cn/api/class_game_framework_1_1_procedure_1_1_procedure_base.html">ProcedureBase</a> 类并实现自己的流程类即可使用。</p><h1 id="2-流程的生命周期"><a href="#2-流程的生命周期" class="headerlink" title="2. 流程的生命周期"></a>2. 流程的生命周期</h1><p><img src="/images/UGF%E5%AD%A6%E4%B9%A01-%E6%B5%81%E7%A8%8B/UGF%E6%B5%81%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif"></p><blockquote><p>游戏启动后会自动进入 <strong>默认流程 ProcedureLaunch</strong> 需要自己编写自定义流程并跳转</p></blockquote><p><img src="/images/UGF%E5%AD%A6%E4%B9%A01-%E6%B5%81%E7%A8%8B/image-20211018174117794.png" srcset="/img/loading.gif"></p><h1 id="3-使用流程的流程"><a href="#3-使用流程的流程" class="headerlink" title="3. 使用流程的流程"></a>3. 使用流程的流程</h1><ol><li>新建脚本，脚本中的类需要派生自 <a href="http://gameframework.cn/api/class_game_framework_1_1_procedure_1_1_procedure_base.html">ProcedureBase</a> 类。<br>代码如下：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> GameFramework.Procedure;<br><span class="hljs-keyword">using</span> ProcedureOwner = GameFramework.Fsm.IFsm&lt;GameFramework.Procedure.IProcedureManager&gt;;<br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Game</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProcedureMain</span> : <span class="hljs-title">ProcedureBase</span><br>    &#123;<br>        <span class="hljs-comment">// 游戏初始化时执行。</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInit</span>(<span class="hljs-params">ProcedureOwner procedureOwner</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">base</span>.OnInit(procedureOwner);<br>        &#125;<br> <br>        <span class="hljs-comment">// 每次进入这个流程时执行。</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnter</span>(<span class="hljs-params">ProcedureOwner procedureOwner</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">base</span>.OnEnter(procedureOwner);<br>        &#125;<br> <br>        <span class="hljs-comment">// 每次轮询执行。</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUpdate</span>(<span class="hljs-params">ProcedureOwner procedureOwner, <span class="hljs-built_in">float</span> elapseSeconds, <span class="hljs-built_in">float</span> realElapseSeconds</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">base</span>.OnUpdate(procedureOwner, elapseSeconds, realElapseSeconds);<br>        &#125;<br> <br>        <span class="hljs-comment">// 每次离开这个流程时执行。</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLeave</span>(<span class="hljs-params">ProcedureOwner procedureOwner, <span class="hljs-built_in">bool</span> isShutdown</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">base</span>.OnLeave(procedureOwner, isShutdown);<br>        &#125;<br> <br>        <span class="hljs-comment">// 游戏退出时执行。</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>(<span class="hljs-params">ProcedureOwner procedureOwner</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">base</span>.OnDestroy(procedureOwner);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>通过编译后，GameFramework-&gt;Procedure 的 Inspector 中会出现这个新增加的流程，勾选上这个流程，使之成为可用流程之一<br><img src="/images/UGF%E5%AD%A6%E4%B9%A01-%E6%B5%81%E7%A8%8B/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16345510922256.png" srcset="/img/loading.gif"></p><blockquote><p>Entrance  Procedure（入口流程)<br>即为游戏开始的脚本。<br>其余勾选的即为游戏里用得到的流程。<br>其实流程没什么神秘的，他就像个状态机，游戏里的任一时刻只有一个状态<br>比如你打开背包，就离开当前的大厅，进入背包流程，当你点击返回大厅按钮，就离开背包流程，进入大厅流程。切换场景也是如此。</p></blockquote></li><li><p>使用 ChangeState 方法在主流程或其他流程上切入该流程<br><code>ChangeState&lt;ProcedureMain&gt;(procedureOwner); // 切换流程到 ProcedureMain</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp-序列化控制</title>
    <link href="/2024/01/18/CSharp-%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/01/18/CSharp-%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-使用属性控制"><a href="#1-使用属性控制" class="headerlink" title="1. 使用属性控制"></a>1. 使用属性控制</h1><h2 id="1-1-Serializable"><a href="#1-1-Serializable" class="headerlink" title="1.1 [Serializable]"></a>1.1 [Serializable]</h2><h3 id="1-1-1-用法"><a href="#1-1-1-用法" class="headerlink" title="1.1.1 用法"></a>1.1.1 用法</h3><p><strong>自动序列化</strong>：<br>在类上添加 <code>[Serializable]</code> 属性后，.NET 序列化器（如 <code>BinaryFormatter</code>、<code>SoapFormatter</code> 等）可以自动序列化该类的实例。<br>这意味着序列化器会遍历类的所有字段，无需额外编码就能将其转换成一种可存储或传输的格式。</p><p><strong>字段处理</strong>：<br>默认情况下，序列化器包含类中的所有公共和私有字段。<br>如果需要排除某些字段，可以使用 <code>[NonSerialized]</code> 属性。</p><p><strong>用途：</strong><br>适用于简单的数据存储类，不需要在序列化过程中执行复杂逻辑。</p><p><strong>优势：</strong></p><ul><li><strong>简洁</strong>：无需编写额外的序列化代码。</li><li><strong>易用性</strong>：适用于大多数标准序列化场景。</li></ul><p><strong>局限性：</strong></p><ul><li><strong>缺乏控制</strong>：无法自定义序列化过程。</li><li><strong>无法执行额外逻辑</strong>：在序列化或反序列化过程中无法执行自定义代码。</li></ul><p><strong>案例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> SerializedField;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-2-和Unity属性的区分"><a href="#1-1-2-和Unity属性的区分" class="headerlink" title="1.1.2 和Unity属性的区分"></a>1.1.2 和Unity属性的区分</h3><p><code>.NET</code> 的 <code>[Serializable]</code> 属性和 <code>Unity</code> 的 <code>[Serializable]</code> 属性虽然同名，但它们在用途和工作方式上有所不同。</p><p>理解这两者的区别对于正确使用它们非常重要。</p><table><thead><tr><th></th><th>.NET 的 <code>[Serializable]</code> 属性</th><th>Unity 的 <code>[Serializable]</code> 属性</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>用于标记一个类或结构可以被序列化。这是 .NET 中的二进制序列化机制的一部分，主要用于深度复制对象、持久化对象状态、在不同应用程序域之间传递对象等场景。</td><td>用于标记一个类或结构体，使其实例的字段在 Unity 编辑器的 Inspector 面板中可见。这对于游戏开发过程中调试和调整数据非常有用。</td></tr><tr><td><strong>工作方式</strong></td><td>.NET 的序列化器（如 <code>BinaryFormatter</code>）可以自动序列化该类的实例，包括其所有的私有和公共字段。不需要额外编码来指定哪些字段被序列化。</td><td>公共字段和符合特定条件的私有字段（通常是用 <code>[SerializeField]</code> 标记的私有字段）会出现在 Inspector 面板中。这并不意味着它们会被自动序列化到磁盘；它只是使这些字段在编辑器中可编辑。</td></tr><tr><td><strong>环境</strong></td><td>用于 .NET 标准环境，如在创建桌面应用程序、Web 应用程序等时。</td><td>专门用于 Unity 游戏开发环境。</td></tr></tbody></table><ul><li>在 Unity 中：<br>如果你想使一个自定义类的实例在 Inspector 中可编辑，就给这个类添加 <code>[Serializable]</code> 属性。<br>记住，这并不是为了序列化到文件或进行网络传输，而是为了编辑器的可视化。</li><li>在 .NET 应用程序中：<br>如果你需要对对象进行二进制序列化（例如，通过网络传输，或者保存到文件系统），就使用 .NET 的 <code>[Serializable]</code>。</li></ul><p>了解这些区别可以帮助你在不同的开发环境中做出恰当的选择，以满足你的序列化需求。</p><h2 id="1-2-NonSerialized"><a href="#1-2-NonSerialized" class="headerlink" title="1.2 [NonSerialized]"></a>1.2 [NonSerialized]</h2><p>用于字段。<br>当一个类标记为 <code>[Serializable]</code>，但你想排除类中的某些字段不参与序列化时，可以在这些字段上使用 <code>[NonSerialized]</code> 属性。</p><p><strong>示例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> SerializedField;<br>    [<span class="hljs-meta">NonSerialized</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> NonSerializedField;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-其它属性"><a href="#1-3-其它属性" class="headerlink" title="1.3 其它属性"></a>1.3 其它属性</h2><p>这些属性用于标记在序列化过程的不同阶段调用的方法。</p><ul><li><code>[OnSerializing]</code> 和 <code>[OnSerialized]</code> 用于序列化过程。</li><li><code>[OnDeserializing]</code> 和 <code>[OnDeserialized]</code> 用于反序列化过程。</li></ul><p>这些方法提供了在序列化和反序列化过程中执行自定义逻辑的能力。</p><ul><li><code>[OnSerializing]</code><br><strong>功能</strong>：<br><code>[OnSerializing]</code> 属性用于标记在对象开始序列化之前调用的方法。<br>这允许在对象的状态被转换为可序列化格式之前执行自定义逻辑。<br><strong>使用场景</strong>：<br>如果你需要在序列化之前准备或调整对象的数据（例如，清理敏感信息，计算某些字段的值），则可以使用此属性。</li><li><code>[OnSerialized]</code><br><strong>功能</strong>：<br><code>[OnSerialized]</code> 属性标记在对象序列化完成之后调用的方法。<br>这可以在对象的状态已经被序列化后执行额外操作。<br><strong>使用场景</strong>：<br>在序列化后记录日志、恢复序列化前的状态或执行清理操作时很有用。</li><li><code>[OnDeserializing]</code><br><strong>功能</strong>：<br><code>[OnDeserializing]</code> 属性用于标记在对象开始反序列化之前调用的方法。<br>这使得在对象的状态从序列化格式转换回对象之前执行自定义逻辑成为可能。<br><strong>使用场景</strong>：<br>用于在对象的状态被重构之前进行初始化或设置默认值。<br>例如，如果某些字段在较旧的版本中不存在，可以在此阶段为它们设置默认值。</li><li><code>[OnDeserialized]</code><br><strong>功能</strong>：<br><code>[OnDeserialized]</code> 属性标记在对象反序列化完成之后调用的方法。<br>这允许在对象的状态已经从序列化格式重构回来之后执行额外的逻辑。<br><strong>使用场景</strong>：<br>可以用于校验数据完整性、执行依赖于对象完整状态的初始化过程或其他后处理操作。</li></ul><p><strong>示例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySerializableClass</span> : <span class="hljs-title">ISerializable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br><br>    [<span class="hljs-meta">OnSerializing</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializingMethod</span>(<span class="hljs-params">StreamingContext context</span>)</span>&#123;<br>        <span class="hljs-comment">// 在序列化之前执行的代码</span><br>    &#125;<br><br>    [<span class="hljs-meta">OnSerialized</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSerializedMethod</span>(<span class="hljs-params">StreamingContext context</span>)</span>&#123;<br>        <span class="hljs-comment">// 在序列化之后执行的代码</span><br>    &#125;<br><br>    [<span class="hljs-meta">OnDeserializing</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializingMethod</span>(<span class="hljs-params">StreamingContext context</span>)</span>&#123;<br>        <span class="hljs-comment">// 在反序列化之前执行的代码</span><br>    &#125;<br><br>    [<span class="hljs-meta">OnDeserialized</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDeserializedMethod</span>(<span class="hljs-params">StreamingContext context</span>)</span>&#123;<br>        <span class="hljs-comment">// 在反序列化之后执行的代码</span><br>    &#125;<br><br>    <span class="hljs-comment">// 其他序列化相关的方法和构造函数...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这些属性提供了不同层次和不同场景下的序列化控制，使你能够根据具体需求选择合适的序列化机制和控制方式。</p><h1 id="2-使用-ISerializable-接口控制"><a href="#2-使用-ISerializable-接口控制" class="headerlink" title="2. 使用 ISerializable 接口控制"></a>2. 使用 ISerializable 接口控制</h1><h2 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h2><p><strong>自定义序列化</strong>：<br>实现 <code>ISerializable</code> 接口意味着你需要提供序列化和反序列化逻辑。</p><p><strong>用途：</strong><br>适用于需要精细控制序列化过程的情况。<br>如序列化的对象包含复杂类型、需要基于条件序列化字段、或需要在序列化过程中执行特殊操作（如加密）。</p><p><strong>优势：</strong></p><ul><li><strong>灵活性</strong>：可以精确控制哪些数据被序列化以及如何进行序列化。</li><li><strong>额外操作</strong>：可以在序列化和反序列化过程中执行自定义逻辑。</li></ul><p><strong>局限性：</strong></p><ul><li><strong>复杂性</strong>：实现更为复杂，需要更多的编码工作。</li><li><strong>易错性</strong>：由于需要手动控制序列化细节，因此更容易出错。</li></ul><h2 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h2><p><strong>接口要求实现两部分：</strong><code>GetObjectData</code> 方法和一个特殊的构造函数。</p><ul><li><strong><code>void GetObjectData(SerializationInfo info, StreamingContext context)</code> 方法</strong>：<br>在对象序列化时调用。此方法负责将对象的状态添加到 <code>SerializationInfo</code> 对象中。<br><strong>参数：</strong><ul><li>**SerializationInfo <code>info</code>**：<br>一个 <code>SerializationInfo</code> 对象，用于存储序列化数据。<br>你需要将对象的状态（通常是字段或属性的值）添加到这个对象中。</li><li>**StreamingContext <code>context</code>**：<br>一个 <code>StreamingContext</code> 对象，包含序列化的源或目的地的附加上下文信息。<br>这个参数通常在普通序列化场景中不会被使用，但在某些特殊情况下（例如跨 AppDomain 序列化时）可能会用到。</li></ul></li><li><strong>构造函数</strong>：<br>在对象反序列化时调用。此构造函数使用 <code>SerializationInfo</code> 中的数据来重构对象。<br><strong>参数：</strong><ul><li>**SerializationInfo <code>info</code>**：<br>同上，你需要将对象的状态从中取出后赋给对象。</li><li>**StreamingContext <code>context</code>**：<br>同上</li></ul></li></ul><p><strong>案例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">ISerializable</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Property1 &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Property2 &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 序列化方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetObjectData</span>(<span class="hljs-params">SerializationInfo info, StreamingContext context</span>)</span>&#123;<br>        info.AddValue(<span class="hljs-string">&quot;Property1&quot;</span>, Property1);<br>        info.AddValue(<span class="hljs-string">&quot;Property2&quot;</span>, Property2);<br>    &#125;<br><br>    <span class="hljs-comment">// 反序列化构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params">SerializationInfo info, StreamingContext context</span>)</span>&#123;<br>        Property1 = info.GetInt32(<span class="hljs-string">&quot;Property1&quot;</span>);<br>        Property2 = info.GetString(<span class="hljs-string">&quot;Property2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-SerializationInfo-类"><a href="#2-3-SerializationInfo-类" class="headerlink" title="2.3 SerializationInfo 类"></a>2.3 <code>SerializationInfo</code> 类</h2><p><code>SerializationInfo</code> 类是 .NET 框架中处理对象序列化的一个关键组件。<br>在 .NET 中是自定义序列化和反序列化过程的核心。<br>它提供了一种灵活的方式来存储和检索对象的状态，并且是在实现 <code>ISerializable</code> 接口时处理对象序列化的标准机制。<br>通过使用 <code>SerializationInfo</code>，开发者可以精确控制对象的序列化表示，以及如何从序列化格式中重建对象的状态。</p><p><strong>作用：</strong><br><code>SerializationInfo</code> 类存储所需的数据和上下文，以便序列化和反序列化对象。<br>它主要用于自定义序列化过程，即当一个类实现 <code>ISerializable</code> 接口时，<code>SerializationInfo</code> 用于存储和检索对象的状态（字段、属性等）。</p><p><strong>原理：</strong></p><ul><li><strong>数据存储</strong>：<br><code>SerializationInfo</code> 包含键值对的集合，其中键是数据成员的名称，值是数据成员的值。这个集合用于在序列化过程中保存对象的状态，并在反序列化过程中重建对象。</li><li><strong>类型安全</strong>：<br><code>SerializationInfo</code> 提供了一系列方法，用于以类型安全的方式添加和检索各种类型的数据。</li></ul><p><strong>主要方法：</strong></p><ul><li><code>AddValue(string name, object value)</code>：<br>将名字和值的对添加到 <code>SerializationInfo</code> 存储中。</li><li><code>GetValue(string name, Type type)</code>：<br>从 <code>SerializationInfo</code> 中检索指定类型的值。</li><li>还有一系列的 <code>Get</code> 和 <code>Add</code> 方法，针对不同的数据类型<br>如 <code>GetInt32</code>, <code>GetBoolean</code>, <code>GetString</code>, <code>AddInt32</code>, <code>AddBoolean</code>, <code>AddString</code> 等。</li></ul><p><strong>适用场景：</strong></p><ul><li><strong>自定义序列化</strong>：<br>当需要控制类的序列化和反序列化过程时。这通常在处理复杂对象（如含有不可序列化成员的对象）或需要在序列化过程中执行特定操作的情况下发生。</li><li><strong>跨应用程序域通信</strong>：<br>在不同应用程序域之间传递对象时，可通过实现 <code>ISerializable</code> 接口和使用 <code>SerializationInfo</code> 来确保对象的正确序列化和反序列化。</li></ul><h1 id="3-结合使用-Serializable-和-ISerializable"><a href="#3-结合使用-Serializable-和-ISerializable" class="headerlink" title="3. 结合使用[Serializable] 和 ISerializable"></a>3. 结合使用<code>[Serializable]</code> 和 <code>ISerializable</code></h1><p>在某些情况下，你可能会同时使用 <code>[Serializable]</code> 属性和实现 <code>ISerializable</code> 接口。这样做的理由通常是，你希望利用默认序列化行为，但对某些部分需要自定义处理。</p><p><strong>比如：</strong><br>考虑一个包含敏感数据（如密码）的类，你可能不希望将密码字段直接序列化，而是需要在序列化时对其进行加密。<br>在这种情况下，实现 <code>ISerializable</code> 接口就非常合适，因为它允许你控制序列化过程，确保敏感信息的安全。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ul><li>使用 <code>[Serializable]</code> 属性是一种简单、自动的序列化方法，适合于不需要特殊序列化逻辑的普通场景。</li><li>实现 <code>ISerializable</code> 接口提供了序列化过程的完全控制，适合于需要定制序列化行为或执行额</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lua速通教程</title>
    <link href="/2024/01/18/Lua%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B/"/>
    <url>/2024/01/18/Lua%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Lua速通教程"><a href="#Lua速通教程" class="headerlink" title="Lua速通教程"></a>Lua速通教程</h1><p><strong>学习目标：</strong><br>能够使用Lua脚本在Unity中进行游戏Game Play逻辑的开发</p><p><strong>适用人群：</strong><br>前两个阶段适合有一定编程语言基础的(至少会一门编程语言，如C#，Python)的人学习。<br>后两个阶段则时候有Unity使用基础的人学习。</p><h1 id="0-攻略大纲"><a href="#0-攻略大纲" class="headerlink" title="0. 攻略大纲"></a>0. 攻略大纲</h1><ol><li><strong>第一阶段：Lua基础</strong><ol><li><strong>Lua介绍</strong>：简要了解Lua的历史、特点和在游戏开发中的应用。</li><li><strong>环境配置</strong>：配置安装Lua环境，选择合适的ide。</li><li><strong>基础语法</strong>：学习Lua的变量、数据类型、操作符和控制结构。</li><li><strong>表</strong>：Lua中表（table）的具体使用。</li><li>**代码组织(环境，模块，包)**：如何使用Lua的模块和包来组织代码。</li></ol></li><li><strong>第二阶段：Lua进阶</strong><ol start="6"><li><strong>文件I/O</strong>：学习如何在Lua中进行文件读写。</li><li><strong>错误处理</strong>：理解Lua中的错误处理和异常机制。</li><li><strong>协同程序</strong>（coroutine）：介绍Lua的协同程序，这是Lua的一大特色。</li><li><strong>反射（Reflection）</strong>：介绍Lua中的反射机制与具体的反射写法。</li><li><strong>序列化与反序列化：</strong>介绍lua中如何将表序列化与反序列化。</li><li><strong>垃圾收集（GC）</strong>：介绍lua的垃圾回收机制和实际开发时需要注意的点。</li></ol></li></ol><p>在每个阶段之后，我们将进行简短的练习和问题解答。</p><h1 id="1-Lua介绍"><a href="#1-Lua介绍" class="headerlink" title="1. Lua介绍"></a>1. Lua介绍</h1><h2 id="1-1-历史背景"><a href="#1-1-历史背景" class="headerlink" title="1.1 历史背景"></a>1.1 历史背景</h2><p>Lua是在1993年由巴西里约热内卢天主教大学的Roberto Ierusalimschy, Luiz Henrique de Figueiredo, 和 Waldemar Celes开发的。</p><p>最初设计为一种简单的脚本语言，用于配置文件和数据解析。但随着时间的发展，Lua已经成为一种功能强大的轻量级编程语言。</p><h2 id="1-2-应用领域"><a href="#1-2-应用领域" class="headerlink" title="1.2 应用领域"></a>1.2 应用领域</h2><p><strong>游戏开发：</strong><br>许多游戏使用Lua来编写游戏逻辑和UI。<br>例如《魔兽世界》、《星际争霸II》和《Garry’s Mod》。<br>Lua在快速原型开发和游戏测试中非常好用，因为它允许开发者快速迭代和测试代码而无需频繁的编译过程。</p><p><strong>嵌入式系统：</strong><br>由于Lua的轻量级和可嵌入性，它常被用于嵌入式系统，如网络设备和家用电器。</p><p><strong>Web应用：</strong><br>Lua也被用于服务器端脚本，尤其是与Nginx结合时。</p><h2 id="1-3-Lua的优缺点"><a href="#1-3-Lua的优缺点" class="headerlink" title="1.3 Lua的优缺点"></a>1.3 Lua的优缺点</h2><p><strong>优点：</strong></p><ul><li><strong>易学易用</strong>：<br>Lua具有非常简洁和清晰的语法，上手快，非常适合初学者。</li><li><strong>可移植性</strong>：<br>Lua拥有高度的可移植性，几乎可以在所有操作系统和平台上运行。</li><li><strong>高效率</strong>：<br>Lua的执行速度非常快，特别是当与Just-In-Time（JIT）编译器结合使用时。</li><li><strong>高灵活：</strong><br>Lua的表（table）结构非常灵活，可以用作数组、字典，甚至可以模拟面向对象的特性。</li><li><strong>丰富的社区支持：</strong><br>Lua有一个活跃的开发社区，提供大量文档、教程和第三方库。</li><li><strong>广泛的应用</strong>：<br>在游戏开发和嵌入式系统中有广泛的应用案例。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>性能局限：</strong><br>虽然Lua的性能很好，但与编译语言（如C/C++）相比，它在处理大规模复杂计算任务时可能会显得慢一些。<br>对于大多数游戏开发场景，Lua的性能已经足够。通常，只有在非常计算密集的任务中，性能差异才会变得明显。</li><li><strong>面向对象编程的限制：</strong><br>Lua本身不是一种面向对象的语言，虽然可以通过表和元表来模拟对象，但这种方式对于习惯了传统面向对象语言的开发者来说可能不够直观。</li><li><strong>标准库的限制：</strong><br>与Python等语言相比，Lua的标准库较小，对于某些任务可能需要依赖外部库或自行实现功能。</li><li><strong>类型系统：</strong><br>Lua是一种动态类型语言，这可能导致在复杂应用中出现类型相关的错误，这些错误在编译时不容易被发现。</li></ul><p><strong>结论：</strong><br>Lua是一个强大的工具，特别是在需要快速开发和嵌入脚本的场合。它的简单性、灵活性和高效性使其成为游戏开发和嵌入式系统的热门选择。然而，它也有其局限性，特别是在性能和面向对象编程方面。<br>选择使用Lua时，需要根据项目的具体需求和上下文来权衡这些因素。</p><h1 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2 环境配置"></a>2 环境配置</h1><h2 id="2-1-安装Lua环境"><a href="#2-1-安装Lua环境" class="headerlink" title="2.1 安装Lua环境"></a>2.1 安装Lua环境</h2><ol><li><p><strong>下载Lua解释器：</strong><br>你可以从Lua的官方网站 <a href="https://www.lua.org/">lua.org</a> 下载Lua解释器。网站上提供了源代码，你可以在大多数操作系统上编译安装。<br><img src="/images/Lua%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B/image-1.png" srcset="/img/loading.gif"><br><img src="/images/Lua%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B/image-2.png" srcset="/img/loading.gif"></p></li><li><p><strong>配置系统环境变量：</strong></p><ol><li>右键点击“此电脑”或“我的电脑”，选择“属性”。</li><li>点击“高级系统设置”。</li><li>在“系统属性”窗口中，点击“环境变量”。</li><li>在“系统变量”下，找到并选择“Path”，点击“编辑”。</li><li>点击“新建”，添加Lua解释器的安装路径。</li><li>点击“确定”保存更改。<br><img src="/images/Lua%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B/image-3.png" srcset="/img/loading.gif"></li></ol></li><li><p><strong>检查Lua环境是否配置成功：</strong></p><ol><li>打开命令提示符：<br>在Windows上，你可以按<code>Win + R</code>键，输入<code>cmd</code>，然后按回车键来打开命令提示符。</li><li>在命令提示符中输入以下命令：<code>lua54</code></li><li>如果有如下输出，则说明 lua 环境安装成功<br> <img src="/images/Lua%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B/image-4.png" srcset="/img/loading.gif"><h2 id="2-2-安装并配置IDE"><a href="#2-2-安装并配置IDE" class="headerlink" title="2.2 安装并配置IDE"></a>2.2 安装并配置IDE</h2></li></ol></li></ol><p>以下是三种比较主流的LuaIDE，根据自身情况和喜好，三选一即可。<br>个人推荐VSCode</p><h3 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h3><p>VS Code是一个轻量级、功能强大的编辑器，它通过插件支持Lua语言。</p><p><strong>配置步骤如下：</strong></p><ol><li><p><strong>安装VS Code</strong>：<br>如果你还没有安装VS Code，可以从其<a href="https://code.visualstudio.com/">官方网站</a>下载并安装。</p></li><li><p><strong>安装Lua插件</strong>：</p><ol><li><strong>Lua</strong><br>提供了Lua语言的基本支持和增强功能。</li><li><strong>LuaDebug</strong><br>针对Lua语言的调试插件<ul><li><strong>断点调试</strong>：允许你设置断点，逐步执行Lua代码。</li><li><strong>变量检查</strong>：在调试期间查看和修改变量的值。</li><li><strong>调试控制</strong>：提供了继续、暂停、停止、逐步进入等调试控制功能。</li></ul></li><li><strong>Code Runner</strong><br>一个通用的代码运行插件，支持多种编程语言，包括Lua。</li></ol></li><li><p><strong>设置CodeRunner的Lua解释器路径</strong></p><ol><li><p>打开 executorMap 设置</p><pre><code>  ![](/images/Lua速通教程/image-5.png)</code></pre></li><li><p>增加lua解释器路径</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;code-runner.executorMap&quot;: &#123;<br>&quot;lua&quot;: &quot;D:\\Environments\\Lua\\lua-5.4.2_Win64_bin\\lua54.exe&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>![[语言学习/Lua/assets/image-6.png]]</p></li></ol></li><li><p><strong>测试是否成功</strong>：<br>安装完插件后，就可以在VS Code中创建和编辑Lua文件了。<br><img src="/images/Lua%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B/image-7.png" srcset="/img/loading.gif"></p><h3 id="Ride配置"><a href="#Ride配置" class="headerlink" title="Ride配置"></a>Ride配置</h3></li></ol><p>Rider是由JetBrains开发的一个强大的跨平台IDE，支持多种语言，但需要注意的是，Rider本身不原生支持Lua。要在Rider中使用Lua，你可能需要借助插件，如 EmmyLua。</p><ol><li><strong>安装Rider</strong>：<br>首先，确保你已经安装了Rider。</li><li><strong>查找并安装Lua插件</strong>：<ol><li>在Rider中，打开 <code>File</code> &gt; <code>Settings</code> &gt; <code>Plugins</code>。</li><li>搜索Lua相关的插件，如EmmyLua。</li><li>安装插件并重启Rider。</li></ol></li><li><strong>开始编写Lua代码</strong>：<br>安装好插件后，你就可以在Rider中创建Lua文件并开始编程了。</li></ol><h3 id="在线Lua环境工具"><a href="#在线Lua环境工具" class="headerlink" title="在线Lua环境工具"></a>在线Lua环境工具</h3><p>对于快速实验或学习Lua，使用在线工具是一个方便的选择。<br>这里有一些推荐的在线Lua环境：</p><ol><li><strong>Repl.it</strong>：<br><a href="https://repl.it/languages/lua">Repl.it</a> 提供了一个简单的在线Lua编程环境，无需安装任何东西。</li><li><strong>Lua Demo</strong>：<br><a href="https://www.lua.org/demo.html">Lua Demo</a> 是Lua官方网站提供的一个简易在线运行环境。</li><li><strong>TutorialsPoint Lua Compiler</strong>：<br><a href="https://www.tutorialspoint.com/execute_lua_online.php">TutorialsPoint</a> 也提供在线Lua编译器。</li></ol><p>使用这些在线工具，你可以直接在浏览器中编写和运行Lua代码，非常适合初学者或进行小型实验。</p><h1 id="3-基础语法"><a href="#3-基础语法" class="headerlink" title="3 基础语法"></a>3 基础语法</h1><h2 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h2><h3 id="3-1-1-全部8种数据类型"><a href="#3-1-1-全部8种数据类型" class="headerlink" title="3.1.1 全部8种数据类型"></a>3.1.1 全部8种数据类型</h3><table><thead><tr><th>数据类型</th><th>用途</th><th>值/引用</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td><strong>Nil<br />(空)</strong></td><td>表示不存在或无效的值</td><td>值类型</td><td>和其他语言的null相同</td><td><code>a = nil</code> <br />表示 <code>a</code> 是一个无值变量。</td></tr><tr><td><strong>Boolean<br />(布尔)</strong></td><td>用于条件判断</td><td>值类型</td><td></td><td><code>isLuaEasy = true</code></td></tr><tr><td><strong>Number<br />（数字）</strong></td><td>用于存储数字</td><td>值类型</td><td>Lua中的数字类型默认为双精度浮点数（没有单独的整数或单浮点类型）</td><td><code>num1 = 10</code></td></tr><tr><td><strong>String<br />（字符串）</strong></td><td>用于存储文本</td><td>值类型</td><td>字符串在Lua中是不可变的，连接两个字符串时实际上会创建一个新的字符串</td><td><code>greeting = &quot;Hello&quot;</code></td></tr><tr><td><strong>Table<br />（表）</strong></td><td>数据结构类型，用于嵌套存储其他数据类型</td><td>引用类型</td><td>Lua中唯一的数据结构类型，可以用作数组、字典或对象</td><td>数组示例：<br /><code>arr = &#123; &quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot; &#125;</code> <br />字典示例：<br /><code>person = &#123; name = &quot;Alice&quot;, age = 30 &#125;</code></td></tr><tr><td><strong>Function<br />（函数型）</strong></td><td>用于调用事件和方法</td><td>引用类型</td><td>在Lua中，函数也是一种数据类型，可以存储在变量中，作为参数传递，或作为其他函数的返回值</td><td><code>add = function(a, b) return a + b end</code></td></tr><tr><td><strong>Thread<br />（线程型）</strong></td><td>用于实现协同程序（coroutines）</td><td>引用类型</td><td>线程在Lua中可以用来执行非阻塞操作或并行执行</td><td>见表下</td></tr><tr><td><strong>Userdata<br />（用户数据型）</strong></td><td>用于表示由应用程序或C语言代码创建的数据类型</td><td>引用类型</td><td>通常用于Lua绑定到C语言库</td><td>略</td></tr></tbody></table><p><strong>线程案例补充：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Foo start&quot;</span>)<br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Foo end&quot;</span>) <br><span class="hljs-keyword">end</span> <br><span class="hljs-comment">-- 创建协同程序 </span><br><span class="hljs-keyword">local</span> co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(foo) <br><span class="hljs-comment">-- 启动协同程序 </span><br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)  <span class="hljs-comment">-- 输出 &quot;Foo start&quot; </span><br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)  <span class="hljs-comment">-- 输出 &quot;Foo end&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-1-2-值类型与引用类型"><a href="#3-1-2-值类型与引用类型" class="headerlink" title="3.1.2 值类型与引用类型"></a>3.1.2 值类型与引用类型</h3><p>在Lua中，数据类型可以根据它们是如何被存储和传递（值传递或引用传递）来分类为“值类型”和“引用类型”。</p><p>了解Lua中哪些类型是值类型，哪些是引用类型，对于理解变量如何存储和传递、以及如何在函数间传递参数非常重要。这也对于理解性能考量和内存管理方面的影响至关重要。</p><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><ul><li><p>Nil（空）</p></li><li><p>Boolean（布尔型）</p></li><li><p>Number（数字型）</p></li><li><p>String（字符串型）</p></li></ul><p>这些类型的变量直接存储它们的值。<br>当这些类型的变量被赋值给另一个变量时，它们的值会被复制。<br>在Lua中，即使是字符串也被当作值类型，尽管在许多其他语言中，字符串可能被视为引用类型。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>Table（表）</li><li>Function（函数型）</li><li>Thread（线程型）</li><li>Userdata（用户数据型）</li></ul><p>这些类型的变量存储的是对它们数据的引用。<br>这意味着，当你将这类变量赋值给另一个变量时，新变量实际上是指向原始数据的引用。<br>因此，修改引用类型的变量可能会影响原始数据。</p><blockquote><p><strong>重要说明：</strong></p><ul><li>当你操作一个引用类型的变量时，你实际上是在操作一个指向数据的引用，而不是数据本身。</li><li>值类型在操作过程中，值的副本会被创建和传递，而不会影响原始数据。</li></ul></blockquote><h3 id="3-1-3-动态类型与类型转换"><a href="#3-1-3-动态类型与类型转换" class="headerlink" title="3.1.3 动态类型与类型转换"></a>3.1.3 动态类型与类型转换</h3><h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h4><p>Lua是动态类型语言，变量不用声明类型，在首次赋值时自动确定类型。</p><p>在Lua中，变量没有预先定义的类型，相反，类型是与值相关联的，而不是与变量。这意味着同一个变量在不同时间可以持有不同类型的值。</p><p>这样的动态类型给lua带来了：</p><ol><li><strong>灵活性</strong>：<br>你可以将任何类型的值赋给任何变量。<br>例如，一个原本存储数字的变量之后可以被赋予一个字符串。</li><li><strong>简洁性</strong>：<br>在定义变量时不需要指定类型，Lua运行时会自动处理变量的类型。</li><li><strong>动态</strong>：<br>变量类型可以在运行时改变，这给编程带来了极大的灵活性，但同时也要求程序员更加注意类型相关的错误。</li></ol><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>在Lua中，类型检查通常是通过使用内置的<code>type</code>函数来完成的。</p><p>Lua没有提供类似于C#中的<code>is</code>或<code>as</code>操作符，但你可以使用<code>type</code>函数来获取一个值的类型，然后根据需要进行比较或相应的处理。</p><p>以下是针对Lua支持的所有基本数据类型的<code>type</code>函数的使用示例：</p><ol><li><p><strong>Nil(空)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(var) == <span class="hljs-string">&quot;nil&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var is nil&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Boolean(布尔)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(var) == <span class="hljs-string">&quot;boolean&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var is a boolean&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Number(数字)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(var) == <span class="hljs-string">&quot;number&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var is a number&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>String(字符串)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(var) == <span class="hljs-string">&quot;string&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var is a string&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Table(表)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(var) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var is a table&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Function(函数)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(var) == <span class="hljs-string">&quot;function&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var is a function&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Thread(线程)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(var) == <span class="hljs-string">&quot;thread&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var is a thread&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Userdata(用户数据)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(var) == <span class="hljs-string">&quot;userdata&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;var is userdata&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>特殊情况：区分整数和浮点数</strong></p><p>从Lua 5.3开始，整数和浮点数被视为<code>number</code>类型的不同子类型。虽然<code>type</code>函数对于这两者都会返回<code>&quot;number&quot;</code>，但你可以使用<code>math.type</code>来进一步区分它们：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> math.type(<span class="hljs-keyword">var</span>) == <span class="hljs-string">&quot;integer&quot;</span> then<br>    print(<span class="hljs-string">&quot;var is an integer&quot;</span>)<br>elseif math.type(<span class="hljs-keyword">var</span>) == <span class="hljs-string">&quot;float&quot;</span> then<br>    print(<span class="hljs-string">&quot;var is a float&quot;</span>)<br>end<br></code></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>Lua会在需要时自动进行一些基本的类型转换（如数字到字符串的转换）也称为类型提升或隐式转换。</p><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><ul><li><p><strong>字符串和数字</strong>：<br>Lua在需要时会在字符串和数字之间进行自动转换。</p><ul><li><p>当一个数字和字符串进行算术操作时，字符串会被尝试转换为数字。<br><code>print(&quot;123&quot; + 1)  -- 输出 124 (字符串&quot;123&quot;被转换为数字)</code></p></li><li><p>当数字用于字符串上下文时，比如拼接操作，数字将被转换为字符串。<br><code>print(123 .. &quot; apples&quot;)  -- 输出 &quot;123 apples&quot; (数字123被转换为字符串)</code></p></li></ul></li><li><p><strong>布尔值</strong>：<br>在条件表达式中</p><ul><li><p><code>nil</code> 和 <code>false</code> 被视为假</p></li><li><p>其他所有值（包括0和空字符串）都被视为真。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0 is true in Lua&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>注意事项：</strong></p><ul><li><strong>避免假设</strong>：<br>在编写Lua代码时，避免过分依赖隐式类型转换，特别是在数据类型不明确的情况下。<br>明确的类型检查和转换可以使代码更可靠、更易于理解。</li><li><strong>错误处理</strong>：<br>自动类型转换可能导致意外的结果，尤其是在处理外部数据或复杂的逻辑时。<br>因此，有时候显式检查和转换类型更为安全。</li></ul><p><strong>几个隐式类型转换的案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;10&quot;</span> + <span class="hljs-number">1</span>)  <span class="hljs-comment">-- 输出 11</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;10&quot;</span> * <span class="hljs-string">&quot;2&quot;</span>)  <span class="hljs-comment">-- 输出 20</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;10&quot;</span> == <span class="hljs-number">10</span>)  <span class="hljs-comment">-- 输出 false</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;10&quot;</span> == <span class="hljs-built_in">tostring</span>(<span class="hljs-number">10</span>))  <span class="hljs-comment">-- 输出 true</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0 is true&quot;</span>)  <span class="hljs-comment">-- 这段代码会执行</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Empty string is true&quot;</span>)  <span class="hljs-comment">-- 这段代码也会执行</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h5 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h5><ul><li><strong>字符串到数字:</strong><ul><li>使用 <code>tonumber()</code> 函数将字符串转换为数字。</li><li>如果转换失败（例如，字符串不是有效的数字表示），则返回 <code>nil</code>。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> num = <span class="hljs-built_in">tonumber</span>(<span class="hljs-string">&quot;123&quot;</span>)  <span class="hljs-comment">-- 转换成功，num为123</span><br><span class="hljs-keyword">local</span> fail = <span class="hljs-built_in">tonumber</span>(<span class="hljs-string">&quot;abc&quot;</span>)  <span class="hljs-comment">-- 转换失败，fail为nil</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong>数字到字符串:</strong><ul><li>使用 <code>tostring()</code> 函数将数字转换为字符串。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> str = <span class="hljs-built_in">tostring</span>(<span class="hljs-number">123</span>)  <span class="hljs-comment">-- str为&quot;123&quot;</span><br></code></pre></td></tr></table></figure></li><li>使用<code>string.char()ASCII</code>码转为字符。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> str = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">char</span>(<span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>)<br><span class="hljs-built_in">print</span>(str)  <span class="hljs-comment">-- 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li>布尔型 通常不需要转换</li><li>表（table）和函数（function）通常不需要转换<br>因为它们是复杂的结构或行为，而不是基本的数据类型。</li><li>对于 用户数据型（userdata） 和 线程型（thread） 类型，通常没有必要或方法进行转换，因为它们代表了特定于应用程序的数据和并发执行的线程。</li></ul><p><strong>注意事项：</strong></p><ul><li><strong>有效性检查</strong>：<br>在进行显式类型转换时，应该注意检查结果是否有效（比如 <code>tonumber()</code> 是否返回了 <code>nil</code>）。</li><li><strong>类型安全</strong>：<br>显式类型转换增加了类型安全性，因为你明确指定了如何和何时进行转换。</li><li><strong>转换的局限性</strong>：<br>显式类型转换有其局限性，不是所有类型的转换都有意义或可能。</li></ul><h2 id="3-2-变量与赋值"><a href="#3-2-变量与赋值" class="headerlink" title="3.2 变量与赋值"></a>3.2 变量与赋值</h2><h3 id="3-2-1-声明变量"><a href="#3-2-1-声明变量" class="headerlink" title="3.2.1 声明变量"></a>3.2.1 声明变量</h3><p>Lua中的变量在首次赋值时被创建。Lua是动态类型语言，不需要类型声明。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = <span class="hljs-number">10</span>  -- 创建一个名为x的变量并赋值为<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="3-2-2-局部变量与全局变量"><a href="#3-2-2-局部变量与全局变量" class="headerlink" title="3.2.2 局部变量与全局变量"></a>3.2.2 局部变量与全局变量</h3><p>Lua中的变量可以分为局部变量和全局变量，它们的主要区别在于作用域和生命周期。<br>理解局部变量和全局变量的这些差异对于编写高效、可读性强和易于维护的Lua代码非常重要。</p><table><thead><tr><th>区别点</th><th>局部变量</th><th>全局变量</th></tr></thead><tbody><tr><td><strong>作用域</strong></td><td>局部变量只在它被声明的代码块内有效。代码块通常是函数、循环或条件语句。</td><td>全局变量在整个Lua脚本中都是有效的，无论在哪里声明。</td></tr><tr><td><strong>声明</strong></td><td>使用<code>local</code>关键字声明<br />如 <code>local x = 10</code>。</td><td>不使用<code>local</code>关键字，直接赋值即可<br />如 <code>x = 10</code>。</td></tr><tr><td><strong>内存管理</strong></td><td>当代码块执行结束后，局部变量就会被释放。</td><td>全局变量存储在全局环境中，除非显式地设置为<code>nil</code>，否则不会被自动释放。</td></tr><tr><td><strong>性能</strong></td><td>使用局部变量可以提高程序的运行效率，因为它们存储在栈上，且访问速度更快。</td><td>频繁使用全局变量可能降低程序性能，并可能导致命名冲突和难以追踪的错误。</td></tr></tbody></table><p><strong>示例:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 局部变量</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fooLocalTest</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> localVar = <span class="hljs-string">&quot;I am local&quot;</span><br>    <span class="hljs-built_in">print</span>(localVar)  <span class="hljs-comment">-- 正确：在作用域内访问</span><br><span class="hljs-keyword">end</span><br><br>fooLocalTest()<br><span class="hljs-built_in">print</span>(localVar)  <span class="hljs-comment">-- 错误：localVar在这里是不可见的</span><br><br><br><span class="hljs-comment">-- 全局变量</span><br>globalVar = <span class="hljs-string">&quot;I am global&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fooGlobalTest</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(globalVar)  <span class="hljs-comment">-- 正确：全局变量在任何地方都可见</span><br><span class="hljs-keyword">end</span><br><br>fooGlobalTest()<br><span class="hljs-built_in">print</span>(globalVar)  <span class="hljs-comment">-- 正确：全局变量在任何地方都可见</span><br></code></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li><strong>使用建议</strong>：<br>通常建议尽量使用局部变量，这样可以避免意外的全局变量污染和命名冲突，同时提高代码的模块化和可维护性。</li><li><strong>内存和性能</strong>：<br>局部变量在性能和内存管理方面更有优势，因为它们在不再需要时会被自动回收。</li><li><strong>全局变量的谨慎使用</strong>：<br>尽管全局变量在某些情况下很有用（比如作为配置设置或共享数据），但应该谨慎使用，并且明确知道其作用域和生命周期。</li></ul><blockquote><p>注意：函数也可以算做变量，所以函数也有局部函数和全局函数的区分</p></blockquote><h2 id="3-3-控制结构"><a href="#3-3-控制结构" class="headerlink" title="3.3 控制结构"></a>3.3 控制结构</h2><h3 id="3-3-1-条件语句"><a href="#3-3-1-条件语句" class="headerlink" title="3.3.1 条件语句"></a>3.3.1 条件语句</h3><ul><li><p><strong>if语句</strong>：语句是最基本的条件语句，用于当条件为真时执行代码块。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> condition <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 执行条件为真时的代码</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>elseif 和 else语句</strong>:</p><p><code>elseif</code> 用于添加额外的条件判断。<br><code>else</code> 用于当所有条件都不满足时执行的代码块。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> condition1 <span class="hljs-keyword">then</span><br>  <span class="hljs-comment">-- 条件1为真时执行</span><br><span class="hljs-keyword">elseif</span> condition2 <span class="hljs-keyword">then</span><br>  <span class="hljs-comment">-- 条件2为真时执行</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-comment">-- 所有条件都不为真时执行</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="3-3-2循环"><a href="#3-3-2循环" class="headerlink" title="3.3.2循环"></a>3.3.2循环</h3></li></ul><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p><code>while</code>循环会在给定条件为真时重复执行代码块。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &lt;= <span class="hljs-number">5</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i)<br>    i = i + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="数值for循环"><a href="#数值for循环" class="headerlink" title="数值for循环"></a>数值for循环</h4><p>数值<code>for</code>循环使用一个计数器变量，该变量从初始值开始，每次循环增加固定的步长，直到达到终止值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">5</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="泛型for循环"><a href="#泛型for循环" class="headerlink" title="泛型for循环"></a>泛型for循环</h4><p>泛型<code>for</code>循环用于遍历表或数组。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> colors = &#123;<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, color <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(colors) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i, color)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="repeat…until-循环"><a href="#repeat…until-循环" class="headerlink" title="repeat…until 循环"></a>repeat…until 循环</h4><p><code>repeat...until</code>循环至少执行一次代码块，然后重复执行直到给定条件为真。<br>类似于别的语言的do…while</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><br><span class="hljs-keyword">repeat</span><br>    <span class="hljs-built_in">print</span>(i)<br>    i = i + <span class="hljs-number">1</span><br><span class="hljs-keyword">until</span> i &gt; <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="终止循环break"><a href="#终止循环break" class="headerlink" title="终止循环break"></a>终止循环break</h4><p>用于提前终止循环。<br><code>break</code>可以用在<code>for</code>、<code>while</code>和<code>repeat...until</code>循环中，当执行到<code>break</code>时，循环将立即终止。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">5</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">break</span>  <span class="hljs-comment">-- 当i大于5时终止循环</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="没有continue！但是有goto"><a href="#没有continue！但是有goto" class="headerlink" title="没有continue！但是有goto"></a>没有continue！但是有goto</h4><p>Lua中没有直接提供<code>continue</code>语句，这是一个在许多其他编程语言中用于跳过当前循环迭代并继续执行下一个迭代的语句。在Lua中，如果你需要实现类似<code>continue</code>的功能，你需要采用不同的方法来构造你的循环逻辑。</p><p>在Lua中，你通常可以通过在循环体内使用<code>if</code>和<code>goto</code>语句来模拟<code>continue</code>的行为。例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">10</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">-- 模拟continue，跳过偶数</span><br>        <span class="hljs-keyword">goto</span> continue<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">print</span>(i)  <span class="hljs-comment">-- 只打印奇数</span><br>    ::continue::<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>从Lua 5.2开始，Lua引入了有限的<code>goto</code>语句，你可以使用<code>goto</code>与标签来实现类似<code>continue</code>的效果。<br>如上面的示例所示，<code>goto continue</code>跳到循环末尾的<code>::continue::</code>标签，从而开始下一次循环迭代。</p><h3 id="3-3-3-逻辑运算与关系运算"><a href="#3-3-3-逻辑运算与关系运算" class="headerlink" title="3.3.3 逻辑运算与关系运算"></a>3.3.3 逻辑运算与关系运算</h3><p><strong>逻辑运算符</strong>：</p><ul><li><strong><code>and</code>（与）</strong>：<br>当两个条件都为真时，结果为真。</li><li><strong><code>or</code>（或）</strong>：<br>当至少一个条件为真时，结果为真。</li><li><strong><code>not</code>（非）</strong>：<br>反转条件的真假。</li></ul><p><strong>关系运算符</strong>：</p><ul><li><strong>== 相等</strong></li><li><strong>~= 不等</strong></li><li>&lt;小于</li><li>&gt;大于</li><li>&gt;=大于等于</li><li>&lt;=小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> x = <span class="hljs-number">10</span><br><span class="hljs-keyword">local</span> y = <span class="hljs-number">20</span><br><br><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> y &gt; <span class="hljs-number">15</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Both conditions are true&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">15</span> <span class="hljs-keyword">or</span> y &gt; <span class="hljs-number">15</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;At least one condition is true&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (x &gt; <span class="hljs-number">15</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;x is not greater than 15&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>短路求值:</strong></p><p>Lua中的<code>and</code>和<code>or</code>运算符执行短路求值：</p><ul><li>**<code>and</code>**：如果第一个条件为假，则不再评估第二个条件。</li><li>**<code>or</code>**：如果第一个条件为真，则不再评估第二个条件。</li></ul><p>这可以用于编写更高效的代码，如在访问可能为<code>nil</code>的表项之前先检查表是否存在。</p><h2 id="3-4-基本数据操作"><a href="#3-4-基本数据操作" class="headerlink" title="3.4 基本数据操作"></a>3.4 基本数据操作</h2><h3 id="3-4-1-数字"><a href="#3-4-1-数字" class="headerlink" title="3.4.1 数字"></a>3.4.1 数字</h3><p>在Lua中，数字是一种非常基本的数据类型。</p><p>Lua中的数字类型（<code>number</code>）通常是以双精度浮点数形式表示的，尽管从Lua 5.3开始，整数也作为一个独立的子类型被引入。</p><p>下面我们将详细介绍Lua中数字的基本操作。</p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><ul><li><strong>加法</strong> (<code>+</code>): 计算两个数的和。</li><li><strong>减法</strong> (<code>-</code>): 计算两个数的差。</li><li><strong>乘法</strong> (<code>*</code>): 计算两个数的积。</li><li><strong>除法</strong> (<code>/</code>): 计算两个数的商。</li><li><strong>取模</strong> (<code>%</code>): 计算两个数相除的余数。</li><li><strong>指数</strong> (<code>^</code>): 计算一个数的指数。</li></ul><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">local</span> b = <span class="hljs-number">3</span><br><br><span class="hljs-built_in">print</span>(a + b)  <span class="hljs-comment">-- 输出 13</span><br><span class="hljs-built_in">print</span>(a - b)  <span class="hljs-comment">-- 输出 7</span><br><span class="hljs-built_in">print</span>(a * b)  <span class="hljs-comment">-- 输出 30</span><br><span class="hljs-built_in">print</span>(a / b)  <span class="hljs-comment">-- 输出 3.3333333333333</span><br><span class="hljs-built_in">print</span>(a % b)  <span class="hljs-comment">-- 输出 1</span><br><span class="hljs-built_in">print</span>(a ^ b)  <span class="hljs-comment">-- 输出 1000</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>Lua语言中没有<code>++</code>、<code>--</code>、<code>+=</code>、<code>-=</code>等操作符。<br>它没有包含这些在其他语言中常见的递增、递减和复合赋值操作符。<br>你需要显式地写出完整的赋值表达式</p></blockquote><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>从Lua 5.2开始，语言内核引入了对位运算的原生支持。Lua 5.2及以后的版本提供了以下位运算符：</p><ul><li><strong>按位与</strong> (<code>&amp;</code>)</li><li><strong>按位或</strong> (<code>|</code>)</li><li><strong>按位异或</strong> (<code>~</code>)</li><li><strong>按位非</strong> (<code>~</code>)</li><li><strong>左移</strong> (<code>&lt;&lt;</code>)</li><li><strong>右移</strong> (<code>&gt;&gt;</code>)</li></ul><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> a = <span class="hljs-number">0x5</span>  <span class="hljs-comment">-- 二进制为 0101</span><br><span class="hljs-keyword">local</span> b = <span class="hljs-number">0x3</span>  <span class="hljs-comment">-- 二进制为 0011</span><br><br><span class="hljs-keyword">local</span> c = a &amp; b   <span class="hljs-comment">-- 按位与，结果为 1 (二进制 0001)</span><br><span class="hljs-keyword">local</span> d = a | b   <span class="hljs-comment">-- 按位或，结果为 7 (二进制 0111)</span><br><span class="hljs-keyword">local</span> e = ~a      <span class="hljs-comment">-- 按位非，结果为 -6 (二进制 ...1010，按二进制补码表示)</span><br><span class="hljs-keyword">local</span> f = a ~ b   <span class="hljs-comment">-- 按位异或，结果为 6 (二进制 0110)</span><br><span class="hljs-keyword">local</span> g = a &lt;&lt; <span class="hljs-number">1</span>  <span class="hljs-comment">-- 左移，结果为 10 (二进制 1010)</span><br><span class="hljs-keyword">local</span> h = a &gt;&gt; <span class="hljs-number">1</span>  <span class="hljs-comment">-- 右移，结果为 2 (二进制 0010)</span><br></code></pre></td></tr></table></figure><h4 id="数学计算函数"><a href="#数学计算函数" class="headerlink" title="数学计算函数"></a>数学计算函数</h4><p>Lua的标准库提供了一系列用于数学计算的函数，包括：</p><ul><li><code>math.abs(x)</code>: 返回 <code>x</code> 的绝对值。</li><li><code>math.floor(x)</code>: 返回不大于 <code>x</code> 的最大整数。</li><li><code>math.ceil(x)</code>: 返回不小于 <code>x</code> 的最小整数。</li><li><code>math.sqrt(x)</code>: 返回 <code>x</code> 的平方根。</li><li><code>math.max(x, ...)</code>: 返回所有参数中的最大值。</li><li><code>math.min(x, ...)</code>: 返回所有参数中的最小值。</li><li><code>math.random()</code>: 生成一个在[0,1)区间的伪随机数。</li><li><code>math.random(n)</code>: 生成一个从1到 <code>n</code> 的伪随机整数。</li><li><code>math.random(m, n)</code>: 生成一个从 <code>m</code> 到 <code>n</code> 的伪随机整数。</li><li><code>math.floor(x)</code>: 返回不大于<code>x</code>的最大整数（向下取整）。</li><li><code>math.ceil(x)</code>: 返回不小于<code>x</code>的最小整数（向上取整）。</li><li><code>math.modf(x)</code>: 返回<code>x</code>的整数部分和小数部分。</li></ul><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">abs</span>(<span class="hljs-number">-5</span>))     <span class="hljs-comment">-- 输出 5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">floor</span>(<span class="hljs-number">3.7</span>))  <span class="hljs-comment">-- 输出 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">ceil</span>(<span class="hljs-number">3.7</span>))   <span class="hljs-comment">-- 输出 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">16</span>))    <span class="hljs-comment">-- 输出 4</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">-- 输出 5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">-- 输出 1</span><br><br><span class="hljs-keyword">local</span> floatNum = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">local</span> floorNum = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">floor</span>(floatNum)  <span class="hljs-comment">-- 结果为 3</span><br><span class="hljs-keyword">local</span> ceilNum = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">ceil</span>(floatNum)    <span class="hljs-comment">-- 结果为 4</span><br><span class="hljs-keyword">local</span> intPart, fracPart = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">modf</span>(floatNum)  <span class="hljs-comment">-- intPart为 3, fracPart为 0.14</span><br></code></pre></td></tr></table></figure><p>Lua没有内置的四舍五入函数，但你可以通过<code>math.floor</code>或<code>math.ceil</code>函数结合加上0.5来实现四舍五入。</p><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">round</span><span class="hljs-params">(num)</span></span><br>    <span class="hljs-keyword">return</span> num &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">floor</span>(num + <span class="hljs-number">0.5</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">ceil</span>(num - <span class="hljs-number">0.5</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(round(<span class="hljs-number">3.14</span>))  <span class="hljs-comment">-- 输出 3</span><br><span class="hljs-built_in">print</span>(round(<span class="hljs-number">3.5</span>))   <span class="hljs-comment">-- 输出 4</span><br><span class="hljs-built_in">print</span>(round(<span class="hljs-number">-3.5</span>))  <span class="hljs-comment">-- 输出 -3</span><br></code></pre></td></tr></table></figure><h4 id="练习题-3-4-1"><a href="#练习题-3-4-1" class="headerlink" title="练习题 3.4.1"></a>练习题 3.4.1</h4><h5 id="题目-1-最大值函数"><a href="#题目-1-最大值函数" class="headerlink" title="题目 1: 最大值函数"></a>题目 1: 最大值函数</h5><p>编写一个Lua函数，接收一系列数字作为参数，并返回这些数字中的最大值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Max</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(Max(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment">-- 预期输出 15</span><br></code></pre></td></tr></table></figure><h5 id="题目-2-计算圆的面积"><a href="#题目-2-计算圆的面积" class="headerlink" title="题目 2: 计算圆的面积"></a>题目 2: 计算圆的面积</h5><p>编写一个函数，接受一个圆的半径作为参数，并返回该圆的面积（使用公式：面积 = π * 半径^2）。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CircleArea</span><span class="hljs-params">(radius)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(CircleArea(<span class="hljs-number">5</span>))  <span class="hljs-comment">-- 预期输出78.539816339745</span><br></code></pre></td></tr></table></figure><h5 id="题目-3-斐波那契数列"><a href="#题目-3-斐波那契数列" class="headerlink" title="题目 3: 斐波那契数列"></a>题目 3: 斐波那契数列</h5><p>编写一个函数，接受一个整数<code>n</code>，并返回斐波那契数列的第<code>n</code>个数。斐波那契数列的定义为：F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(n)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(Fibonacci(<span class="hljs-number">10</span>))  <span class="hljs-comment">-- 预期输出55</span><br></code></pre></td></tr></table></figure><h5 id="题目-4-检测素数"><a href="#题目-4-检测素数" class="headerlink" title="题目 4: 检测素数"></a>题目 4: 检测素数</h5><p>编写一个函数，检测一个给定的整数是否是素数（只能被1和自身整除的数）。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsPrime</span><span class="hljs-params">(num)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(IsPrime(<span class="hljs-number">29</span>))  <span class="hljs-comment">-- 预期输出 true 或 false</span><br></code></pre></td></tr></table></figure><h5 id="题目-5-数字倒序"><a href="#题目-5-数字倒序" class="headerlink" title="题目 5: 数字倒序"></a>题目 5: 数字倒序</h5><p>编写一个函数，接受一个整数，并返回其数字倒序的整数。例如，给定123，返回321。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReverseNumber</span><span class="hljs-params">(num)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(ReverseNumber(<span class="hljs-number">123</span>))  <span class="hljs-comment">-- 预期输出 321</span><br></code></pre></td></tr></table></figure><h3 id="3-4-2-字符串"><a href="#3-4-2-字符串" class="headerlink" title="3.4.2 字符串"></a>3.4.2 字符串</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>使用单引号、双引号或中括号定义字符串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> str1 = <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-keyword">local</span> str2 = <span class="hljs-string">&#x27;Lua&#x27;</span><br><span class="hljs-keyword">local</span> str3 = <span class="hljs-string">[[Multi-line</span><br><span class="hljs-string">string]]</span><br></code></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>使用 <code>..</code> 连接字符串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">luaCopy code<br><span class="hljs-keyword">local</span> fullName = <span class="hljs-string">&quot;Lua &quot;</span> .. <span class="hljs-string">&quot;Language&quot;</span><br></code></pre></td></tr></table></figure><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>如果你不使用长括号定义字符串，而是选择使用普通的单引号或双引号，那么需要使用反斜线 <code>\</code> 来转义特定的字符。<br>这种方式类似于许多其他编程语言的字符串转义机制。</p><p><strong>常见的转义序列：</strong></p><ul><li><strong>换行符</strong>：<code>\n</code></li><li><strong>回车符</strong>：<code>\r</code></li><li><strong>制表符</strong>：<code>\t</code></li><li><strong>反斜线</strong>：<code>\\</code></li><li><strong>单引号</strong>：<code>\&#39;</code>（当你的字符串用单引号包围时）</li><li><strong>双引号</strong>：<code>\&quot;</code>（当你的字符串用双引号包围时）</li></ul><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> singleLineString = <span class="hljs-string">&quot;这是一个单行字符串。\n它包含了一个换行符，以及一些特殊字符：\\ \&quot; \&#x27;&quot;</span><br><span class="hljs-built_in">print</span>(singleLineString)<br><br><span class="hljs-comment">--输出</span><br>这是一个单行字符串。<br>它包含了一个换行符，以及一些特殊字符：\ <span class="hljs-string">&quot; &#x27;</span><br></code></pre></td></tr></table></figure><p><strong>长括号</strong></p><p>如果你使用长括号定义字符串，就无需转义</p><p>Lua中的长括号（或称为长字符串）是一种特殊的语法，用于定义多行字符串或包含特殊字符的字符串，而不需要转义。长括号使用一对双方括号 <code>[[...]]</code> 来界定字符串。</p><p>它在处理多行字符串或需要保留原始格式的字符串时非常有用。<br>了解并熟练使用这一特性可以让处理文本数据在Lua中变得更加容易和直观。</p><p><strong>长括号定义字符串的特点</strong></p><ol><li><strong>多行字符串</strong>：<br>长括号非常适合定义包含多行文本的字符串。</li><li><strong>无需转义</strong>：<br>在长括号内部，不需要转义引号或其他特殊字符，这使得包含复杂文本（如JSON或XML）的字符串更容易编写和阅读。</li><li><strong>保留格式</strong>：<br>字符串的格式（包括空格、换行等）会被完全保留。</li></ol><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> multiLineString = <span class="hljs-string">[[</span><br><span class="hljs-string">这是一个多行字符串。</span><br><span class="hljs-string">可以包含换行</span><br><span class="hljs-string">以及其他 &#x27;特殊&#x27; 字符，比如 &quot;引号&quot; 无需转义。</span><br><span class="hljs-string">]]</span><br><span class="hljs-built_in">print</span>(multiLineString)<br><br><span class="hljs-comment">--输出：</span><br>这是一个多行字符串。<br>可以包含换行<br>以及其他 <span class="hljs-string">&#x27;特殊&#x27;</span> 字符，比如 <span class="hljs-string">&quot;引号&quot;</span> 无需转义。<br></code></pre></td></tr></table></figure><p>这段代码中的 <code>multiLineString</code> 变量包含了一个多行字符串，其中的换行和空格都被保留了下来。</p><p><strong>长括号的转义：</strong></p><p>Lua还支持嵌套的长括号，这允许在字符串内部包含长括号。<br>这是通过在两边的方括号间添加相等数量的等号来实现的。</p><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> nestedString = <span class="hljs-string">[==[</span><br><span class="hljs-string">这个字符串内可以包含长括号，例如：</span><br><span class="hljs-string">[[ 这是内部的长括号 ]]</span><br><span class="hljs-string">]==]</span><br><span class="hljs-built_in">print</span>(nestedString)<br></code></pre></td></tr></table></figure><p>在这个示例中，字符串由 <code>[==[</code> 和 <code>]==]</code> 包围，因此内部的 <code>[[</code> 和 <code>]]</code> 不会被解释为字符串的界定符，而是字符串内容的一部分。</p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>Lua提供了强大的字符串格式化功能，类似于C#中的<code>String.Format</code>。<br>在Lua中，这是通过<code>string.format</code>函数实现的，它的使用方式类似于C语言中的<code>printf</code>函数。</p><p><code>string.format</code>函数允许你创建一个格式化的字符串。它使用格式化字符串作为第一个参数，该字符串可以包含一系列的格式化指示符，后续参数将替换这些指示符。</p><p><strong>常用的格式化指示符：</strong></p><ul><li><code>%s</code>：格式化字符串</li><li><code>%d</code> 或 <code>%i</code>：格式化整数</li><li><code>%f</code>：格式化浮点数</li><li><code>%.nf</code>：格式化浮点数，<code>n</code> 指定小数点后的位数</li><li>%x：16进制表示</li></ul><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> name = <span class="hljs-string">&quot;Lua&quot;</span><br><span class="hljs-keyword">local</span> version = <span class="hljs-number">5.4</span><br><span class="hljs-keyword">local</span> year = <span class="hljs-number">2023</span><br><span class="hljs-keyword">local</span> str = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;Language: %s, Version: %.1f, Year: %d&quot;</span>, name, version, year)<br><span class="hljs-built_in">print</span>(str)<br><br><span class="hljs-keyword">local</span> dateStr = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;Today is %02d/%02d/%04d&quot;</span>, day, month, year)<br><span class="hljs-comment">-- 其中 `%02d` 和 `%04d` 确保了数字的格式。</span><br><span class="hljs-built_in">print</span>(dateStr)<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Language:</span> <span class="hljs-string">Lua,</span> <span class="hljs-attr">Version:</span> <span class="hljs-number">5.4</span><span class="hljs-string">,</span> <span class="hljs-attr">Year:</span> <span class="hljs-number">2023</span><br><span class="hljs-string">“Today</span> <span class="hljs-string">is</span> <span class="hljs-number">05</span><span class="hljs-string">/06/2023”</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>%s</code> 被替换为字符串变量 <code>name</code>，<code>%.1f</code> 被替换为浮点数 <code>version</code>（保留一位小数），<code>%d</code> 被替换为整数 <code>year</code>。</p><h4 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h4><p>Lua的字符串库提供了许多有用的函数来处理字符串。以下是一些常用的函数：</p><ul><li><p><strong>string.len(s)</strong><br>返回字符串<code>s</code>的长度。</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> length = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-built_in">print</span>(length)  <span class="hljs-comment">-- 输出 5</span><br></code></pre></td></tr></table></figure></li><li><p><strong>string.upper(s) 和 string.lower(s)</strong><br>将字符串<code>s</code>转换为大写或小写。</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">upper</span>(<span class="hljs-string">&quot;Hello&quot;</span>))  <span class="hljs-comment">-- 输出 &quot;HELLO&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">string</span>.<span class="hljs-built_in">lower</span>(<span class="hljs-string">&quot;Hello&quot;</span>))  <span class="hljs-comment">-- 输出 &quot;hello&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>string.sub(s, i, j)</strong><br>返回字符串<code>s</code>中从索引<code>i</code>到<code>j</code>的子串（包括索引<code>i</code>和<code>j</code>处的字符）。<br>如果<code>j</code>未指定，则返回从<code>i</code>到字符串末尾的子串。</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> subStr = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">sub</span>(<span class="hljs-string">&quot;Hello Lua&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(subStr)  <span class="hljs-comment">-- 输出 &quot;ello&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>string.gsub(s, pattern, replacement)</strong><br>在字符串<code>s</code>中替换所有匹配<code>pattern</code>的部分为<code>replacement</code>。</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> result = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&quot;Hello Lua&quot;</span>, <span class="hljs-string">&quot;Lua&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment">-- 输出 &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>string.find(s, pattern)</strong><br>在字符串<code>s</code>中查找<code>pattern</code>，返回找到的第一个匹配项的起始和结束索引。<br>如果未找到匹配项，则返回<code>nil</code>。</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> start, finish = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Hello Lua&quot;</span>, <span class="hljs-string">&quot;Lua&quot;</span>)<br><span class="hljs-built_in">print</span>(start, finish)  <span class="hljs-comment">-- 输出 &quot;7 9&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>string.match(s, pattern)</strong><br>从字符串<code>s</code>中提取与<code>pattern</code>匹配的子串。</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-built_in">date</span> = <span class="hljs-string">&quot;Today is 17/03/2023&quot;</span><br><span class="hljs-keyword">local</span> d, m, y = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">match</span>(<span class="hljs-built_in">date</span>, <span class="hljs-string">&quot;(%d+)/(%d+)/(%d+)&quot;</span>)<br><span class="hljs-built_in">print</span>(d, m, y)  <span class="hljs-comment">-- 输出 &quot;17 03 2023&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>string.gmatch(s, pattern)</strong><br>全局匹配函数用于创建一个迭代器，该迭代器可以遍历字符串中所有匹配指定模式的子串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">gmatch</span>(<span class="hljs-string">&quot;Hello Lua World&quot;</span>, <span class="hljs-string">&quot;%a+&quot;</span>) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(word)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>string.rep(s , repeatTimes)</strong><br>用于重复一个字符串指定次数，并返回结果。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> repeated = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">rep</span>(<span class="hljs-string">&quot;Lua &quot;</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(repeated)  <span class="hljs-comment">-- 输出 &quot;Lua Lua Lua &quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>string.reverse(s)</strong><br>返回一个字符串的翻转</p></li><li><p><strong>string.dump(target)</strong><br>函数用于将一个函数转换为一个字符串。<br>这个字符串包含了该函数的字节码表示。这通常用于序列化函数以便存储或传输，然后可以通过<code>load</code>函数重新加载并执行。</p><p><strong>使用场景：</strong></p><ul><li><strong>序列化函数</strong>：用于保存函数的字节码，可以跨会话或网络传输。</li><li><strong>调试目的</strong>：查看函数的内部字节码结构。</li></ul></li></ul><h4 id="练习题-3-4-2"><a href="#练习题-3-4-2" class="headerlink" title="练习题 3.4.2"></a>练习题 3.4.2</h4><h5 id="题目-1-字符串反转"><a href="#题目-1-字符串反转" class="headerlink" title="题目 1: 字符串反转"></a>题目 1: 字符串反转</h5><p>编写一个Lua函数，接受一个字符串作为参数，并返回这个字符串的反转。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReverseString</span><span class="hljs-params">(str)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(ReverseString(<span class="hljs-string">&quot;Hello Lua&quot;</span>))  <span class="hljs-comment">-- 预期输出 &quot;auL olleH&quot;</span><br></code></pre></td></tr></table></figure><h5 id="题目-2-单词计数"><a href="#题目-2-单词计数" class="headerlink" title="题目 2: 单词计数"></a>题目 2: 单词计数</h5><p>编写一个Lua函数，统计并返回给定字符串中单词的数量。这里，你可以假设单词之间由空格分隔。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CountWords</span><span class="hljs-params">(str)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(CountWords(<span class="hljs-string">&quot;Hello Lua world&quot;</span>))  <span class="hljs-comment">-- 预期输出 3</span><br></code></pre></td></tr></table></figure><h5 id="题目-3-字符串中的大写字母"><a href="#题目-3-字符串中的大写字母" class="headerlink" title="题目 3: 字符串中的大写字母"></a>题目 3: 字符串中的大写字母</h5><p>编写一个Lua函数，接受一个字符串并返回该字符串中大写字母的数量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CountUpperCase</span><span class="hljs-params">(str)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(CountUpperCase(<span class="hljs-string">&quot;Hello Lua&quot;</span>))  <span class="hljs-comment">-- 预期输出 2</span><br></code></pre></td></tr></table></figure><h5 id="题目-4-判断字符串是否是回文"><a href="#题目-4-判断字符串是否是回文" class="headerlink" title="题目 4: 判断字符串是否是回文"></a>题目 4: 判断字符串是否是回文</h5><p>编写一个Lua函数，检查一个字符串是否是回文（即正着读和反着读都相同）。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(str)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(IsPalindrome(<span class="hljs-string">&quot;racecar&quot;</span>))  <span class="hljs-comment">-- 预期输出 true</span><br><span class="hljs-built_in">print</span>(IsPalindrome(<span class="hljs-string">&quot;hello&quot;</span>))    <span class="hljs-comment">-- 预期输出 false</span><br></code></pre></td></tr></table></figure><h5 id="题目-5-字符串替换"><a href="#题目-5-字符串替换" class="headerlink" title="题目 5: 字符串替换"></a>题目 5: 字符串替换</h5><p>编写一个Lua函数，替换字符串中的所有指定子串为另一个子串。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReplaceString</span><span class="hljs-params">(str, original, replacement)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(ReplaceString(<span class="hljs-string">&quot;cats and dogs&quot;</span>, <span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;birds&quot;</span>))  <span class="hljs-comment">-- 预期输出 &quot;birds and dogs&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-4-3-函数"><a href="#3-4-3-函数" class="headerlink" title="3.4.3 函数"></a>3.4.3 函数</h3><p>Lua中的函数极其灵活，可以用于各种高级编程模式，如闭包、高阶函数和回调。理解和熟练使用这些特性，将使你能够充分利用Lua的功能，编写出更为高效和可读的代码。</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li><p><strong>定义函数</strong>：使用<code>function</code>关键字。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span><span class="hljs-params">(name)</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, &quot;</span> .. name)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>调用函数</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">greet(<span class="hljs-string">&quot;Lua&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>返回值：</strong><br>Lua函数可以返回多个值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxmin</span><span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> a, b<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> b, a<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span> = maxmin(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span>)  <span class="hljs-comment">-- 输出 &quot;10 5&quot;</span><br></code></pre></td></tr></table></figure><p>当函数的参数只有一个字符串常量时，调用函数的()可以被省略。<br>例如：</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>) <span class="hljs-comment">--输出&quot;你好&quot;</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;你好&quot;</span><span class="hljs-comment">--输出&quot;你好&quot;</span><br></code></pre></td></tr></table></figure><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><p>Lua函数可以接受变长参数，通过<code>...</code>表示。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">local</span> total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(&#123;...&#125;) <span class="hljs-keyword">do</span><br>        total = total + v<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> total<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">-- 输出 &quot;15&quot;</span><br></code></pre></td></tr></table></figure><p><code>table.pack</code> 和 <code>table.unpack</code> 是两个处理变长参数或数组的有用函数。</p><h5 id="table-pack"><a href="#table-pack" class="headerlink" title="table.pack"></a>table.pack</h5><p><code>table.pack</code> 用于将多个参数打包成一个表。<br>这在处理变长参数时尤其有用，因为它允许将所有参数捕获到一个表中，以便后续处理。</p><p><strong>用法</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = <span class="hljs-built_in">table</span>.pack(...)<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> myTable = <span class="hljs-built_in">table</span>.pack(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(myTable[<span class="hljs-number">1</span>])  <span class="hljs-comment">-- 输出 1</span><br><span class="hljs-built_in">print</span>(myTable.n)   <span class="hljs-comment">-- 输出 4，因为表中有 4 个元素</span><br></code></pre></td></tr></table></figure><h5 id="table-unpack"><a href="#table-unpack" class="headerlink" title="table.unpack"></a>table.unpack</h5><p><code>table.unpack</code> 是 <code>unpack</code> 函数在 Lua 5.2 及更高版本中的等价函数（在 Lua 5.1 中仍然是 <code>unpack</code>）。<br>它用于将表中的元素作为多个返回值返回，这在将表中的值传递给期望多个参数的函数时非常有用。</p><p><strong>用法</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(t)<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> myTable = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(myTable))  <span class="hljs-comment">-- 输出 1  2  3  4</span><br></code></pre></td></tr></table></figure><h5 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h5><p><code>table.pack</code> 和 <code>table.unpack</code> 可以结合使用，以在函数间传递变长参数列表。这对于编写可以接受任意数量参数的函数或将参数传递给另一个期望多个参数的函数非常有用。</p><p><strong>示例</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">local</span> args = <span class="hljs-built_in">table</span>.pack(...)<br>    <span class="hljs-keyword">local</span> total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, args.n <span class="hljs-keyword">do</span><br>        total = total + args[i]<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> total<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span><span class="hljs-params">(factor, ...)</span></span><br>    <span class="hljs-keyword">local</span> args = <span class="hljs-built_in">table</span>.pack(...)<br>    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, args.n <span class="hljs-keyword">do</span><br>        args[i] = args[i] * factor<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">unpack</span>(args)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(sum(multiply(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))  <span class="hljs-comment">-- 将 1, 2, 3 每个数字乘以 2，然后计算总和，输出 12</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>multiply</code> 函数接受一个因子和一系列数字，将每个数字乘以因子，然后使用 <code>table.unpack</code> 返回所有结果。<code>sum</code> 函数接受一系列数字并计算它们的总和。我们通过 <code>table.pack</code> 和 <code>table.unpack</code> 将参数从 <code>multiply</code> 传递到 <code>sum</code>。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>在Lua中，函数可以作为参数传递给其他函数，或者作为返回值。</p><p><strong>函数作为参数:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">codefunction apply(func, x)<br>    <span class="hljs-keyword">return</span> func(x)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(apply(square, <span class="hljs-number">5</span>))  <span class="hljs-comment">-- 输出 &quot;25&quot;</span><br></code></pre></td></tr></table></figure><p><strong>返回函数:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiplier</span><span class="hljs-params">(factor)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span><br>        <span class="hljs-keyword">return</span> x * factor<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> double = multiplier(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(double(<span class="hljs-number">5</span>))  <span class="hljs-comment">-- 输出 &quot;10&quot;</span><br></code></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>Lua支持匿名函数，这在编写一次性函数或传递给高阶函数时非常有用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> result = apply(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span> <span class="hljs-keyword">end</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment">-- 输出 &quot;6&quot;</span><br></code></pre></td></tr></table></figure><h4 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h4><p>尾调用（Tail Call）是函数编程中的一个概念，指的是一个函数在其返回时直接调用另一个函数，而没有更多的操作。<br>尾调用是一种特殊的函数调用，因为在执行尾调用时，当前函数的执行环境（包括调用栈帧）可以被释放，因为所有的局部变量都不再需要了。</p><p>尾调用的示例:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> g(x) <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在这个例子中，函数 <code>f</code> 在返回时直接调用函数 <code>g</code>，而不做任何其他操作。这是一个尾调用的例子。</p><p>在 Lua 中，尾调用有特别的优化：尾递归优化。<br>如果一个函数的最后一个动作是调用另一个函数（包括它自己），Lua 会使用一种称为“尾调用消除”的技术，它可以让尾调用不使用任何额外的栈空间，从而避免增加额外的栈帧。这意味着尾递归函数可以进行大量的递归调用而不会溢出栈。</p><p>需要注意的时，函数的最后一个操作必须只是调用另一个函数才算尾调用，有其他操作的就不算。<br>比如以下的几个例子就不算：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span></span> g(x) <span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> g(x) + <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> x <span class="hljs-keyword">or</span> g(x)<br><span class="hljs-keyword">return</span> (g(x))<br></code></pre></td></tr></table></figure><h4 id="练习题-3-4-3"><a href="#练习题-3-4-3" class="headerlink" title="练习题 3.4.3"></a>练习题 3.4.3</h4><h5 id="题目-1-阶乘函数"><a href="#题目-1-阶乘函数" class="headerlink" title="题目 1:阶乘函数"></a>题目 1:阶乘函数</h5><p>编写一个Lua函数，计算并返回一个给定整数的阶乘。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Factorial</span><span class="hljs-params">(n)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(Factorial(<span class="hljs-number">5</span>))  <span class="hljs-comment">-- 预期输出 120</span><br></code></pre></td></tr></table></figure><h5 id="题目-2-高阶函数映射"><a href="#题目-2-高阶函数映射" class="headerlink" title="题目 2:高阶函数映射"></a>题目 2:高阶函数映射</h5><p>编写一个Lua函数，接受一个函数和一个数组，返回一个新数组，该数组是将原始数组中的每个元素通过给定函数转换后的结果。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Map</span><span class="hljs-params">(func, array)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> result = Map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span> <span class="hljs-keyword">end</span>, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)<br><span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(result) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(v) <span class="hljs-keyword">end</span>  <span class="hljs-comment">-- 预期输出 2, 4, 6</span><br></code></pre></td></tr></table></figure><h5 id="题目-3-闭包计数器"><a href="#题目-3-闭包计数器" class="headerlink" title="题目 3:闭包计数器"></a>题目 3:闭包计数器</h5><p>编写一个Lua函数，返回一个闭包，该闭包每次被调用时返回一个递增的整数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CreateCounter</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> counter = CreateCounter()<br><span class="hljs-built_in">print</span>(counter())  <span class="hljs-comment">-- 预期输出 1</span><br><span class="hljs-built_in">print</span>(counter())  <span class="hljs-comment">-- 预期输出 2</span><br></code></pre></td></tr></table></figure><h5 id="题目-4-组合函数"><a href="#题目-4-组合函数" class="headerlink" title="题目 4:组合函数"></a>题目 4:组合函数</h5><p>编写一个Lua函数，它接受两个函数f和g作为参数，并返回一个新的函数。这个新函数在被调用时，应先将其参数传递给g，然后将g的结果传递给f，最后返回f的结果。   </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Compose</span><span class="hljs-params">(f, g)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Square</span><span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">return</span> x * x<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Increment</span><span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> squareAfterIncrementing = Compose(Square, Increment)<br><span class="hljs-built_in">print</span>(squareAfterIncrementing(<span class="hljs-number">4</span>))  <span class="hljs-comment">-- 预期输出 25 (即 (4 + 1) ^ 2)</span><br></code></pre></td></tr></table></figure><h5 id="题目-5-组合函数"><a href="#题目-5-组合函数" class="headerlink" title="题目 5:组合函数"></a>题目 5:组合函数</h5><p>编写一个Lua函数，接受任意数量的参数，并返回它们的总和。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sum</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(Sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">-- 预期输出 15</span><br></code></pre></td></tr></table></figure><h3 id="3-4-4-日期与时间"><a href="#3-4-4-日期与时间" class="headerlink" title="3.4.4 日期与时间"></a>3.4.4 日期与时间</h3><p> 在 Lua 中处理日期和时间主要依赖于 <code>os</code> 库中的 <code>os.time</code> 和 <code>os.date</code> 函数。这些函数提供了获取和格式化日期和时间的能力。</p><p>使用 <code>os.time</code> 和 <code>os.date</code>，你可以方便地在 Lua 中处理日期和时间，无论是进行时间计算还是格式化输出日期和时间。</p><h4 id="os-time"><a href="#os-time" class="headerlink" title="os.time"></a>os.time</h4><p><code>os.time</code> 函数用于</p><ul><li>获取当前时间</li><li>将日期转换为时间戳（自 1970 年 1 月 1 日以来的秒数）。</li></ul><p><strong>参数：表（可选）</strong>：<br>一个描述日期和时间的表。<br>这个表可以包含年（year）、月（month）、日（day）、小时（hour）、分钟（min）、秒（sec）等字段。<br>如果没有提供表，<code>os.time</code> 返回当前时间的时间戳。</p><p><strong>返回值：时间戳</strong>：<br>一个数字，表示自 Unix 纪元（1970 年 1 月 1 日）以来的秒数。</p><p><strong>代码案例:</strong></p><p>获取当前时间的时间戳：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> now = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Current timestamp:&quot;</span>, now)<br></code></pre></td></tr></table></figure><p>将特定日期转换为时间戳：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> someDay = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">time</span>(&#123;year=<span class="hljs-number">2020</span>, month=<span class="hljs-number">1</span>, day=<span class="hljs-number">1</span>, hour=<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, sec=<span class="hljs-number">0</span>&#125;)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Timestamp of 2020-01-01:&quot;</span>, someDay)<br></code></pre></td></tr></table></figure><h4 id="os-date"><a href="#os-date" class="headerlink" title="os.date"></a>os.date</h4><p><code>os.date</code> 函数用于</p><ul><li>格式化时间戳为可读的日期和时间字符串</li><li>返回一个包含日期和时间信息的表</li></ul><p><strong>参数:</strong></p><ul><li><strong>格式字符串（可选）</strong>：<br>指定输出格式的字符串。默认为 <code>%c</code>，表示本地日期和时间的完整格式。<br><code>os.date</code> 的格式字符串遵循 C 语言中 <code>strftime</code> 函数的规则。<br>常用的格式指示符包括<ul><li><strong>%a</strong>：缩写的星期几名称（如 Wed）</li><li><strong>%A</strong>：完整的星期几名称（如 Wednesday）</li><li><strong>%b</strong>：缩写的月份名称（如 Sep）</li><li><strong>%B</strong>：完整的月份名称（如 September）</li><li><strong>%c</strong>：日期和时间（如 09/16/98 23:48:10）</li><li><strong>%d</strong>：月份中的第几天（01-31）</li><li><strong>%H</strong>：24小时制的小时数（00-23）</li><li><strong>%I</strong>：12小时制的小时数（01-12）</li><li><strong>%j</strong>：年份中的第几天（001-366）</li><li><strong>%m</strong>：月份（01-12）</li><li><strong>%M</strong>：分钟数（00-59）</li><li><strong>%p</strong>：AM 或 PM</li><li><strong>%S</strong>：秒数（00-59）</li><li><strong>%U</strong>：年份中的第几周，以周日为一周的第一天（00-53）</li><li><strong>%w</strong>：星期几（0-6），星期天为0</li><li><strong>%W</strong>：年份中的第几周，以周一为一周的第一天（00-53）</li><li><strong>%x</strong>：日期（如 09/16/98）</li><li><strong>%X</strong>：时间（如 23:48:10）</li><li><strong>%y</strong>：年份的最后两位数字（00-99）</li><li><strong>%Y</strong>：完整的年份（如 1998）</li><li><strong>%Z</strong>：时区名称（如果不存在，则返回空字符串）</li><li>**%%**：百分号自身</li></ul></li><li><strong>时间戳（可选）</strong>：<br>要格式化的时间戳。如果没有提供，<code>os.date</code> 使用当前时间。</li></ul><p><strong>返回值:</strong><br><strong>格式化的日期/时间字符串</strong> 或 <strong>日期/时间表</strong>，取决于格式字符串。</p><p><strong>代码案例:</strong></p><p>获取并打印当前日期和时间：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">print</span>(&quot;Current <span class="hljs-built_in">date</span> and <span class="hljs-built_in">time</span>:&quot;, os.<span class="hljs-built_in">date</span>())<br></code></pre></td></tr></table></figure><p>以特定格式打印日期和时间：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Date (YYYY-MM-DD):&quot;</span>, os.date(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>))<br></code></pre></td></tr></table></figure><p>获取当前时间的表：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> dateTable = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">date</span>(<span class="hljs-string">&quot;*t&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Year:&quot;</span>, dateTable.year)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Month:&quot;</span>, dateTable.month)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Day:&quot;</span>, dateTable.day)<br></code></pre></td></tr></table></figure><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><h5 id="题目-1-计算两个日期之间的天数差"><a href="#题目-1-计算两个日期之间的天数差" class="headerlink" title="题目 1:计算两个日期之间的天数差"></a>题目 1:计算两个日期之间的天数差</h5><p><strong>描述：</strong><br>编写一个 Lua 程序，计算两个给定日期之间的天数差。<br>你需要使用 <code>os.time</code> 函数将日期转换为时间戳，然后计算它们之间的差异，并将其转换回天数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 计算两个日期之间的天数差</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">daysBetween</span><span class="hljs-params">(date1, date2)</span></span><br>    <span class="hljs-comment">--写下你的答案</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> date1 = &#123;year=<span class="hljs-number">2021</span>, month=<span class="hljs-number">1</span>, day=<span class="hljs-number">1</span>&#125;<br><span class="hljs-keyword">local</span> date2 = &#123;year=<span class="hljs-number">2021</span>, month=<span class="hljs-number">1</span>, day=<span class="hljs-number">31</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Days between: &quot;</span> .. daysBetween(date1, date2))<br></code></pre></td></tr></table></figure><p><strong>预期输出：</strong>Days between: 30</p><h5 id="题目-2-格式化当前日期和时间"><a href="#题目-2-格式化当前日期和时间" class="headerlink" title="题目 2:格式化当前日期和时间"></a>题目 2:格式化当前日期和时间</h5><p><strong>描述：</strong><br>使用 <code>os.date</code> 函数，编写一个 Lua 程序来格式化并打印当前日期和时间，格式为 <code>&quot;YYYY-MM-DD HH:MM:SS&quot;</code>。</p><p><strong>预期输出：</strong>Current date and time: 2021-09-21 12:34:56</p><h5 id="题目-3-计算特定日期是星期几"><a href="#题目-3-计算特定日期是星期几" class="headerlink" title="题目 3:计算特定日期是星期几"></a>题目 3:计算特定日期是星期几</h5><p><strong>描述：</strong><br>编写一个 Lua 程序，计算给定日期是星期几。例如，输入 <code>&#123;year=2021, month=9, day=21&#125;</code> 应该返回该日期是星期几。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dayOfWeek</span><span class="hljs-params">(date)</span></span><br>    <span class="hljs-comment">--写下你的答案</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> myDate = &#123;year=<span class="hljs-number">2021</span>, month=<span class="hljs-number">9</span>, day=<span class="hljs-number">21</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The day of the week is: &quot;</span> .. dayOfWeek(myDate))<br></code></pre></td></tr></table></figure><p><strong>预期输出：</strong> The day of the week is: Tuesday</p><h5 id="题目-4-创建一个简单的倒计时器"><a href="#题目-4-创建一个简单的倒计时器" class="headerlink" title="题目 4:创建一个简单的倒计时器"></a>题目 4:创建一个简单的倒计时器</h5><p><strong>描述：</strong><br>编写一个 Lua 程序，创建一个简单的倒计时器。<br>程序应该接受一定数量的秒数，然后每秒钟递减，直到达到零。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countdown</span><span class="hljs-params">(seconds)</span></span><br>    <span class="hljs-comment">--写下你的答案</span><br><span class="hljs-keyword">end</span><br><br>countdown(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p><strong>预期输出：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">5</span> <span class="hljs-built_in">seconds</span> remaining<br><span class="hljs-number">4</span> <span class="hljs-built_in">seconds</span> remaining<br><span class="hljs-number">3</span> <span class="hljs-built_in">seconds</span> remaining<br><span class="hljs-number">2</span> <span class="hljs-built_in">seconds</span> remaining<br><span class="hljs-number">1</span> <span class="hljs-built_in">seconds</span> remaining<br>Time<span class="hljs-string">&#x27;s up!</span><br></code></pre></td></tr></table></figure><h2 id="3-5-代码规范"><a href="#3-5-代码规范" class="headerlink" title="3.5 代码规范"></a>3.5 代码规范</h2><h3 id="3-5-1-命名规范"><a href="#3-5-1-命名规范" class="headerlink" title="3.5.1 命名规范"></a>3.5.1 命名规范</h3><p>Lua作为一种灵活的编程语言，并没有官方强制的命名规范，但遵循一些通用的命名约定可以使你的代码更加清晰和易于维护。以下是一些推荐的Lua编程中的命名规范：</p><table><thead><tr><th>代码内容</th><th>命名方法</th><th>示例</th></tr></thead><tbody><tr><td>局部变量</td><td>小驼峰式命名</td><td><code>local function doSomethingImportant() end</code></td></tr><tr><td>全局变量</td><td>大驼峰式命名</td><td><code>GlobalVariable = 20</code></td></tr><tr><td>常量</td><td>全大写，并用下划线分隔</td><td><code>local MAX_SIZE = 100</code></td></tr><tr><td>表和模块</td><td>大驼峰式命名</td><td><code>local Person = &#123;&#125;</code></td></tr></tbody></table><p>任何变量，函数或标识符都不能与lua的保留字同名</p><p><strong>lua保留字如下：</strong></p><table><thead><tr><th>local</th><th>function</th><th>return</th><th>end</th><th>nil</th></tr></thead><tbody><tr><td>if</td><td>elseif</td><td>else</td><td>true</td><td>false</td></tr><tr><td>and</td><td>or</td><td>not</td><td>then</td><td>break</td></tr><tr><td>for</td><td>in</td><td>repeat</td><td>do</td><td>while</td></tr><tr><td>until</td><td>goto</td><td></td><td></td><td></td></tr></tbody></table><h3 id="3-5-2-注释"><a href="#3-5-2-注释" class="headerlink" title="3.5.2 注释"></a>3.5.2 注释</h3><h4 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h4><p>单行注释以两个连字符<code>--</code>开始。从这两个连字符开始到行末的所有内容都被视为注释，不会被Lua执行。</p><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 这是一个单行注释</span><br><span class="hljs-keyword">local</span> x = <span class="hljs-number">10</span>  <span class="hljs-comment">-- 这也是一个单行注释</span><br></code></pre></td></tr></table></figure><p>在这个示例中，第一行完全是注释，而第二行中的<code>local x = 10</code>是代码，<code>-- 这也是一个单行注释</code>是注释。</p><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><p>多行注释使用一对长括号<code>--[[</code> 和 <code>]]</code>来界定。所有在这两个标记之间的内容都被视为注释。</p><p><strong>示例:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--[[</span><br><span class="hljs-comment">这是一个多行注释。</span><br><span class="hljs-comment">可以跨越多行。</span><br><span class="hljs-comment">]]</span><br><span class="hljs-keyword">local</span> y = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>在这个示例中，从<code>--[[</code>开始到<code>]]</code>结束的部分是多行注释。</p><h4 id="注释的最佳实践"><a href="#注释的最佳实践" class="headerlink" title="注释的最佳实践"></a>注释的最佳实践</h4><ul><li><strong>清晰性</strong>：<br>注释应该清晰地解释代码的意图和行为，而不是简单地描述代码是做什么的。</li><li><strong>更新</strong>：<br>确保随着代码的变化更新注释，以防止出现误导。</li><li><strong>适度</strong>：<br>适当地使用注释，过多的注释可能会使代码难以阅读，而过少则可能使代码难以理解。</li></ul><p>注释是编写清晰、可维护代码的重要部分。<br>合理地使用注释可以帮助你和其他开发者更好地理解和维护代码。</p><h1 id="4-表"><a href="#4-表" class="headerlink" title="4. 表"></a>4. 表</h1><p>Lua中的表（table）是一种非常灵活的数据结构，它实际上是一个关联数组（associative array）。表可以用作普通的数组、字典、集合，甚至是对象。在Lua中，表是唯一的复合数据类型，用于构建各种复杂的数据结构。</p><h2 id="4-1-基础操作"><a href="#4-1-基础操作" class="headerlink" title="4.1 基础操作"></a>4.1 基础操作</h2><ul><li><strong>创建</strong><br><code>local myTable = &#123;&#125;</code><br>使用大括号<code>&#123;&#125;</code>创建一个新表</li><li><strong>插入</strong><br><code>table.insert(t, [pos,] value)</code><br>向表<code>t</code>中的指定位置<code>pos</code>插入值<code>value</code>。如果未指定<code>pos</code>，则默认插入到表的末尾。</li><li><strong>移除</strong><br><code>table.remove(t, [pos])</code><br>从表<code>t</code>中移除位于位置<code>pos</code>的元素。如果未指定<code>pos</code>，则默认移除表中的最后一个元素。</li><li><strong>排序</strong><br><code>table.sort(t, [comp])</code><br>对表<code>t</code>进行排序。如果提供了比较函数<code>comp</code>，则使用该函数确定元素顺序。</li><li><strong>连接成字符串</strong><br><code>table.concat(t, [sep [, i [, j]]])</code><br>连接表<code>t</code>中的字符串元素，从索引<code>i</code>到<code>j</code>，使用字符串<code>sep</code>作为分隔符。</li><li><strong>解包</strong><br><code>table.unpack(t, [i [, j]])</code><br>返回表<code>t</code>中从索引<code>i</code>到<code>j</code>的所有元素。等同于Lua 5.1中的<code>unpack</code>函数。</li><li><strong>打包</strong><br><code>table.pack(...)</code> (Lua 5.2+)<br>将传入的参数封装到一个新表中，并返回这个表。</li></ul><h2 id="4-2-表用作数组"><a href="#4-2-表用作数组" class="headerlink" title="4.2 表用作数组"></a>4.2 表用作数组</h2><p>Lua表可以用作数组，索引通常从1开始。</p><p><strong>初始化</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> fruits = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(fruits[<span class="hljs-number">1</span>])  <span class="hljs-comment">-- 输出 &quot;apple&quot;</span><br></code></pre></td></tr></table></figure><p><strong>遍历</strong>：<br>使用<code>ipairs</code>遍历数组风格的表：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i, fruit <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(fruits) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(i, fruit)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>多维表</strong>：<br>表可以嵌套，用于创建多维数组或更复杂的数据结构。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> matrix = &#123;<br>  &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,<br>  &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,<br>  &#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>&#125;<br><span class="hljs-built_in">print</span>(matrix[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>])  <span class="hljs-comment">-- 输出 6</span><br></code></pre></td></tr></table></figure><p><strong>取长运算符：</strong><br>Lua中的<code>#</code>运算符用于获取表的长度，它主要适用于序列（数组部分的表），即索引连续的表。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;<br><span class="hljs-built_in">print</span>(#arr)  <span class="hljs-comment">-- 输出 5</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>#arr</code> 返回数组 <code>arr</code> 中的元素数量。</p><blockquote><p>注意事项：</p><ul><li>当表被用作数组时，<code>#</code>运算符返回到第一个<code>nil</code>元素之前的元素数量。</li><li>对于非数组（非连续索引）的表，<code>#</code>的行为可能是未定义的，应避免在这种表上使用<code>#</code>。</li></ul></blockquote><h2 id="4-3-表用作字典"><a href="#4-3-表用作字典" class="headerlink" title="4.3 表用作字典"></a>4.3 表用作字典</h2><p>表也可以用作键-值对集合，类似于字典或哈希表。</p><p><strong>初始化</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> person = &#123;<br>  name = <span class="hljs-string">&quot;Alice&quot;</span>,<br>  age = <span class="hljs-number">30</span><br>&#125;<br><span class="hljs-built_in">print</span>(person[<span class="hljs-string">&quot;name&quot;</span>])  <span class="hljs-comment">-- 输出 &quot;Alice&quot;</span><br><span class="hljs-built_in">print</span>(person.age)  <span class="hljs-comment">-- 输出 30</span><br></code></pre></td></tr></table></figure><p><strong>遍历</strong>：<br>使用<code>pairs</code>遍历字典风格的表：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(person) <span class="hljs-keyword">do</span><br><span class="hljs-built_in">print</span>(key, value)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="练习题-4-1"><a href="#练习题-4-1" class="headerlink" title="练习题 4.1"></a>练习题 4.1</h2><h4 id="题目-1-表的合并"><a href="#题目-1-表的合并" class="headerlink" title="题目 1: 表的合并"></a>题目 1: 表的合并</h4><p>编写一个Lua函数，接受两个表作为参数，返回一个新表，该表是将这两个表的元素合并在一起。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MergeTables</span><span class="hljs-params">(t1, t2)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> result = MergeTables(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;)<br><span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(result) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(v) <span class="hljs-keyword">end</span>  <span class="hljs-comment">-- 预期输出 1, 2, 3, 4, 5, 6</span><br></code></pre></td></tr></table></figure><h4 id="题目-2-键值反转"><a href="#题目-2-键值反转" class="headerlink" title="题目 2: 键值反转"></a>题目 2: 键值反转</h4><p>编写一个Lua函数，接受一个表作为参数，返回一个新表，该表的键和值是原表的值和键。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReverseKeyValue</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> result2 = ReverseKeyValue(&#123;a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>, c = <span class="hljs-number">3</span>&#125;)<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(result2) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(k, v) <span class="hljs-keyword">end</span>  <span class="hljs-comment">-- 预期输出 1 a, 2 b, 3 c</span><br></code></pre></td></tr></table></figure><h4 id="题目-3-表的深度拷贝"><a href="#题目-3-表的深度拷贝" class="headerlink" title="题目 3: 表的深度拷贝"></a>题目 3: 表的深度拷贝</h4><p>编写一个Lua函数，实现对表的深度拷贝，确保原表和新表完全独立，修改一个不会影响另一个。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DeepCopy</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> original = &#123;a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, b = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;<br><span class="hljs-keyword">local</span> copy = DeepCopy(original)<br>copy.a[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(original.a[<span class="hljs-number">1</span>])  <span class="hljs-comment">-- 预期输出 1</span><br></code></pre></td></tr></table></figure><h4 id="题目-4-表中最大值的键"><a href="#题目-4-表中最大值的键" class="headerlink" title="题目 4: 表中最大值的键"></a>题目 4: 表中最大值的键</h4><p>编写一个Lua函数，找出数值型表中最大元素的键。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MaxKey</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br>    <span class="hljs-keyword">local</span> maxValue = <span class="hljs-built_in">math</span>.mininteger<br>    <span class="hljs-keyword">local</span> <span class="hljs-built_in">output</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> value &gt;= maxValue <span class="hljs-keyword">then</span><br>            maxValue = value<br>            <span class="hljs-built_in">output</span> = key<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">output</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> result = MaxKey(&#123;a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>, c = <span class="hljs-number">15</span>&#125;)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment">-- 预期输出 &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="题目-5-表元素的计数"><a href="#题目-5-表元素的计数" class="headerlink" title="题目 5: 表元素的计数"></a>题目 5: 表元素的计数</h4><p>编写一个Lua函数，接受一个表作为参数，返回一个新表，该表记录了原表中每个元素出现的次数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CountElements</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> result = CountElements(&#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>&#125;)<br><span class="hljs-keyword">for</span> fruit, count <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(result) <span class="hljs-keyword">do</span> <span class="hljs-built_in">print</span>(fruit, count) <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="4-4-元表与元方法"><a href="#4-4-元表与元方法" class="headerlink" title="4.4 元表与元方法"></a>4.4 元表与元方法</h2><h3 id="4-4-1-元表（Metatable）"><a href="#4-4-1-元表（Metatable）" class="headerlink" title="4.4.1 元表（Metatable）"></a>4.4.1 元表（Metatable）</h3><p>在Lua中，元表是一种特殊的表，它为另一个表（称为目标表）定义了特殊的行为。<br>元表可以改变目标表的行为，包括算术操作、比较操作、索引操作等。</p><blockquote><p>注意：元表和目标表可以是一个表，这也是利用元表来模拟集成派生的关键</p></blockquote><p><strong>设置元表：</strong></p><p>使用<code>setmetatable</code>函数为表设置元表：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-keyword">local</span> mt = &#123;&#125;  <span class="hljs-comment">-- 元表</span><br><span class="hljs-built_in">setmetatable</span>(t, mt)<br></code></pre></td></tr></table></figure><p><strong>获得元表：</strong></p><p>使用<code>getmetatable</code>函数获取目标表的元表</p><h3 id="4-4-2-元方法（Metamethod）"><a href="#4-4-2-元方法（Metamethod）" class="headerlink" title="4.4.2 元方法（Metamethod）"></a>4.4.2 元方法（Metamethod）</h3><p>元方法是元表中的特殊键，用于定义某些操作的行为。<br>当对表进行特定操作时，如果该表有元表，并且元表中有相应的元方法，那么这个元方法就会被调用。</p><h4 id="算数元方法"><a href="#算数元方法" class="headerlink" title="算数元方法"></a>算数元方法</h4><p>可用于表的算数运算符重载</p><ul><li><code>__add</code>+（加法）</li><li><code>__sub</code>-（减法）</li><li><code>__mul</code>*（乘法）</li><li><code>__div</code>/（除法）</li><li><code>__mod</code>%（取模）</li><li><code>__unm</code>-（取负）</li><li><code>__pow</code>^（幂运算）</li><li><code>__idiv</code>：//（整除）</li></ul><h4 id="位运算元方法"><a href="#位运算元方法" class="headerlink" title="位运算元方法"></a>位运算元方法</h4><p>可用于表的位运算符号重载</p><ul><li><code>__band</code>：&amp;（位与）</li><li><code>__bor</code>：|（位或）</li><li><code>__bxor</code>：~（位异或）</li><li><code>__bnot</code>：~（位非）</li><li><code>__shl</code>：&lt;&lt;（位左移）</li><li><code>__shr</code>：&gt;&gt;（位右移）</li></ul><h4 id="关系元方法"><a href="#关系元方法" class="headerlink" title="关系元方法"></a>关系元方法</h4><p>可用于表的关系运算符重载</p><ul><li><code>__eq</code>（等于）</li><li><code>__lt</code>（小于）</li><li><code>__le</code>（小于等于</li></ul><h4 id="其他元方法"><a href="#其他元方法" class="headerlink" title="其他元方法"></a>其他元方法</h4><ul><li><p><code>__index</code>：<br>当访问表中不存在的键时调用。可以是一个函数或另一个表</p></li><li><p><code>__newindex</code>：<br>当向表中不存在的键赋值时调用。</p></li><li><p><code>__metatable</code>：<br>用于保护元表，防止外部访问和修改。</p></li><li><p><code>__call</code>：<br>当Lua尝试调用一个表时调用。</p></li><li><p><code>__tostring</code>：<br>改变表转换为字符串时的行为。</p></li><li><p><code>__len</code>：<br>改变获取表长度（<code>#</code>操作符）的行为。</p></li><li><p><code>__concat</code>：<br>重载连接操作符（<code>..</code>）</p></li><li><p><code>__gc</code>：<br>垃圾收集（在表被回收时调用）<br>重载析构函数</p></li><li><p><code>__mode</code>：<br>设置弱表的行为</p></li><li><p><code>__close</code>：<br>关闭操作（Lua 5.4中引入）<br>类似于Go语言的<code>defer</code>语句，即在离开局部作用域时自动执行某些操作。</p></li></ul><h3 id="4-4-3-绕过元表和元方法"><a href="#4-4-3-绕过元表和元方法" class="headerlink" title="4.4.3 绕过元表和元方法"></a>4.4.3 绕过元表和元方法</h3><p>有一些Lua语言内置的基础函数，它们提供了直接操作表的能力，绕过了元表（metatable）的拦截机制。<br>这些函数是Lua标准库的一部分，提供了对表的底层访问。</p><ul><li>**<code>rawset</code>**：<br>用于直接设置表中的值，绕过元表中的<code>__newindex</code>元方法。</li><li>**<code>rawget</code>**：<br>用于直接从表中获取值，绕过元表中的<code>__index</code>元方法。</li><li>**<code>rawequal</code>**：<br>检查两个值是否相等，不触发元表中的<code>__eq</code>元方法。</li><li>**<code>rawlen</code>**：<br>返回表的长度，不触发元表中的<code>__len</code>元方法。</li></ul><p><strong>示例：</strong><br>使用<code>__index</code>和<code>__newindex</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> mt = &#123;<br>    <span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(table, key)</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Key does not exist&quot;</span><br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-built_in">__newindex</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(table, key, value)</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;You cannot change this table&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>&#125;<br><br><span class="hljs-keyword">local</span> t = &#123;&#125;<br><span class="hljs-built_in">setmetatable</span>(t, mt)<br><br><span class="hljs-built_in">print</span>(t.someKey)  <span class="hljs-comment">-- 输出 &quot;Key does not exist&quot;</span><br>t.someKey = <span class="hljs-number">1</span>     <span class="hljs-comment">-- 输出 &quot;You cannot change this table&quot;</span><br></code></pre></td></tr></table></figure><h2 id="练习题-4-4"><a href="#练习题-4-4" class="headerlink" title="练习题 4.4"></a>练习题 4.4</h2><h3 id="题目-1：创建一个只读表"><a href="#题目-1：创建一个只读表" class="headerlink" title="题目 1：创建一个只读表"></a>题目 1：创建一个只读表</h3><p>编写一个Lua函数，该函数接收一个表，并返回一个新的表，新表是只读的，任何试图修改它的操作都会抛出错误。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createReadOnlyTable</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> readOnlyT = CreateReadOnlyTable(&#123;a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>&#125;)<br>readOnlyT.a = <span class="hljs-number">3</span>  <span class="hljs-comment">-- 应该抛出错误</span><br></code></pre></td></tr></table></figure><h3 id="题目-2：实现一个简单的向量类"><a href="#题目-2：实现一个简单的向量类" class="headerlink" title="题目 2：实现一个简单的向量类"></a>题目 2：实现一个简单的向量类</h3><p>使用表和元表来模拟一个简单的二维向量类，支持向量的加法和字符串表示。</p><blockquote><p>如果这题暂时不会，可以学完下面的表用作对象4.5.1后再来看看</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 实现向量类</span><br><span class="hljs-keyword">local</span> Vector = &#123;&#125;<br><span class="hljs-comment">-- 在这里编写代码</span><br><br><span class="hljs-keyword">local</span> v1 = Vector:new(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">local</span> v2 = Vector:new(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(v1 + v2)  <span class="hljs-comment">-- 应该输出 &quot;Vector(4, 6)&quot;</span><br><span class="hljs-built_in">print</span>(v1 - v2)  <span class="hljs-comment">-- 应该输出 &quot;Vector(-2, -2)&quot;</span><br></code></pre></td></tr></table></figure><h3 id="题目-3：自定义迭代器"><a href="#题目-3：自定义迭代器" class="headerlink" title="题目 3：自定义迭代器"></a>题目 3：自定义迭代器</h3><p>创建一个表和相应的元表，使得该表能通过自定义的迭代器进行迭代。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CreateIterableTable</span><span class="hljs-params">(t)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> itTable = CreateIterableTable(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;)<br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> itTable <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(element)  <span class="hljs-comment">-- 应该依次输出 1, 2, 3, 4, 5</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="题目-4：表的算术操作"><a href="#题目-4：表的算术操作" class="headerlink" title="题目 4：表的算术操作"></a>题目 4：表的算术操作</h3><p>编写元方法来使得两个表可以进行算术运算，如两个表的元素相加。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AddTables</span><span class="hljs-params">(t1, t2)</span></span><br>    <span class="hljs-comment">-- 在这里编写代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> t1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">local</span> t2 = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br><span class="hljs-keyword">local</span> result = AddTables(t1, t2)<br><span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(result) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(v)  <span class="hljs-comment">-- 应该依次输出 5, 7, 9</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="4-5-表用作对象"><a href="#4-5-表用作对象" class="headerlink" title="4.5 表用作对象"></a>4.5 表用作对象</h2><p>在Lua中，表也可以用作类和对象。<br>你可以在表中存储函数以及数据，从而模拟面向对象编程的功能。</p><blockquote><p>Lua本身不具有内置的类系统</p></blockquote><h3 id="4-5-1-类的实现"><a href="#4-5-1-类的实现" class="headerlink" title="4.5.1 类的实现"></a>4.5.1 类的实现</h3><p>“类”可以通过一个表来定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> MyClass = &#123;<br>    param1 = <span class="hljs-string">&#x27;a&#x27;</span>, param2 = <span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-comment">-- 定义字段并初始化(可选)</span><br>    <br>    new = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, param1, param2)</span></span><span class="hljs-comment">-- 构造函数</span><br>        <span class="hljs-keyword">local</span> instance = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, <span class="hljs-built_in">self</span>)<br>    instance.param1 = param1<br>    instance.param2 = param2<br>    <span class="hljs-keyword">return</span> instance<br><span class="hljs-keyword">end</span>,<br>    <br>    method1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><span class="hljs-comment">-- 定义方法1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">self</span>.param1)<br>    <span class="hljs-keyword">end</span>,<br>    <br>    <span class="hljs-built_in">__gc</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><span class="hljs-comment">-- 定义析构函数(可选)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;对象析构&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>&#125;MyClass.<span class="hljs-built_in">__index</span> = MyClass <span class="hljs-comment">-- 设置类的元方法__index为自己</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClass:method2</span><span class="hljs-params">()</span></span><span class="hljs-comment">-- 定义方法2</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">self</span>.param2)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClass.method3</span><span class="hljs-params">(self, param)</span></span><span class="hljs-comment">-- 定义方法3</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">self</span>.param1..<span class="hljs-built_in">self</span>.param2)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> obj = MyClass:new(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<span class="hljs-comment">-- 实例化类，产生对象</span><br><br>obj.method1(obj) <span class="hljs-comment">--输出：Hello</span><br>obj:method2()<span class="hljs-comment">--输出：World</span><br>obj:method3()<span class="hljs-comment">--输出：HelloWorld</span><br><span class="hljs-comment">--输出：对象析构</span><br></code></pre></td></tr></table></figure><p>这个案例中需要注意的点有：</p><ul><li><p><strong>字段初始化</strong>：<br>在Lua中，类的字段通常是在构造函数中进行的。<br>不过也可以在类的定义中初始化。</p></li><li><p><strong>构造函数：</strong><br>Lua本身没有给我们提供构造函数，new方法实际上是我们自己定义的，这是模拟面向对象编程中类的构造器的标准做法。</p></li><li><p><strong>__index元方法：</strong><br>将<code>MyClass.__index</code>设置为<code>MyClass</code>本身，使得当尝试访问类实例中不存在的字段或方法时，Lua会在<code>MyClass</code>表中查找。<br>正确设置<code>__index</code>元方法对于类的方法能够正确工作是至关重要的。</p></li><li><p><strong>__gc元方法：</strong><br>设置<code>__gc</code>元方法相当于实现了类的析构函数</p></li><li><p><strong>类方法的定义：</strong></p><ul><li><strong>类内部方法定义</strong>：<br><code>method1</code>在类定义的大括号内定义。<br>这种方法使类定义更紧凑，但可能会使得类定义过于庞大，特别是当方法较多时。</li><li><strong>类外部方法定义</strong>：<br><code>method2</code>和<code>method3</code>在类定义外部定义。<br>这种方式使得每个方法更加独立，但可能会分散类的定义。</li></ul></li><li><p><strong>类方法的调用：</strong></p><ul><li><p><strong>点<code>.</code>调用方式</strong>：<br>当使用点<code>.</code>调用方法时，需要显式地传递<code>self</code>参数。</p></li><li><p><strong>冒号<code>:</code>调用方式</strong>：<br>当使用冒号<code>:</code>调用方法时，Lua会自动将调用该方法的表作为<code>self</code>参数传递给该方法。</p></li><li><p><strong><code>self</code>参数</strong><br>在Lua中，<code>self</code>是一个用于面向对象风格编程的关键字。<br>它在方法定义和调用中发挥着重要作用，类似于其他编程语言（如Python的<code>self</code>或Java和C++的<code>this</code>）中的自引用。</p><p><code>self</code>允许在方法内部访问和操作对象的状态。它提供了一种直观的方式来实现对象的方法，使得Lua代码更加易于理解和维护。尽管Lua没有内置的面向对象系统，但通过使用表、元表和<code>self</code>参数，Lua可以非常灵活地模拟面向对象的行为。</p><blockquote><p>注意:<br>在Lua中，<code>self</code>不是一个保留字，而是按照惯例使用。你可以选择使用其他名字，但<code>self</code>是最常用的。</p></blockquote></li></ul></li><li><p><strong>实例化：</strong><br>使用<code>MyClass:new()</code>来创建类的实例。<br>这种方式模拟了面向对象语言中的对象创建过程。</p></li></ul><h3 id="4-5-2-静态方法与静态属性"><a href="#4-5-2-静态方法与静态属性" class="headerlink" title="4.5.2 静态方法与静态属性"></a>4.5.2 静态方法与静态属性</h3><p>想要在Lua中实现静态类，静态方法，静态属性，也都是靠用表进行模拟。</p><p>我们看一下下面的案例，就能体会到其中的奥秘：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> StaticClass = &#123;<br>    count = <span class="hljs-number">0</span>,<br>    new = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(self)</span></span><br>        <span class="hljs-keyword">local</span> instance = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, <span class="hljs-built_in">self</span>)<br>        <span class="hljs-keyword">return</span> instance<br>    <span class="hljs-keyword">end</span>,<br>    instanceMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(self)</span></span><br>        <span class="hljs-built_in">self</span>.count = <span class="hljs-built_in">self</span>.count + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br>&#125;StaticClass.<span class="hljs-built_in">__index</span> = StaticClass<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StaticClass.staticMethod</span> <span class="hljs-params">()</span></span><br>    StaticClass.count = StaticClass.count + <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span> <br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printCount</span><span class="hljs-params">(class, instance1, instance2)</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;StaticClass:&quot;</span>..class.count..<span class="hljs-string">&quot; instance1:&quot;</span>..instance1.count..<span class="hljs-string">&quot; instance2:&quot;</span>..instance2.count)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> instance1 = StaticClass:new()<br><span class="hljs-keyword">local</span> instance2 = StaticClass:new()<br>printCount(StaticClass, instance1, instance2)<br>instance1:instanceMethod()<br>printCount(StaticClass, instance1, instance2)<br>instance1.staticMethod()<br>printCount(StaticClass, instance1, instance2)<br>StaticClass.staticMethod()<br>printCount(StaticClass, instance1, instance2)<br>instance2:instanceMethod()<br>printCount(StaticClass, instance1, instance2)<br><br><span class="hljs-comment">--[[输出：</span><br><span class="hljs-comment">StaticClass:0 instance1:0 instance2:0</span><br><span class="hljs-comment">StaticClass:0 instance1:1 instance2:0</span><br><span class="hljs-comment">StaticClass:1 instance1:1 instance2:1</span><br><span class="hljs-comment">StaticClass:2 instance1:1 instance2:2</span><br><span class="hljs-comment">StaticClass:2 instance1:1 instance2:3</span><br><span class="hljs-comment">]]</span><br></code></pre></td></tr></table></figure><ol><li><code>StaticClass</code>类创建了两个实例：<code>instance1</code>与<code>instance2</code><br>此时两个实例表内并没有<code>count</code>，输出时是根据<code>__index</code>去类表中取的<code>count</code>值<br>所以三个值都为类表中的静态值，就是0</li><li>实例表<code>instance1</code>调用了实例方法<code>instanceMethod</code><br>它是用<code>self.count =</code> 在实例表<code>instance1</code>中增加了字段<code>cout</code><br>而这个<code>cout</code>值=类表<code>StaticClass</code>的<code>cout</code>值+1<br>所以此时：<ul><li>类表中的静态<code>cout</code>值还是0</li><li>实例表<code>instance1</code>内有了自己的<code>cout</code>，值是1</li><li>实例表<code>instance2</code>内仍然没有<code>cout</code>，依然是从类表取，所以也是0</li></ul></li><li>实例表<code>instance1</code>用”.”调用了方法<code>staticMethod</code>，且没有传入self参数<br>所以实际上是通过<code>__index</code>去类表中调用了<code>staticMethod</code>方法<br>这样就模拟了静态方法<br>所以此时：<ul><li>类表中的静态cout值变为1</li><li>实例表<code>instance1</code>自己的<code>cout</code>值是1</li><li>实例表<code>instance2</code>内也还没有<code>cout</code>，依然是从类表取，所以也是1</li></ul></li><li>类表<code>StaticClass</code>用“.”调用方法<code>staticMethod</code>，且没有传入self参数<br>实际执行和上一步基本一样，只是少了从<code>instance1</code>的<code>__index</code>找到<code>staticMethod</code>这一步<br>所以此时：<ul><li>类表中的静态cout值变为2</li><li>实例表<code>instance1</code>自己的<code>cout</code>值是1</li><li>实例表<code>instance2</code>内也还没有<code>cout</code>，依然是从类表取，所以也是2</li></ul></li><li>实例表<code>instance2</code>调用了实例方法<code>instanceMethod</code><br>它是用<code>self.count =</code> 在实例表<code>instance2</code>中增加了字段<code>cout</code><br>而这个<code>cout</code>值=类表<code>StaticClass</code>的<code>cout</code>值+1<br>所以此时：<ul><li>类表中的静态cout值为2</li><li>实例表<code>instance1</code>自己的<code>cout</code>值是1</li><li>实例表<code>instance2</code>内有了自己的<code>cout</code>，值是3</li></ul></li></ol><p>由上面的过程分析可知，lua用模拟的方式实现了静态方法和静态属性，但本质上还是有所差异。</p><p>需要在使用的时候小心避免出现实例和静态混淆的情况。</p><p>要在Lua中清晰地模拟静态方法和属性，最好遵循一些指导原则：</p><ol><li><p><strong>明确区分静态属性和实例属性</strong>：<br>静态属性应该定义在类表中，实例属性应该只在实例创建时(构造函数中)定义。</p></li><li><p><strong>避免在实例方法中修改静态属性</strong>：<br>实例方法应该只操作实例属性。<br>如果需要修改静态属性，应该通过显式地引用类表来操作。</p></li><li><p><strong>使用明确的方法调用方式</strong>：</p><p>静态方法只通过<code>类表.方法()</code>的方式调用。实例方法应该通过实例调用。<br>这有助于防止误操作静态属性。</p></li></ol><h3 id="4-5-3-继承与派生"><a href="#4-5-3-继承与派生" class="headerlink" title="4.5.3 继承与派生"></a>4.5.3 继承与派生</h3><p>lua的继承也是用元表来模拟实现的</p><p><strong>继承派生案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> BaseClass = &#123;<span class="hljs-comment">-- 基类定义</span><br>    new = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><span class="hljs-comment">-- 基类构造函数</span><br>    <span class="hljs-keyword">local</span> instance = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, <span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">return</span> instance<br><span class="hljs-keyword">end</span>,<br> <br>    baseMethod = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><span class="hljs-comment">-- 基类方法定义</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用基类方法&quot;</span>)<br><span class="hljs-keyword">end</span><br>&#125;BaseClass.<span class="hljs-built_in">__index</span> = BaseClass<br><br><span class="hljs-keyword">local</span> DerivedClass = &#123;<span class="hljs-comment">-- 子类定义</span><br>    new = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><span class="hljs-comment">-- 子类构造函数</span><br>        <span class="hljs-comment">-- *设置基类实例为子类的元表</span><br>    <span class="hljs-keyword">local</span> instance = <span class="hljs-built_in">setmetatable</span>(BaseClass:new(), <span class="hljs-built_in">self</span>)<br>    <span class="hljs-keyword">return</span> instance<br><span class="hljs-keyword">end</span>,<br>    <br>    baseMethod = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><span class="hljs-comment">-- 重写基类方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用派生类方法&quot;</span>)<br>        BaseClass.baseMethod()<span class="hljs-comment">-- 调用基类方法</span><br><span class="hljs-keyword">end</span>,<br>    <br>derivedMethod = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用派生类方法&quot;</span>)<br><span class="hljs-keyword">end</span><br>&#125;DerivedClass.<span class="hljs-built_in">__index</span> = DerivedClass<br><span class="hljs-comment">-- *设置子类的元表为基类模拟继承</span><br><span class="hljs-built_in">setmetatable</span>(DerivedClass, &#123;<span class="hljs-built_in">__index</span> = BaseClass&#125;)<br><br><span class="hljs-keyword">local</span> obj = DerivedClass:new()<br>obj:baseMethod()    <span class="hljs-comment">-- 输出：调用派生类方法调用基类方法</span><br>obj:derivedMethod() <span class="hljs-comment">-- 输出：调用派生类方法</span><br></code></pre></td></tr></table></figure><p>这个案例中需要注意的点有：</p><ul><li><strong>子类构造函数</strong>：<br>在子类的<code>new</code>函数中，使用了<code>BaseClass:new()</code>来创建一个基类实例，并将其元表设置为<code>DerivedClass</code>，这样子类实例既拥有基类的特性又拥有子类的特性。</li><li><strong>继承基类</strong>：<br>通过<code>setmetatable(DerivedClass, &#123;__index = BaseClass&#125;)</code>，<code>DerivedClass</code>继承了<code>BaseClass</code>。<br>这意味着当在<code>DerivedClass</code>中查找不存在的字段时，Lua会在<code>BaseClass</code>中继续查找。</li><li><strong>Base：</strong><br>在Lua中，没有像某些其他面向对象语言（如C#或Java）中那样的内置<code>base</code>或<code>super</code>关键字来直接引用父类。<br>但是，你仍然可以访问和调用基类（父类）的方法，即使在子类中有同名的方法。<br>这可以通过直接访问基类的方法实现。<br>注意：你必须使用<code>基类表.基类方法(self)</code>的方法来调用基方法</li></ul><p>通过这种方式，我们也可以用lua写出接口/抽象类，虚方法的模拟。因为原理大同小异，我们就只提供接口的模拟案例。</p><p><strong>接口模拟案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> IShape = &#123;<span class="hljs-comment">-- 接口定义</span><br>    draw = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;接口draw未实现！&quot;</span>)<br>    <span class="hljs-keyword">end</span>,<br>    area = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;接口area未实现！&quot;</span>)<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-built_in">type</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;接口type未实现！&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>&#125;IShape.<span class="hljs-built_in">__index</span> = IShape<br><br><span class="hljs-keyword">local</span> Circle = &#123;<span class="hljs-comment">-- 实现接口的子类定义</span><br>    radius = <span class="hljs-number">0</span>,<br>    new = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, radius)</span></span><br>        <span class="hljs-keyword">local</span> obj = <span class="hljs-built_in">setmetatable</span>(&#123;radius = radius&#125;, &#123;<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">self</span>&#125;)<br>        <span class="hljs-keyword">return</span> obj<br>    <span class="hljs-keyword">end</span>,<br>    draw = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- 接口的实现</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Drawing a circle.&quot;</span>)<br>    <span class="hljs-keyword">end</span>,<br>    area = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <span class="hljs-comment">-- 接口的实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">pi</span> * <span class="hljs-built_in">self</span>.radius ^ <span class="hljs-number">2</span><br>    <span class="hljs-keyword">end</span><br>&#125;Circle.<span class="hljs-built_in">__index</span> = Circle<br><span class="hljs-built_in">setmetatable</span>(Circle, &#123;<span class="hljs-built_in">__index</span> = IShape&#125;)<br><br><span class="hljs-keyword">local</span> circle = Circle:new(<span class="hljs-number">5</span>)<br>circle:draw()<br><span class="hljs-built_in">print</span>(circle:area())<br>circle:<span class="hljs-built_in">type</span>()<br></code></pre></td></tr></table></figure><p>同样的lua也可以通过模拟去实现多继承。</p><p><strong>案例如下：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> BaseClass1 = &#123;<span class="hljs-comment">--基类1定义</span><br>    new = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><br>        <span class="hljs-keyword">local</span> instance = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, <span class="hljs-built_in">self</span>)<br>        <span class="hljs-keyword">return</span> instance<br>    <span class="hljs-keyword">end</span>,<br><br>    baseMethod1 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用BaseClass1的方法&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>&#125;BaseClass1.<span class="hljs-built_in">__index</span> = BaseClass1<br><br><span class="hljs-keyword">local</span> BaseClass2 = &#123;<span class="hljs-comment">--基类2定义</span><br>    new = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><br>        <span class="hljs-keyword">local</span> instance = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, <span class="hljs-built_in">self</span>)<br>        <span class="hljs-keyword">return</span> instance<br>    <span class="hljs-keyword">end</span>,<br><br>    baseMethod2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用BaseClass2的方法&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>&#125;BaseClass2.<span class="hljs-built_in">__index</span> = BaseClass2<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MultipleInheritance</span><span class="hljs-params">(...)</span></span><br>    <span class="hljs-keyword">local</span> classes = &#123;...&#125;<br>    <span class="hljs-keyword">local</span> derived = &#123;&#125;<br>    derived.<span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(table, key)</span></span><br>        <span class="hljs-comment">-- 首先检查是否在派生类自身中定义了方法</span><br>        <span class="hljs-keyword">if</span> derived[key] <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> derived[key]<br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-comment">-- 然后检查基类中的方法</span><br>        <span class="hljs-keyword">for</span> _, class <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(classes) <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">if</span> class[key] <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span> class[key]<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> derived<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> DerivedClass = MultipleInheritance(BaseClass1, BaseClass2)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DerivedClass:new</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> instance = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, DerivedClass)<br>    <span class="hljs-keyword">return</span> instance<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DerivedClass:derivedMethod</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用DerivedClass自己的方法&quot;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> obj = DerivedClass:new()<br>obj:baseMethod1()  <span class="hljs-comment">-- 调用BaseClass1的方法</span><br>obj:baseMethod2()  <span class="hljs-comment">-- 调用BaseClass2的方法</span><br>obj:derivedMethod() <span class="hljs-comment">-- 调用DerivedClass自己的方法</span><br></code></pre></td></tr></table></figure><p>其中的私有表并不是必须的，直接将私有属性和方法散写在方法内作为局部变量也可以达成一样的闭包效果</p><h3 id="4-5-4-私有性"><a href="#4-5-4-私有性" class="headerlink" title="4.5.4 私有性"></a>4.5.4 私有性</h3><p>Lua中没有权限关键字(public,privte,protect等)。Lua的作者认为，如果不想访问一个对象的内容，那别访问就是了，比如在私有名称前加上下划线”_”，这样就能看出来是私有属性，别去访问就好。</p><p>不过如果一定想要实现私有性，是可以通过lua灵活的语言特性来模拟的。<br>私有性有很多种不同的方法可以模拟。</p><h4 id="闭包模拟"><a href="#闭包模拟" class="headerlink" title="闭包模拟"></a>闭包模拟</h4><p>私有性可以通过闭包（闭包是函数和函数所能访问的词法作用域的组合）来实现。<br>我们可以定义一个函数，这个函数内部有两个表。</p><ul><li>私有表用来存储对象的私有属性或方法。</li><li>公有表用来存储对象的公有属性或方法。</li></ul><p>最后返回共有表作为整个对象的代理或接口。<br>这样因为函数的闭包性质，私有表的内容就无法访问到了。就成功的模拟实现了私有性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyClass</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> privteTable = &#123; <span class="hljs-comment">-- 私有表</span><br>        privateVariable = <span class="hljs-string">&quot;我是私有属性&quot;</span>,<span class="hljs-comment">-- 私有属性</span><br>        privateMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span><span class="hljs-comment">-- 私有方法</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我是私有方法&quot;</span>)<br>        <span class="hljs-keyword">end</span><br>    &#125;privteTable.<span class="hljs-built_in">__index</span> = privteTable<br>    <br>    <span class="hljs-comment">-- 公开的方法和属性</span><br>    <span class="hljs-keyword">local</span> publicTable = &#123; <span class="hljs-comment">-- 公有表</span><br>        publicMethod = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><span class="hljs-comment">-- 公开方法可以访问私有成员</span><br>            <span class="hljs-built_in">print</span>(privteTable.privateVariable)<br>        <span class="hljs-keyword">end</span><br>    &#125;publicTable.<span class="hljs-built_in">__index</span> = publicTable<br>    <span class="hljs-keyword">return</span> publicTable<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> instance = MyClass()<br>instance.publicMethod()  <span class="hljs-comment">-- 输出: 我是私有属性</span><br><span class="hljs-comment">-- instance.privateVariable 在这里是不可访问的</span><br><span class="hljs-comment">-- instance.privateMethod   在这里是不可访问的</span><br></code></pre></td></tr></table></figure><p>但是使用这种方法进行私有性模拟的对象想要再实现继承派生就需要再做额外的模拟操作了。建议在不需要继承派生的对象上使用。</p><h4 id="对偶表示"><a href="#对偶表示" class="headerlink" title="对偶表示"></a>对偶表示</h4><p>对偶表示的原理是：<br>把一个对象的私有属性和方法都存储到一个表中，然后再把这个表当作值，这个对象当作键，存储到一个类外的表中。</p><p><strong>案例如下：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> privateInfos = &#123;&#125;<span class="hljs-comment">-- 外部表存储私有数据</span><br>PersonInfo = &#123;<br>    new = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(self, name, age)</span></span><br>        <span class="hljs-keyword">local</span> instance = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, <span class="hljs-built_in">self</span>)<br>        instance.name = name<span class="hljs-comment">-- name是公有字段</span><br>        <span class="hljs-keyword">local</span> privateInfo = &#123;age = age&#125;<span class="hljs-comment">-- age是私有字段，存储到外部表</span><br>        privateInfos[instance] = privateInfo<br>        <span class="hljs-keyword">return</span> instance<br>    <span class="hljs-keyword">end</span>,<br>    getAge = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(self)</span></span><span class="hljs-comment">-- 通过公有方法来获取私有属性</span><br>        <span class="hljs-keyword">return</span> privateInfos[<span class="hljs-built_in">self</span>].age<br>    <span class="hljs-keyword">end</span><br>&#125;PersonInfo.<span class="hljs-built_in">__index</span> = PersonInfo<br><br><span class="hljs-keyword">local</span> tom = PersonInfo:new(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">17</span>)<br><span class="hljs-built_in">print</span>(tom.name)<br><span class="hljs-built_in">print</span>(tom:getAge())<br></code></pre></td></tr></table></figure><p>这样做，并不能真正防止其他代码直接访问或修改这些数据。这种方法确实提供了一定程度的封装，因为它防止了直接通过对象实例访问或修改私有数据，但这并不是真正的私有性，因为外部表本身仍然是全局可访问的。</p><blockquote><p>而且必须注意的是：<br>一旦我们将实例作为外部私有数据存储表的键，那么它的GC将无法自动生效。<br>因此需要注意内存管理，特别是在删除实例时，也应从 外部私有数据存储表中移除相应的条目以避免内存泄露。</p></blockquote><h3 id="练习题-4-5"><a href="#练习题-4-5" class="headerlink" title="练习题 4.5"></a>练习题 4.5</h3><p>创建一个lua文件，并在该文件中编写代码以满足以下要求：</p><ol><li><strong>定义一个简单的类和实例</strong><br>定义一个名为Car的类，它有两个属性：make（制造商）和year（年份）。还要定义一个名为new的方法来创建新实例，并初始化这些属性。</li><li><strong>实现一个实例方法</strong><br>给Car类添加一个名为getAge的方法，该方法返回车辆的年龄。假设当前年份为2023。</li><li><strong>静态属性和静态方法</strong><br>为Car类添加一个静态属性totalCars，用于跟踪创建的车辆总数。同时添加一个静态方法getTotalCars，返回创建的车辆总数。</li><li><strong>继承</strong><br>创建一个ElectricCar类，它继承自Car类，并添加一个额外的属性batterySize。</li><li><strong>多态性</strong><br>为ElectricCar类重写getAge方法，使其在返回年龄的同时还输出一条消息表明这是一辆电动车。</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 你的代码</span><br><br><span class="hljs-comment">-- 测试代码</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;题目1&quot;</span>)<br><span class="hljs-keyword">local</span> myCar = Car:new(<span class="hljs-string">&quot;Toyota&quot;</span>, <span class="hljs-number">2020</span>)<br><span class="hljs-built_in">print</span>(myCar.make)  <span class="hljs-comment">-- 应输出 &quot;Toyota&quot;</span><br><span class="hljs-built_in">print</span>(myCar.year)  <span class="hljs-comment">-- 应输出 2020</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;题目2&quot;</span>)<br><span class="hljs-built_in">print</span>(myCar:getAge())  <span class="hljs-comment">-- 应输出 3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;题目3&quot;</span>)<br><span class="hljs-keyword">local</span> car1 = Car:new(<span class="hljs-string">&quot;Toyota&quot;</span>, <span class="hljs-number">2020</span>)<br><span class="hljs-keyword">local</span> car2 = Car:new(<span class="hljs-string">&quot;Honda&quot;</span>, <span class="hljs-number">2018</span>)<br><span class="hljs-built_in">print</span>(Car.getTotalCars())  <span class="hljs-comment">-- 应输出创建的车辆总数:3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;题目4&quot;</span>)<br><span class="hljs-keyword">local</span> myElectricCar = ElectricCar:new(<span class="hljs-string">&quot;Tesla&quot;</span>, <span class="hljs-number">2022</span>, <span class="hljs-number">75</span>)<br><span class="hljs-built_in">print</span>(myElectricCar.make)  <span class="hljs-comment">-- 应输出 &quot;Tesla&quot;</span><br><span class="hljs-built_in">print</span>(myElectricCar.batterySize)  <span class="hljs-comment">-- 应输出 75</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;题目5&quot;</span>)<br><span class="hljs-built_in">print</span>(myElectricCar:getAge())  <span class="hljs-comment">-- 应输出年龄和一条关于电动车的消息</span><br></code></pre></td></tr></table></figure><h1 id="5-代码组织-环境，模块，包"><a href="#5-代码组织-环境，模块，包" class="headerlink" title="5. 代码组织(环境，模块，包)"></a>5. 代码组织(环境，模块，包)</h1><p>我们接下来学习Lua中的环境、模块和包。<br>这是Lua编程中非常重要的一部分，它关系到如何组织和结构化大型应用程序。</p><h2 id="5-1-环境"><a href="#5-1-环境" class="headerlink" title="5.1 环境"></a>5.1 环境</h2><p>在Lua中，环境（Environment）是一个非常重要的概念，它涉及到变量的作用域和存储。Lua使用环境来保存变量和函数，这对于编写模块化和可重用的代码非常重要。</p><p><strong>环境的具体作用：</strong></p><ul><li><strong>作用域管理</strong>：<br>Lua中的每个函数都有自己的环境，用于保存该函数中定义的局部变量。</li><li><strong>全局环境</strong>：<br>Lua脚本开始执行时，有一个默认的全局环境，所有全局变量都存储在这里。</li><li><strong>避免冲突</strong>：<br>通过使用不同的环境，可以避免变量名冲突，特别是在大型项目或多模块程序中。</li></ul><h3 id="5-1-1-全局环境-G"><a href="#5-1-1-全局环境-G" class="headerlink" title="5.1.1 全局环境(_G)"></a>5.1.1 全局环境(_G)</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>从语法层面讲，Lua只要是不带local关键字的变量，就是全局变量。但实际上，lua并没有真正意义上的全局变量，它仍然是在用表来模拟实现全局变量。</p><ul><li>真的全局变量：<br>当你声明了一个全局变量后，它在编译时就会存储在一个全局作用域中。<br>无论是声明前的代码，还是声明后的代码都应该可以访问的到。</li><li>Lua用表模拟的全局变量：<br>将你声明的全局变量存在一个特殊的表中。<br>你可以动态地添加、修改或删除全局变量。<br>而在你声明全局变量前的代码中是无法访问到这个全局变量的<br>(因为它根本还没放进那个特殊的表中！)</li></ul><p>Lua将所谓的“全局变量”保存在一个称为全局环境(global environment)的普通表中。<br>这个表是叫<code>_G</code>。<code>_G</code>是一个特殊的表，在Lua程序启动时，<code>_G</code>被自动创建，它本质上是全局环境的一个表示。</p><p>当你定义一个不带<code>local</code>关键字的变量时，这个变量就会成为<code>_G</code>表的一个成员。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p><strong>访问全局变量</strong>：<br>你可以通过<code>_G[变量名]</code>的方式来访问全局变量。<br>当然调用声明过的全局变量时可以省略_G而直接使用全局变量名调用。<br>这种方式主要是为了调用<strong>具有动态名称的全局变量</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 动态生成变量名</span><br><span class="hljs-keyword">local</span> varName = <span class="hljs-string">&quot;globalVar&quot;</span><br><span class="hljs-comment">-- 使用_G来设置全局变量</span><br><span class="hljs-built_in">_G</span>[varName] = <span class="hljs-string">&quot;这是一个动态创建的全局变量&quot;</span><br><span class="hljs-comment">-- 使用相同的方式访问这个全局变量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">_G</span>[varName])  <span class="hljs-comment">-- 输出: 这是一个动态创建的全局变量</span><br></code></pre></td></tr></table></figure></li><li><p><strong>避免污染</strong>：<br><code>_G</code>的存在可以帮助你识别和避免全局变量污染。<br>在复杂的应用中，不小心创建了意料之外的全局变量是很常见的问题。<br>我们可以通过设置<code>_G</code>表的元表来禁止定义或访问尚不存在的全局变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">setmetatable</span>(<span class="hljs-built_in">_G</span>, &#123;<br>    <span class="hljs-built_in">__newindex</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_, n)</span></span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;试图定义未知的全局变量 &quot;</span> .. n, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">end</span>,<br>    <span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_, n)</span></span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;试图访问未定义的全局变量 &quot;</span> .. n, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">end</span>,<br>&#125;)<br><br><span class="hljs-built_in">rawset</span>(<span class="hljs-built_in">_G</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">-- 使用rawset绕过元表定义新全局变量</span><br><span class="hljs-built_in">print</span>(A)<span class="hljs-comment">-- 输出：1</span><br>A = <span class="hljs-number">10</span> <br><span class="hljs-built_in">print</span>(A)<span class="hljs-comment">-- 输出：10</span><br>B = <span class="hljs-number">20</span> <span class="hljs-comment">-- 报错：试图定义未知的全局变量</span><br></code></pre></td></tr></table></figure><p>这种操作叫做<strong>严格模式</strong></p></li><li><p><strong>枚举全局变量</strong>：<br>你可以遍历<code>_G</code>来查看程序中定义的所有全局变量。<br>这对于调试和代码审查特别有用。<br>例如如下代码就是直接通过访问_G表来获取全部的全局变量，并打印出来：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs lua">A = <span class="hljs-number">1</span><br>B = <span class="hljs-number">2</span><br>C = <span class="hljs-string">&quot;C等于3&quot;</span><br><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">_G</span>) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(n..<span class="hljs-string">&quot;:&quot;</span>..<span class="hljs-built_in">tostring</span>(<span class="hljs-built_in">_G</span>[n]))<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">--[[</span><br><span class="hljs-comment">以下为输出结果：</span><br><span class="hljs-comment">table:table: 0000000000f39b10</span><br><span class="hljs-comment">_G:table: 0000000000f36c30</span><br><span class="hljs-comment">rawlen:function: 0000000065b9cea0</span><br><span class="hljs-comment">assert:function: 0000000065b9d980</span><br><span class="hljs-comment">collectgarbage:function: 0000000065b9d330</span><br><span class="hljs-comment">arg:table: 0000000000f3a050</span><br><span class="hljs-comment">dofile:function: 0000000065b9d900</span><br><span class="hljs-comment">utf8:table: 0000000000f39c50</span><br><span class="hljs-comment">_VERSION:Lua 5.4</span><br><span class="hljs-comment">rawset:function: 0000000065b9cdf0</span><br><span class="hljs-comment">loadfile:function: 0000000065b9d830</span><br><span class="hljs-comment">load:function: 0000000065b9d730</span><br><span class="hljs-comment">B:2</span><br><span class="hljs-comment">A:1</span><br><span class="hljs-comment">setmetatable:function: 0000000065b9d560</span><br><span class="hljs-comment">rawget:function: 0000000065b9ce50</span><br><span class="hljs-comment">io:table: 0000000000f3a090</span><br><span class="hljs-comment">debug:table: 0000000000f39cd0</span><br><span class="hljs-comment">package:table: 0000000000f38570</span><br><span class="hljs-comment">pcall:function: 0000000065b9ca70</span><br><span class="hljs-comment">select:function: 0000000065b9cb20</span><br><span class="hljs-comment">rawequal:function: 0000000065b9cf00</span><br><span class="hljs-comment">warn:function: 0000000065b9cf50</span><br><span class="hljs-comment">math:table: 0000000000f39bd0</span><br><span class="hljs-comment">tonumber:function: 0000000065b9cbc0</span><br><span class="hljs-comment">print:function: 0000000065b9cff0</span><br><span class="hljs-comment">ipairs:function: 0000000065b9d0e0</span><br><span class="hljs-comment">os:table: 0000000000f39c90</span><br><span class="hljs-comment">error:function: 0000000065b9d2b0</span><br><span class="hljs-comment">require:function: 0000000000f384f0</span><br><span class="hljs-comment">C:C等于3</span><br><span class="hljs-comment">pairs:function: 0000000065b9d610</span><br><span class="hljs-comment">xpcall:function: 0000000065b9c970</span><br><span class="hljs-comment">next:function: 0000000065b9d130</span><br><span class="hljs-comment">getmetatable:function: 0000000065b9d8a0</span><br><span class="hljs-comment">type:function: 0000000065b9ca10</span><br><span class="hljs-comment">string:table: 0000000000f3a010</span><br><span class="hljs-comment">tostring:function: 0000000065b9caf0</span><br><span class="hljs-comment">coroutine:table: 0000000000f39800</span><br><span class="hljs-comment">]]</span><br></code></pre></td></tr></table></figure><p>你会发现，输出的结果除了有我们定义的全局变量A,B,C外，还有很多Lua自身的方法和表，这些都是全局环境的一部分。</p></li></ul><h3 id="5-1-2-局部环境-ENV"><a href="#5-1-2-局部环境-ENV" class="headerlink" title="5.1.2 局部环境(_ENV)"></a>5.1.2 局部环境(_ENV)</h3><p><code>_ENV</code>是Lua 5.2及以上版本引入的一个新概念。<br>它代表了当前代码块的环境。每个函数都有自己的<code>_ENV</code>，用于查找和存储变量。<br>通过改变<code>_ENV</code>，你可以更改函数的环境，使其访问不同的变量集合。</p><p>在Lua 5.2及以上版本中，<code>_ENV</code>取代了旧版本中的<code>setfenv</code>和<code>getfenv</code>功能。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li><p><code>_ENV</code>本质上仍然是一个表。<br>它默认指向全局环境<code>_G</code>，所以它最初包含所有全局变量。<br>但是，<code>_ENV</code>本身是可以更改的，可以指向任何表。</p></li><li><p>编译器会在编译所有代码前，在外层给每个函数创建局部变量<code>_ENV</code><br>通常在函数定义时就确定，除非显式修改它。</p></li><li><p>所有在函数内的自由名称</p><blockquote><p>(就是未在局部环境中声明的变量<code>var x</code>，实际上就是函数外部定义的全局变量)</p></blockquote><p> 会被编译器自动设置为<code>_ENV.自由名称</code><br> 其实就是从<code>_ENV</code>表指向<code>_G</code>表从而去全局变量中寻找了</p></li><li><p><strong><code>_ENV</code>遵循通常的定界规则</strong><br>我们可以根据这个特性，让多个函数共享一个公共环境。<br>或是在一个函数内创造多个局部环境</p><ul><li><p><strong>函数作用域</strong>：<br>在Lua中定义的每个函数都有自己的作用域。<br><code>_ENV</code>作为当前环境的引用，也受到这些作用域规则的约束。<br>这意味着在一个函数内部改变<code>_ENV</code>只影响该函数及其内部定义的函数。</p><p>比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">_ENV</span> = &#123; <span class="hljs-built_in">print</span> = <span class="hljs-built_in">print</span> &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)  <span class="hljs-comment">-- 正常输出</span><br><span class="hljs-keyword">end</span><br>test()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)  <span class="hljs-comment">-- 出错，因为全局环境的print在test函数外不可访问</span><br></code></pre></td></tr></table></figure><p>这里，函数<code>test</code>内部的<code>_ENV</code>被修改，仅在函数内有效。<br>一旦离开函数，<code>_ENV</code>的改变不会影响外部环境。</p></li><li><p><strong>代码块作用域</strong>：<br>Lua中的局部变量（使用<code>local</code>关键字定义的变量）在它们被定义的那个代码块中有效。<br>同样，如果在一个代码块中设置了<code>_ENV</code>（作为局部变量），它只会影响该代码块。</p><blockquote><p>例如各种循环语句的代码块中</p></blockquote><p>比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">2</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">_ENV</span> = &#123; <span class="hljs-built_in">print</span> = <span class="hljs-built_in">print</span> &#125;<br>    <span class="hljs-built_in">print</span>(i)  <span class="hljs-comment">-- 正常输出</span><br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done&quot;</span>)  <span class="hljs-comment">-- 出错，因为全局环境的print在循环外不可访问</span><br></code></pre></td></tr></table></figure><p>在这个循环内，<code>_ENV</code>被修改了，但这种修改只在循环内部有效。</p></li><li><p>**全局和局部<code>_ENV</code>**：<br>如果<code>_ENV</code>被定义为全局变量（没有使用<code>local</code>关键字），它会影响所有没有自己局部<code>_ENV</code>的代码。<br>如果在函数或代码块中用<code>local _ENV = ...</code>定义了<code>_ENV</code>，那么这个新的环境只影响当前作用域。<br>比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">local</span> <span class="hljs-built_in">_ENV</span> = &#123;<span class="hljs-built_in">_G</span> = <span class="hljs-built_in">_G</span>&#125;<br>    <span class="hljs-built_in">print</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(s)</span></span> <span class="hljs-built_in">_G</span>.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Modified:&quot;</span>, s) <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)  <span class="hljs-comment">-- 输出 &quot;Modified: Hello&quot;</span><br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello&quot;</span>)  <span class="hljs-comment">-- 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>在这个代码块内，<code>_ENV</code>被局部化和修改，影响仅限于这个代码块。</p></li></ul></li></ul><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul><li><p><strong>控制代码禁止使用全局变量</strong><br>因为<code>_ENV</code>默认是指向<code>_G</code>的，如果我们将它设为nil，则后续局部环境中就无法再直接访问全局变量了。<br>案例如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">A = <span class="hljs-number">10</span> <span class="hljs-comment">-- 声明全局变量A</span><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">print</span> = <span class="hljs-built_in">print</span> <span class="hljs-comment">-- 声明局部变量print函数=_G中的print函数</span><br><span class="hljs-built_in">_ENV</span> = <span class="hljs-literal">nil</span> <span class="hljs-comment">-- 设置局部环境指向nil</span><br><span class="hljs-built_in">print</span>(A) <span class="hljs-comment">-- 此时的print是局部变量，A无法访问，会报错</span><br></code></pre></td></tr></table></figure></li><li><p><strong>绕过局部声明的变量</strong></p><p>和_G一样，可以直接获取全局变量<br>案例如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">A = <span class="hljs-number">10</span><br><span class="hljs-keyword">local</span> A = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">_ENV</span>.A) <span class="hljs-comment">-- 输出：10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">_G</span>.A) <span class="hljs-comment">-- 输出：10</span><br><span class="hljs-built_in">print</span>(A) <span class="hljs-comment">-- 输出：20</span><br></code></pre></td></tr></table></figure></li><li><p><strong>建立新环境实现沙盒(重点)</strong><br>通过设置不同的<code>_ENV</code>，可以为不同的函数或代码块创建隔离的环境，这对于执行安全的脚本和模块化编程非常有用。<br>有两种方法可以实现沙盒：</p><ul><li><p><code>_ENV</code>等于包含<code>_G</code>的新表<br>实现方法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> newEnv = &#123;<span class="hljs-built_in">_G</span> = <span class="hljs-built_in">_G</span>&#125;<br><span class="hljs-built_in">_ENV</span> = newEnv<br></code></pre></td></tr></table></figure><p>这种方法的特点是：</p><ul><li>提供了对全局环境的直接访问。</li><li>可以通过<code>_ENV._G</code>访问和修改全局环境。</li><li>更改<code>_ENV._G</code>中的内容实际上会改变全局环境<code>_G</code>。</li></ul></li><li><p>继承了<code>_G</code>的新表<br>实现方法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> newEnv = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="hljs-built_in">__index</span> = <span class="hljs-built_in">_G</span>&#125;)<br><span class="hljs-built_in">_ENV</span> = newEnv<br></code></pre></td></tr></table></figure><p>这种方法的特点是：</p><ul><li>任何在新环境中未定义的变量都会通过<code>__index</code>元方法回退到全局环境<code>_G</code>。</li><li>更改新环境中的变量不会影响<code>_G</code>中的相应变量。</li></ul></li></ul><p>在比较这两种方法时，首先要考虑的是您对沙盒环境的需求：<br>如果需要完全隔离的环境，第二种方法（继承<code>_G</code>）更合适。<br>如果需要在沙盒环境中保留对原始全局环境的修改能力，第一种方法（包含<code>_G</code>的新表）可能更适合。</p></li></ul><h2 id="5-2-模块"><a href="#5-2-模块" class="headerlink" title="5.2 模块"></a>5.2 模块</h2><p>在Lua中，模块是一种将代码组织成独立单元的方式。<br>模块通常包含函数、变量和其他Lua结构，可在其他Lua脚本中重复使用。</p><p><strong>模块的作用：</strong></p><ul><li><strong>代码重用</strong>：模块化编程允许重复使用代码，减少重复工作。</li><li><strong>命名空间管理</strong>：模块帮助避免命名冲突，因为每个模块有自己的命名空间。</li></ul><p>模块是Lua中实现代码封装和重用的重要机制，有助于创建结构清晰、易于维护的代码库。</p><p>直白的来讲，一个模块就是一些代码，这些代码可以通过函数require加载，然后创建并返回一个表。这个表就像是某种命名空间，其中定义的内容是模块中导出的东西，比如函数和常量。</p><h3 id="5-2-1-创建模块"><a href="#5-2-1-创建模块" class="headerlink" title="5.2.1 创建模块"></a>5.2.1 创建模块</h3><p>创建模块有两种方法：</p><p><strong>方法一:</strong></p><ol><li><strong>创建一个表</strong>：<br>表将作为模块的主体，包含模块的所有功能。</li><li><strong>添加功能</strong>：<br>向这个表中添加函数、变量等。</li><li><strong>返回这个表</strong>：<br>最后，使用<code>return</code>语句返回这个表，使其成为模块的导出。</li></ol><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 文件名mymodule.lua</span><br><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.add</span><span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">return</span> a + b<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M.subtract</span><span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">return</span> a - b<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p><strong>方法二:</strong></p><ol><li><strong>定义功能：</strong><br>把所有的函数和属性都定义为局部变量</li><li><strong>构建表并返回：</strong><br>创建一个表，将前面的功能全部装入此表中，然后返回此表</li></ol><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 文件名anothermodule.lua</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">return</span> a + b<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subtract</span><span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">return</span> a - b<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> M = &#123;<br>    add = add,<br>    subtract = subtract<br>&#125;<br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p>这两种方法纯粹写法不一样，其他基本上都相同。<br>第二种写法可以让模块内的变量名称和模块外使用时的名称不一致，但除非特殊需求，否则还是保持一致比较好。</p><p>你还可以结合我们之前5.1环境的相关内容来编写模块，比如说禁止模块内更改全局变量，在模块内创建新局部环境制造沙盒等功能。</p><h3 id="5-2-2-使用模块"><a href="#5-2-2-使用模块" class="headerlink" title="5.2.2 使用模块"></a>5.2.2 使用模块</h3><h4 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h4><p>在其他Lua脚本中，你可以使用<code>require</code>函数来加载并使用模块。</p><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> myModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;myModule&quot;</span>)<br>myModule.myFunction()<br></code></pre></td></tr></table></figure><p><strong>原理如下：</strong></p><p>当调用<code>require</code>函数时</p><ol><li>首先在表<code>package.loaded</code>中检查模块是否已被加载。<ul><li>若模块已被加载过：<br>不会运行任何新代码，返回之前已经加载的同一个值。 </li></ul></li><li>搜索具有<code>package.path</code>指定模块名的lua文件<ul><li>若找不到lua文件：<br>搜索具有<code>package.cpath</code>指定的相应名称的C标准库<br>找到后由<code>package.loadlib</code>加载并返回结果<ul><li>若再找不到就报错</li></ul></li></ul></li><li>找到对应lua文件后，用函数<code>loadfile</code>将其加载，返回一个加载器<code>loader</code>作为结果</li><li>将加载结果返回，并保存在<code>package.loaded</code>中</li></ol><p><code>require</code> 函数根据 <code>package.path</code> 和 <code>package.cpath</code> 变量来确定加载模块和包的路径。这些路径不是固定的，而是取决于系统上的 Lua 配置。<br>通常，这些路径会包括：</p><ul><li>Lua 安装目录</li><li>当前工作目录</li><li>以及其他一些标准位置。</li></ul><p>可以在 Lua 脚本中运行时修改这些路径。<br>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">package</span>.<span class="hljs-built_in">path</span> = <span class="hljs-built_in">package</span>.<span class="hljs-built_in">path</span> .. <span class="hljs-string">&quot;;/你的模块路径/?.lua&quot;</span><br><span class="hljs-built_in">package</span>.<span class="hljs-built_in">cpath</span> = <span class="hljs-built_in">package</span>.<span class="hljs-built_in">cpath</span> .. <span class="hljs-string">&quot;;/你的C模块路径/?.so&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>;</code>是目标路径的分隔符<br>可以增加多个目标路径按顺序寻找。</li><li><code>?.lua</code> 和 <code>?.so</code> 是占位符<br>Lua 在搜索文件时会将模块名替换到这些位置。</li></ul><p>通过调整这些变量，可以自定义 Lua 在 <code>require</code> 函数被调用时查找模块的位置。</p><blockquote><p>模块在任何情况下只加载一次，如何处理冲突的加载，取决于模块本身，详见下面的init文件介绍</p></blockquote><h4 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h4><p>Lua中没有直接卸载模块的内置功能。但可以通过从<code>package.loaded</code>表中移除对应模块的引用来间接实现。</p><p>例如，要卸载一个名为<code>myModule</code>的模块，可以这样做：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">package</span>.<span class="hljs-built_in">loaded</span>[<span class="hljs-string">&quot;myModule&quot;</span>] = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><h3 id="5-2-3-子模块与包"><a href="#5-2-3-子模块与包" class="headerlink" title="5.2.3 子模块与包"></a>5.2.3 子模块与包</h3><p>模块，子模块，包这三个概念都是Lua用来细分代码功能，清晰代码结构的。<br>他们分别从物理和抽象两方面做到了这点：</p><h4 id="模块，子模块，包，子包的概念"><a href="#模块，子模块，包，子包的概念" class="headerlink" title="模块，子模块，包，子包的概念"></a>模块，子模块，包，子包的概念</h4><h5 id="物理方面"><a href="#物理方面" class="headerlink" title="物理方面"></a>物理方面</h5><ul><li>包，就是文件夹</li><li>模块，就是lua代码文件</li><li>包的子模块，就是某个文件夹下的所有lua代码文件</li><li>包的子包，就是文件夹中的文件夹</li><li>模块的子模块，在物理层面上没有意义</li></ul><h5 id="抽象方面"><a href="#抽象方面" class="headerlink" title="抽象方面"></a>抽象方面</h5><p>Lua支持具有层次结构的模块名，通过.来分割名称中的层次。例如：mod.sub。<br>无论你物理层面要怎么组织lua代码文件和文件夹，最终在代码抽象层面都会变成命名空间的层级关系。</p><p><strong>命名空间层级关系：</strong></p><ol><li><strong>顶级命名空间</strong>：<br>Lua的全局环境（<code>_G</code>）可以被看作是最顶级的命名空间，所有全局变量和函数都属于这个命名空间。</li><li><strong>包</strong>：<br>每个包构成一个独立的命名空间。包内的模块通常通过包的名称来访问，这有助于避免不同包之间的命名冲突。</li><li><strong>模块</strong>：<br>每个模块文件也创建了一个命名空间。模块内定义的函数、表和其他变量只在该模块内可见，除非它们被显式地导出。</li><li><strong>子模块/子包</strong>：<br>在包内部，可以有更细粒度的命名空间划分，如子模块或子包。这些子命名空间进一步组织和封装了代码，有助于维护大型项目。</li></ol><p><strong>这样做的作用有：</strong></p><ul><li><strong>避免冲突</strong>：<br>通过命名空间，相同名称的变量或函数可以在不同的模块中独立存在，避免相互干扰。</li><li><strong>代码组织</strong>：<br>清晰的命名空间结构使代码更加模块化，便于理解和维护。</li><li><strong>重用性和封装</strong>：<br>良好的命名空间设计提高了代码的重用性和封装性，有助于构建可维护和可扩展的应用程序。</li></ul><h4 id="init-lua文件"><a href="#init-lua文件" class="headerlink" title="init.lua文件"></a>init.lua文件</h4><p>从Lua语言的视角来看，同一个包的子模块没有显示的关联。<br>加载一个模块并不会自动加载它的任何子模块。<br>同样的，加载一个子模块也不会自动的加载它的付模块。<br>如果想实现自动加载和处理依赖关系，需要我们自己在包中实现。<br>一般可以在包中的init.lua实现</p><p>当你使用<code>require</code>加载一个包（文件夹）而不是一个单独的Lua文件时，Lua会默认寻找该文件夹中的<code>init.lua</code>文件作为入口点。</p><p>它通常用于初始化包，设置包内所需的各种条件，比如加载包内的模块、设置包级别的变量、执行初始化代码等。</p><p>假设有一个包结构如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">mylib/<br>├── init.<span class="hljs-keyword">lua</span><br>├── moduleA.<span class="hljs-keyword">lua</span><br>└── moduleB.<span class="hljs-keyword">lua</span><br></code></pre></td></tr></table></figure><p>当你执行<code>require(&quot;mylib&quot;)</code>时，Lua实际上会加载并执行<code>mylib</code>目录下的<code>init.lua</code>文件。</p><p>假设<code>mylib</code>的<code>init.lua</code>文件如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> M = &#123;&#125;<br><br>M.moduleA = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mylib.moduleA&quot;</span>)<br>M.moduleB = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mylib.moduleB&quot;</span>)<br><br><span class="hljs-keyword">return</span> M<br></code></pre></td></tr></table></figure><p>这个<code>init.lua</code>文件加载了同一文件夹下的其他模块，并将它们放入了一个表中返回。当你在其他地方使用<code>require(&quot;mylib&quot;)</code>时，你实际上得到的是这个表，它包含对<code>moduleA</code>和<code>moduleB</code>的引用。</p><p><code>init.lua</code>文件在Lua的包结构中起着核心作用，它使得包的使用更加方便和直观。通过使用<code>init.lua</code>，你可以将一个包作为一个单一的单位来加载和管理，而不是单独处理包中的每个模块。</p><h4 id="文件组织结构案例"><a href="#文件组织结构案例" class="headerlink" title="文件组织结构案例"></a>文件组织结构案例</h4><p>让我们通过一个具体的案例来展示：</p><ul><li>包、子包、模块和子模块的物理层面组织</li><li>它们在Lua中如何被<code>require</code>调用</li><li>它们在命名空间层面的结果。</li></ul><p>假设我们有以下的文件结构：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">codemylib/<br>├── init.<span class="hljs-keyword">lua</span><br>├── moduleA.<span class="hljs-keyword">lua</span><br>└── subpackage/<br>    ├── init.<span class="hljs-keyword">lua</span><br>    └── moduleB.<span class="hljs-keyword">lua</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>mylib</code></strong> 是一个包。</li><li><strong><code>moduleA.lua</code></strong> 是<code>mylib</code>包的一个模块。</li><li><strong><code>subpackage</code></strong> 是<code>mylib</code>的一个子包。</li><li><strong><code>moduleB.lua</code></strong> 是<code>subpackage</code>的一个模块。</li></ul><p><strong>使用require加载：</strong></p><ul><li>要加载<code>mylib</code>包<br>可以使用<code>require(&quot;mylib&quot;)</code>。<br>这将执行<code>mylib</code>文件夹中的<code>init.lua</code>文件。</li><li>要加载<code>mylib</code>中的<code>moduleA</code>模块<br>可以使用<code>require(&quot;mylib.moduleA&quot;)</code>。</li><li>要加载<code>subpackage</code>中的<code>moduleB</code>模块<br>可以使用<code>require(&quot;mylib.subpackage.moduleB&quot;)</code>。</li></ul><p><strong>命名空间的结果：</strong></p><ul><li><strong><code>mylib</code></strong><br>在命名空间中代表包的顶层。</li><li><strong><code>moduleA</code></strong><br>成为<code>mylib</code>命名空间的一部分，可以通过<code>mylib.moduleA</code>访问其中的内容（假设<code>moduleA</code>返回了一个表）。</li><li><strong><code>subpackage</code></strong><br>本身也是一个命名空间，属于<code>mylib</code>的子命名空间。</li><li><strong><code>moduleB</code></strong><br>在<code>mylib.subpackage</code>命名空间下，可以通过<code>mylib.subpackage.moduleB</code>访问其中的内容（同样假设<code>moduleB</code>返回了一个表）。</li></ul><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><p>写一个包，里面包含栈，链表，队列，哈希表，树，堆等模块。需要写的标准，有独立运行沙盒，并且通用。</p><h1 id="6-文件IO"><a href="#6-文件IO" class="headerlink" title="6. 文件IO"></a>6. 文件IO</h1><p>Lua的IO操作主要分为两种模式：简单模式和完整模式。</p><h2 id="6-1-简单模式"><a href="#6-1-简单模式" class="headerlink" title="6.1 简单模式"></a>6.1 简单模式</h2><p>在 Lua 中，简单模式（Simple I/O）是处理文件和标准输入输出的一种方便方式。<br>它适合于简单的输入输出需求，尤其是小型脚本或命令行程序。</p><p><strong>模式特点：</strong></p><ul><li>不需要显式打开和关闭文件，Lua 自动处理。</li><li>默认情况下，标准输入和输出分别关联到系统的标准输入（通常是键盘）和标准输出（通常是终端或屏幕）。</li></ul><p><strong>使用场景：</strong></p><ul><li>适用于简单的文本读写操作。</li><li>当需要快速从控制台输入读取或向控制台输出写入时。</li></ul><p><strong>相关方法：</strong></p><ul><li><p><strong>io.input</strong><br>设置或获取当前输入文件<br>参数：可选，文件名或文件句柄<br><code>io.input(&#39;example.txt&#39;)</code></p><ul><li><strong>io.input():close()</strong><br>关闭当前输入文件<br><code>io.input():close()</code> </li></ul></li><li><p><strong>io.output</strong><br>设置或获取当前输出文件<br>参数：可选，文件名或文件句柄<br><code>io.output(&#39;output.txt&#39;)</code></p><ul><li><strong>io.output():close()</strong><br>关闭当前输出文件<br><code>io.output():close()</code></li></ul></li><li><p><strong>io.write</strong><br>控制台输出或文件写入数据<br>参数：需要写入的字符串<br><code>io.write(&quot;Hello, world\n&quot;)</code></p></li><li><p><strong>io.read</strong><br>控制台输入或文件读取数据<br><code>local line = io.read(&quot;l&quot;)</code><br>参数：读取模式</p><ul><li><code>&quot;a&quot;</code>：<br>从当前位置读取整个文件。</li><li><code>&quot;l&quot;</code>：<br>读取下一行。这是默认参数，如果没有指定参数，<code>io.read()</code> 将采用这种方式。返回的字符串不包括换行符。</li><li><code>&quot;L&quot;</code>：<br>类似于 <code>l</code>，但是包括换行符在内的完整行。</li><li><code>&quot;n&quot;</code>：<br>读取一个数字并返回它。如果读取失败，返回 nil。</li><li>数字：<br>读取指定数量的字符。例如，<code>io.read(5)</code> 将读取五个字符。</li></ul></li><li><p><strong>io.lines</strong><br>以迭代的方式逐行读取文件<br>参数：文件名称<br>非常适用于处理大文件或逐行处理文件内容的场景。<br>每次迭代都读取文件的下一行，直到文件结束。<br>这种方法的优点是简洁和易于处理大文件，因为它不会一次性将整个文件内容加载到内存中。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">lines</span>(<span class="hljs-string">&quot;example.txt&quot;</span>) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(line)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p><strong>print</strong><br>向控制台打印数据<br>参数：需要打印的值<br><code>print(&quot;Hello, world&quot;)</code></p></li></ul><p>其中print和io.write的区别是：</p><ul><li><strong>格式化：</strong><ul><li><code>print</code> 自动在其参数之间添加空格，并在输出的末尾添加换行符。</li><li> <code>io.write</code> 则不添加任何额外的字符，完全按照提供的参数输出。</li></ul></li><li><strong>参数类型：</strong><ul><li><code>print</code> 可以接受任何类型的参数，并会调用 <code>tostring</code> 函数将其转换为字符串。</li><li><code>io.write</code> 只能接受字符串或数值类型的参数。</li></ul></li><li><strong>输出目标：</strong><ul><li><code>print</code> 默认输出到标准输出，通常是控制台或终端。</li><li><code>io.write</code> 则输出到当前的输出文件，这可以是通过 <code>io.output</code> 设置的任何文件，如果没有特别设置，则默认也是标准输出。</li></ul></li></ul><blockquote><p>应该只在代码的调试部分使用print！<br>需要正式使用且完全控制输出时，应该使用io.write！</p></blockquote><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 设置输入文件</span><br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;input.txt&quot;</span>)<br><br><span class="hljs-comment">-- 设置输出文件</span><br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">output</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)<br><br><span class="hljs-comment">-- 读取输入文件的第一行</span><br><span class="hljs-keyword">local</span> line = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()<br><br><span class="hljs-comment">-- 向输出文件写入这一行</span><br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;从 input.txt 读取的内容：&quot;</span>, line, <span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment">-- 向标准输出（通常是终端或控制台）打印一条消息</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已将内容写入 output.txt 文件。&quot;</span>)<br><br><span class="hljs-comment">-- 关闭输入和输出文件</span><br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>():<span class="hljs-built_in">close</span>()<br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">output</span>():<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><p><strong>总的来说：</strong><br><code>io.read</code>与<code>io.write</code>更适用于文件操作，而<code>print</code>更适用于简单的标准输出。<br>当设置了<code>io.input</code>和<code>io.output</code>后，<code>io.read</code>和<code>io.write</code>将操作指定的文件，而不是控制台的输入输出。</p><p>简单模式提供了一种快捷的方式来进行基本的输入输出操作，但在需要更精细控制文件操作时，应考虑使用完整模式（Complete I/O）。</p><h2 id="6-2-完整模式"><a href="#6-2-完整模式" class="headerlink" title="6.2 完整模式"></a>6.2 完整模式</h2><p>在 Lua 中，完整模式（Complete I/O）提供了对文件输入输出操作的完整控制。<br>完整模式适合于需要精确控制文件读写操作的场景，特别是处理较大的数据时。它也允许你同时操作多个文件。<br>与简单模式相比，完整模式允许你打开特定的文件进行读写，并且在操作完成后关闭文件。</p><h3 id="6-2-1-基本用法"><a href="#6-2-1-基本用法" class="headerlink" title="6.2.1 基本用法"></a>6.2.1 基本用法</h3><ol><li><p><strong>打开文件</strong>：<br>使用 <code>io.open</code> 打开文件。<br>它接受两个参数：文件名，模式。<br>打开模式如下:</p><ul><li><code>&quot;r&quot;</code>：以只读方式打开文件。文件必须存在。</li><li><code>&quot;w&quot;</code>：以写入方式打开文件，用于创建新文件或覆盖现有文件。</li><li><code>&quot;a&quot;</code>：以追加方式打开文件，写入的数据将添加到文件末尾。如果文件不存在，将创建一个新文件。</li><li><code>&quot;r+&quot;</code>：以读写方式打开一个现有文件。</li><li><code>&quot;w+&quot;</code>：以读写方式打开文件，用于创建新文件或覆盖现有文件。</li><li><code>&quot;a+&quot;</code>：以读写方式打开文件，写入的数据将添加到文件末尾。如果文件不存在，将创建一个新文件。</li><li><code>&quot;b&quot;</code>：在模式字符串的末尾添加（如<code>&quot;rb&quot;</code>、<code>&quot;wb&quot;</code>或<code>&quot;ab&quot;</code>），用于以二进制模式打开文件。在某些系统中，这与文本模式可能无区别。</li></ul><p>本函数有两个返回值：文件句柄和错误信息。</p><ul><li>如果成功，您将得到一个文件句柄用于后续的读写操作</li><li>如果失败，文件句柄将为<code>nil</code>，并且可以获取一个描述错误原因的字符串。</li></ul></li><li><p><strong>错误处理</strong>：<br>在打开文件时要检查错误。<code>io.open</code> 在失败时返回 nil 和错误信息。</p></li><li><p><strong>读取文件</strong>：<br>使用 <code>file:read</code> 方法进行读取。<br>它的参数与 <code>io.read</code> 相似，如 <code>&quot;a&quot;</code>（读取全部内容）、<code>&quot;l&quot;</code>（读取一行）等。<br>例如，<code>file:read(&quot;a&quot;)</code> 读取整个文件。</p></li><li><p><strong>写入文件</strong>：<br>使用 <code>file:write</code> 方法写入。<br>你可以传递任意数量的参数，它们会被顺序写入。<br>例如，<code>file:write(&quot;Hello World\n&quot;)</code> 会写入字符串。</p></li><li><p><strong>文件位置</strong>：<br>可以使用 <code>file:seek</code> 方法移动文件读写位置。</p></li><li><p><strong>缓冲</strong>：<br>默认情况下，输出是缓冲的。<br>可以使用 <code>io.flush</code> 来刷新输出缓冲区。</p></li><li><p><strong>关闭文件</strong>：<br>使用 <code>file:close</code> 方法关闭文件。这个步骤很重要，以确保所有数据都正确保存并释放文件资源。</p></li></ol><p><strong>案例如下：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 打开文件进行读取</span><br><span class="hljs-keyword">local</span> file, err = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> file <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;无法打开文件: &quot;</span> .. err)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 读取文件内容</span><br><span class="hljs-keyword">local</span> content = file:<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*a&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件内容：&quot;</span>, content)<br><br><span class="hljs-comment">-- 关闭文件</span><br>file:<span class="hljs-built_in">close</span>()<br><br><span class="hljs-comment">-- 打开文件进行写入</span><br>file, err = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> file <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;无法打开文件: &quot;</span> .. err)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 写入数据到文件</span><br>file:<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;处理后的内容\n&quot;</span>)<br>file:<span class="hljs-built_in">write</span>(content)<br><br><span class="hljs-comment">-- 刷新缓冲区并关闭文件</span><br>file:<span class="hljs-built_in">flush</span>()<br>file:<span class="hljs-built_in">close</span>()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已将内容写入 output.txt&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="6-2-2-模式混用与流缓存"><a href="#6-2-2-模式混用与流缓存" class="headerlink" title="6.2.2 模式混用与流缓存"></a>6.2.2 模式混用与流缓存</h3><p>函数<code>io.input</code>与<code>io.output</code>允许混合使用简单与完整两种I/O模式。</p><ul><li>调用无参的<code>io.input</code>与<code>io.output</code>可以获得当前的输入输出流(无论是什么模式的)</li><li>调用有参的<code>io.input(流)</code>与<code>io.output(流)</code>可以设置当前的输入输出流(无论是什么模式的)</li></ul><p>所以也可以缓存多个流来回调换。</p><p><strong>代码如下：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 打开两个文件：一个用于读取，一个用于写入</span><br><span class="hljs-keyword">local</span> readFile = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">local</span> writeFile = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br><br><span class="hljs-comment">-- 缓存当前标准输入输出流</span><br><span class="hljs-keyword">local</span> defaultInput = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>()<br><span class="hljs-keyword">local</span> defaultOutput = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">output</span>()<br><br><span class="hljs-comment">-- 切换标准输入到 readFile</span><br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>(readFile)<br><br><span class="hljs-comment">-- 从 readFile 读取内容并打印到标准输出</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*a&quot;</span>))<br><br><span class="hljs-comment">-- 切换标准输出到 writeFile</span><br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">output</span>(writeFile)<br><br><span class="hljs-comment">-- 写入内容到 writeFile</span><br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;这是写入到 output.txt 的内容。\n&quot;</span>)<br><br><span class="hljs-comment">-- 恢复标准输入输出流</span><br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">input</span>(defaultInput)<br><span class="hljs-built_in">io</span>.<span class="hljs-built_in">output</span>(defaultOutput)<br><br><span class="hljs-comment">-- 关闭打开的文件</span><br>readFile:<span class="hljs-built_in">close</span>()<br>writeFile:<span class="hljs-built_in">close</span>()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;操作完成，已恢复标准输入输出流。&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="6-3-其他文件操作"><a href="#6-3-其他文件操作" class="headerlink" title="6.3 其他文件操作"></a>6.3 其他文件操作</h2><ul><li><p><strong><code>file:seek([whence[, offset]])</code>**：<br>**作用</strong>：移动文件读写指针到指定位置。<br><strong>参数：</strong><br><code>whence</code>：基准位置（”set”，”cur”，”end”）。<br><code>offset</code>：相对于基准位置的偏移量。</p><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)<br>file:seek(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-number">-10</span>)  <span class="hljs-comment">-- 移动到文件末尾前的 10 个字节</span><br><span class="hljs-built_in">print</span>(file:<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*a&quot;</span>))<br>file:<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure></li><li><p><strong><code>io.tmpfile()</code>**：<br>**作用：</strong>创建一个临时文件，用于读写操作。文件在程序结束或关闭时自动删除。<br><strong>无参数</strong><br><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> tmp = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">tmpfile</span>()<br>tmp:<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;临时数据&quot;</span>)<br>tmp:seek(<span class="hljs-string">&quot;set&quot;</span>)<br><span class="hljs-built_in">print</span>(tmp:<span class="hljs-built_in">read</span>(<span class="hljs-string">&quot;*a&quot;</span>))  <span class="hljs-comment">-- 读取写入的内容</span><br>tmp:<span class="hljs-built_in">close</span>()           <span class="hljs-comment">-- 关闭临时文件，文件被自动删除</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>file:flush()</code>**：<br>**作用</strong>：立即将文件的输出缓冲区内容写入磁盘，而不等待自动刷新。<br><strong>无参数</strong><br><strong>案例：</strong></p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br>file:<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;一些数据&quot;</span>)<br>file:<span class="hljs-built_in">flush</span>()  <span class="hljs-comment">-- 确保数据写入磁盘</span><br>file:<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure></li><li><p><strong><code>file:setvbuf(mode, size)</code>**：<br>**作用</strong>：设置文件的缓冲模式。<br><strong>参数：</strong><br><code>mode</code>：缓冲模式（”no”，”full”，或 “line”）。<br><code>size</code>：缓冲区大小（可选）。</p><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> file = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)<br>file:setvbuf(<span class="hljs-string">&quot;full&quot;</span>, <span class="hljs-number">1024</span>)  <span class="hljs-comment">-- 设置为全缓冲，缓冲区大小 1024 字节</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>os.rename(oldname, newname)</code>**：<br>**作用</strong>：重命名文件或目录。<br><strong>参数：</strong><br><code>oldname</code>：原文件或目录名。<br><code>newname</code>：新文件或目录名。</p><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>.<span class="hljs-built_in">rename</span>(<span class="hljs-string">&quot;oldfile.txt&quot;</span>, <span class="hljs-string">&quot;newfile.txt&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong><code>os.remove(filename)</code>**：<br>**作用</strong>：删除指定的文件。<br><strong>参数：</strong><code>filename</code>：要删除的文件名。<br><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>.<span class="hljs-built_in">remove</span>(<span class="hljs-string">&quot;unnecessaryfile.txt&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="6-4-其他系统调用"><a href="#6-4-其他系统调用" class="headerlink" title="6.4 其他系统调用"></a>6.4 其他系统调用</h2></li><li><p><strong><code>os.exit([code[, close]])</code>**：<br>**作用</strong>：终止程序运行。<br><strong>参数：</strong><br><code>code</code>：退出码（可选），默认为零表示成功。<br><code>close</code>：布尔值，确定是否关闭 Lua 虚拟机。<br><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>.<span class="hljs-built_in">exit</span>()       <span class="hljs-comment">-- 正常退出</span><br><span class="hljs-built_in">os</span>.<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>)      <span class="hljs-comment">-- 错误退出</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>os.getenv(varname)</code>**：<br>**作用</strong>：获取环境变量的值。<br><strong>参数：</strong><code>varname</code>：环境变量名。<br><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-built_in">path</span> = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;PATH&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">path</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong><code>os.execute(command)</code>**：<br>**作用</strong>：运行一个系统命令。<br><strong>参数：</strong><code>command</code>：要执行的命令字符串。<br><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">os</span>.<span class="hljs-built_in">execute</span>(<span class="hljs-string">&quot;ls -l&quot;</span>)  <span class="hljs-comment">-- 在 Unix/Linux 上列出当前目录</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>io.popen(command[, mode])</code>**：<br>**作用</strong>：开启一个进程并连接到其标准输入或输出。<br><strong>参数：</strong><br><code>command</code>：要执行的命令。<br><code>mode</code>：连接类型（”r” 读或 “w” 写）。<br><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> p = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">popen</span>(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>)  <span class="hljs-comment">-- 在 Unix/Linux 上读取目录内容</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> p:<span class="hljs-built_in">lines</span>() <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(line)<br><span class="hljs-keyword">end</span><br>p:<span class="hljs-built_in">close</span>()<br></code></pre></td></tr></table></figure><h2 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h2></li></ul><p>编写一个Lua脚本来执行以下任务：</p><ol><li><strong>读取文件</strong>：<br>从一个名为<code>example.txt</code>的文件中读取内容。</li><li><strong>内容处理</strong>：<br>对读取的每一行内容执行以下操作：<ul><li>将每行的内容转换为大写。</li><li>在每行的前面添加行号，格式为<code>Line [行号]: </code>。<br>例如，第一行应该被修改为<code>Line 1: [内容]</code>。</li></ul></li><li><strong>写入处理后的内容</strong>：<br>将处理后的每一行内容写入到一个新的文件<code>processed_output.txt</code>中。</li><li><strong>复制文件内容</strong>：<br>将<code>example.txt</code>文件的原始内容复制到一个新文件<code>copy_of_example.txt</code>中。</li></ol><blockquote><p><code>example.txt</code>原文您随便编吧</p></blockquote><h1 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a>7. 错误处理</h1><h2 id="7-1-报错"><a href="#7-1-报错" class="headerlink" title="7.1 报错"></a>7.1 报错</h2><p>在Lua中，<code>error</code>函数和<code>assert</code>方法是两种常用的报错机制。<br>它们用于不同的场景并具有不同的工作原理。</p><p>这两个函数都是错误处理的关键部分，它们使您能够在发现问题时立即中断程序的执行，并提供有关问题的信息。它们在Lua编程中非常有用，尤其是在处理不可恢复的错误或无效的输入时。</p><p>下面详细解释这两个函数的用法和原理。</p><h3 id="7-1-1-error函数"><a href="#7-1-1-error函数" class="headerlink" title="7.1.1 error函数"></a>7.1.1 error函数</h3><p><code>error(message [, level])</code></p><p><strong>参数：</strong></p><ul><li><code>message</code>：错误信息，通常是字符串。</li><li><code>level</code>：可选参数，用于确定错误信息中提供的堆栈跟踪的级别。<br>是一个整数，用于确定错误信息中提供的堆栈跟踪的起始点。<br>这个数字决定了栈回溯从哪一层函数调用开始。<ul><li>级别 1 表示在 error 被调用的地方（默认级别）</li><li>级别 2 表示在调用 error 函数的函数中，依此类推。</li></ul></li></ul><p><strong>返回值：</strong><br>当调用<code>error</code>函数时，程序不会继续到<code>error</code>调用之后的代码。<br>因此，<code>error</code>函数本身并不返回任何值。</p><p><strong>原理：</strong></p><ol><li><code>error</code>函数抛出一个Lua错误，终止当前函数的执行。</li><li>错误被抛出后，Lua会尝试查找最近的错误处理函数<br>（通常是<code>pcall</code>或<code>xpcall</code>中定义的，后续会在错误处理中介绍）。</li><li>如果没有找到错误处理函数，程序将终止，并显示错误信息。</li></ol><p><strong>使用场景：</strong></p><ul><li>当您的代码在某些条件下需要主动抛出错误时，使用<code>error</code>。</li><li>通常用于检测和报告函数的非法参数或其他不期望的情况。</li></ul><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;除数不能为0&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> a / b<br><span class="hljs-keyword">end</span><br>divide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment">-- 将触发错误</span><br></code></pre></td></tr></table></figure><h3 id="7-1-2-assert函数"><a href="#7-1-2-assert函数" class="headerlink" title="7.1.2 assert函数"></a>7.1.2 assert函数</h3><p><code>assert(v [, message])</code></p><p><strong>参数：</strong></p><ul><li><code>v</code>：要检测的表达式或值。</li><li><code>message</code>：可选参数，如果<code>v</code>为假，则显示的错误信息。</li></ul><p><strong>返回值：</strong></p><ul><li>如果条件为真，<code>assert</code>函数返回所有传入的参数。</li><li>如果条件为假，则<code>assert</code>会调用<code>error</code>，抛出一个错误。不会有返回值。</li></ul><p><strong>原理：</strong></p><ol><li><code>assert</code>函数首先检查第一个参数<code>v</code>是否为真（即非nil且非false）。<ol><li>如果<code>v</code>为真，<code>assert</code>返回所有传入的参数。</li><li>如果<code>v</code>为假，<code>assert</code>使用<code>error</code>函数抛出错误，错误信息为第二个参数<code>message</code>，如果未提供<code>message</code>，则有一个默认错误信息。</li></ol></li><li>类似于<code>error</code>，如果错误未被捕获，程序将终止。</li></ol><p><strong>使用场景：</strong></p><ul><li>用于条件检查，确保程序运行期间的某个条件为真。</li><li>常用于参数检查或在重要条件不满足时快速失败。</li></ul><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addPositiveNumbers</span><span class="hljs-params">(a, b)</span></span><br>    <span class="hljs-built_in">assert</span>(a &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;两个参数都必须是正数&quot;</span>)<br>    <span class="hljs-keyword">return</span> a + b<br><span class="hljs-keyword">end</span><br>addPositiveNumbers(<span class="hljs-number">5</span>, <span class="hljs-number">-1</span>)  <span class="hljs-comment">-- 将触发错误</span><br></code></pre></td></tr></table></figure><p><strong>二者区别：</strong></p><p><code>error</code>：</p><ul><li>直接抛出一个错误。</li><li>可以自定义错误信息，并且可以选择性地指定堆栈跟踪的级别。</li><li>这通常用于表示一种异常情况，如程序内部逻辑错误，或者当代码达到一个不应该到达的状态时。</li><li>它更关注于代码内部的异常状态。</li></ul><p><code>assert</code>：</p><ul><li>用于断言一个条件为真。如果条件为假，则抛出错误。</li><li>通常只需要一个错误消息。</li><li>这通常用于验证函数的输入参数或确保程序运行期间某些条件得到满足。</li><li>它更多用于输入验证和预期条件的检查。</li></ul><h2 id="7-2-错误处理"><a href="#7-2-错误处理" class="headerlink" title="7.2 错误处理"></a>7.2 错误处理</h2><p>在Lua中，错误处理和异常处理主要通过<code>pcall</code>和<code>xpcall</code>两个函数实现。<br>这些函数提供了一种处理运行时错误的方式，允许程序捕获和处理异常，而不是直接崩溃。</p><p>下面详细解释这两个函数。</p><h3 id="7-2-1-pcall-Protected-Call"><a href="#7-2-1-pcall-Protected-Call" class="headerlink" title="7.2.1 pcall(Protected Call)"></a>7.2.1 pcall(Protected Call)</h3><p><code>pcall(function, arg1, arg2, ...)</code></p><p><strong>参数：</strong></p><ul><li>要调用的函数</li><li>该函数的参数(数量可变)</li></ul><p><strong>返回值：</strong></p><ol><li><p>布尔值</p><ul><li><p>无错误：返回true</p></li><li><p>有错误：返回false</p></li></ul></li><li><p>后续返回值</p><ul><li><p>无错误：被调函数的所有返回值</p></li><li><p>有错误：错误信息(是一个对象)</p></li></ul></li></ol><p><strong>原理:</strong><br><code>pcall</code>会以一种保护模式执行一个函数(参数1)，并在执行过程中捕获发生的任何错误。<br>这意味着如果被调用的函数中发生了错误（例如，通过<code>error</code>函数抛出），<code>pcall</code>可以防止错误导致整个程序崩溃。</p><blockquote><p>类似于其他语言的try catch，但pacll只try了并返回结果告诉你有没有错，并没有catch。</p></blockquote><p><strong>适用场景：</strong><br>当你想安全地调用一个可能会出错的函数时使用<code>pcall</code>，尤其是在错误可能导致程序中断的情况下。</p><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mightFail</span><span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;Negative value not allowed&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sqrt</span>(x)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">status</span>, result = <span class="hljs-built_in">pcall</span>(mightFail, <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">status</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Result:&quot;</span>, result)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error:&quot;</span>, result)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="7-2-2-xpcall-eXtended-Protected-Call"><a href="#7-2-2-xpcall-eXtended-Protected-Call" class="headerlink" title="7.2.2 xpcall(eXtended Protected Call)"></a>7.2.2 <code>xpcall</code>(eXtended Protected Call)</h3><p><code>xpcall(function, errorHandler, arg1, arg2, ...)</code></p><p><strong>参数：</strong></p><ul><li>被调用的函数</li><li>一个错误处理函数</li><li>被调用函数的参数(数量可变)</li></ul><p><strong>返回值：</strong></p><ol><li>布尔值<br>与<code>pcall</code>一样。<ul><li>没错误：返回<code>true</code>；</li><li>有错误：返回<code>false</code>。</li></ul></li><li>后续返回值<ul><li>没错误：返回被调用函数的所有返回值。</li><li>有错误：返回错误处理函数的返回值。</li></ul></li></ol><p><strong>原理：</strong><br><code>xpcall</code>与<code>pcall</code>类似，但它允许你指定一个错误处理函数，这个函数会在发生错误时调用。</p><blockquote><p>完全类似于其他语言的try catch。被调用函数就是try的内容，错误处理函数就是catch的内容。</p></blockquote><p><strong>适用场景：</strong></p><p>当你需要更详细的错误信息或自定义错误处理逻辑时，使用<code>xpcall</code>。<br>错误处理函数可以用于记录错误、清理资源或以其他方式响应错误。</p><p><strong>案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mightFail</span><span class="hljs-params">(x)</span></span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;Negative value not allowed&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">sqrt</span>(x)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorHandler</span><span class="hljs-params">(err)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Something went wrong: &quot;</span> .. err<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">status</span>, result = <span class="hljs-built_in">xpcall</span>(mightFail, errorHandler, <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">status</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Result:&quot;</span>, result)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error:&quot;</span>, result)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="7-3-自定义错误信息与栈回溯"><a href="#7-3-自定义错误信息与栈回溯" class="headerlink" title="7.3 自定义错误信息与栈回溯"></a>7.3 自定义错误信息与栈回溯</h2><p>在Lua中，错误信息和栈回溯（stack traceback）是调试和错误处理的关键组成部分。当Lua代码发生错误时，理解错误信息和如何获取栈回溯信息对于快速定位和解决问题至关重要。</p><p><strong>错误信息：</strong></p><p>在Lua中，当代码运行出错时，Lua运行时会生成一个错误信息的对象。<br>错误信息通常包含错误的描述，有时还包括发生错误的位置信息。</p><p>可以使用<code>error</code>或<code>assert</code>函数可以生成自定义错误信息。<br>把自定义的错误信息当做参数传给这俩函数就可以。</p><p>错误信息通常是字符串，描述了发生的错误。<br>也可以是任何类型的值（如表、数字等）。不过在实际应用中，使用字符串作为错误对象更为常见，因为它们能提供易于理解的错误描述。</p><p><strong>栈回溯：</strong></p><p>在错误信息中可以增加栈回溯。<br>栈回溯提供了错误发生时的函数调用序列，帮助开发者理解错误发生的上下文。它特别有用于定位错误发生的位置和原因。</p><p>可以使用<code>xpcall</code>函数和<code>debug</code>库中的函数来进行栈回溯信息的报错。</p><p><strong>案例如下：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">riskyFunction</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">-- 可能出错的代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myErrorHandler</span><span class="hljs-params">(err)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error occurred: &quot;</span> .. err .. <span class="hljs-string">&quot;\n&quot;</span> .. <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">traceback</span>()<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-built_in">status</span>, result = <span class="hljs-built_in">xpcall</span>(riskyFunction, myErrorHandler)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">status</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(result)  <span class="hljs-comment">-- 打印错误信息和栈回溯</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在这个例子中，如果<code>riskyFunction</code>发生错误，<code>xpcall</code>会调用<code>myErrorHandler</code>，后者生成包含错误信息和栈回溯的字符串。这样可以更容易地定位和理解错误的原因。</p><h2 id="7-4-调试库函数"><a href="#7-4-调试库函数" class="headerlink" title="7.4 调试库函数"></a>7.4 调试库函数</h2><p>Lua的调试库提供了一系列功能强大的工具，用于调试和检查Lua代码的运行时状态。</p><p>调试库的常用函数有：</p><ul><li><p><strong><code>debug.debug</code></strong><br><strong>参数：</strong>无参数无返回值<br><strong>作用：</strong>该函数提供了一个简单的交互式调试环境。<br>当调用这个函数时，Lua会暂停执行当前程序，并提供一个命令行界面，允许你检查和修改变量，甚至可以调用函数。直到你输入一个空行，这时Lua会退出调试环境并继续执行原来的程序。</p></li><li><p><strong><code>debug.traceback</code></strong><br><strong>参数：</strong></p><ul><li><p><code>message</code>（可选）：<br>一个初始错误消息。如果提供，它将被附加在栈回溯信息的开头。</p></li><li><p><code>level</code>（可选）：<br>一个数字，用于指定从哪一层调用栈开始生成栈回溯信息。<br>默认值是<code>1</code>，表示当前函数的调用者。</p></li></ul><p><strong>返回值：</strong>返回一个字符串，包含了从指定的栈层开始到栈底的所有函数调用信息。<br><strong>作用：</strong>该函数用于生成当前线程的栈回溯。<br>它提供了从当前函数到栈底的所有函数调用信息，这对于理解程序在某一时刻的执行流程非常有用。</p></li><li><p><strong><code>debug.getinfo</code></strong><br><strong>参数：</strong></p><ul><li><code>function</code>或<code>level</code>：指定要查询的函数或堆栈层级。</li><li><code>what</code>（可选）：一个字符串，指定要返回的信息类别。<ul><li><code>&quot;n&quot;</code>: 返回函数名。</li><li><code>&quot;S&quot;</code>: 返回函数定义的源文件名。</li><li><code>&quot;l&quot;</code>: 返回函数定义的行号。</li><li><code>&quot;u&quot;</code>: 返回函数的上值（upvalue）数量。</li><li><code>&quot;f&quot;</code>: 返回函数本身。</li><li><code>&quot;L&quot;</code>: 返回函数活动的行号表。</li><li><code>&quot;&gt;&quot;</code>: 仅对 C 函数有效，不返回函数的源文件名和行号信息。</li></ul></li></ul><p><strong>返回值</strong>：一个包含了所请求信息的表。<br><strong>功能</strong>：获取关于一个特定函数的信息。用于检查函数的详细信息，包括源文件、定义的行号、是否是Lua函数等。</p></li><li><p><strong><code>debug.getlocal</code></strong><br><strong>参数：</strong></p><ul><li><code>level</code>：堆栈层级。</li><li><code>local</code>：局部变量的索引。</li></ul><p><strong>返回值</strong>：变量的名称和值。<br><strong>功能</strong>：获取一个函数的局部变量的名称和值。<br>可以用来检查特定函数调用中的局部变量。</p></li><li><p><strong><code>debug.setlocal</code></strong><br><strong>参数</strong>：与<code>debug.getlocal</code>相同。<br><strong>返回值</strong>：被设置的变量的名称，如果无法设置则为<code>nil</code>。<br><strong>功能</strong>：设置一个函数的局部变量的值。</p></li><li><p><strong><code>debug.getupvalue</code></strong> 和 <strong><code>debug.setupvalue</code></strong><br><strong>参数：</strong></p><ul><li><code>func</code>：函数。</li><li><code>up</code>：上值的索引。</li></ul><p><strong>返回值</strong>：<code>getupvalue</code>返回上值的名称和值，<code>setupvalue</code>返回被设置的上值的名称。<br><strong>功能</strong>：<code>getupvalue</code>用于获取一个闭包的上值（upvalue），<code>setupvalue</code>用于设置这些值。</p></li><li><p><strong><code>debug.getmetatable</code></strong> 和 <strong><code>debug.setmetatable</code></strong><br><strong>参数</strong>：<code>object</code>（要获取或设置元表的对象）。<br><strong>返回值</strong>：<code>getmetatable</code>返回元表，<code>setmetatable</code>返回对象。<br><strong>功能</strong>：<code>getmetatable</code>用于获取一个对象的元表，<code>setmetatable</code>用于设置对象的元表。</p></li><li><p><strong><code>debug.getregistry</code></strong><br><strong>返回值</strong>：Lua注册表。<br><strong>功能</strong>：获取Lua的注册表。<br>注册表是一个全局表，用来保存所有用C注册到Lua的对象。</p></li><li><p><strong><code>debug.getuservalue</code></strong> 和 <strong><code>debug.setuservalue</code></strong><br><strong>参数</strong>：用户数据对象。<br><strong>返回值</strong>：<code>getuservalue</code>返回附加值，<code>setuservalue</code>返回用户数据对象。<br><strong>功能</strong>：用于获取或设置用户数据（userdata）的附加值。</p></li></ul><blockquote><p>注意：<br><code>debug</code>库的使用可能会降低代码的可移植性和性能它更多用于开发和调试阶段，而不是生产环境！</p></blockquote><h2 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h2><p>创建一个Lua脚本，执行以下任务：</p><ol><li><strong>定义函数</strong>：<br>编写一个函数<code>safeDivision(numerator, denominator)</code>，该函数接受两个参数：分子<code>numerator</code>和分母<code>denominator</code>。</li><li><strong>错误检查：</strong><ul><li>如果分母为零，则使用<code>error</code>函数抛出错误。</li><li>使用<code>assert</code>来断言结果不是无限大。</li></ul></li><li><strong>错误处理：</strong><ul><li>使用<code>xpcall</code>调用<code>safeDivision</code>，并在调用中故意传递一个零作为分母来触发错误。</li><li>为<code>xpcall</code>提供一个自定义错误处理函数，该函数生成并返回包含错误信息和栈回溯的字符串。</li></ul></li><li><strong>调试信息：</strong><br>在<code>safeDivision</code>函数内，使用<code>debug.getinfo</code>报告函数被调用时的当前行号和所在的文件。</li><li><strong>变量探查：</strong><br>在<code>safeDivision</code>内部，使用<code>debug.getlocal</code>获取并打印所有局部变量的名称和值。</li></ol><h1 id="8-协同程序"><a href="#8-协同程序" class="headerlink" title="8. 协同程序"></a>8. 协同程序</h1><p>协程并不是Lua独有的概念，其他很多语言也都支持协程(C#，Java等)。所以关于协程的概念和定义我们在这里不过多赘述，可以找别的资料去学习。</p><p>Lua中的协程是一种非常强大的特性，它允许你编写出非阻塞、协作式多任务的代码。</p><p>在Lua中，协程是通过<code>coroutine</code>库来实现的。所有相关的函数都被放在表<code>coroutine</code>中。</p><p><strong>应用场景：</strong></p><ol><li><strong>非阻塞IO操作</strong>：<br>在需要执行长时间运行的IO操作时，例如文件读写或网络操作，协程允许这些操作在不阻塞整个程序的情况下执行。</li><li><strong>游戏开发</strong>：<br>在游戏编程中，协程可以用来编写复杂的游戏逻辑，如角色行为或动画，而不影响游戏的主循环。</li><li><strong>协作式多任务</strong>：<br>当需要多个任务交替执行时，协程提供了一种实现方式，每个任务可以主动挂起和恢复，避免了传统并发编程中的复杂性。</li><li><strong>复杂流程控制</strong>：<br>在需要管理复杂的工作流程时，协程可以使得逻辑控制更加清晰。</li></ol><h2 id="8-1-创建协程"><a href="#8-1-创建协程" class="headerlink" title="8.1 创建协程"></a>8.1 创建协程</h2><p>在Lua中，可以通过以下两种方式创建协程：</p><ol><li><p><strong>使用 <code>coroutine.create</code></strong><br><strong>功能</strong>：创建一个新的协程，但不立即启动它。<br><strong>参数</strong>：接受一个Lua函数。<br><strong>返回值</strong>：返回一个协程对象(thread)。<br><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br>    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, Coroutine!&quot;</span>) <br>    <span class="hljs-keyword">end</span><br>)<br></code></pre></td></tr></table></figure></li><li><p><strong>使用 <code>coroutine.wrap</code></strong><br><strong>功能</strong>：<br>同样创建一个新的协程，但返回一个函数而不是协程对象。<br>当调用这个函数时，传入的参数会作为协程的参数，并且协程会被启动或恢复执行。<br><strong>参数</strong>：接受一个Lua函数。<br><strong>返回值</strong>：返回一个函数，用于启动或恢复协程。<br><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">wrap</span>(<br><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, Coroutine!&quot;</span>) <br><span class="hljs-keyword">end</span><br>)<br>co()  <span class="hljs-comment">-- 启动协程</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>二者区别：</strong></p><ul><li><strong>返回类型</strong>：<ul><li><code>coroutine.create</code> 返回一个协程对象</li><li> <code>coroutine.wrap</code> 返回一个函数。</li></ul></li><li><strong>错误处理</strong>：<ul><li><code>coroutine.create</code> 需要配合 <code>coroutine.resume</code> 使用，可以显式处理错误。</li><li> <code>coroutine.wrap</code> 在内部处理了错误，如果协程内部发生错误，它会抛出错误。</li></ul></li><li><strong>使用便利性</strong>：<br><code>coroutine.wrap</code> 提供了一种更为简洁的协程使用方式，不需要显式调用<code>coroutine.resume</code>。</li></ul><blockquote><p>注意：<br>虽然warp比create简化了操作，但也降低了灵活性。<br>通过warp创建的协程无法进行状态检查与异常处理。</p></blockquote><h2 id="8-2-协程控制"><a href="#8-2-协程控制" class="headerlink" title="8.2 协程控制"></a>8.2 协程控制</h2><p>协程一旦创建，可以通过以下函数来控制其执行：</p><ul><li><p><strong><code>coroutine.resume</code></strong><br><strong>功能：</strong>用于启动或继续一个协程的执行。<br>会切换到指定的协程上下文，开始或继续执行该协程的代码。<br>如果协程之前被<code>yield</code>挂起，则从<code>yield</code>的位置继续执行。<br><strong>参数：</strong></p><ul><li>目标协程对象：<br>第一个参数是一个由<code>coroutine.create</code>创建的协程。</li><li>传递给协程的参数：<br>在启动协程时，这些参数将被传递给协程的主体函数。</li></ul><p><strong>返回值：</strong></p><ul><li><p>第一个返回值：布尔值<br>表示协程是否成功切换（<code>true</code>表示成功，<code>false</code>表示有错误发生）。</p></li><li><p>后续返回值：</p><ul><li>如果协程内部执行了<code>yield</code>，则这些返回值是<code>yield</code>传递出来的。</li><li>如果协程运行到结束，则是协程函数的返回值。</li><li>如果发生错误，则返回错误信息</li></ul></li></ul><p>(与之前错误处理部分的pcall相同，resume也是运行在保护模式中的)</p><p><strong>案例：</strong></p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br>   <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span></span><br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co&quot;</span>, a, b)<br>   <span class="hljs-keyword">local</span> r = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>(a + b, a - b)<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co&quot;</span>, r)<br>   <span class="hljs-keyword">return</span> a * b<br>   <span class="hljs-keyword">end</span><br>)<br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment">-- 启动协程</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>coroutine.yield</code></strong><br><strong>功能：</strong><br>用于挂起（暂停）当前协程的执行，并将控制权交还给<code>coroutine.resume</code>的调用者<br><strong>参数：</strong><br>可变参数：这些参数将被传递给<code>resume</code>的调用者。<br><strong>返回值：</strong><br>由下一次<code>coroutine.resume</code>调用提供的参数决定。<br><strong>案例：</strong></p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br><span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span><br>   <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, x <span class="hljs-keyword">do</span><br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co&quot;</span>, i)<br>       <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>()<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-keyword">end</span><br>)<br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co, <span class="hljs-number">3</span>)  <span class="hljs-comment">-- 第一次执行</span><br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)     <span class="hljs-comment">-- 第二次执行，继续从yield处执行</span><br></code></pre></td></tr></table></figure><p>  在这个案例中，协程每次通过<code>yield</code>挂起，然后由外部的<code>resume</code>调用继续执行。<br>这种方式可以用于控制协程的执行节奏，或者在等待某个事件时暂停协程。</p></li></ul><blockquote><p>协程是支持嵌套的。<br>可以由一个协程去调用另一个协程，那么另一个协程就是这个协程的子协程。</p></blockquote><h3 id="resume-yield数据交换"><a href="#resume-yield数据交换" class="headerlink" title="resume-yield数据交换"></a>resume-yield数据交换</h3><p>你应该有留意到resume函数与yield函数的参数与返回值是存在一定程度的相互关联的。<br>实际上我们可以利用这一点做到协程内外的数据交换。</p><p>它的原理是这样的：</p><ol><li><p>当调用<code>resume</code>函数用于启动协程时,<br>会把额外参数传递给协程目标函数的参数表。<br>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br>    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, c)</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co&quot;</span>, a, b, c+<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">end</span><br>)<br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment">--&gt; co 1 2 5</span><br></code></pre></td></tr></table></figure></li><li><p>当调用<code>resume</code>函数用于恢复协程时，<br>会把额外参数传递给<code>yield</code>函数的返回值<br>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br>    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co1&quot;</span>, x)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;co2&quot;</span>, <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>())<br>    <span class="hljs-keyword">end</span><br>)<br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co, <span class="hljs-string">&quot;hi&quot;</span>)  <span class="hljs-comment">--&gt; co1 hi</span><br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment">--&gt; co 45</span><br></code></pre></td></tr></table></figure></li><li><p>当协程遇到<code>yield</code>会暂停协程，回到最开始调用协程的地方(也就是<code>resume</code>)<br>会把<code>yield</code>的参数传递给<code>resume</code>的第二个返回值(没有遇到错误的情况下)<br>例如:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br>    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span></span><br>        <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>(a + b, a - b)<br>    <span class="hljs-keyword">end</span><br>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>))   <span class="hljs-comment">--&gt; true 30 10</span><br></code></pre></td></tr></table></figure></li><li><p>当协程运行结束时(遇到<code>return</code>或代码段运行完了)，<br>会把协程<code>return</code>的值传递给<code>resume</code>的第二个返回值(没有遇到错误的情况下)<br>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br>    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>,<span class="hljs-number">7</span><br>    <span class="hljs-keyword">end</span><br>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co))   <span class="hljs-comment">--&gt; true 6 7</span><br></code></pre></td></tr></table></figure><h2 id="8-3-协程状态"><a href="#8-3-协程状态" class="headerlink" title="8.3 协程状态"></a>8.3 协程状态</h2></li></ol><h3 id="8-3-1-状态与状态转换"><a href="#8-3-1-状态与状态转换" class="headerlink" title="8.3.1 状态与状态转换"></a>8.3.1 状态与状态转换</h3><p>在Lua中，协程有四种主要的状态：挂起（suspended）、运行（running）、正常（normal）和死亡（dead）。理解这些状态及其转化过程对于有效地使用协程至关重要。<br><img src="/images/Lua%E9%80%9F%E9%80%9A%E6%95%99%E7%A8%8B/image-8.png" srcset="/img/loading.gif"></p><ol><li><strong>挂起（Suspended）</strong><br>这是协程最常见的状态。<br>一个协程在两种情况下处于挂起状态：<ul><li>当它尚未开始运行时。</li><li>当它通过<code>coroutine.yield</code>暂停执行时</li></ul></li><li><strong>运行（Running）</strong><br>当协程正在执行时，它处于运行状态。<br>在任何时刻，只有一个协程处于运行状态，即当前正在执行的协程。</li><li><strong>正常（Normal）</strong><br>一个协程在调用其他协程（即在外部协程的<code>coroutine.resume</code>调用中）被视为处于正常状态。这个状态通常表示协程处于活动状态，但当前并未执行代码。</li><li><strong>死亡（Dead）</strong><br>当协程的主体函数结束执行后，协程进入死亡状态。<br>一个协程也会因为运行时错误而死亡。</li></ol><h3 id="8-3-2-状态查询"><a href="#8-3-2-状态查询" class="headerlink" title="8.3.2 状态查询"></a>8.3.2 状态查询</h3><p>我们可以通过两个函数来对协程进行状态查询：</p><ul><li><p><code>coroutine.status</code><br><strong>功能</strong>：获取一个协程的当前状态。<br><strong>参数</strong>：一个协程对象（通过 <code>coroutine.create</code> 创建的）。<br><strong>返回值</strong>：一个字符串，表示协程的状态。<br><strong>示例</strong>：</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(<br>   <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Inside Coroutine&quot;</span>)<br>       <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">yield</span>()<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Resuming Coroutine&quot;</span>)<br>   <span class="hljs-keyword">end</span><br>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Status:&quot;</span>, <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">status</span>(co))  <span class="hljs-comment">-- &quot;Status: suspended&quot;</span><br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Status:&quot;</span>, <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">status</span>(co))  <span class="hljs-comment">-- &quot;Status: suspended&quot;</span><br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Status:&quot;</span>, <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">status</span>(co))  <span class="hljs-comment">-- &quot;Status: dead&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><code>coroutine.running()</code><br><strong>功能</strong>：获取当前正在运行的协程及一个布尔值，表示是否为主协程。<br><strong>参数</strong>：无参数。<br><strong>返回值</strong>：当前正在运行的协程对象和一个布尔值。</p><ul><li>如果当前正在运行的协程是主协程（即Lua主线程）<br>则返回的布尔值为 <code>true</code>；否则为 <code>false</code>。</li><li>如果没有协程在运行，则返回 <code>nil</code>。</li></ul><p><strong>示例</strong>：</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printCoroutineStatus</span><span class="hljs-params">()</span></span><br>   <span class="hljs-keyword">local</span> co, ismain = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">running</span>()<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Running Coroutine:&quot;</span>, co, <span class="hljs-string">&quot;Is Main Coroutine:&quot;</span>, ismain)<br><span class="hljs-keyword">end</span><br>printCoroutineStatus()  <span class="hljs-comment">-- 在主协程中调用</span><br>co = <span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">create</span>(printCoroutineStatus)<br><span class="hljs-built_in">coroutine</span>.<span class="hljs-built_in">resume</span>(co)  <span class="hljs-comment">-- 在子协程中调用</span><br></code></pre></td></tr></table></figure><h2 id="练习题-4"><a href="#练习题-4" class="headerlink" title="练习题"></a>练习题</h2></li></ul><h3 id="题目-1：协程状态监控"><a href="#题目-1：协程状态监控" class="headerlink" title="题目 1：协程状态监控"></a>题目 1：协程状态监控</h3><p>创建一个协程，并在外部循环中监控并打印其状态。需要涉及到协程的全部状态。</p><h3 id="题目-2：计时器"><a href="#题目-2：计时器" class="headerlink" title="题目 2：计时器"></a>题目 2：计时器</h3><p>实现一个协程，能在指定时间后执行某个指定的函数。<br>该计时器可以暂停，恢复，重置，取消，循环等操作。</p><h1 id="9-反射"><a href="#9-反射" class="headerlink" title="9. 反射"></a>9. 反射</h1><p>反射是程序用来检查和修改自身某些部分的能力。<br>Lua 不具备传统编程语言中的完整反射机制，但它也支持几种不同的反射机制：</p><ul><li><code>type</code>和<code>pairs</code>这样的允许运行时检查和遍历未知数据结构的函数</li><li><code>load</code>和<code>require</code>这样运行程序在自身中追加代码或更新代码的函数</li></ul><p>不过仍有一些方面是缺失的，就需要调试库(debug library)来弥补这方面的空白。</p><p>其它几个前面的章节都已经介绍过了，本章节主要介绍动态加载代码的几个函数与调试库的反射功能。</p><h2 id="9-1-动态加载代码"><a href="#9-1-动态加载代码" class="headerlink" title="9.1 动态加载代码"></a>9.1 动态加载代码</h2><p>lua可以实现动态加载代码主要是靠以下几个函数：</p><ul><li><strong>require</strong>：<br>模块化和依赖管理，带有缓存。<br>(实际上require是对loadfile的封装)</li><li><strong>load</strong>：<br>从字符串动态编译代码，提供运行前的控制和错误处理。</li><li><strong>loadfile</strong>：<br>从文件动态编译代码，类似于 <code>load</code> 但用于文件。</li><li><strong>dofile</strong>：<br>直接执行文件中的代码，用于快速脚本执行。</li></ul><p>其中require已经在前面的5.2.2加载模块部分讲解过了，我们这里只对剩下的三个函数进行讲解。</p><h3 id="9-1-1-load"><a href="#9-1-1-load" class="headerlink" title="9.1.1 load"></a>9.1.1 load</h3><p>Lua 的 <code>load</code> 函数是一个强大的工具，用于动态加载和执行字符串形式的 Lua 代码。</p><p><strong>功能</strong></p><ul><li><strong>动态执行代码</strong>：<br><code>load</code> 函数用于编译一个字符串为 Lua 代码块（函数），但不立即执行它。<br>这允许您在运行时动态地加载和执行代码。</li><li><strong>安全性</strong>：<br>与直接使用 <code>loadstring</code> 或 <code>dofile</code> 相比，<code>load</code> 提供了更高的安全性，因为它允许您检查代码是否正确编译，然后再执行。</li></ul><p><strong>参数：</strong></p><ul><li><strong>字符串或加载器函数</strong>：<br><code>load</code> 的第一个参数可以是包含 Lua 代码的字符串，或者是一个加载器函数。<br>加载器函数在每次调用时应返回代码的新片段，直到没有更多的片段时返回 <code>nil</code>。</li><li><strong>块名称</strong>（可选）：<br>用于错误信息和调试信息中的代码块名称。</li><li><strong>模式</strong>（可选）：<br>控制是否允许加载二进制代码块。<ul><li><code>&quot;b&quot;</code>（只允许二进制代码块）</li><li><code>&quot;t&quot;</code>（只允许文本代码块）</li><li> <code>&quot;bt&quot;</code>（两者都允许）</li></ul></li><li><strong>环境</strong>（可选，在 Lua 5.2 及更高版本中）：<br>指定代码块将在其中运行的环境。详见前面5.1.2局部环境提到的内容</li></ul><p><strong>返回值：</strong></p><ul><li>如果编译成功，返回编译后的代码块（函数）；</li><li>如果编译失败，返回 <code>nil</code>与错误信息</li></ul><p><strong>适用场景：</strong></p><ul><li><strong>配置文件</strong>：<br>动态加载和执行配置文件，特别是当配置文件格式为 Lua 代码时。</li><li><strong>动态代码执行</strong>：<br>在需要根据条件构造并执行代码时，例如在模板引擎或某些类型的 DSL 中。</li><li><strong>沙盒执行</strong>：<br>在自定义环境中安全地执行第三方代码，可以用于插件系统或脚本沙盒。</li></ul><p><strong>注意事项:</strong></p><ul><li><strong>安全风险</strong>：<br>执行用户提供的代码时需谨慎，因为它可能导致安全漏洞，如代码注入攻击。</li><li><strong>性能考虑</strong>：<br>频繁地编译和执行大量代码可能会影响性能。</li><li><strong>环境隔离</strong>：<br>在 Lua 5.2 及更高版本中，可以通过设置环境参数来限制代码块的执行环境，减少安全风险。</li></ul><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 示例：动态执行一段代码</span><br><span class="hljs-keyword">local</span> code = <span class="hljs-string">&quot;return 2 + 2&quot;</span><br><span class="hljs-keyword">local</span> chunk, errorMsg = <span class="hljs-built_in">load</span>(code)<br><br><span class="hljs-keyword">if</span> chunk <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Result:&quot;</span>, chunk())  <span class="hljs-comment">-- 输出: Result: 4</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error compiling code:&quot;</span>, errorMsg)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这个例子展示了如何使用 <code>load</code> 编译和执行一个简单的数学运算。<br>如果字符串有效，编译后的函数会被调用并输出结果。<br>如果字符串包含错误，将打印出错误信息。</p><p><strong>游戏开发中的用法：</strong></p><p>在实际的游戏开发中，Lua的<code>load</code>函数可以用于多种场景，尤其是在那些需要动态脚本执行或灵活配置的场合。</p><p>以下是一些典型的应用例子：</p><ol><li><strong>动态配置和脚本</strong><br><code>load</code>可以用来执行游戏的配置脚本。<br>这些脚本可能包含关于游戏级别、角色属性或游戏规则的信息。通过动态加载这些脚本，可以在不重启游戏的情况下修改配置。</li><li><strong>热更新和模块化</strong><br>在游戏运行时动态更新代码是一种常见需求。<br>使用<code>load</code>，开发者可以实现热更新机制，允许游戏在运行时加载和执行新的或修改过的脚本，从而快速迭代和修复bug。</li><li><strong>插件和扩展系统</strong><br>游戏可以提供一种机制，允许第三方开发者或玩家编写自己的脚本来扩展游戏功能。<br>通过<code>load</code>函数，可以安全地加载并执行这些插件或扩展脚本。</li><li><strong>条件式逻辑执行</strong><br>在某些情况下，游戏的特定行为可能需要根据运行时的条件动态确定。<br><code>load</code>可以用来编译和执行构建在运行时的脚本片段，实现复杂的、条件性的逻辑。</li><li><strong>脚本化的AI和事件处理</strong><br>在复杂的游戏中，AI行为或事件响应逻辑可能非常复杂。<br><code>load</code>可以用于执行动态生成的脚本，这些脚本定义了角色的行为或游戏中的事件响应。</li></ol><p><strong>注意事项：</strong></p><ul><li><strong>安全性</strong>：<br>动态执行代码增加了出错的风险，特别是当执行用户提供的脚本时。<br>需要确保脚本执行环境的安全性，防止恶意代码执行。</li><li><strong>性能</strong>：<br>频繁编译和执行大量的脚本可能会影响游戏性能，特别是在资源有限的设备上。</li></ul><p>总之，<code>load</code>在游戏开发中提供了极大的灵活性，但也带来了安全和性能上的挑战。正确使用时，它可以极大地增强游戏的动态性和可扩展性。</p><h3 id="9-1-2-loadfile"><a href="#9-1-2-loadfile" class="headerlink" title="9.1.2 loadfile"></a>9.1.2 loadfile</h3><p><strong>功能：</strong><br><code>loadfile</code> 用于读取 Lua 文件的内容并编译为函数，但不立即执行它。</p><p><strong>参数：</strong><br><strong>文件路径</strong>：<br>指定要加载的 Lua 文件的路径。<br>如果没有提供路径，则默认尝试加载当前工作目录下的文件。</p><p><strong>返回值：</strong></p><ul><li><strong>成功</strong>：返回编译后的函数。</li><li><strong>失败</strong>：返回 <code>nil</code> 和一个错误消息。</li></ul><p><strong>适用场景：</strong></p><ul><li><strong>配置文件加载</strong>：动态加载配置文件，尤其是内容可能更改的情况。</li><li><strong>模块和脚本加载</strong>：作为模块系统的一部分，用于加载模块代码。</li><li><strong>条件执行</strong>：在确定是否执行代码之前，先对文件进行语法检查。</li></ul><p><strong>注意事项：</strong></p><ul><li><strong>文件路径</strong>：确保文件路径正确，且文件具有正确的语法。</li><li><strong>错误处理</strong>：由于 <code>loadfile</code> 不会立即执行代码，需要处理编译过程中可能出现的错误。</li></ul><p><strong>原理：</strong><br><code>loadfile</code> 函数首先将文件内容读入内存，然后编译这些内容为 Lua 函数（字节码）。这个函数可以被稍后调用以执行文件中的代码。</p><p><strong>案例：</strong><br>假设你有一个配置文件 <code>config.lua</code>，其中包含一些游戏设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- config.lua 文件内容</span><br>setting = &#123;<br>    volume = <span class="hljs-number">0.75</span>,<br>    resolution = &#123; width = <span class="hljs-number">1920</span>, height = <span class="hljs-number">1080</span> &#125;,<br>    difficulty = <span class="hljs-string">&quot;normal&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你可以使用 <code>loadfile</code> 来加载这个配置文件，然后根据需要执行它：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 加载 config.lua 但不执行</span><br><span class="hljs-keyword">local</span> loadConfig = <span class="hljs-built_in">loadfile</span>(<span class="hljs-string">&quot;config.lua&quot;</span>)<br><br><span class="hljs-keyword">if</span> loadConfig <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 执行加载的函数以应用配置</span><br>    loadConfig()<br><br>    <span class="hljs-comment">-- 访问配置</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Volume setting:&quot;</span>, setting.volume)<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed to load config.lua&quot;</span>)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>loadfile</code> 用于读取并编译 <code>config.lua</code> 文件，但不立即执行它。<br>这允许进行错误检查或其他逻辑判断，然后再通过调用返回的函数来实际应用配置。</p><h3 id="9-1-3-dofile"><a href="#9-1-3-dofile" class="headerlink" title="9.1.3 dofile"></a>9.1.3 dofile</h3><p><strong>功能：</strong><br><code>dofile</code> 用于读取并立即执行 Lua 文件。</p><p><strong>参数：</strong><br><strong>文件路径</strong>：指定要执行的 Lua 文件的路径。</p><p><strong>返回值：</strong><br>文件中最后一个表达式的返回值。</p><p><strong>适用场景：</strong></p><ul><li><strong>直接执行脚本</strong>：当需要立即执行一个 Lua 脚本文件时，特别是初始化脚本或配置。</li><li><strong>简化的文件执行</strong>：对于不需要预先检查或多次执行的脚本。</li></ul><p><strong>注意事项：</strong></p><ul><li><strong>错误处理</strong>：<code>dofile</code> 在执行时可能抛出错误，需要相应地处理这些错误。</li><li><strong>性能考虑</strong>：对于频繁执行的代码，<code>dofile</code> 可能不如预编译的函数高效。</li></ul><p><strong>原理：</strong><br><code>dofile</code> 函数读取文件内容，将其编译为函数，并立即执行这个函数。</p><p><strong>案例：</strong><br>假设你有一个 Lua 脚本 <code>initialize.lua</code>，用于初始化一些游戏数据：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- initialize.lua 文件内容</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Initializing game data&quot;</span>)<br><br><span class="hljs-comment">-- 初始化代码...</span><br>gameData = &#123;<br>    level = <span class="hljs-number">1</span>,<br>    score = <span class="hljs-number">0</span>,<br>    playerLives = <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Initialization complete&quot;</span>)<br></code></pre></td></tr></table></figure><p>你可以使用 <code>dofile</code> 来直接执行这个脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 直接执行 initialize.lua</span><br><span class="hljs-built_in">dofile</span>(<span class="hljs-string">&quot;initialize.lua&quot;</span>)<br><br><span class="hljs-comment">-- 访问初始化后的游戏数据</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Starting level:&quot;</span>, gameData.level)<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>dofile</code> 直接读取并执行了 <code>initialize.lua</code> 文件。这是一种快速方便的方式来执行不需要预编译或特殊错误处理的脚本，例如初始化脚本或简单配置文件。</p><h3 id="练习题-5"><a href="#练习题-5" class="headerlink" title="练习题"></a>练习题</h3><h4 id="题目-1：动态执行代码"><a href="#题目-1：动态执行代码" class="headerlink" title="题目 1：动态执行代码"></a>题目 1：动态执行代码</h4><p><strong>描述：</strong> 编写一个 Lua 程序，使用 <code>load</code> 函数动态执行给定的数学表达式字符串，并打印结果。例如，给定字符串 <code>&quot;return 2 + 2&quot;</code>。</p><p>**预计输出:**4</p><h4 id="题目-2：动态修改配置"><a href="#题目-2：动态修改配置" class="headerlink" title="题目 2：动态修改配置"></a>题目 2：动态修改配置</h4><p><strong>描述：</strong> 假设有一个配置文件 <code>config.lua</code>，内容如上所述。编写一个 Lua 程序，使用 <code>loadfile</code> 函数加载 <code>config.lua</code> 文件，然后动态修改 <code>setting</code> 表中的 <code>volume</code> 和 <code>resolution</code>，最后打印出修改后的配置。</p><p>config.lua文件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- config.lua</span><br>setting = &#123;<br>    volume = <span class="hljs-number">0.5</span>,<br>    resolution = &#123; width = <span class="hljs-number">800</span>, height = <span class="hljs-number">600</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>预期输出：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">codeVolume</span>: <span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">Resolution</span>: <span class="hljs-number">1920</span>x<span class="hljs-number">1080</span><br></code></pre></td></tr></table></figure><h2 id="9-2-调试库"><a href="#9-2-调试库" class="headerlink" title="9.2 调试库"></a>9.2 调试库</h2><blockquote><p>以下内容更多是用于调试代码或模拟沙盒时使用，而且一边情况下用IDE的断点调试工具更有性价比，可以仅作了解或略过不看</p></blockquote><p>调试库由两类函数组成：</p><ul><li>自省函数(introspective function)<br>用来检查一个正在运行的程序的几个方面，如活动函数的栈，正在执行的代码行，局部变量的名称和值。</li><li>钩子(hook)<br>用来跟踪一个程序执行的生命周期。</li></ul><p>值得注意的是：调试库必须被慎重的使用。</p><ul><li>调试库的功能普遍性能不高</li><li>调试库会打破语言的一些固有规则，会导致代码混乱，更难维护</li></ul><h3 id="9-2-1-自省函数"><a href="#9-2-1-自省函数" class="headerlink" title="9.2.1 自省函数"></a>9.2.1 自省函数</h3><p>Lua的自省（Introspection）功能，主要由<code>debug</code>库提供，使得程序能够在运行时检查其自身的状态和结构。自省功能对于深入理解程序行为、调试和高级编程任务非常重要。</p><p>以下是Lua中一些主要的自省函数及其功能：</p><ol><li><strong>debug.getinfo</strong><br><strong>功能</strong>：返回有关函数的详细信息。<br><strong>参数</strong>：接受一个函数或堆栈层级（数字）。<br><strong>返回值</strong>：一个包含函数信息的表，如函数名、定义的源文件、行号等。</li><li><strong>debug.getlocal和debug.setlocal</strong><br><strong>功能</strong>：分别用于获取和设置一个函数的局部变量的名称和值。<br><strong>参数</strong>：堆栈层级和局部变量的索引。set时还需传入新的值。<br><strong>返回值</strong>：<br>获取时返回局部变量的名称和值。<br>设置时返回被设置的变量的名称，如果设置失败，则为 <code>nil</code>。</li><li><strong>debug.getupvalue 和 debug.setupvalue</strong><br><strong>功能</strong>：分别用于获取和设置一个函数的上值（upvalue，闭包中的外部变量）。<br><strong>参数</strong>：函数和上值的索引。<br><strong>返回值</strong>：<code>getupvalue</code> 返回上值的名称和值，<code>setupvalue</code> 返回被设置的上值的名称。</li><li><strong>debug.getmetatable 和 debug.setmetatable</strong><br><strong>功能</strong>：分别用于获取和设置一个对象的元表（metatable）。<br><strong>参数</strong>：对象（表或其他可设置元表的类型）。<br><strong>返回值</strong>：元表。</li><li><strong>debug.traceback</strong><br><strong>功能</strong>：生成当前调用栈的回溯信息。<br><strong>参数</strong>：可选的消息字符串和起始堆栈层级。<br><strong>返回值</strong>：包含回溯信息的字符串。</li><li><strong>debug.getregistry</strong><br><strong>功能</strong>：获取Lua的注册表，这是一个特殊的表，用于存储所有用C注册到Lua的对象。<br><strong>返回值</strong>：Lua注册表。</li></ol><p>我们接下来挑几个重点进行介绍</p><h4 id="getinfo"><a href="#getinfo" class="headerlink" title="getinfo"></a>getinfo</h4><p><code>debug.getinfo</code> 是 Lua 中的一个强大的自省函数，用于获取有关函数的详细信息。</p><p><strong>参数:</strong></p><ul><li><p><strong>函数或堆栈层级</strong>：<br>可以是一个函数或表示调用堆栈层级的数字。</p><ul><li><p>传递函数时，获取该函数的信息；</p></li><li><p>传递数字时，获取堆栈上相应层级的函数的信息。</p></li></ul></li><li><p><strong>‘what’ 字符串</strong>（可选）：<br>用于指定要返回哪些信息。<br>可能的值包括</p><ul><li><code>&quot;n&quot;</code>（名称）<br><code>name</code>,<code>namewhat</code></li><li><code>&quot;S&quot;</code>（源）<br><code>source</code>,<code>short_src</code>,<code>what</code>,<code>linedefined</code>,<code>lastlinedefined</code></li><li><code>&quot;l&quot;</code>（行号）<br><code>currentline</code></li><li><code>&quot;u&quot;</code>（上值数量）<br><code>nup</code>,<code>nparams</code>,<code>isvararg</code></li><li><code>&quot;f&quot;</code>（函数本身）<br><code>func</code></li><li><code>&quot;L&quot;</code>（行号列表）<br><code>activelines</code></li></ul></li></ul><p><strong>返回值:</strong><br>是一个表，可能包含以下字段(由传入的what字符串决定有那些字段)：</p><ul><li><strong>source</strong>：函数定义的源文件或代码块。</li><li><strong>short_src</strong>：源文件或代码块的简短版本，通常用于错误消息。</li><li><strong>linedefined</strong>：函数定义的开始行号。</li><li><strong>lastlinedefined</strong>：函数定义的结束行号。</li><li><strong>what</strong>：函数的类型（”Lua”、”C” 或 “main”）。</li><li><strong>name</strong>：函数的名称（如果可用）。</li><li><strong>namewhat</strong>：描述名称的类型（如 “global”、”local”、”method” 等）。</li><li><strong>nups</strong>：函数上值的数量。</li><li><strong>nparams</strong>（仅在 Lua 5.1 中不可用）：函数参数的数量。</li><li><strong>isvararg</strong>（仅在 Lua 5.1 中不可用）：函数是否是可变参数函数。</li><li><strong>func</strong>：函数本身。</li><li><strong>activelines</strong>：包含所有活跃行号的表。</li></ul><p><strong>使用场景:</strong></p><ul><li><strong>调试和错误报告</strong>：获取函数的详细信息，用于调试或生成错误报告。</li><li><strong>性能分析</strong>：分析函数调用和执行，如在性能分析工具中。</li><li><strong>高级函数操作</strong>：在需要详细了解函数行为的高级编程任务中。</li></ul><p><strong>代码案例:</strong></p><p>获取一个函数的信息并打印出来：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testFunction</span><span class="hljs-params">()</span></span><br>    <span class="hljs-comment">-- 函数内容</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> info = <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getinfo</span>(testFunction)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Function info:&quot;</span>)<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(info) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(k, v)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个简单的函数 <code>testFunction</code>，然后使用 <code>debug.getinfo</code> 获取它的信息，并遍历这些信息将它们打印出来。</p><p><strong>注意事项:</strong></p><ul><li><code>debug.getinfo</code> 通常用于调试目的，因为它可能会影响性能。</li><li>函数的某些信息（如名称）可能不总是可用，特别是对于匿名函数或在某些上下文中调用的函数。</li><li>在安全性敏感的环境中慎用，因为它可以用来探查函数的内部细节。</li></ul><h4 id="getlocal-setlocal"><a href="#getlocal-setlocal" class="headerlink" title="getlocal,setlocal"></a>getlocal,setlocal</h4><h5 id="getlocal"><a href="#getlocal" class="headerlink" title="getlocal"></a>getlocal</h5><p><code>debug.getlocal</code> 是 Lua 中用于获取函数局部变量信息的自省函数。<br>它允许你查看或修改函数的局部变量，这在调试和高级编程中非常有用。</p><p><strong>参数：</strong></p><ul><li><strong>函数调用堆栈层级</strong>：<br>一个数字，指定要访问的堆栈层级。<br><code>1</code> 表示当前函数，<code>2</code> 表示调用当前函数的函数，依此类推。</li><li><strong>局部变量的索引</strong>：<br>一个数字，表示要访问的局部变量的索引。<br>局部变量按照它们在代码中出现的顺序进行索引。</li></ul><p><strong>返回值：</strong>变量名称和值</p><ul><li>如果成功，返回局部变量的名称和值；</li><li>如果索引超出了局部变量的数量，返回 <code>nil</code>。</li></ul><p><strong>使用场景：</strong></p><ul><li><strong>调试</strong>：在调试时检查和修改函数的局部变量。</li><li><strong>运行时分析</strong>：分析函数行为，如检查变量的值或状态。</li><li><strong>高级函数操作</strong>：在复杂的编程任务中，如动态修改函数行为。</li></ul><p><strong>注意事项：</strong></p><ul><li><strong>性能影响</strong>：<br>频繁使用 <code>debug.getlocal</code> 可能会影响性能，特别是在循环或性能敏感的代码中。</li><li><strong>变量索引</strong>：<br>局部变量的索引可能会因为函数的不同部分而变化，尤其是在存在条件分支或循环时。</li><li><strong>安全性</strong>：<br>修改局部变量的值可能会导致程序行为不稳定或不可预测，应谨慎使用。</li></ul><h5 id="setlocal"><a href="#setlocal" class="headerlink" title="setlocal"></a>setlocal</h5><p><code>debug.setlocal</code> 允许你修改指定函数堆栈层级上的局部变量的值。</p><p><strong>参数:</strong></p><ul><li><strong>堆栈层级</strong>：<br>一个数字，表示要修改的函数在调用堆栈中的层级。<br>层级 <code>1</code> 是当前函数，层级 <code>2</code> 是调用当前函数的函数，依此类推。</li><li><strong>局部变量的索引</strong>：一个数字，表示要修改的局部变量在其函数内的索引。</li><li><strong>新的值</strong>：要设置的新值。</li></ul><p><strong>返回值:</strong></p><ul><li>如果设置成功，返回变量的名称；</li><li>如果索引超出了局部变量的数量，返回 <code>nil</code>。</li></ul><p><strong>使用场景:</strong></p><ul><li><strong>调试时修改状态</strong>：<br>在调试过程中，可以用来修改函数的内部状态，从而观察不同状态下的行为。</li><li><strong>运行时行为修改</strong>：<br>在高级编程任务中，动态修改程序的行为，尤其是在测试或特定条件下。</li></ul><p><strong>代码案例:</strong></p><p>下面是一个简单的示例，演示了如何使用 <code>debug.setlocal</code> 修改函数的局部变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testFunction</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original value of a:&quot;</span>, a)<br>    <span class="hljs-comment">-- 假设我们想在这里修改变量a的值</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 调用函数</span><br>testFunction()<br><br><span class="hljs-comment">-- 修改 testFunction 中的局部变量 a</span><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">modifyLocalVar</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> name = <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getlocal</span>(<span class="hljs-number">2</span>, i)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> name <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">setlocal</span>(<span class="hljs-number">2</span>, i, <span class="hljs-number">20</span>)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">end</span><br>        i = i + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>modifyLocalVar()<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>testFunction</code> 定义了一个局部变量 <code>a</code>。<br>我们在 <code>modifyLocalVar</code> 函数中使用 <code>debug.setlocal</code> 来修改 <code>a</code> 的值。<br>这个例子展示了基本的用法，但请注意，实际中通常需要在函数执行的上下文中使用 <code>debug.setlocal</code>，例如在调试器中或在错误处理函数里。</p><p><strong>注意事项：</strong></p><ul><li><strong>性能和安全</strong>：<br>频繁使用 <code>debug.setlocal</code> 可能会影响性能，并且不当使用可能导致程序行为不稳定。</li><li><strong>变量索引</strong>：<br>确定正确的局部变量索引可能有些复杂，尤其是在函数具有复杂的控制流程时。</li><li><strong>适用场合</strong>：通常仅在调试和特定的高级编程场景中使用。</li></ul><p><code>debug.setlocal</code> 提供了强大的能力来动态改变函数的内部状态，但应谨慎使用，以避免不可预期的副作用。</p><p><code>debug.getupvalue</code> 和 <code>debug.setupvalue</code> 是 Lua 中用于访问和修改函数闭包中的上值（upvalues）的函数。在 Lua 的函数编程模型中，闭包和上值是实现函数作用域和持久状态的关键机制。以下是这两个函数的详细描述：</p><h4 id="getupvalue-setupvalue"><a href="#getupvalue-setupvalue" class="headerlink" title="getupvalue,setupvalue"></a>getupvalue,setupvalue</h4><h5 id="debug-getupvalue"><a href="#debug-getupvalue" class="headerlink" title="debug.getupvalue"></a>debug.getupvalue</h5><p><code>debug.getupvalue</code> 用于获取闭包中的上值（即函数外部的局部变量，被闭包所捕获）。</p><p><strong>参数:</strong></p><ul><li><strong>函数</strong>：闭包函数。</li><li><strong>上值的索引</strong>：一个数字，表示要访问的上值的索引。</li></ul><p><strong>返回值:</strong></p><ul><li>如果成功，返回:<ul><li>上值的名称</li><li>上值的值</li><li>bool 值<code>isenv</code>上值是否是函数的环境（_ENV）(lua5.2以上版本)</li></ul></li><li>如果索引超出了上值的数量，返回 <code>nil</code>。</li></ul><p>其中参数isenv避免了一个诡异的问题。<br>该参数用于说明我们是否处于一个从<code>_ENV</code>变量中查询全局名称的递归调用中。一个不使用全局变量的函数可能没有上值<code>_ENV</code>。<br>在这种情况下，如果我们试图把<code>_ENV</code>当作全局变量来查询，那么由于我们需要ENV来得到其自身的值，就有可能会陷人无限递归循环。<br>因此，当isenv为真且函数getvarvalue找不到局部变量或值时，getvarvalue就不应该再尝试全局变量。</p><p><strong>使用场景:</strong></p><ul><li><strong>调试</strong>：在调试时检查闭包中捕获的变量。</li><li><strong>运行时分析</strong>：分析闭包行为，特别是在高级编程和动态代码修改中。</li></ul><p><strong>代码案例:</strong></p><p>获取并打印一个闭包中的上值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> a = <span class="hljs-string">&quot;upvalue&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">print</span>(a) <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> myClosure = outer()<br><span class="hljs-keyword">local</span> name, value = <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getupvalue</span>(myClosure, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Upvalue name:&quot;</span>, name, <span class="hljs-string">&quot;value:&quot;</span>, value)<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>outer</code> 函数创建了一个闭包，该闭包捕获了局部变量 <code>a</code>。我们使用 <code>debug.getupvalue</code> 来获取并打印这个上值的名称和值。</p><h5 id="debug-setupvalue"><a href="#debug-setupvalue" class="headerlink" title="debug.setupvalue"></a>debug.setupvalue</h5><p><code>debug.setupvalue</code> 用于设置闭包中的上值。</p><p><strong>参数:</strong></p><ul><li><strong>函数</strong>：闭包函数。</li><li><strong>上值的索引</strong>：一个数字，表示要修改的上值的索引。</li><li><strong>新的值</strong>：要设置的新值。</li></ul><p><strong>返回值:</strong></p><ul><li>如果成功，返回:<ul><li>上值的名称</li><li>上值的值</li><li>bool 值<code>isenv</code>上值是否是函数的环境（_ENV）(lua5.2以上版本)</li></ul></li><li>如果索引超出了上值的数量，返回 <code>nil</code>。</li></ul><p><strong>使用场景:</strong></p><ul><li><strong>运行时行为修改</strong>：在高级编程任务中，动态修改闭包捕获的变量。</li><li><strong>调试和测试</strong>：在调试或测试时修改闭包的状态。</li></ul><p><strong>代码案例:</strong></p><p>修改一个闭包中的上值：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> a = <span class="hljs-string">&quot;upvalue&quot;</span><br>    <span class="hljs-keyword">local</span> closure = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-built_in">print</span>(a) <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> closure, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(newVal)</span></span> <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">setupvalue</span>(closure, <span class="hljs-number">1</span>, newVal) <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> myClosure, setUpvalue = outer()<br>myClosure()  <span class="hljs-comment">-- 打印原始的上值</span><br>setUpvalue(<span class="hljs-string">&quot;new value&quot;</span>)<br>myClosure()  <span class="hljs-comment">-- 打印修改后的上值</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>outer</code> 函数返回了一个闭包和一个用于修改闭包上值的函数。我们首先打印了原始的上值，然后使用 <code>debug.setupvalue</code> 修改它，并再次打印以观察变化。</p><p><strong>注意事项:</strong></p><ul><li><strong>性能和安全</strong>：频繁使用这些函数可能会影响性能，并且不当使用可能导致程序行为不稳定。</li><li><strong>适用场合</strong>：主要用于调试和特定的高级编程场景。</li><li><strong>谨慎修改</strong>：修改上值可能会对闭包的行为产生重大影响，应谨慎使用。</li></ul><h3 id="9-2-2-钩子"><a href="#9-2-2-钩子" class="headerlink" title="9.2.2 钩子"></a>9.2.2 钩子</h3><p>Lua 中的钩子（Hook）机制是一个强大的特性，它允许你监视和调试 Lua 程序的行为。通过钩子，你可以追踪程序的执行，比如函数的调用、返回，以及某些特定事件的发生。这在调试和性能分析中非常有用。</p><p><strong>钩子函数可以在以下几种事件发生时被调用：</strong></p><ul><li>**”call”**：<br>当 Lua 调用一个函数时。</li><li>**”return”**：<br>当 Lua 从一个函数返回时。</li><li>**”line”**：<br>当 Lua 执行到新的一行代码时。</li><li>**”count”**：<br>每执行一定数量的指令后。</li><li>**”tail call”**：<br>执行尾调用时。<br>尾调用在 Lua 中被视为返回，因此不会触发常规的“call”和“return”事件。</li></ul><p><strong>使用钩子：</strong></p><p>使用 <code>debug.sethook</code> 函数设置钩子。<br>这个函数接受三个参数：</p><ol><li><strong>钩子函数：</strong>当指定的事件发生时被调用的函数。</li><li><strong>字符串：</strong>指定触发钩子函数的事件类型。</li><li><strong>数字（可选）：</strong>对于 “count” 事件，这个数字表示多少指令执行一次钩子函数。</li></ol><p><strong>钩子函数的参数：</strong></p><p>钩子函数接受两个参数：</p><ol><li><strong>事件类型：</strong><br>一个字符串，表示触发钩子的事件类型（”call”, “return”, “line”, “count”, “tail call”）。</li><li><strong>行号（仅当事件类型为 “line” 时）：</strong>表示当前执行的行号。</li></ol><p><strong>使用场景：</strong></p><ul><li><strong>调试</strong>：跟踪函数调用和返回，监控程序执行流程。</li><li><strong>性能分析</strong>：通过计数或行号事件监控程序的性能。</li><li><strong>行为监控</strong>：在某些操作发生时进行日志记录或执行特定的代码。</li></ul><p><strong>案例：</strong><br>下面是一个简单的示例，展示如何使用钩子来追踪函数调用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trace</span><span class="hljs-params">(event, line)</span></span><br>    <span class="hljs-keyword">local</span> s = <span class="hljs-built_in">debug</span>.<span class="hljs-built_in">getinfo</span>(<span class="hljs-number">2</span>).short_src<br>    <span class="hljs-built_in">print</span>(s .. <span class="hljs-string">&quot;:&quot;</span> .. line)<br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">debug</span>.<span class="hljs-built_in">sethook</span>(trace, <span class="hljs-string">&quot;line&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><span class="hljs-keyword">end</span><br>myFunction()<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为 <code>trace</code> 的钩子函数，用于在每次 Lua 执行到新的一行代码时打印文件名和行号。<br>然后我们使用 <code>debug.sethook</code> 设置这个函数为钩子，并指定 “line” 事件触发钩子。</p><p><strong>注意事项：</strong></p><ul><li><strong>性能影响</strong>：<br>频繁触发的钩子（尤其是 “line” 和 “count” 事件）可能会对程序性能产生显著影响。</li><li><strong>调试与日常使用</strong>：<br>钩子通常用于调试或性能分析，而不是程序的日常功能。</li><li><strong>安全性</strong>：<br>在钩子函数中执行复杂的操作或修改程序状态需要谨慎，以避免引入错误或不稳定行为。</li></ul><h3 id="练习题-6"><a href="#练习题-6" class="headerlink" title="练习题"></a>练习题</h3><h4 id="题目-1：追踪函数调用"><a href="#题目-1：追踪函数调用" class="headerlink" title="题目 1：追踪函数调用"></a>题目 1：追踪函数调用</h4><p>使用 Lua 的调试库，编写一个程序来追踪任意一个函数的调用。程序应该在函数被调用时打印出函数名和调用的参数。</p><h4 id="题目-2：实现一个简单的调试器"><a href="#题目-2：实现一个简单的调试器" class="headerlink" title="题目 2：实现一个简单的调试器"></a>题目 2：实现一个简单的调试器</h4><p>实现一个简单的 Lua 调试器，它能够在每次执行新的一行代码时打印出当前的文件名和行号。使用 <code>debug.sethook</code> 设置钩子，并实现相应的钩子函数。</p><h4 id="题目-3：修改闭包上值"><a href="#题目-3：修改闭包上值" class="headerlink" title="题目 3：修改闭包上值"></a>题目 3：修改闭包上值</h4><p>给定以下 Lua 函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> secretNumber = <span class="hljs-number">42</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>        <span class="hljs-keyword">return</span> secretNumber<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> myClosure = outer()<br></code></pre></td></tr></table></figure><p>编写一个 Lua 程序，使用 <code>debug.getupvalue</code> 和 <code>debug.setupvalue</code> 函数找到闭包 <code>myClosure</code> 中的上值 <code>secretNumber</code> 并修改它的值。然后验证修改是否成功。</p><h1 id="10-序列化与反序列化"><a href="#10-序列化与反序列化" class="headerlink" title="10. 序列化与反序列化"></a>10. 序列化与反序列化</h1><p>Lua 中的序列化是将表（Lua 的一种数据结构）转换为可存储或传输的格式：</p><ul><li>字符流(字符串)</li><li>字节流(二进制)</li></ul><p>而反序列化则是将这种格式恢复为原始表的过程。</p><p>这在数据持久化、网络通信等方面非常有用。</p><h2 id="10-1-字符流"><a href="#10-1-字符流" class="headerlink" title="10.1 字符流"></a>10.1 字符流</h2><p>Lua 的序列化与许多其他语言中的序列化机制有所不同。</p><p>在诸如 Java、C#、Python 等语言中，序列化通常涉及将数据结构转换为标准化的格式，如 JSON、XML 或自定义的二进制格式。这些格式通常是语言无关的，使得不同语言编写的程序能够互相交换数据。</p><p>Lua 中的序列化机制，尤其是简单的实现，通常涉及以下方面的差异：</p><ol><li><strong>Lua代码作为序列化格式</strong>：<br>Lua 的序列化经常直接生成可执行的 Lua 代码(可以是作为一种自描述数据)。<br>这意味着反序列化通常就是执行这段代码，从而重建原始的数据结构。<br>这种方式在 Lua 社区中较为常见，因为它利用了 Lua 强大的字符串处理和代码执行能力。</li><li><strong>没有标准化格式</strong>：<br>Lua 标准库本身并不提供序列化和反序列化功能。<br>因此，Lua 程序员通常会实现自己的序列化逻辑，或者使用第三方库。<br>这与像 Python 或 Java 这样内置了序列化机制的语言不同。</li><li><strong>侧重于可读性和简洁性</strong>：<br>Lua 序列化的一个常见目标是生成可读和简洁的字符串表示，这在配置文件和简单的数据持久化场景中非常有用。</li><li><strong>安全性问题</strong>：<br>使用 Lua 代码作为序列化格式可能带来安全风险，因为执行反序列化的字符串可能会执行任意代码。<br>这与 JSON 或 XML 等更为“静态”的格式相比，风险更高。</li><li><strong>跨语言兼容性不是主要目标</strong>：<br>由于 Lua 序列化通常生成 Lua 代码，这使得生成的数据与其他语言的兼容性不是主要考虑因素。相比之下，JSON 或 XML 格式由于其语言中立性，更适合用于跨语言的数据交换。</li></ol><p>总的来说，Lua 的序列化方法倾向于利用其动态语言的特性，生成易于理解和使用的 Lua 代码片段。</p><p>这种方法在 Lua 的应用场景中很有效，但可能不适合所有情况，尤其是在需要跨语言兼容性或更高安全性的环境下。在这些情况中，使用 JSON 或其他标准化数据交换格式可能是更好的选择。</p><p>对于带循环的表和不带循环的表，序列化和反序列化的步骤及其注意事项略有不同。</p><h3 id="10-1-1-不带循环的表"><a href="#10-1-1-不带循环的表" class="headerlink" title="10.1.1 不带循环的表"></a>10.1.1 不带循环的表</h3><p><strong>序列化步骤：</strong></p><ol><li><strong>遍历表</strong>：递归地遍历表中的所有键值对。</li><li><strong>格式化数据</strong>：将每个键和值转换为字符串格式。</li><li><strong>构建字符串</strong>：将格式化后的键值对拼接成一个符合 Lua 语法的表表示字符串。</li></ol><p><strong>反序列化步骤：</strong></p><ol><li><strong>解析字符串</strong>：使用 <code>load</code> 或 <code>loadstring</code> 函数加载序列化的字符串。</li><li><strong>执行代码</strong>：执行加载的函数来重建原始的表。</li></ol><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serialize</span><span class="hljs-params">(table)</span></span><br>    <span class="hljs-keyword">local</span> result = &#123;&#125;<br><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">table</span>) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">local</span> key, value<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(k) == <span class="hljs-string">&quot;string&quot;</span> <span class="hljs-keyword">then</span><br>            key = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%q&quot;</span>, k)<br>        <span class="hljs-keyword">else</span><br>            key = <span class="hljs-built_in">tostring</span>(k)<br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">then</span><br>            value = serialize(v)<br>        <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">type</span>(v) == <span class="hljs-string">&quot;string&quot;</span> <span class="hljs-keyword">then</span><br>            value = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%q&quot;</span>, v)<br>        <span class="hljs-keyword">else</span><br>            value = <span class="hljs-built_in">tostring</span>(v)<br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(result, <span class="hljs-string">&quot;[&quot;</span> .. key .. <span class="hljs-string">&quot;] = &quot;</span> .. value)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> .. <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(result, <span class="hljs-string">&quot;, &quot;</span>) .. <span class="hljs-string">&quot;&#125;&quot;</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> myTable = &#123; name = <span class="hljs-string">&quot;Lua&quot;</span>, year = <span class="hljs-number">1993</span> &#125;<br><span class="hljs-keyword">local</span> serialized = serialize(myTable)<br><span class="hljs-built_in">print</span>(serialized)<br><br><span class="hljs-keyword">local</span> deserialized = <span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;return &quot;</span> .. serialized)()<br><span class="hljs-built_in">print</span>(deserialized.name, deserialized.year)<br></code></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>安全性</strong>：在反序列化时，确保字符串来自可信的来源。</li><li><strong>数据类型限制</strong>：无法序列化函数、线程、用户数据等。</li></ul><h3 id="10-1-2-带循环的表"><a href="#10-1-2-带循环的表" class="headerlink" title="10.1.2 带循环的表"></a>10.1.2 带循环的表</h3><p><strong>序列化步骤：</strong></p><ol><li><strong>追踪循环引用</strong>：在序列化过程中追踪已访问的表，以避免无限递归。</li><li><strong>格式化数据</strong>：将每个键和值转换为字符串格式，对于已访问过的表，仅存储引用。</li><li><strong>构建字符串</strong>：构建一个能够在反序列化时重建循环引用的字符串。</li></ol><p><strong>反序列化步骤：</strong></p><ol><li><strong>解析字符串</strong>：使用 <code>load</code> 或 <code>loadstring</code> 函数加载序列化的字符串。</li><li><strong>重建循环引用</strong>：执行加载的函数时，确保正确重建循环引用。</li></ol><p><strong>示例：</strong></p><p>处理循环引用需要更复杂的逻辑。这里提供一个简化的示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serialize</span><span class="hljs-params">(tbl, seen)</span></span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(tbl) ~= <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(tbl) == <span class="hljs-string">&quot;string&quot;</span> <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;%q&quot;</span>, tbl)<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">tostring</span>(tbl)<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> seen[tbl] <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> seen[tbl]<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">local</span> ref = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;ref%d&quot;</span>, <span class="hljs-built_in">tostring</span>(tbl):<span class="hljs-built_in">match</span>(<span class="hljs-string">&quot;:%s*(.+)&quot;</span>))<br>    seen[tbl] = ref<br><br>    <span class="hljs-keyword">local</span> result = &#123;&#125;<br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(tbl) <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(result, <span class="hljs-string">&quot;[&quot;</span> .. serialize(k, seen) .. <span class="hljs-string">&quot;]=&quot;</span> .. serialize(v, seen))<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> ref .. <span class="hljs-string">&quot;=&#123;&quot;</span> .. <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(result, <span class="hljs-string">&quot;,&quot;</span>) .. <span class="hljs-string">&quot;&#125;&quot;</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serializeWithRefs</span><span class="hljs-params">(tbl)</span></span><br>    <span class="hljs-keyword">local</span> seen = &#123;&#125;<br>    <span class="hljs-keyword">local</span> refs = &#123;&#125;<br>    <span class="hljs-keyword">local</span> main = serialize(tbl, seen)<br><br>    <span class="hljs-keyword">for</span> t, ref <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(seen) <span class="hljs-keyword">do</span><br>        <span class="hljs-keyword">if</span> ref ~= main <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(refs, ref .. <span class="hljs-string">&quot;=&quot;</span> .. serialize(t, &#123;&#125;))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;do local &quot;</span> .. main .. <span class="hljs-string">&quot;; &quot;</span> .. <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(refs, <span class="hljs-string">&quot;; &quot;</span>) .. <span class="hljs-string">&quot;; return &quot;</span> .. main .. <span class="hljs-string">&quot;; end&quot;</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 测试带有循环引用的表</span><br><span class="hljs-keyword">local</span> myTable = &#123;&#125;<br>myTable.a = &#123;b = myTable&#125;<br><br><span class="hljs-keyword">local</span> serialized = serializeWithRefs(myTable)<br><span class="hljs-built_in">print</span>(serialized)<br><br><span class="hljs-comment">-- 反序列化</span><br><span class="hljs-keyword">local</span> deserialized = <span class="hljs-built_in">load</span>(serialized)()<br><span class="hljs-built_in">print</span>(deserialized, deserialized.a.b == deserialized)<br></code></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>serializeWithRefs</code> 函数负责序列化表，处理循环引用，并返回一个可以执行的 Lua 代码字符串。</li><li><code>serialize</code> 函数是一个辅助函数，用于递归地序列化表和其子表。它使用 <code>seen</code> 表来追踪已访问过的表并避免循环引用。</li><li>在测试代码中，<code>myTable</code> 包含了指向自身的引用，展示了循环引用的情况。</li><li>使用 <code>load</code> 函数可以反序列化生成的字符串，重建原始的表结构，包括其循环引用。</li></ul><p><strong>注意事项：</strong></p><ul><li><strong>循环引用处理</strong>：在序列化时需要特别注意循环引用的处理。</li><li><strong>安全性</strong>：反序列化时，确保字符串来自可信的来源。</li><li><strong>复杂度</strong>：带循环引用的表的序列化和反序列化逻辑比不带循环引用的表更复杂，可能需要更多的错误处理和边界情况检</li></ul><h2 id="10-2-字节流"><a href="#10-2-字节流" class="headerlink" title="10.2 字节流"></a>10.2 字节流</h2><p>当我们需要对序列化后的字符流进行加密传输时，将字符流转成字节流，然后再进行加密操作，是一个不错的选择。</p><p>将序列化后的字符串（字符流）转换为字节流，以及将字节流转回字符串，在 Lua 中可以通过一些基本的字符串操作来实现。这里有两个步骤：首先将字符串转换为字节流，然后再将字节流转换回字符串。</p><p>有四个相关的函数：</p><ul><li><code>string.byte()</code><br>将目标字符转化为字节</li><li><code>string.char()</code><br>将目标字节转化为字符</li><li><code>string.pack</code><br>将目标字符流转化为字节流</li><li><code>string.unpack</code><br>将目标字节流转化为字符流</li></ul><p><strong>两种方法对比：</strong></p><p><code>string.pack</code> 和 <code>string.unpack</code> 是 Lua 5.3 引入的两个非常强大的函数，专门用于处理字节流和二进制数据。这些函数提供了一种更高效、更系统化的方式来处理字节流的打包（序列化）和解包（反序列化）。</p><p>使用 <code>string.pack</code> 和 <code>string.unpack</code> 而不是手动处理字节流的好处包括：</p><ol><li><strong>效率更高</strong>：这些函数是为高效处理二进制数据而设计的，比手动遍历字符串和构建字节表要高效得多。</li><li><strong>更广泛的数据类型支持</strong>：可以处理各种数据类型，包括整数、浮点数、字符串等，并允许指定不同的字节大小和端序。</li><li><strong>更简单的语法</strong>：只需一行代码就能完成复杂的数据打包和解包操作，而不是多行循环和条件语句。</li><li><strong>更好的数据控制</strong>：可以精确控制数据如何被编码和解码，例如指定整数是 32 位还是 64 位，是大端序还是小端序。</li></ol><h3 id="10-2-1-字符流转字节流"><a href="#10-2-1-字符流转字节流" class="headerlink" title="10.2.1 字符流转字节流"></a>10.2.1 字符流转字节流</h3><h4 id="string-pack"><a href="#string-pack" class="headerlink" title="string.pack()"></a>string.pack()</h4><p><strong>功能：</strong><br>将目标字符流打包成字节流，这个函数特别适用于需要将数据以二进制形式存储或传输的场景。</p><p><strong>参数：</strong></p><ul><li><strong>格式字符串</strong>：<br>定义了如何将参数打包成二进制数据。它由一系列格式字符组成，每个字符指定一个值的类型和大小。</li><li><strong>值</strong>：<br>根据格式字符串指定的类型和数量，传入的值将被打包成二进制形式。</li></ul><p><strong>格式字符串：</strong></p><ul><li><p><strong>基本格式字符：</strong></p><ul><li><p><code>b</code>：一个有符号的字节（8 位）。</p></li><li><p><code>B</code>：一个无符号的字节（8 位）。</p></li><li><p><code>h</code>：一个有符号的短整数（16 位）。</p></li><li><p><code>H</code>：一个无符号的短整数（16 位）。</p></li><li><p><code>l</code>：一个有符号的长整数（32 位）。</p></li><li><p><code>L</code>：一个无符号的长整数（32 位）。</p></li><li><p><code>j</code>：一个有符号的 lua_Integer。</p></li><li><p><code>J</code>：一个无符号的 lua_Integer。</p></li><li><p><code>T</code>：一个无符号的 size_t。</p></li><li><p><code>f</code>：一个单精度浮点数（32 位）。</p></li><li><p><code>d</code>：一个双精度浮点数（64 位）。</p></li><li><p><code>n</code>：一个 lua_Number。</p></li><li><p><code>i[n]</code>：一个 n 位的有符号整数。例如，<code>i16</code> 表示 16 位有符号整数。</p></li><li><p><code>I[n]</code>：一个 n 位的无符号整数。例如，<code>I16</code> 表示 16 位无符号整数。</p></li><li><p><code>s[n]</code>：<br>一个长度前缀的字符串，<code>n</code> 是长度字段的大小（默认为 <code>size_t</code>）。例如，<code>s2</code> 表示使用 2 字节长度前缀的字符串。</p></li><li><p><code>c[n]</code>：<br>一个固定长度的字符串，由 <code>n</code> 指定长度。如果字符串短于 <code>n</code>，则用零填充；如果长于 <code>n</code>，则截断。</p></li><li><p><code>z</code>：以零结尾的字符串。</p></li><li><p><code>x</code>：一个填充字节（忽略的字节）。</p></li><li><p><code>Xop</code>：<br>对齐选项，<code>op</code> 是一个数字，用于指定数据的对齐方式。例如，<code>X4</code> 表示 4 字节对齐。</p></li></ul></li><li><p><strong>复合格式字符：</strong></p><ul><li><p><code>A</code>：一个以长度 <code>A</code> 对齐的块（<code>A</code> 是一个数字）。</p></li><li><p><code>&gt;</code>：后续的数据采用大端序（网络序）。</p></li><li><p><code>&lt;</code>：后续的数据采用小端序。</p></li></ul></li></ul><p><strong>注意事项：</strong></p><ul><li>不同平台和不同 Lua 版本对于整数和浮点数的处理可能有所不同，特别是在大小（32 位 vs 64 位）和字节序（大端 vs 小端）方面。</li><li>在使用 <code>s[n]</code>、<code>c[n]</code> 和 <code>z</code> 时要注意字符串的长度和结束符，以避免数据截断或错误的填充。</li><li><code>x</code> 和 <code>Xop</code> 对于处理特定格式的二进制数据（如协议字段对齐）很有用，但在一般用途中可能不常见。</li><li>使用大端序或小端序格式字符（<code>&gt;</code> 和 <code>&lt;</code>）可以确保在不同架构的系统间正确交换数据。</li></ul><p><strong>返回值：</strong><br>返回一个二进制字符串，其中包含按照格式字符串指定的方式打包的所有值。</p><p><strong>使用案例:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> num1, num2 = <span class="hljs-number">123</span>, <span class="hljs-number">456</span><br><span class="hljs-keyword">local</span> str = <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-keyword">local</span> packed = <span class="hljs-built_in">string</span>.pack(<span class="hljs-string">&quot;i4i4s&quot;</span>, num1, num2, str)<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>i4</code> 表示一个 4 字节的整数，<code>s</code> 表示一个长度前缀的字符串。<br>函数将 <code>num1</code>、<code>num2</code> 和 <code>str</code> 打包成一个二进制字符串。</p><p><strong>注意事项:</strong></p><ul><li>确保了解每个格式字符的含义，以正确地打包数据。</li><li>使用与系统架构一致的格式（如字节大小和端序）。</li><li>避免在安全敏感的应用中使用不受信任的格式字符串，以防止潜在的安全漏洞。</li></ul><h4 id="string-byte"><a href="#string-byte" class="headerlink" title="string.byte()"></a>string.byte()</h4><p><strong>功能：</strong><br>用于提取字符串中一个或多个字符的数值编码。这在需要分析或操作字符串的单个字符时非常有用。</p><p><strong>参数：</strong></p><ol><li><strong>字符串</strong>：需要提取字节的字符串。</li><li><strong>开始位置</strong>（可选）：从字符串中提取字节的起始位置，默认为 1（字符串的开始）。</li><li><strong>结束位置</strong>（可选）：提取字节的结束位置，默认为开始位置，即默认提取单个字节。</li></ol><p><strong>返回值：</strong><br>返回从指定位置开始的一个或多个字符的整数 ASCII（或 Unicode）值。如果指定了范围，则返回对应范围内每个字符的 ASCII 值。</p><p><strong>使用案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> str = <span class="hljs-string">&quot;Hello, Lua!&quot;</span><br><span class="hljs-keyword">local</span> ascii = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">byte</span>(str, <span class="hljs-number">1</span>) <span class="hljs-comment">-- 提取第一个字符的ASCII值</span><br><span class="hljs-built_in">print</span>(ascii) <span class="hljs-comment">-- 输出 72，即字符 &#x27;H&#x27; 的 ASCII 值</span><br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>字符串索引从 1 开始，不是从 0 开始。</li><li>确保索引在字符串的有效范围内，否则 <code>string.byte</code> 返回 <code>nil</code>。</li><li>对于非标准 ASCII 字符（如 Unicode 字符），返回值可能不是预期的单字节编码。</li></ul><h3 id="10-2-2-字节流转字符流"><a href="#10-2-2-字节流转字符流" class="headerlink" title="10.2.2 字节流转字符流"></a>10.2.2 字节流转字符流</h3><h4 id="string-unpack"><a href="#string-unpack" class="headerlink" title="string.unpack"></a>string.unpack</h4><p><strong>功能：</strong><br>用于从二进制字符串中解析出按照指定格式打包的数据。<br>它与 <code>string.pack</code> 相对应，用于读取由 <code>string.pack</code> 生成的二进制数据。</p><p><strong>参数：</strong></p><ul><li><strong>格式字符串</strong>：<br>与 <code>string.pack</code> 使用的格式字符串相同，定义了如何从二进制数据中解析值。</li><li><strong>二进制字符串</strong>：<br>包含了要解包的数据。</li><li><strong>初始位置</strong>（可选）：<br>从二进制字符串中开始解包的位置，默认为 1。</li></ul><p><strong>返回值：</strong><br>返回解包后的值，以及下一个未处理字节的位置。</p><p><strong>使用案例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> num1, num2, str, pos = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">unpack</span>(<span class="hljs-string">&quot;i4i4s&quot;</span>, packed)<br><span class="hljs-built_in">print</span>(num1, num2, str)  <span class="hljs-comment">-- 输出 123, 456, &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，使用与打包时相同的格式字符串来解包 <code>packed</code> 字符串，获取原始的值。</p><p><strong>注意事项：</strong></p><ul><li>确保解包格式与打包时使用的格式一致。</li><li>在处理大型或复杂的二进制数据时要注意性能和内存使用。</li><li>解包时要考虑数据对齐和端序，特别是在跨平台应用中。</li></ul><h4 id="string-char"><a href="#string-char" class="headerlink" title="string.char()"></a>string.char()</h4><p><strong>功能：</strong><br>用于根据提供的一个或多个 ASCII 值构造字符串。这在需要从字符编码生成字符串时非常有用。</p><p><strong>参数:</strong><br>接受一个或多个整数作为参数，每个整数对应一个字符的 ASCII（或 Unicode）值。</p><p><strong>返回值:</strong><br>返回一个字符串，由所有提供的 ASCII 值对应的字符组成。</p><p><strong>案例:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> charStr = <span class="hljs-built_in">string</span>.<span class="hljs-built_in">char</span>(<span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>) <span class="hljs-comment">-- 使用 ASCII 值构造字符串</span><br><span class="hljs-built_in">print</span>(charStr) <span class="hljs-comment">-- 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><p><strong>注意事项:</strong></p><ul><li>ASCII 值应在有效的字符编码范围内（通常是 0 到 255）。</li><li>对于非单字节编码（如 Unicode），<code>string.char</code> 可能无法正确生成预期字符。</li><li>当使用超出有效范围的值时，行为可能是未定义的。</li></ul><h2 id="练习题-7"><a href="#练习题-7" class="headerlink" title="练习题"></a>练习题</h2><p><strong>题目描述</strong>： 编写一个 Lua 程序，包括以下功能：</p><ol><li><strong>序列化</strong>：<br>编写一个函数 <code>serializeTable</code>，它接受一个可能包含循环引用的表，并将其序列化为一个字符串。确保处理循环引用的情况。</li><li><strong>反序列化</strong>：<br>编写一个函数 <code>deserializeTable</code>，它接受一个序列化的字符串，并将其反序列化为 Lua 表。</li><li><strong>字节流转换</strong>：<ul><li>编写一个函数 <code>convertToByteStream</code>，将给定的字符串使用 <code>string.pack</code> 转换为字节流。</li><li>编写一个函数 <code>convertFromString</code>，将给定的字节流使用 <code>string.unpack</code> 转换回原始字符串。</li></ul></li><li><strong>测试</strong>：<br>在测试部分，创建一个包含循环引用的表，序列化它，然后反序列化，并展示转换字节流的过程。</li></ol><p><strong>示例代码框架</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">serializeTable</span><span class="hljs-params">(tbl)</span></span><br>    <span class="hljs-comment">-- 你的代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deserializeTable</span><span class="hljs-params">(serializedStr)</span></span><br>    <span class="hljs-comment">-- 你的代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertToByteStream</span><span class="hljs-params">(str)</span></span><br>    <span class="hljs-comment">-- 你的代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertFromString</span><span class="hljs-params">(byteStream)</span></span><br>    <span class="hljs-comment">-- 你的代码</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 测试</span><br><span class="hljs-keyword">local</span> testTable = &#123;name = <span class="hljs-string">&quot;Lua&quot;</span>&#125;<br>testTable.<span class="hljs-built_in">self</span> = testTable  <span class="hljs-comment">-- 创建循环引用</span><br><br><span class="hljs-keyword">local</span> serialized = serializeTable(testTable)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Serialized:&quot;</span>, serialized)<br><br><span class="hljs-keyword">local</span> deserialized = deserializeTable(serialized)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deserialized:&quot;</span>, deserialized.name, deserialized.<span class="hljs-built_in">self</span>.name)<br><br><span class="hljs-keyword">local</span> byteStream = convertToByteStream(serialized)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Byte Stream:&quot;</span>, byteStream)<br><br><span class="hljs-keyword">local</span> originalString = convertFromString(byteStream)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Original String:&quot;</span>, originalString)<br></code></pre></td></tr></table></figure><p><strong>预期输出</strong>：</p><ul><li>序列化的字符串表示。</li><li>反序列化的表内容。</li><li>字节流表示。</li><li>字节流转换回的原始字符串。</li></ul><h1 id="11-垃圾收集"><a href="#11-垃圾收集" class="headerlink" title="11. 垃圾收集"></a>11. 垃圾收集</h1><p>Lua语言通过垃圾收集(GarbageCollection)自动地删除成为垃圾的对象，从而将程序员从内存管理的绝大部分负担中解放出来，例如无效指针，内存泄露等问题。</p><p>Lua的GC的主要机制有3部分</p><ul><li>弱引用表(weak table)<br>用于收集Lua中还可以被程序访问的对象</li><li>析构器(finalizer)<br>用于收集不在垃圾收集器直接控制下的外部对象</li><li>collectgarbage函数<br>用于控制垃圾收集器的步长</li></ul><h2 id="11-1-垃圾收集器"><a href="#11-1-垃圾收集器" class="headerlink" title="11.1 垃圾收集器"></a>11.1 垃圾收集器</h2><p>Lua 中的垃圾收集（Garbage Collection，简称 GC）是一种自动内存管理机制，用于回收程序不再使用的内存。</p><p>Lua 的垃圾回收器基于标记-清除算法，并通过一些优化来提高效率。</p><h3 id="11-1-1-原理"><a href="#11-1-1-原理" class="headerlink" title="11.1.1 原理"></a>11.1.1 原理</h3><p><strong>以下是 Lua 垃圾回收的基本原理：</strong></p><ol><li><strong>可达性分析</strong>：<br>Lua 的垃圾回收器主要通过可达性分析来判断对象（如表、函数、用户数据等）是否还“活着”。<br>一个对象如果可以从全局变量或某个活跃的栈上的变量通过一系列引用访问到，那么这个对象就被认为是可达的，即它还“活着”。</li><li><strong>标记-清除算法</strong>：<br>Lua 垃圾回收的核心是标记-清除算法，该算法分为两个阶段：<ul><li><strong>标记阶段</strong>：遍历所有可达的对象，并标记它们为活动的。</li><li><strong>清除阶段</strong>：遍历所有对象，回收那些未被标记的对象所占用的内存。</li></ul></li><li><strong>增量收集</strong>：<br>为了避免长时间的暂停（Pause），Lua 实现了增量垃圾回收。在增量回收中，垃圾回收过程被分解成一系列小步骤，这些步骤在程序的执行过程中逐渐完成。</li></ol><p>Lua 选择使用基于可达性的标记-清除算法主要是因为它提供了更好的处理循环引用的能力，并且对于 Lua 这样的动态语言来说，它能更有效地处理各种复杂的数据结构。虽然这种方式可能会导致垃圾回收时的暂停时间相对较长，但通过增量收集的策略，Lua 成功地将这种影响降到了最低。</p><p><strong>以下是 Lua 垃圾回收的过程：</strong></p><ol><li><strong>开始阶段</strong>：<br>垃圾收集开始时，所有对象都是未标记的。</li><li><strong>根集合标记</strong>：<br>首先标记根集合，根集合通常包括全局变量和当前活跃的函数参数、局部变量等。</li><li><strong>传递标记</strong>：<br>从根集合开始，遍历所有可达的对象。对于每个可达的对象，标记它并遍历它引用的所有对象。</li><li><strong>清除阶段</strong>：<br>完成标记后，清除所有未标记的对象。</li><li><strong>结束</strong>：<br>垃圾回收结束，程序继续运行直到下一次垃圾回收启动。</li></ol><p><strong>注意事项：</strong></p><ul><li><strong>性能考虑</strong>：<br>虽然 Lua 的垃圾回收器设计得比较高效，但在内存使用密集或性能关键的程序中，不当的垃圾回收设置可能会导致性能问题。</li><li><strong>可达性与循环引用</strong>：<br>在设计数据结构时，需要注意循环引用的问题，因为它们可能会阻止垃圾回收器回收相关的对象。</li></ul><p>Lua 的垃圾回收机制在大多数情况下都能很好地工作，但了解其工作原理可以帮助你更好地管理内存使用，特别是在开发大型或资源敏感的应用程序时。</p><h3 id="11-1-2-collectgarbage-函数"><a href="#11-1-2-collectgarbage-函数" class="headerlink" title="11.1.2 collectgarbage 函数"></a>11.1.2 collectgarbage 函数</h3><p><code>collectgarbage</code> 函数在 Lua 中用于控制和监控垃圾回收器的行为。</p><p><strong>功能：</strong></p><ol><li><strong>手动控制垃圾回收</strong>：允许手动触发或停止垃圾回收过程。</li><li><strong>调整垃圾回收器行为</strong>：修改垃圾回收器的操作参数。</li><li><strong>监控内存使用</strong>：提供当前使用的内存量信息。</li></ol><p><strong>应用场景：</strong></p><ol><li><strong>性能优化</strong>：在性能关键的时刻控制垃圾回收，以避免自动垃圾回收带来的性能波动。</li><li><strong>内存管理</strong>：在内存使用达到特定阈值时手动触发垃圾回收。</li><li><strong>资源紧张的环境</strong>：在资源受限的环境下（如嵌入式设备），更精细地管理内存使用。</li><li><strong>调试和测试</strong>：识别和解决内存泄漏或其他内存相关问题。</li></ol><p><strong>参数：</strong></p><p><code>collectgarbage</code> 函数可以接受以下参数，用于指定不同的操作：</p><ol><li><p>**”collect”**：执行一次完整的垃圾回收循环。<br><code>collectgarbage(&quot;collect&quot;)</code></p></li><li><p>**”stop”**：停止垃圾回收器的自动运行。<br><code>collectgarbage(&quot;stop&quot;)</code></p></li><li><p>**”restart”**：重新启动垃圾回收器的自动运行。<br><code>collectgarbage(&quot;restart&quot;)</code></p></li><li><p>**”count”**：返回当前使用的内存量（以千字节为单位）。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取当前使用的内存量（以千字节为单位）</span><br><span class="hljs-keyword">local</span> memoryUsed = <span class="hljs-built_in">collectgarbage</span>(<span class="hljs-string">&quot;count&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Memory used (in KB):&quot;</span>, memoryUsed)<br></code></pre></td></tr></table></figure></li><li><p>**”step”**：执行垃圾回收的一个步骤。参数是一个整数，表示要运行的步数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 执行一定数量的垃圾收集步骤</span><br><span class="hljs-keyword">local</span> stepCount = <span class="hljs-number">200</span><br><span class="hljs-built_in">collectgarbage</span>(<span class="hljs-string">&quot;step&quot;</span>, stepCount)<br></code></pre></td></tr></table></figure></li><li><p>**”setpause”**：设置垃圾回收的暂停时间。参数是一个百分比值。<br><code>collectgarbage(&quot;setpause&quot;, value)</code><br><code>value</code> 表示在完成一次垃圾收集后，Lua 分配的内存达到上次收集后内存使用量的多少百分比时，将再次启动垃圾收集器。这个值决定了垃圾收集的“积极程度”。</p><blockquote><p>可以简单理解为堆多少垃圾清理一次</p></blockquote></li><li><p>**”setstepmul”**：设置垃圾回收的步进倍率。参数是一个整数。<br><code>collectgarbage(&quot;setstepmul&quot;, value)</code><br>这里的 <code>value</code> 是一个整数，表示垃圾收集器在每次 Lua 分配内存时执行的工作量。</p><blockquote><p>可以简单理解为清理一次垃圾要清理多少</p></blockquote></li></ol><p><strong>返回值：</strong></p><ul><li><strong>对于 “collect”、”stop”、”restart”、”step”、”setpause” 和 “setstepmul” 模式</strong>：<br>无返回值。</li><li><strong>对于 “count” 模式</strong>：<br>返回当前使用的内存量，单位是千字节。</li></ul><p><strong>注意事项：</strong></p><ol><li><strong>性能考虑</strong>：<br>过度或不当使用 <code>collectgarbage</code> 可能会对程序性能产生不利影响。特别是在高性能需求的场景中，应谨慎使用。</li><li><strong>内存管理平衡</strong>：<br>手动管理内存可能会打破 Lua 内建的内存管理机制的平衡，需根据具体场景合理使用。</li><li><strong>调试用途</strong>：<br>在调试和测试阶段，使用 <code>collectgarbage</code> 可以帮助识别内存问题，但在生产环境中应避免依赖它来解决内存泄漏等问题。</li><li><strong>步进调整</strong>：<br>在调整步进倍率（”setstepmul”）和暂停时间（”setpause”）时，应理解它们对垃圾回收行为的影响，以避免产生意外的副作用。</li></ol><h2 id="11-2-弱引用表"><a href="#11-2-弱引用表" class="headerlink" title="11.2 弱引用表"></a>11.2 弱引用表</h2><h3 id="11-2-1-基础原理"><a href="#11-2-1-基础原理" class="headerlink" title="11.2.1 基础原理"></a>11.2.1 基础原理</h3><p>Lua 中的弱引用表是一个非常重要的概念，特别是在处理垃圾回收和内存管理时。</p><p>在 Lua 中，表（table）可以被设定为弱引用表。<br>在弱引用表中，表的键值（key）或值（value）不会阻止所引用的对象被垃圾回收器回收。这是通过设置表的元表中的 <code>__mode</code> 字段来实现的。</p><p><strong>弱引用表的功能如下：</strong></p><ol><li><strong>避免循环引用</strong>：<br>弱引用表是解决循环引用问题的有效工具。<br>在循环引用中，即使对象不再被程序使用，由于相互引用，它们的引用计数不会降至零，导致无法被正常回收。弱引用表允许这些对象被回收。</li><li><strong>缓存对象</strong>：<br>弱引用表常用于缓存，允许缓存的对象在不再被其他地方引用时自动释放。</li></ol><p><strong>弱引用表的类型：</strong></p><ul><li><p><strong>弱键（weak keys）</strong>：<br><strong>设置方法</strong>：在表的元表中设置 <code>__mode</code> 字段为 <code>&quot;k&quot;</code>。<br><strong>特点：</strong></p><ul><li>表的键不会阻止所引用的对象被垃圾回收器回收。</li><li>一旦键所引用的对象被回收，与之关联的键值对也会从表中删除。</li></ul><p><strong>应用场景：</strong><br>常用于需要关联额外数据到对象上，但不希望这种关联阻止对象被回收的情况。<br>例如，为对象附加元数据或属性，而不影响其生命周期。</p></li><li><p><strong>弱值（weak values）</strong>：<br><strong>设置方法</strong>：在表的元表中设置 <code>__mode</code> 字段为 <code>&quot;v&quot;</code>。<br><strong>特点：</strong></p><ul><li>表的值不会阻止所引用的对象被垃圾回收器回收。</li><li>一旦值所引用的对象被回收，相应的键值对也会从表中删除。</li></ul><p><strong>应用场景：</strong><br>常用于缓存或临时存储数据，其中数据可以被自动清理而不影响程序的其他部分。<br>例如，缓存一些可能再次需要的计算结果，但这些结果并不是必需的。</p></li><li><p><strong>同时弱键和弱值</strong>：<br><strong>设置方法</strong>：在表的元表中设置 <code>__mode</code> 字段为 <code>&quot;kv&quot;</code>。<br><strong>特点：</strong></p><ul><li>同时应用弱键和弱值的特性。</li><li>只要键或值被回收，相应的键值对就会从表中删除。</li></ul><p><strong>应用场景：</strong><br>当需要建立对象之间的关联，但不希望这些关联影响对象的生命周期时使用。<br>例如，在对象之间建立双向引用或关联，但不希望它们因为相互引用而无法被回收。</p></li></ul><p><strong>注意事项：</strong></p><ul><li>使用弱引用表时要小心，因为它们中的对象可能随时被回收。</li><li>弱引用表的行为可能会导致程序难以调试，特别是在涉及内存管理的问题时。</li></ul><p>弱引用表在内存管理方面提供了很大的灵活性。<br>通过控制键和值的弱引用性质，可以创建出各种有用的数据结构，如缓存、关联存储、元数据管理等，同时避免了循环引用或不必要的内存占用问题。<br>然而，使用弱引用表时也需要小心，因为其中的数据可能随时被垃圾回收器回收，因此应确保程序逻辑考虑到这一点。</p><h3 id="11-2-2-使用方法"><a href="#11-2-2-使用方法" class="headerlink" title="11.2.2 使用方法"></a>11.2.2 使用方法</h3><p>创建一个弱引用表，其值为弱引用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> a = &#123;&#125;  <span class="hljs-comment">-- 创建一个普通表</span><br><span class="hljs-keyword">local</span> b = &#123;&#125;  <span class="hljs-comment">-- 创建另一个普通表</span><br><br><span class="hljs-comment">-- 设置一个弱引用表</span><br><span class="hljs-keyword">local</span> weakTable = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="hljs-built_in">__mode</span> = <span class="hljs-string">&quot;v&quot;</span>&#125;)<br>weakTable[a] = b  <span class="hljs-comment">-- 在弱引用表中设置一个键值对</span><br><br><span class="hljs-comment">-- 检查弱引用表中的内容</span><br><span class="hljs-built_in">print</span>(weakTable[a])  <span class="hljs-comment">-- 输出表 b</span><br><br><span class="hljs-comment">-- 删除原始引用</span><br>a = <span class="hljs-literal">nil</span>  <span class="hljs-comment">-- 删除对表 a 的引用</span><br><span class="hljs-built_in">collectgarbage</span>()  <span class="hljs-comment">-- 执行垃圾回收</span><br><br><span class="hljs-comment">-- 再次检查弱引用表中的内容</span><br><span class="hljs-built_in">print</span>(weakTable[a])  <span class="hljs-comment">-- 输出 nil，因为表 b 已被回收</span><br></code></pre></td></tr></table></figure><p>在这个例子中，由于 <code>weakTable</code> 是一个弱引用表，当删除对 <code>a</code> 的引用并进行垃圾回收后，与 <code>a</code> 相关联的值 <code>b</code> 也被回收，因为没有其他强引用指向它。</p><h3 id="11-2-3-实际应用"><a href="#11-2-3-实际应用" class="headerlink" title="11.2.3 实际应用"></a>11.2.3 实际应用</h3><h4 id="记忆函数"><a href="#记忆函数" class="headerlink" title="记忆函数"></a>记忆函数</h4><p>在 Lua 中，使用弱引用表实现记忆函数（Memoization）是一种优化技术，用于提高具有重复计算的函数的性能。</p><p>记忆函数通过缓存以前的计算结果来避免重复的计算。</p><p><strong>原理:</strong></p><ul><li><strong>缓存计算结果</strong>：<br>记忆函数通过创建一个内部缓存（在本例中为 <code>cache</code>），用于存储函数参数和对应的计算结果。</li><li><strong>键值对</strong>：<br>函数的参数被用作键，计算结果被存储为值。</li><li><strong>弱引用</strong>：<br>使用弱引用表作为缓存，确保缓存中的内容不会阻止垃圾回收器回收它们所引用的对象。</li></ul><p><strong>功能:</strong></p><ul><li><strong>减少重复计算</strong>：对于具有重复输入的函数，记忆函数避免了重复计算，通过从缓存中检索结果来提高效率。</li><li><strong>自动管理缓存</strong>：使用弱引用表自动管理缓存，当缓存的数据不再被其他地方引用时，它们可以被垃圾回收。</li></ul><p><strong>适用场景:</strong></p><ul><li><strong>递归函数</strong>：例如，斐波那契数列的计算。</li><li><strong>计算成本高的函数</strong>：对于计算成本高且经常被重复调用的函数。</li><li><strong>函数的输出仅取决于输入</strong>：即纯函数（Pure Function）。</li></ul><p><strong>注意事项:</strong></p><ul><li><strong>内存使用</strong>：<br>虽然弱引用表会自动管理内存，但如果函数的输入范围非常大，缓存可能会占用大量内存。</li><li><strong>并发环境</strong>：<br>在多线程或并发环境中，需要考虑线程安全和同步问题。</li><li><strong>纯函数</strong>：<br>记忆函数最适合应用于纯函数，即函数的输出完全由输入决定，没有副作用。</li></ul><p>示例：使用弱引用表实现的记忆函数</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span><span class="hljs-params">(f)</span></span><br>    <span class="hljs-keyword">local</span> cache = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="hljs-built_in">__mode</span> = <span class="hljs-string">&quot;kv&quot;</span>&#125;)  <span class="hljs-comment">-- 创建一个弱引用表</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(...)</span></span><br>        <span class="hljs-keyword">local</span> key = <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(&#123;...&#125;, <span class="hljs-string">&quot;,&quot;</span>)<br>        <span class="hljs-keyword">if</span> cache[key] <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> cache[key]  <span class="hljs-comment">-- 如果缓存中有结果，直接返回</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">local</span> result = f(...)<br>            cache[key] = result  <span class="hljs-comment">-- 将新的计算结果存储在缓存中</span><br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 示例：使用记忆函数优化斐波那契数列的计算</span><br><span class="hljs-keyword">local</span> fib = memoize(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span></span><br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> n <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)<br><span class="hljs-keyword">end</span>)<br><br><span class="hljs-built_in">print</span>(fib(<span class="hljs-number">10</span>))  <span class="hljs-comment">-- 计算第10个斐波那契数</span><br></code></pre></td></tr></table></figure><p>通过使用弱引用表实现的记忆函数，可以有效地提高函数的性能，尤其是在处理递归或计算密集型任务时。弱引用表的使用确保了缓存不会过度占用内存，从而平衡了性能和资源使用。</p><h4 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h4><p>使用弱引用表来实现对象属性是一种内存管理技术，它允许在对象不再被使用时自动释放其属性，从而避免内存泄漏。</p><p>这在创建临时或缓存对象时特别有用，因为它减少了程序员需要手动管理内存的负担。</p><p><strong>原理:</strong></p><ol><li><strong>弱引用表作为属性容器</strong>：<br>使用弱引用表作为存储对象属性的容器。<br>对象本身作为弱引用表的键，而与之相关的属性存储为对应的值。</li><li><strong>自动内存管理</strong>：<br>当对象不再被其他地方引用时，由于弱引用表的特性，这个对象以及它的属性将自动被垃圾回收器回收。</li></ol><p><strong>功能:</strong></p><ul><li><strong>属性存储</strong>：为每个对象提供一个用于存储其属性的空间。</li><li><strong>自动清理</strong>：当对象不再被引用时，自动清理与该对象关联的属性，减少内存占用。</li></ul><p><strong>适用场景:</strong></p><ul><li><strong>临时对象</strong>：<br>用于管理临时创建的对象及其属性，例如在游戏开发中的临时实体。</li><li><strong>缓存系统</strong>：<br>在实现缓存机制时，防止长期持有不再需要的对象。</li><li><strong>数据绑定</strong>：<br>当对象与外部资源（如UI元素）绑定时，确保在对象释放后自动释放这些资源。</li></ul><p><strong>注意事项:</strong></p><ul><li><strong>生命周期管理</strong>：<br>由于属性的生命周期与对象绑定，确保在对象生命周期内合理使用这些属性。</li><li><strong>调试难度</strong>：<br>由于属性可能随时被回收，调试相关问题可能会更加复杂。</li><li><strong>内存泄漏风险</strong>：<br>虽然弱引用表有助于自动内存管理，但仍需注意避免在其他地方意外持有对这些对象的引用，以免造成内存泄漏。</li></ul><p>通过使用弱引用表来存储对象属性，可以有效地管理对象的生命周期和相关资源，从而简化内存管理并提高程序的稳定性和性能。</p><p><strong>示例:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 创建一个存储对象属性的弱引用表</span><br><span class="hljs-keyword">local</span> properties = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, &#123; <span class="hljs-built_in">__mode</span> = <span class="hljs-string">&quot;k&quot;</span> &#125;)<br><br><span class="hljs-comment">-- 定义一个函数来创建新对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObject</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> obj = &#123;&#125;  <span class="hljs-comment">-- 创建一个新对象</span><br>    properties[obj] = &#123;&#125;  <span class="hljs-comment">-- 初始化对象的属性</span><br>    <span class="hljs-keyword">return</span> obj<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 定义一个函数来设置对象属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setProperty</span><span class="hljs-params">(obj, key, value)</span></span><br>    properties[obj][key] = value<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 定义一个函数来获取对象属性</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProperty</span><span class="hljs-params">(obj, key)</span></span><br>    <span class="hljs-keyword">return</span> properties[obj][key]<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">-- 使用示例</span><br><span class="hljs-keyword">local</span> myObject = createObject()<br>setProperty(myObject, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;My Object&quot;</span>)<br><span class="hljs-built_in">print</span>(getProperty(myObject, <span class="hljs-string">&quot;name&quot;</span>))  <span class="hljs-comment">-- 输出: My Object</span><br></code></pre></td></tr></table></figure><h4 id="瞬表"><a href="#瞬表" class="headerlink" title="瞬表"></a>瞬表</h4><p>在 Lua 中，瞬表（ephemeron table）是一种特殊类型的弱引用表，它解决了一些传统弱引用表无法处理的特殊情况。瞬表主要用于在键和值之间建立弱引用关系，而这种关系的弱引用性取决于键是否还被其他地方引用。以下是瞬表的原理、功能、适用场景和注意事项的说明。</p><p><strong>原理:</strong></p><ol><li><strong>键值间的弱引用关系</strong>：<br>在瞬表中，值的生命周期取决于键的生命周期。<br>只要键是可访问的，与之关联的值也会被保留。<br>当键不再被访问时，与其关联的值可以被垃圾回收器回收。</li><li><strong>垃圾回收的处理</strong>：<br>Lua 的垃圾回收器在处理瞬表时，会特别检查这种键值依赖关系。<br>如果一个值只被它的键所引用，那么这个键值对可以被回收。</li></ol><p><strong>功能:</strong></p><ul><li><strong>处理特殊的弱引用情况</strong>：<br>瞬表允许创建键到值的弱引用，其中值的生命周期依赖于键。</li><li><strong>自动内存管理</strong>：<br>在键不再被其他地方引用时，自动回收与键关联的值。</li></ul><p><strong>适用场景:</strong></p><ul><li><strong>缓存机制</strong>：<br>用于实现缓存，其中缓存项（值）依赖于特定的对象（键）。</li><li><strong>资源管理</strong>：<br>管理与对象关联的资源，例如，当对象被销毁时，自动释放与之关联的资源。</li><li><strong>数据绑定</strong>：<br>在数据绑定场景中，当数据对象不再存在时，自动清理绑定的UI元素或其他资源。</li></ul><p><strong>注意事项:</strong></p><ul><li><strong>对垃圾回收的依赖</strong>：瞬表的行为依赖于垃圾回收的实现和时机。</li><li><strong>调试难度</strong>：由于瞬表中的数据可能随时被回收，调试相关问题可能较为复杂。</li><li><strong>正确的使用</strong>：确保理解瞬表的工作原理和限制，避免不当使用导致的潜在问题。</li></ul><p><strong>示例:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 创建一个瞬表</span><br><span class="hljs-keyword">local</span> ephemeron = <span class="hljs-built_in">setmetatable</span>(&#123;&#125;, &#123; <span class="hljs-built_in">__mode</span> = <span class="hljs-string">&quot;k&quot;</span> &#125;)<br><br><span class="hljs-comment">-- 示例对象和属性</span><br><span class="hljs-keyword">local</span> key = &#123;&#125;  <span class="hljs-comment">-- 对象</span><br><span class="hljs-keyword">local</span> value = <span class="hljs-string">&quot;some value&quot;</span>  <span class="hljs-comment">-- 与对象相关联的值</span><br><br><span class="hljs-comment">-- 在瞬表中设置键值对</span><br>ephemeron[key] = value<br><br><span class="hljs-comment">-- 使用瞬表</span><br><span class="hljs-built_in">print</span>(ephemeron[key])  <span class="hljs-comment">-- 输出: some value</span><br><br><span class="hljs-comment">-- 当键不再被引用时，与其关联的值可以被回收</span><br>key = <span class="hljs-literal">nil</span><br><span class="hljs-built_in">collectgarbage</span>()  <span class="hljs-comment">-- 强制进行垃圾回收</span><br><br><span class="hljs-comment">-- 尝试访问原先的值</span><br><span class="hljs-built_in">print</span>(ephemeron[key])  <span class="hljs-comment">-- 输出: nil，因为键值对已被回收</span><br></code></pre></td></tr></table></figure><p>瞬表是 Lua 中处理复杂内存管理场景的强大工具，但需要对其行为有足够的了解和正确的使用方式，以确保程序的稳定性和性能。</p><h2 id="11-3-析构器"><a href="#11-3-析构器" class="headerlink" title="11.3 析构器"></a>11.3 析构器</h2><p>在 Lua 中，析构器的概念与在其他一些面向对象编程语言中的析构器略有不同。<br>由于 Lua 是一种基于原型的脚本语言，它不具备内建的类或对象系统，也没有像 C++ 或 Java 那样的析构方法。</p><p>然而，Lua 提供了一种机制，称为“元方法”，其中特别的 <code>__gc</code> 元方法可以用来模拟析构器的行为。</p><p><strong>原理：</strong><br><strong>__gc 元方法</strong>：<br>在 Lua 中，当一个具有 <code>__gc</code> 元方法的表被垃圾回收器准备回收时，<code>__gc</code> 元方法会被调用。这提供了一个执行清理任务的机会，类似于其他语言中的析构器。</p><blockquote><p><strong>仅对用户数据有效</strong>：<br>在 Lua 5.1 版本中，<code>__gc</code> 元方法仅对用户数据（userdata）有效。<br>从 Lua 5.2 版本开始，普通的表也可以拥有 <code>__gc</code> 元方法。</p></blockquote><p><strong>功能:</strong></p><ul><li><strong>清理资源</strong>：<br>在对象不再需要时，自动执行清理操作，如关闭文件、释放内存等。</li><li><strong>自动化管理</strong>：<br>管理对象的生命周期，确保在对象生命周期结束时自动执行所需的清理逻辑。</li></ul><p><strong>适用场景:</strong></p><ul><li><strong>资源管理</strong>：<br>用于管理需要显式释放的资源，如文件句柄、网络连接、动态分配的内存等。</li><li><strong>复杂对象清理</strong>：<br>清理那些具有复杂状态或需要执行特殊清理逻辑的对象。</li></ul><p><strong>注意事项:</strong></p><ul><li><strong>确保被回收</strong>：<br>Lua 的垃圾回收机制基于可达性分析，确保对象最终变得不可达以触发析构器。</li><li><strong>避免依赖析构器顺序</strong>：<br>由于垃圾回收的顺序是不确定的，应避免编写依赖于析构器调用顺序的代码。</li><li><strong>不适用于立即清理</strong>：<br>析构器的调用取决于垃圾回收器的运行，可能不会立即执行。</li></ul><p><strong>示例:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 创建一个可以拥有析构器行为的表</span><br><span class="hljs-keyword">local</span> myObject = &#123;&#125;<br><br><span class="hljs-comment">-- 定义析构器行为</span><br><span class="hljs-keyword">local</span> mt = &#123;<br>    <span class="hljs-built_in">__gc</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(self)</span></span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;析构器被调用，资源被清理&quot;</span>)<br>    <span class="hljs-keyword">end</span><br>&#125;<br><br><span class="hljs-comment">-- 设置元表来启用析构器</span><br><span class="hljs-built_in">setmetatable</span>(myObject, mt)<br><br><span class="hljs-comment">-- 手动调用垃圾回收以触发析构器（仅用于演示）</span><br>myObject = <span class="hljs-literal">nil</span><br><span class="hljs-built_in">collectgarbage</span>()<br></code></pre></td></tr></table></figure><h2 id="练习题-8"><a href="#练习题-8" class="headerlink" title="练习题"></a>练习题</h2><h3 id="题目-1：实现一个记忆函数"><a href="#题目-1：实现一个记忆函数" class="headerlink" title="题目 1：实现一个记忆函数"></a>题目 1：实现一个记忆函数</h3><p>编写一个 Lua 函数 <code>memoize(f)</code>，它接收一个函数 <code>f</code> 并返回一个新的函数。这个新函数应该缓存 <code>f</code> 的结果，以避免对相同输入重复计算。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">memoize</span><span class="hljs-params">(foo)</span></span><br>    <span class="hljs-comment">--填写您的答案</span><br><span class="hljs-keyword">end</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span></span><br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> n <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)<br><span class="hljs-keyword">end</span><br><br>memoizedFib = memoize(fib)<br><span class="hljs-built_in">print</span>(memoizedFib(<span class="hljs-number">10</span>))  <span class="hljs-comment">-- 预计输出斐波那契数列的第10项</span><br></code></pre></td></tr></table></figure><h3 id="题目-2：使用弱引用表"><a href="#题目-2：使用弱引用表" class="headerlink" title="题目 2：使用弱引用表"></a>题目 2：使用弱引用表</h3><p>创建一个弱引用表 <code>weakTable</code>，其中键为弱引用。<br>插入几个键值对，然后删除对原始键的引用，强制进行垃圾回收，并验证键值对是否被自动移除。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 创建弱引用表</span><br><span class="hljs-comment">--填写您的答案</span><br>weakTable = ...<br><br><span class="hljs-comment">-- 插入键值对</span><br><span class="hljs-keyword">local</span> key1 = &#123;&#125;<br><span class="hljs-keyword">local</span> key2 = &#123;&#125;<br>weakTable[key1] = <span class="hljs-string">&quot;value1&quot;</span><br>weakTable[key2] = <span class="hljs-string">&quot;value2&quot;</span><br><br><span class="hljs-comment">-- 删除引用并进行垃圾回收</span><br>key1 = <span class="hljs-literal">nil</span><br><span class="hljs-built_in">collectgarbage</span>()<br><br><span class="hljs-comment">-- 检查键值对是否存在</span><br><span class="hljs-built_in">print</span>(weakTable[key1])  <span class="hljs-comment">-- 预计输出 nil</span><br><span class="hljs-built_in">print</span>(weakTable[key2])  <span class="hljs-comment">-- 预计输出 &quot;value2&quot;</span><br></code></pre></td></tr></table></figure><h3 id="题目-3：调整垃圾收集器行为"><a href="#题目-3：调整垃圾收集器行为" class="headerlink" title="题目 3：调整垃圾收集器行为"></a>题目 3：调整垃圾收集器行为</h3><p>编写代码来调整 Lua 垃圾收集器的行为。首先设置垃圾收集器暂停为 150%，然后设置步进倍率为 300%。最后，手动触发一次完整的垃圾收集周期，并输出当前内存使用量。</p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>Lua</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导航-实用工具</title>
    <link href="/2024/01/18/%E5%AF%BC%E8%88%AA-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2024/01/18/%E5%AF%BC%E8%88%AA-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="软件工具"><a href="#软件工具" class="headerlink" title="软件工具"></a>软件工具</h1><ul><li><a href="https://getsharex.com/">截屏 ShareX</a></li><li><a href="http://onecommander.com/">高级资源管理器 One Commander</a></li><li><a href="https://www.electronjs.org/">Electron 外部可视化工具框架</a></li><li><a href="https://github.com/DoodleBears/blivechat">弹幕展示 blivechat</a> ​</li><li><a href="https://www.kancloud.cn/lanlulululu/marukotoolbox_faq/1543965">小丸工具箱</a><h1 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h1></li><li><a href="https://www.xuanfengge.com/easeing/easeing/">缓动函数速查表</a></li><li><a href="https://c.runoob.com/front-end/854/">正则表达式在线测试 | 菜鸟工具</a></li><li><a href="https://graphtoy.com/">在线示波器 Graphtoy</a></li><li><a href="https://www.desmos.com/calculator?lang=zh-CN">Desmos | 图形计算器</a></li><li><a href="https://zeroroku.com/bilibili/rank/fans/desc">B站数据观测站</a><h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1></li><li><a href="https://bewildcard.com/">订阅海外软件服务GPT WildCard</a><br>  邀请码：<a href="https://bewildcard.com/i/ZEHE">https://bewildcard.com/i/ZEHE</a></li><li><a href="https://chat.openai.com/chat">ChatGPT</a><pre><code>mycroftcooper1@gmail.com mycroftcooper_1</code></pre></li><li> <a href="https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma">Chat大杂烩ChatHub</a></li><li>快速二次元建模 VRoid<ul><li>工具插件 <a href="https://github.com/xiaoye97/VRoidXYTool">https://github.com/xiaoye97/VRoidXYTool</a></li></ul></li><li><a href="https://soundraw.io/">AI作曲 Soundraw</a></li><li>AI画画<a href="https://huggingface.co/WarriorMama777/OrangeMixs/tree/main/Models">WarriorMama777/OrangeMixs at main</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>导航</category>
      
    </categories>
    
    
    <tags>
      
      <tag>导航</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导航-Unity相关</title>
    <link href="/2024/01/18/%E5%AF%BC%E8%88%AA-Unity%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/01/18/%E5%AF%BC%E8%88%AA-Unity%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><ul><li><a href="https://docs.unity3d.com/cn/current/Manual/UnityManual.html">Unity 用户手册 2020.3 (LTS) - Unity 手册</a></li><li><a href="https://unity3d.com/get-unity/download/archive">Unity非特供版下载</a></li><li><a href="https://www.logiconsole.com/fuck-unity-cn/">如何逃离Unity中国特供版</a></li><li><a href="https://assetstore.unity.com/">Unity资源商店</a><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1></li><li><a href="https://focus-creative-games.github.io/lubandoc/Home.html">鲁班 导表插件</a></li><li><a href="https://linxinfa.blog.csdn.net/article/details/124537415?spm=1001.2014.3001.5502">虚拟相机 Cinemachine 教程</a></li><li><a href="https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras@3.0/manual/index.html">2D瓦片扩展 2D Tilemap Extras</a></li><li><a href="https://blog.csdn.net/q764424567/article/details/105515409/">对话系统插件 Dialogue System 教程 </a></li><li><a href="https://github.com/needle-tools/compilation-visualizer">性能分析器</a></li><li><a href="https://www.gameres.com/875859.html">视频中间件</a><h2 id="Odin-编辑器增强"><a href="#Odin-编辑器增强" class="headerlink" title="Odin (编辑器增强)"></a>Odin (编辑器增强)</h2></li><li> <a href="https://odininspector.com/tutorials">Odin官网</a></li><li>教程：<br>  <a href="https://blog.csdn.net/su9257/article/details/103159984?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_antiscanv2&utm_relevant_index=5">革命性 Unity 编辑器扩展工具 — Odin Inspector 系列教程-CSDN 博客</a><br>  <a href="https://blog.csdn.net/zjz520yy/article/details/119940363">Unity Odin从入门到精通（一）：定制特性详解-CSDN博客</a><br>  <a href="https://www.jianshu.com/p/15dae2b764fe">Odin Inspector 系列教程 — 初识Odin序列化</a><h2 id="状态机行为树"><a href="#状态机行为树" class="headerlink" title="状态机行为树"></a>状态机行为树</h2></li><li><a href="https://opsive.com/support/documentation/behavior-designer/overview/">Behavior Designer 可视化行为树插件</a></li><li><a href="https://nodecanvas.paradoxnotion.com/documentation/?section=framework-concepts">NodeCanvas 可视化状态机/行为树插件 官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/413146333">NodeCanvas 可视化状态机/行为树插件 教程-知乎</a><h2 id="Spine-2D-骨骼动画"><a href="#Spine-2D-骨骼动画" class="headerlink" title="Spine (2D 骨骼动画)"></a>Spine (2D 骨骼动画)</h2><a href="http://zh.esotericsoftware.com/spine-unity#spine-unity-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%96%87%E6%A1%A3">Spine 官方运行时文档</a><h2 id="Ink-文本类脚本插件"><a href="#Ink-文本类脚本插件" class="headerlink" title="Ink (文本类脚本插件)"></a>Ink (文本类脚本插件)</h2></li><li> <a href="https://www.inklestudios.com/ink/">ink 官网</a></li><li><a href="https://github.com/inkle/inky">编辑器 inky</a></li><li><a href="https://www.inklestudios.com/ink/theintercept/">示例游戏 The Intercept</a><h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2></li><li><a href="https://github.com/Tencent/InjectFix">Bug 热修复 InjectFix git仓库</a></li><li><a href="https://zhuanlan.zhihu.com/p/363769414">Bug 热修复 InjectFix 教程</a><h2 id="Shader-拖拖乐"><a href="#Shader-拖拖乐" class="headerlink" title="Shader 拖拖乐"></a>Shader 拖拖乐</h2></li><li><a href="https://linxinfa.blog.csdn.net/article/details/108049048?spm=1001.2014.3001.5502">ShaderGraph 教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/531652423">ASE教程</a><h2 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h2></li><li><a href="https://github.com/vis2k/Mirror">Mirror</a><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1></li><li><a href="https://blog.csdn.net/qq_35361471/article/details/108975864">编辑器扩展教程</a></li><li><a href="https://blog.csdn.net/FifthGently/article/details/78363364">Unity 标签教程</a></li><li><a href="https://docs.unity3d.com/ScriptReference/Device.SystemInfo.html">设备信息查询 SystemInfo</a><h2 id="3C"><a href="#3C" class="headerlink" title="3C"></a>3C</h2></li><li><a href="https://github.com/mixandjam/Celeste-Movement">平台跳跃角色控制器 Celeste-Movement</a></li><li><a href="https://blog.csdn.net/zheliku/article/details/126775302">InputSystem 教程</a><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2></li><li><a href="https://blog.csdn.net/yr1102358773/article/details/123797265?spm=1001.2101.3001.6650.17&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-123797265-blog-127068201.pc_relevant_aa2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-123797265-blog-127068201.pc_relevant_aa2&utm_relevant_index=17">Text 组件自适应小知识</a><h2 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h2></li><li> <a href="https://zhuanlan.zhihu.com/p/421534861">射线检测的概念与应用</a><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2></li><li><a href="https://zhuanlan.zhihu.com/p/482843971">PlayerPrefs 教程</a></li><li><a href="https://blog.csdn.net/candycat1992/article/details/52181814">ScriptableObject 教程</a><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2></li><li><a href="https://zhuanlan.zhihu.com/p/141748334">IL2CPP 与 Mono 代码打包脚本后处理 Scripting Backend</a></li><li><a href="https://blog.csdn.net/weixin_42565127/article/details/115678460">StreamingAssets文件夹 教程</a><h3 id="资源管线"><a href="#资源管线" class="headerlink" title="资源管线"></a>资源管线</h3></li><li><a href="https://zhuanlan.zhihu.com/p/193012525?utm_source=wechat_timeline">资源导入预处理 AssetPostprocessor 教程</a><h3 id="AssetBundles"><a href="#AssetBundles" class="headerlink" title="AssetBundles"></a>AssetBundles</h3></li><li><a href="https://learn.unity.com/tutorial/assets-resources-and-assetbundles?_ga=2.234958339.324524613.1653278604-1577316881.1648608235#">AB 包官方教程</a></li><li><a href="https://www.zhihu.com/question/28609209/answer/226114934">AB 包核心原理</a> </li><li><a href="https://zhuanlan.zhihu.com/p/369080940">图集 AB 包组合拳教程</a><h3 id="Addressables"><a href="#Addressables" class="headerlink" title="Addressables"></a>Addressables</h3></li><li><a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.20/manual/index.html">Addressables 官方文档</a></li><li><a href="https://www.zhihu.com/column/c_1499730067991793664">Addressables 官方教程</a></li><li><a href="https://github.com/Unity-Technologies/Addressables-Sample">Addressables 官方案例</a></li><li><a href="https://www.jianshu.com/p/8009c16fcab3">AA与AB的区别</a></li><li><a href="https://blog.csdn.net/linxinfa/article/details/122390621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166357971516782427466616%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166357971516782427466616&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-122390621-null-null.142%5Ev47%5Ebody_digest,201%5Ev3%5Econtrol&utm_term=Addressable%20Asset%20System&spm=1018.2226.3001.4187">AA详解教程</a><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2></li><li><a href="https://learn.u3d.cn/tutorial/mobile-game-optimization">移动端性能优化 官方教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/387470212">移动端性能优化教程</a><h2 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h2></li><li><a href="https://zhuanlan.zhihu.com/p/85578987">Shader从入门到跑路（1）：朴实无华的图形学基础</a></li><li><a href="https://www.cnblogs.com/iwiniwin/p/15191362.html">各种遮罩详解</a></li><li><a href="https://blog.csdn.net/mkr67n/article/details/117030977">将多个Sprite动态合成一个Sprite</a></li><li><a href="https://www.bilibili.com/read/cv13628561/">镜头光晕 Flare</a></li><li><a href="https://blog.csdn.net/u013354943/article/details/52797568?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-52797568-blog-117026093.pc_relevant_multi_platform_whitelistv1_exp2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-52797568-blog-117026093.pc_relevant_multi_platform_whitelistv1_exp2&utm_relevant_index=2">透明度测试与透明度混合详解</a></li><li><a href="https://www.cnblogs.com/littleperilla/p/16129794.html">2D图片边缘检测(描边效果)</a></li><li><a href="https://github.com/QianMo/X-PostProcessing-Library">很牛的Unity后处理Shader库</a><h2 id="解包知识点"><a href="#解包知识点" class="headerlink" title="解包知识点"></a>解包知识点</h2></li><li><a href="https://github.com/dnSpy/dnSpy/releases/tag/v6.1.8">DNSPY 反向编译 dnSpy</a></li><li><a href="https://github.com/Perfare/AssetStudio">AB 包解包 AssetStudio</a></li><li><a href="https://zhuanlan.zhihu.com/p/95279981">AB 包解包 AssetStudio 教程</a></li><li><a href="https://github.com/SeriousCache/UABE">.assets 和 AssetBundle 编辑器 UABE</a></li><li><a href="https://zhuanlan.zhihu.com/p/515328104">解包汉化教程：UABE+AssetStudio替换TMPro字体</a></li><li><a href="https://github.com/Perfare/UnityLive2DExtractor">从Unity AssetBundle中提取Live2D Cubism 3文件 UnityLive2DExtractor</a></li><li><a href="https://github.com/Perfare/Il2CppDumper/blob/master/README.zh-CN.md">Unity il2cpp 逆向工程</a></li></ul><h1 id="优秀学习博客"><a href="#优秀学习博客" class="headerlink" title="优秀学习博客"></a><strong>优秀学习博客</strong></h1><ul><li><a href="https://onewheelstudio.com/blog">独轮车工作室</a></li><li><a href="https://www.powerhoof.com/">大力脚工作室</a></li><li><a href="https://aihailan.com/blog/">海澜之家</a></li><li>逆向工程狠人大佬<br>  <a href="https://www.perfare.net/">Perfare’s Blog - 不可能有技术含量</a></li><li>大佬定制版 Unity 手册<br>  <a href="https://www.wenjiangs.com/docs/unity3d">Unity3D 组件手册 文档中心</a></li><li>啥插件都出详细教程的大佬<br>  <a href="https://linxinfa.blog.csdn.net/?type=blog">林新发的博客_CSDN博客-Unity3D,android,C#领域博主</a></li><li>架构师大佬的博客<br>  <a href="http://www.liuocean.com/">L’s Blog</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>导航</category>
      
    </categories>
    
    
    <tags>
      
      <tag>导航</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导航-项目导航</title>
    <link href="/2024/01/18/%E5%AF%BC%E8%88%AA-%E9%A1%B9%E7%9B%AE%E5%AF%BC%E8%88%AA/"/>
    <url>/2024/01/18/%E5%AF%BC%E8%88%AA-%E9%A1%B9%E7%9B%AE%E5%AF%BC%E8%88%AA/</url>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="急急开发工具箱"><a href="#急急开发工具箱" class="headerlink" title="急急开发工具箱"></a>急急开发工具箱</h2><p>链接： <a href="https://github.com/MycroftCooper/MycroftToolkit">https://github.com/MycroftCooper/MycroftToolkit</a></p><h2 id="急急游戏框架"><a href="#急急游戏框架" class="headerlink" title="急急游戏框架"></a>急急游戏框架</h2><p>链接： <a href="https://github.com/MycroftCooper/QuickGameFramework">https://github.com/MycroftCooper/QuickGameFramework</a></p><h1 id="活跃中"><a href="#活跃中" class="headerlink" title="活跃中"></a>活跃中</h1><h2 id="肉鸽-2-D-射击"><a href="#肉鸽-2-D-射击" class="headerlink" title="肉鸽 2 D 射击"></a>肉鸽 2 D 射击</h2><p>链接： <a href="https://github.com/WittyKyrie/ARMED-CRAFTSMAN">https://github.com/WittyKyrie/ARMED-CRAFTSMAN</a><br>只做架构</p><h2 id="绿洲计划-3-D"><a href="#绿洲计划-3-D" class="headerlink" title="绿洲计划 3 D"></a>绿洲计划 3 D</h2><p>链接： <a href="https://github.com/MycroftCooper/OasisProject3D">https://github.com/MycroftCooper/OasisProject3D</a></p><h1 id="计划中"><a href="#计划中" class="headerlink" title="计划中"></a>计划中</h1><h2 id="急急-GamePlay-库"><a href="#急急-GamePlay-库" class="headerlink" title="急急 GamePlay 库"></a>急急 GamePlay 库</h2><p>计划中…<br>打算把比较通用的 GamePlay 框架都装进来方便复用</p><h2 id="急急-Shader-效果库"><a href="#急急-Shader-效果库" class="headerlink" title="急急 Shader 效果库"></a>急急 Shader 效果库</h2><p>计划中…<br>用于学习 shader 效果与未来复用</p><h2 id="小游戏合集"><a href="#小游戏合集" class="headerlink" title="小游戏合集"></a>小游戏合集</h2><p>计划中…<br>打算把 2048 和跑酷都装进同一个小游戏内。</p><h1 id="搁置"><a href="#搁置" class="headerlink" title="搁置"></a>搁置</h1><h2 id="萤火"><a href="#萤火" class="headerlink" title="萤火"></a>萤火</h2><p>链接： <a href="https://github.com/MycroftCooper/FireFly">https://github.com/MycroftCooper/FireFly</a></p><h2 id="小老虎射击"><a href="#小老虎射击" class="headerlink" title="小老虎射击"></a>小老虎射击</h2><p>链接： <a href="https://github.com/MycroftCooper/TigerShooting2DGame">https://github.com/MycroftCooper/TigerShooting2DGame</a></p><h1 id="已归档"><a href="#已归档" class="headerlink" title="已归档"></a>已归档</h1><h2 id="新-2048-New-2048"><a href="#新-2048-New-2048" class="headerlink" title="新 2048 New 2048"></a>新 2048 New 2048</h2><p>链接： <a href="https://github.com/MycroftCooper/New2048">https://github.com/MycroftCooper/New2048</a></p><h2 id="恐龙跑酷-DinoParkour"><a href="#恐龙跑酷-DinoParkour" class="headerlink" title="恐龙跑酷 DinoParkour"></a>恐龙跑酷 DinoParkour</h2><p>链接： <a href="https://github.com/MycroftCooper/DinoParkour">https://github.com/MycroftCooper/DinoParkour</a></p>]]></content>
    
    
    <categories>
      
      <category>导航</category>
      
    </categories>
    
    
    <tags>
      
      <tag>导航</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导航-游戏开发</title>
    <link href="/2024/01/18/%E5%AF%BC%E8%88%AA-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2024/01/18/%E5%AF%BC%E8%88%AA-%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><h2 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h2><ul><li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/">C#官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/485120660">C#必备知识备忘录</a></li><li><a href="https://blog.csdn.net/HadesNyx/article/details/107281431">数据结构细讲</a></li><li><a href="https://stackoverflow.com/questions/44734580/why-choose-unityevent-over-native-c-sharp-events">C#原生事件与UnityEvent</a></li><li><a href="https://blog.csdn.net/SAYA_/article/details/49227989">readonly与const</a></li><li>随机数<pre><code>  [Unity关于Random.state的使用](https://blog.csdn.net/lichoueve/article/details/83385660)  [取整模式枚举](https://docs.microsoft.com/zh-cn/dotnet/api/system.midpointrounding?view=net-6.0)</code></pre><h1 id="游戏框架"><a href="#游戏框架" class="headerlink" title="游戏框架"></a>游戏框架</h1></li><li><a href="https://linxinfa.blog.csdn.net/article/details/121244430?spm=1001.2014.3001.5502">自制框架知识梳理</a></li><li><a href="https://rpdc.xiaohongshu.com/52-design-principles">设计理念大全 52 Design Principles</a></li><li><a href="https://blog.csdn.net/qq_40138785/article/details/81065979">UML 设计类图教程</a></li><li><a href="http://c.biancheng.net/view/8462.html">一句话归纳设计模式</a></li><li><a href="https://github.com/guevara/read-it-later/issues/4435">设计模式大全游戏版</a></li><li><a href="https://gpp.tkchu.me/acknowledgements.html">游戏设计模式</a></li><li><a href="https://www.zhihu.com/question/19575617/answer/1314108339">UGC 是什么？</a></li><li><a href="https://baijiahao.baidu.com/s?id=1699531544387171269&wfr=spider&for=pc">常见代码重构技巧</a></li><li><a href="https://blog.codingnow.com/2017/06/overwatch_ecs.html">ECS守望先锋解析</a><h1 id="网络同步"><a href="#网络同步" class="headerlink" title="网络同步"></a>网络同步</h1></li><li>[帧同步与状态同步]( <a href="https://zhuanlan.zhihu.com/p/357973435">https://zhuanlan.zhihu.com/p/357973435</a></li></ul><h1 id="工具软件"><a href="#工具软件" class="headerlink" title="工具软件"></a>工具软件</h1><ul><li><a href="https://www.codeandweb.com/">图集打包 TexturePacker</a></li><li><a href="http://www.snakehillgames.com/spritelamp/">2D法线贴图 Sprite Lamp</a></li><li><a href="https://pixelbasher.dev/index.html">像素软件</a></li><li><a href="https://cascadeur.com/">3DAI 动画软件 cascadeur</a></li><li><a href="https://ffmpeg.org/">FFmpeg</a> </li><li><a href="https://zhuanlan.zhihu.com/p/117523405">FFMPEG命令入门</a><h1 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h1></li><li><a href="https://github.com/QianMo/Real-Time-Rendering-4th-Bibliography-Collectionhttps://blog.csdn.net/poem_qianmo/article/details/120657411?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.essearch_pc_relevant&spm=1001.2101.3001.4242.1">实时渲染圣经</a></li><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门</a></li><li><a href="https://games-cn.org/">计算机图形学与混合现实在线平台</a></li><li><a href="https://www.shadertoy.com/view/ldccW4">在线实时Shader练习 Shadertoy</a></li><li><a href="https://cpetry.github.io/NormalMap-Online/">法线贴图快速生成网站 NormalMap-Online/</a><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1></li><li><a href="https://www.redblobgames.com/">算法博客</a></li><li><a href="https://www.redblobgames.com/grids/hexagons/">六边形网格算法</a></li><li>波函数坍缩算法 (启发式搜索)<br>  <a href="https://github.com/marian42/wavefunctioncollapse">https://github.com/marian42/wavefunctioncollapse</a><br>  <a href="https://github.com/mxgmn/WaveFunctionCollapse">https://github.com/mxgmn/WaveFunctionCollapse</a><br>  <a href="https://zhuanlan.zhihu.com/p/66416593">基于《波函数坍缩算法》的无限城市程序化随机生成</a></li><li><a href="https://blog.csdn.net/qq_41452267/article/details/104610251">球坐标系</a></li><li>噪波<ul><li><a href="https://blog.csdn.net/kuangben2000/article/details/102511295">噪波教程</a></li><li><a href="https://github.com/Auburn/FastNoiseLite">噪波git库</a></li><li><a href="https://zhuanlan.zhihu.com/p/206271895?utm_source=wechat_session">柏林噪声</a></li></ul></li><li><a href="https://github.com/scutan90/DeepLearning-500-questions">深度学习 500 问</a></li><li><a href="https://donjon.bin.sh/">DND工具相关</a></li><li><a href="https://www.mazegenerator.net/">迷宫生成器</a></li></ul><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/340313373">游戏动画技术总结</a></li><li><a href="https://www.xuanfengge.com/easeing/easeing/">缓动函数速查表</a></li><li><a href="https://ultimateframedata.com/">格斗游戏动画分析</a></li><li><a href="https://zhuanlan.zhihu.com/p/84818868">经典游戏动画解析</a><h1 id="美术"><a href="#美术" class="headerlink" title="美术"></a>美术</h1></li><li><a href="https://www.gameuidatabase.com/">游戏UI速查站</a></li><li><a href="https://icons8.com/icons/new"> Icon 免费下载</a><h1 id="游戏设计"><a href="#游戏设计" class="headerlink" title="游戏设计"></a>游戏设计</h1></li><li> <a href="https://zhuanlan.zhihu.com/p/136504436">如何更好的设计游戏的日常任务</a></li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul><li><a href="https://git-scm.com/book/zh/v2">Git 官方教程</a></li><li><a href="https://learngitbranching.js.org/?locale=zh_CN">Git 模拟器</a></li><li><a href="https://blog.csdn.net/qq_30859353/article/details/115726357">使用Sourcetree工具合并分支</a></li><li><a href="http://t.zoukankan.com/webljl-p-14049245.html">回滚与重置 (revert 与 reset)</a></li><li><a href="https://andy-fighting.blog.csdn.net/article/details/115761272?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-115761272-blog-105164912.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-115761272-blog-105164912.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1">git revert回滚merge提交时报错commit xxx is a merge but no -m option</a></li><li><a href="https://blog.csdn.net/weixin_44299027/article/details/121334428">游离状态（detached head）</a></li><li><a href="https://www.zhihu.com/question/20431718">Fork教程</a></li><li><a href="https://blog.csdn.net/qq_21746331/article/details/120776710">标签（git tag）教程</a></li><li><a href="https://www.jianshu.com/p/03a4afc976aa">Unfinished merge报错</a></li><li><a href="https://www.cnblogs.com/spec-dog/p/11043371.html">团队项目的Git分支管理规范</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>导航</category>
      
    </categories>
    
    
    <tags>
      
      <tag>导航</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学基础P1-P6</title>
    <link href="/2024/01/18/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/"/>
    <url>/2024/01/18/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/</url>
    
    <content type="html"><![CDATA[<h1 id="数学基础-P1-P6"><a href="#数学基础-P1-P6" class="headerlink" title="数学基础 P1-P6"></a>数学基础 P1-P6</h1><h1 id="1-向量"><a href="#1-向量" class="headerlink" title="1. 向量"></a>1. 向量</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul><li><p><strong>几何定义：</strong><br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-1.png" srcset="/img/loading.gif"><br>$\vec{a}=\vec{AB}=B-A$<br><strong>几何意义：</strong><br>长度    $|\vec{a}|$                 向量的模<br>方向    $\hat{a}=\vec{a}/|\vec{a|}$    单位向量</p></li><li><p><strong>数学定义</strong><br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-2.png" srcset="/img/loading.gif"><br>向量矩阵   $A=\pmatrix{x\y}$<br>转置矩阵  $A^T=(x,y)$<br>矩阵的模 $|A|=\sqrt{x^2+y^2}$</p></li></ul><h2 id="1-2-运算"><a href="#1-2-运算" class="headerlink" title="1.2 运算"></a>1.2 运算</h2><h3 id="1-2-1-加法运算"><a href="#1-2-1-加法运算" class="headerlink" title="1.2.1 加法运算"></a>1.2.1 加法运算</h3><ul><li>几何学<br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-3.png" srcset="/img/loading.gif"><br><strong>四边形法则</strong>与<strong>三角形法则</strong></li><li>数学<br>$A=\pmatrix{x_{A1}\y_{A2}}$          $B=\pmatrix{x_{B1}\y_{B2}}$<br>$A+B=\pmatrix{x_{A1}+x_{B1}\y_{A2}+y_{B2}}$</li></ul><p><strong>运算结果：</strong>新向量</p><h3 id="1-2-2-点乘"><a href="#1-2-2-点乘" class="headerlink" title="1.2.2 点乘"></a>1.2.2 点乘</h3><ul><li><p>几何学<br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-4.png" srcset="/img/loading.gif"><br>$\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|cos\theta$<br>一般向量：$cos\theta=\cfrac{\vec{a}\cdot\vec{b}}{|\vec{a}||\vec{b}|}$<br>单位向量:   $cos\theta=\hat{a}\cdot\hat{b}$</p><p>适用规则:</p><ul><li>交换律    $\vec{a}\cdot\vec{b}=\vec{b}\cdot\vec{a}$</li><li>分配律    $\vec{a}\cdot(\vec{b}+\vec{c})=\vec{a}\cdot\vec{b}+\vec{a}\cdot\vec{c}$</li><li>结合律   $(k\vec{a})\cdot\vec{b}=\vec{a}\cdot(k\vec{b})=k(\vec{a}\cdot\vec{b})$</li></ul></li><li><p>数学</p><ul><li>2D：$\vec{a}\cdot\vec{b}=\pmatrix{x_a\y_a}\cdot\pmatrix{x_b\y_b}=x_ax_b+y_ay_b$</li><li>3D：$\vec{a}\cdot\vec{b}=\pmatrix{x_a\y_a\z_a}\cdot\pmatrix{x_b\y_b\z_b}=x_ax_b+y_ay_b+z_az_b$</li></ul></li></ul><p><strong>运算结果：</strong>数字</p><p><strong>应用：</strong></p><ol><li><p>计算两向量夹角(光线反射角)<br>$cos\theta=\cfrac{\vec{a}\cdot\vec{b}}{|\vec{a}||\vec{b}|}$</p></li><li><p>计算投影(垂直分解)<br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-5.png" srcset="/img/loading.gif"></p></li><li><p>判断两向量方向<br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-6.png" srcset="/img/loading.gif"></p><p>$\vec{a}\cdot\vec{b}\cases{&gt;0 \Rightarrow同向\=0 \Rightarrow垂直\&lt;0 \Rightarrow逆向}$</p></li></ol><h3 id="1-2-3-叉乘"><a href="#1-2-3-叉乘" class="headerlink" title="1.2.3 叉乘"></a>1.2.3 叉乘</h3><ul><li><p>几何学<br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-7.png" srcset="/img/loading.gif"><br>右手螺旋定则确认新向量方向<br>适用规则：</p><ul><li><p>交换律：$\vec{a}\times\vec{b}=-\vec{b}\times\vec{a}$</p></li><li><p>分配律：$\vec{a}\times(\vec{b}+\vec{c})=\vec{a}\times\vec{b}+\vec{a}\times\vec{c}$</p></li><li><p>结合律：$\vec{a}\times(k\vec{b})=k(\vec{a}\times\vec{b})$</p></li><li><p>零向量：$\vec{a}\times\vec{a}=\vec{0}$</p></li></ul></li><li><p>数学<br>$\vec{a}\times\vec{b}=\pmatrix{y_az_b-y_bz_a\z_ax_b-x_az_b\x_ay_b-y_ax_b}=A*b=\pmatrix{0&amp;-a_a&amp;y_a\z_a&amp;0&amp;-x_a\-y_a&amp;x_a&amp;0}\pmatrix{x_b\y_b\z_b}$<br>A是$\vec{a}$的特征矩阵</p></li></ul><p><strong>运算结果：</strong>新向量</p><p><strong>应用：</strong></p><ol><li>构建坐标系<ul><li>右手坐标系(教学用)：$\vec{x}\times\vec{y}=\vec{z}$</li><li>左手坐标系(生产用)：$\vec{x}\times\vec{y}=-\vec{z}$</li></ul></li><li>判断左右<br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-8.png" srcset="/img/loading.gif"><br>$\vec{a}\times\vec{b}\cases{=+\vec{z}\Rightarrow\vec{b}在\vec{a}左侧\=-\vec{z}\Rightarrow\vec{b}在\vec{a}右侧}$</li><li>判断内外(法线、光栅化)<br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-9.png" srcset="/img/loading.gif"><br>$\cases{\vec{AB}\times\vec{AP}\\vec{BC}\times\vec{BP}\\vec{CA}\times\vec{CP}}$<ul><li>若均在同侧则P在ABC外</li><li>否则P在ABC内</li></ul></li></ol><h1 id="2-矩阵"><a href="#2-矩阵" class="headerlink" title="2.矩阵"></a>2.矩阵</h1><h2 id="2-1-矩阵运算"><a href="#2-1-矩阵运算" class="headerlink" title="2.1 矩阵运算"></a>2.1 矩阵运算</h2><h3 id="2-1-1-加法"><a href="#2-1-1-加法" class="headerlink" title="2.1.1 加法"></a>2.1.1 加法</h3><p>$A_{(M\times N)}B_{(M\times N)}=C_{(M\times N)}$</p><p>$A+B=\pmatrix{a_{11}&amp;a_{12}\a_{21}&amp;a_{22}}+\pmatrix{b_{11}&amp;b_{12}\b_{21}&amp;b_{22}}=\pmatrix{a_{11}+b_{11}&amp;a_{12}+b_{12}\a_{21}+b_{21}&amp;a_{22}+b_{22}}=C$</p><p>$C_{xy}=A_{xy}=B_{xy}$</p><h3 id="2-1-2-乘法"><a href="#2-1-2-乘法" class="headerlink" title="2.1.2 乘法"></a>2.1.2 乘法</h3><h4 id="2-1-2-1-矩阵x数字"><a href="#2-1-2-1-矩阵x数字" class="headerlink" title="2.1.2.1 矩阵x数字"></a>2.1.2.1 矩阵x数字</h4><p>$A\times k=\pmatrix{a_{11}&amp;a_{12}\a_{21}&amp;a_{22}}\times k=\pmatrix{ka_{11}&amp;ka_{12}\ka_{21}&amp;ka_{22}}$</p><h4 id="2-1-2-2-矩阵x矩阵"><a href="#2-1-2-2-矩阵x矩阵" class="headerlink" title="2.1.2.2 矩阵x矩阵"></a>2.1.2.2 矩阵x矩阵</h4><p>M行N列矩阵 X N行P列矩阵 = M行P列矩阵<br>$A_{(M\times N)}B_{(N\times P)}=C_{(M\times P)}$</p><p>$C_{xy}=A_x\cdot B_y$</p><p>例：<br>$\pmatrix{1&amp;3\5&amp;2\0&amp;4}\pmatrix{3&amp;6&amp;9&amp;4\2&amp;7&amp;8&amp;3}=\pmatrix{9&amp;27&amp;33&amp;13\19&amp;44&amp;61&amp;26\8&amp;28&amp;32&amp;12}$</p><p>$26=\pmatrix{5&amp;2}\cdot \pmatrix{4\3}=20+6=26$</p><p><strong>适用规则：</strong></p><ul><li>交换律：$AB \not = BA$</li><li>结合律：$(AB)C=A(BC)$</li><li>分配律：$A(B+C)=AB+AC$</li></ul><h4 id="2-1-2-3-矩阵x向量"><a href="#2-1-2-3-矩阵x向量" class="headerlink" title="2.1.2.3 矩阵x向量"></a>2.1.2.3 矩阵x向量</h4><p>要求：向量必须是列向量才有意义<br>$A_{(N\times M)}B_{(M\times 1)}=C_{(N\times 1)}$<br>用途：向量变换</p><p>例：向量y轴镜像(翻转x)<br>$\pmatrix{-1&amp;0\0&amp;1}\vec{a}=\pmatrix{-1&amp;0\0&amp;1}\pmatrix{x\y}=\pmatrix{-x\y}$</p><h4 id="2-1-2-4-向量运算与矩阵运算的转换"><a href="#2-1-2-4-向量运算与矩阵运算的转换" class="headerlink" title="2.1.2.4 向量运算与矩阵运算的转换"></a>2.1.2.4 向量运算与矩阵运算的转换</h4><p>点乘：<br>$\vec{a}\cdot\vec{b}=\vec{a}^T\vec{b}=\pmatrix{x_a&amp;y_a&amp;z_a}\pmatrix{x_b\y_b\z_b}=(x_ax_b+y_ay_b+z_az_b)$</p><p>叉乘:<br>$\vec{a}\times\vec{b}=A^*b=\pmatrix{0&amp;-z_a&amp;y_a\z_a&amp;0&amp;-x_a\-y_a&amp;x_a&amp;0}\pmatrix{x_b\y_b\z_b}$</p><h3 id="2-1-3-转置"><a href="#2-1-3-转置" class="headerlink" title="2.1.3 转置"></a>2.1.3 转置</h3><p> $A_{(M\times N)}^T=A_{(N\times M)}$<br>$\pmatrix{a_{11}&amp;a_{12}\a_{21}&amp;a_{22}\a_{31}&amp;a_{32}}^T=\pmatrix{a_{11}&amp;a_{21}&amp;a_{31}\a_{12}&amp;a_{22}&amp;a_{32}}$</p><p>特性：$(AB)^T=B^TA^T$</p><h2 id="2-2-单位矩阵与逆矩阵"><a href="#2-2-单位矩阵与逆矩阵" class="headerlink" title="2.2 单位矩阵与逆矩阵"></a>2.2 单位矩阵与逆矩阵</h2><h3 id="2-2-1单位矩阵"><a href="#2-2-1单位矩阵" class="headerlink" title="2.2.1单位矩阵"></a>2.2.1单位矩阵</h3><p>单位矩阵是一个对角阵</p><p>$I_{3\times 3}=\pmatrix{1&amp;0&amp;0\0&amp;1&amp;0\0&amp;0&amp;1}$</p><p>任何矩阵乘单位矩阵不产生变化</p><p>$AI=IA=A$  </p><h3 id="2-2-2-逆矩阵"><a href="#2-2-2-逆矩阵" class="headerlink" title="2.2.2 逆矩阵"></a>2.2.2 逆矩阵</h3><p>若$AB=I$则AB互为逆矩阵，B可记为$A^{-1}$</p><p>$AA^{-1}=A^{-1}A=I$</p><p>$(AB)^{-1}=B^{-1}A^{-1}$</p><h1 id="3-变换"><a href="#3-变换" class="headerlink" title="3. 变换"></a>3. 变换</h1><h2 id="3-1-2D变换"><a href="#3-1-2D变换" class="headerlink" title="3.1 2D变换"></a>3.1 2D变换</h2><h3 id="3-1-1-常见变换"><a href="#3-1-1-常见变换" class="headerlink" title="3.1.1 常见变换"></a>3.1.1 常见变换</h3><p><strong>缩放(Scale)：</strong><br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-10.png" srcset="/img/loading.gif"><br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-11.png" srcset="/img/loading.gif"><br>公式推导：<br>$\cases{x’=s_xx\y’=s_yy}\Rightarrow\pmatrix{x’\y’}=\pmatrix{s_x&amp;0\0&amp;s_y}\pmatrix{x\y}$</p><p>线性变换：<br>$S(s_x,s_y)=\pmatrix{s_x&amp;0\0&amp;s_y}$</p><p>齐次变换：<br>$S(s_x,s_y)=\pmatrix{s_x&amp;0&amp;0\0&amp;s_y&amp;0\0&amp;0&amp;1}\cdot\pmatrix{x\y\1}$</p><p><strong>镜像(Reflection)：</strong><br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-12.png" srcset="/img/loading.gif"><br>公式推导：<br>$\cases{x’=-x\y’=y}\Rightarrow\pmatrix{x’\y’}=\pmatrix{-1&amp;0\0&amp;1}\pmatrix{x\y}$</p><p>线性变换：<br>$\pmatrix{-1&amp;0\0&amp;1}$</p><p>齐次变换：<br>$\pmatrix{-1&amp;0&amp;0\0&amp;1&amp;0\0&amp;0&amp;1}$</p><p><strong>切变(Shear):</strong><br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-13.png" srcset="/img/loading.gif"><br>$\cases{x’=ay\y’=y}\Rightarrow\pmatrix{x’\y’}=\pmatrix{1&amp;a\0&amp;1}\pmatrix{x\y}$</p><p>线性变换：<br>$\pmatrix{1&amp;a\0&amp;1}$</p><p>齐次变换：<br>$\pmatrix{1&amp;a&amp;0\0&amp;1&amp;0\0&amp;0&amp;1}$</p><p><strong>旋转(Rotate):</strong><br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-14.png" srcset="/img/loading.gif"><br>公式推导：<br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-15.png" srcset="/img/loading.gif"><br>线性变换：<br>$R_\theta=\pmatrix{cos\theta&amp;-sin\theta\sin\theta&amp;cos\theta}$</p><p>齐次变换：<br>$R_\theta=\pmatrix{x’\y’\1}=\pmatrix{cos\theta&amp;-sin\theta&amp;0\sin\theta&amp;cos\theta&amp;0\0&amp;0&amp;1}\cdot\pmatrix{x\y\1}$</p><p><strong>平移(Move):</strong><br><img src="/images/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80P1-P6/image-16.png" srcset="/img/loading.gif"><br>公式推导：<br>$\cases{x’=x+t_x\y’=y+t_y}\Rightarrow\pmatrix{x’\y’}=\pmatrix{a&amp;b\c&amp;d}\pmatrix{x\y}+\pmatrix{t_x\t_y}\Rightarrow\pmatrix{x’\y’\1}=\pmatrix{a&amp;b&amp;t_x\c&amp;d&amp;t_y\0&amp;0&amp;1}\cdot\pmatrix{x\y\1}$</p><p>线性变换:<br>$T(t_x,t_y)=\pmatrix{x’\y’}=\pmatrix{1&amp;0\0&amp;1}\pmatrix{x\y}+\pmatrix{t_x\ t_y}$</p><p>齐次变换：<br>$T(t_x,t_y)=\pmatrix{x’\y’\1}=\pmatrix{1&amp;0&amp;t_x\0&amp;1&amp;t_y\0&amp;0&amp;1}\cdot\pmatrix{x\y\1}$</p><h3 id="3-1-2-常见变换矩阵速查表"><a href="#3-1-2-常见变换矩阵速查表" class="headerlink" title="3.1.2 常见变换矩阵速查表"></a>3.1.2 常见变换矩阵速查表</h3><table><thead><tr><th>变换名称</th><th>线性变换矩阵</th><th>齐次变换矩阵</th></tr></thead><tbody><tr><td>缩放(Scale)</td><td>$S(s_x,s_y)=\pmatrix{s_x&amp;0\0&amp;s_y}$</td><td>$S(s_x,s_y)=\pmatrix{s_x&amp;0&amp;0\0&amp;s_y&amp;0\0&amp;0&amp;1}\cdot\pmatrix{x\y\1}$</td></tr><tr><td>镜像(Reflection)</td><td>$\pmatrix{-1&amp;0\0&amp;1}$</td><td>$\pmatrix{-1&amp;0&amp;0\0&amp;1&amp;0\0&amp;0&amp;1}$</td></tr><tr><td>切变(Shear)</td><td>$\pmatrix{1&amp;a\0&amp;1}$</td><td>$\pmatrix{1&amp;a&amp;0\0&amp;1&amp;0\0&amp;0&amp;1}$</td></tr><tr><td>旋转(Rotate)</td><td>$R_\theta=\pmatrix{cos\theta&amp;-sin\theta\sin\theta&amp;cos\theta}$</td><td>$R_\theta=\pmatrix{x’\y’\1}=\pmatrix{cos\theta&amp;-sin\theta&amp;0\sin\theta&amp;cos\theta&amp;0\0&amp;0&amp;1}\cdot\pmatrix{x\y\1}$</td></tr><tr><td>平移(Move)</td><td>$T(t_x,t_y)=\pmatrix{x’\y’}=\pmatrix{1&amp;0\0&amp;1}\pmatrix{x\y}+\pmatrix{t_x\ t_y}$</td><td>$T(t_x,t_y)=\pmatrix{x’\y’\1}=\pmatrix{1&amp;0&amp;t_x\0&amp;1&amp;t_y\0&amp;0&amp;1}\cdot\pmatrix{x\y\1}$</td></tr></tbody></table><h3 id="3-1-2-线性变换-linear-transform-范式"><a href="#3-1-2-线性变换-linear-transform-范式" class="headerlink" title="3.1.2 线性变换(linear transform)范式"></a>3.1.2 线性变换(linear transform)范式</h3><p>只要能将变换推导为以下形式的矩阵，就称之为线性变换</p><p>$\cases{x’=ax+by\y’=cx+dy}\Rightarrow\pmatrix{x’\y’}=\pmatrix{a&amp;b\c&amp;d}\pmatrix{x\y}$</p><p>缩放、镜像、切变、旋转都是线性变换</p><h3 id="3-1-3-齐次坐标"><a href="#3-1-3-齐次坐标" class="headerlink" title="3.1.3 齐次坐标"></a>3.1.3 齐次坐标</h3><p>平移的变换矩阵推导：</p><p>$\cases{x’=x+t_x\y’=y+t_y}\Rightarrow\pmatrix{x’\y’}=\pmatrix{a&amp;b\c&amp;d}\pmatrix{x\y}+\pmatrix{t_x\t_y}$</p><p>平移不是线性变换</p><p>需要一种方法可以简单的表达所有变换：<strong>齐次坐标</strong></p><p> 维度扩展：2维扩3维：</p><ul><li><p>点：$(x,y,1)^T$<br>$\pmatrix{x\y\w}=\pmatrix{x/w\y/w\1},w\not=0$</p></li><li><p>向量：$(x,y,0)^T$<br>向量具有平移不变性，所以是0<br>$\pmatrix{x’\y’\w’}=\pmatrix{1&amp;0&amp;t_x\0&amp;1&amp;t_y\0&amp;0&amp;1}\cdot\pmatrix{x\y\z}=\pmatrix{x+t_x\y+t_y\1}$</p></li><li><p>向量+向量=向量</p></li><li><p>点-点=向量</p></li><li><p>点+向量=点</p></li><li><p>点+点=无意义,在齐次坐标下扩充为两点中点</p></li></ul><p>$\pmatrix{a&amp;b&amp;t_x\c&amp;d&amp;t_y\0&amp;0&amp;1}\cdot\pmatrix{x\y\1}$</p>]]></content>
    
    
    <categories>
      
      <category>计算机图形学</category>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏数值设计与数学模型</title>
    <link href="/2024/01/18/%E6%B8%B8%E6%88%8F%E6%95%B0%E5%80%BC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/01/18/%E6%B8%B8%E6%88%8F%E6%95%B0%E5%80%BC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>我们假设A为初始值，y为每级提升的百分比，x为当前等级，R为x级时该属性的实际值。累乘和累加两种规则下的求R的计算公式分别是什么？</p><p>ChatGPT</p><p>当我们考虑两种规则：累乘和累加时，我们可以这样计算：</p><ol><li><strong>累乘规则</strong>: 每次等级提升，属性值是上一等级的 1+<em>y</em> 倍，其中 y 是每级提升的百分比。例如，如果初始值是 A 并且提升率是 10%，那么 y = 0.10。第一级的属性值是 A×(1+y) ，第二级是 A×(1+y)×(1+y) ，以此类推。</li></ol><p>对于 x 级，R 的计算公式是： R*=*A×(1+<em>y</em>)^x</p><ol><li><strong>累加规则</strong>: 每次等级提升，属性值是上一等级的值加上 A 乘以 y。例如，第一级是 A*+<em>A</em>×<em>y</em>，第二级是 A+A×y+A×y，以此类推。</li></ol><p>对于 x 级，R 的计算公式是： R*=<em>A</em>+<em>x</em>×<em>A</em>×<em>y 或者更简单的形式：R</em>=<em>A</em>×(1+<em>x</em>×*y)</p><p>所以，总结一下：</p><ol><li>对于累乘规则：R=<em>A</em>×(1+<em>y</em>)^x</li><li>对于累加规则：R*=*A×(1+x×y)</li></ol><p>一般在游戏的数值设计中，累加和累乘一般如何运用，有什么区别和特点？</p><p>在游戏的数值设计中，累加和累乘是两种常用的计算方式，它们各自有其特点、优势和局限性。了解这两种规则的运用、区别和特点是非常重要的，因为它们对玩家的游戏体验和长期参与度有直接影响。</p><ol><li><p><strong>累加（线性增长）</strong>:</p><ul><li><p><strong>运用</strong>：累加通常用于游戏初期或基本资源的增长、经验值需求、基础奖励等。</p></li><li><p>特点</p><p>：</p><ul><li><strong>可预测性</strong>：玩家可以很容易地预测未来的奖励或成本，因为它们是线性增长的。</li><li><strong>平稳感</strong>：累加给玩家一种平稳的进步感，没有太多的高潮和低潮。</li><li><strong>早期鼓励</strong>：由于初级和中级玩家的进展较为迅速，这种方式可能更具吸引力。</li></ul></li><li><p><strong>局限性</strong>：可能会导致高级玩家感到乏味或缺乏挑战性，因为难度和奖励的增长都是线性的，没有太大的变化。</p></li></ul></li><li><p><strong>累乘（指数增长）</strong>:</p><ul><li><p><strong>运用</strong>：累乘通常用于游戏的高级内容、升级成本、稀有资源的增长、高级奖励等。</p></li><li><p>特点</p><p>：</p><ul><li><strong>挑战性增长</strong>：对于高级玩家，提供了不断增长的挑战性，要求玩家不断改进策略和技能。</li><li><strong>未知感</strong>：由于增长速度是指数的，玩家可能不太容易预测未来的需求或奖励，这增加了探索的乐趣。</li><li><strong>高级奖励感</strong>：玩家获得的奖励感会随着他们在游戏中的进步而增长，因为高级奖励是以指数方式增长的。</li></ul></li><li><p><strong>局限性</strong>：可能会让新手或不经常玩游戏的玩家感到沮丧，因为难度和成本的增长可能会超过他们的预期。</p></li></ul></li></ol><p>在决定使用哪种方式时，游戏设计师需要根据游戏的目标、目标受众和期望的玩家行为进行权衡。在许多情况下，两种方法可能会同时存在于同一个游戏中，但应用于不同的系统或内容。例如，初级技能的升级成本可能是线性的，而高级技能的升级成本可能是指数的。</p><p>除了这两种，还有哪些游戏数值的设计规则？</p><p>ChatGPT</p><p>游戏数值设计是一门复杂的学科，设计师们采用多种方法和规则来达到期望的玩家体验和游戏平衡。除了累加和累乘规则外，以下是一些常用的数值设计规则和方法：</p><ol><li><strong>阶梯式增长</strong>：这是介于线性和指数之间的增长方式。玩家可能会经历一段时间的线性增长，然后突然遇到一个难度”台阶”，之后又是线性增长，依此类推。</li><li><strong>S曲线增长</strong>：初期和末期增长较慢，中间阶段增长较快。这可以模拟自然过程，如生物的成长曲线。</li><li><strong>对数增长</strong>：初期增长很快，但随着时间的推移，增长逐渐减慢。这常用于经验值系统，确保玩家初期升级快，但后期需要更多努力。</li><li><strong>带有上限的增长</strong>：一些系统为玩家设置上限，例如，玩家每日可以获得的金币数量有限。</li><li><strong>退火算法</strong>：在一些系统中，重复的行为会导致减少的回报。例如，玩家连续打怪可能会发现每只怪物掉落的经验值逐渐减少。</li><li><strong>随机性与概率</strong>：许多游戏中，从战斗伤害到物品掉落，都引入了一定的随机性。设计师们会通过概率分布来控制这种随机性，如均匀分布、正态分布等。</li><li><strong>资源耗尽</strong>：在一些游戏中，玩家会面临资源的有限性，迫使玩家做出策略性的决策。</li><li><strong>风险与回报</strong>：设计师们经常使用更高的风险来吸引玩家，提供更高的回报作为奖励。例如，在很多RPG游戏中，更危险的地方往往有更好的战利品。</li><li><strong>数值缓冲区</strong>：为了避免玩家在初次失败后立即放弃，游戏可能会在初期提供一个缓冲区，例如额外的生命或护盾。</li><li><strong>动态平衡</strong>：这是一个自适应的数值系统，根据玩家的行为或其他玩家的行为进行调整，以保持游戏的平衡和竞争力。</li></ol><p>当然，还有其他很多数值设计规则和方法，它们都是为了创建一个有趣、有挑战性且公平的游戏环境。数值设计是一门艺术，也是一门科学，需要设计师具备深入的理解和多年的经验。</p><p>细说退火算法</p><p>ChatGPT</p><p>退火算法（SimulatedAnnealing）是一种随机搜索算法，受到固体退火过程的启发。退火是一种物理过程，其中物体被加热到高温，然后缓慢冷却，以改变其内部结构，通常是为了增加其韧性。在这一过程中，系统的能量逐渐降低并趋于稳定。</p><p>退火算法的核心思想是用于求解优化问题，特别是在搜索大的解空间时。它以高的“温度”开始，允许算法在搜索过程中接受劣解，但随着“温度”的降低，接受劣解的概率也逐渐降低。这种方法有助于算法跳出局部最优解，从而寻找全局最优解。</p><p>退火算法的基本步骤如下：</p><ol><li><p><strong>初始化</strong>：选择一个初始解和初始温度，以及温度下降的速率。</p></li><li><p>重复以下步骤</p><p>，直到满足某个终止条件（如温度低于某个阈值或达到预定的迭代次数）：</p><ul><li>在当前解附近选择一个新解。</li><li>计算新解和当前解的代价函数之差。</li><li>如果新解更好，或者满足某个随机条件（这个条件基于当前温度和代价函数之差），则接受新解。</li><li>降低温度（通常乘以一个在0到1之间的系数）。</li></ul></li><li><p>返回当前解。</p></li></ol><p>退火算法的特点：</p><ul><li><strong>随机性</strong>：算法接受劣解的能力意味着它不会总是朝向局部最优方向移动。</li><li><strong>逐渐收敛</strong>：随着温度的降低，算法更倾向于搜索最优解而不是随机移动。</li><li><strong>参数选择</strong>：算法的效果很大程度上取决于参数的选择，如初始温度、温度下降速率和终止条件。</li></ul><p>退火算法在各种优化问题中都有应用，包括旅行商问题、作业调度问题、神经网络的权值优化等。</p><p>可以把 1. 累加 2. 累乘 3. 阶梯式 4. s曲线 5.对数增长 这几类归为一类吗？就都是和数学曲线相关的</p><p>ChatGPT</p><p>当然，这些都是描述数值增长或变化方式的数学模型，所以可以归为一个大类，通常可以称为“数学增长模型”或“数学曲线模型”。</p><ol><li><strong>累加（线性增长）</strong>: 这是最简单的数学模型，其中值按固定的量递增或递减。图形上，它呈现为直线。</li><li><strong>累乘（指数增长）</strong>: 这是一个更复杂的模型，其中值按固定的倍数递增或递减。图形上，它通常呈现为一个快速上升的曲线。</li><li><strong>阶梯式增长</strong>: 在图形上，它呈现为一系列的水平段，然后突然跳跃到另一个值，再继续一段时间的水平增长，如此反复。</li><li><strong>S曲线（Logistic增长或Sigmoid增长）</strong>: 这是描述某些生物种群或系统的增长的模型。初期和末期增长较慢，中间增长较快。在图形上，它形似字母”S”。</li><li><strong>对数增长</strong>: 与指数增长相反，对数增长开始时很快，然后逐渐放缓。图形上，它呈现为一个逐渐平稳的曲线。</li></ol><p>所有这些模型都是数学函数，用于描述和预测真实世界或虚拟世界（如游戏）中的现象或行为。在游戏设计、经济学、生物学、工程学和许多其他领域中，这些模型都是非常有价值的工具。所以，归纳为与“数学曲线相关的增长模型”是合理的。</p><p>还有其它与数学曲线相关的数值设计模型吗</p><p>ChatGPT</p><p>当然，数学为数值设计提供了丰富的模型，特别是当我们希望捕捉或模拟某些现象或行为时。以下是一些与数学曲线相关的数值设计模型：</p><ol><li><strong>幂律增长（Power Law）</strong>：在这种模型中，某个变量与另一个变量的幂成比例关系。例如，Pareto原则或80/20规则在经济学中的应用。</li><li><strong>双曲线增长</strong>：这是一个增长速度逐渐减慢但永不达到上限的模型。</li><li><strong>正弦或余弦波动</strong>：在某些系统中，值会按照周期性的方式上升和下降，如季节性的变化。</li><li><strong>高斯/正态分布</strong>：常见于概率和统计中，描述了数据如何围绕平均值分布。在游戏中，这可以用来模拟随机事件的结果。</li><li><strong>二项分布</strong>：描述了成功与失败的二元结果。例如，投掷硬币的结果。</li><li><strong>泊松分布</strong>：描述了在固定的时间或空间内发生的独立事件的次数。例如，一个游戏中的敌人生成率。</li><li><strong>几何分布或指数衰减</strong>：描述了到首次成功需要的试验次数。这在建模玩家等待某个特定事件的时间或次数时可能有用。</li><li><strong>阶跃函数</strong>：类似于阶梯式增长，但通常用于表示在某个特定点值突然改变。</li><li><strong>Bezier曲线</strong>：这是一种通过控制点来定义的曲线，常用于动画和路径设计。</li></ol><p>在数值设计中，选择最佳的数学模型取决于你希望模拟或表示的现象。许多模型可以结合使用或进行调整以更好地适应特定的应用。最重要的是理解每种模型的特点和适用情境，并根据需要进行调整。</p><p>举几个上述数值设计模型在游戏数值设计中的案例</p><p>ChatGPT</p><p>当然，以下是一些游戏中可能使用到的数学模型的实际案例：</p><ol><li><strong>累加（线性增长）</strong>：<ul><li><strong>案例</strong>：玩家每次完成某项任务或击败某个敌人时，都获得固定数量的经验点数。</li></ul></li><li><strong>累乘（指数增长）</strong>：<ul><li><strong>案例</strong>：游戏中，玩家升到下一级所需的经验值是前一级的两倍。</li></ul></li><li><strong>阶梯式增长</strong>：<ul><li><strong>案例</strong>：在一款RPG游戏中，玩家在20级、40级和60级时解锁新技能，但在这之间的级别提升并没有新技能。</li></ul></li><li><strong>S曲线（Logistic增长或Sigmoid增长）</strong>：<ul><li><strong>案例</strong>：在一款经济模拟游戏中，市场对某一商品的需求随着时间的推移先增加、然后达到饱和、再然后逐渐减少。</li></ul></li><li><strong>对数增长</strong>：<ul><li><strong>案例</strong>：玩家初始阶段的经验值增长很快，但随着等级的提升，同样的行动只能带来越来越少的经验值。</li></ul></li><li><strong>幂律增长（Power Law）</strong>：<ul><li><strong>案例</strong>：在一个大型多人在线角色扮演游戏中，只有少数玩家能获得顶级装备，而大多数玩家只能获得常规装备。</li></ul></li><li><strong>正弦或余弦波动</strong>：<ul><li><strong>案例</strong>：一个模拟季节更替的农场游戏，某些作物的产量会随着季节（如春夏秋冬）进行周期性波动。</li></ul></li><li><strong>高斯/正态分布</strong>：<ul><li><strong>案例</strong>：玩家在开启一个宝箱时，获得中等价值物品的机率最高，而获得非常高价值或非常低价值物品的机率都较低。</li></ul></li><li><strong>泊松分布</strong>：<ul><li><strong>案例</strong>：在一个塔防游戏中，敌人的生成速率是固定的，但具体的生成时间点是随机的，符合泊松分布。</li></ul></li><li><strong>Bezier曲线</strong>：<ul><li><strong>案例</strong>：游戏中的一个角色在进行跳跃时，其空中的轨迹或动画可以使用Bezier曲线来设计，以保证流畅和自然。</li></ul></li></ol><p>这些只是简化的例子，真实的游戏设计可能会根据具体需求进行调整和组合使用。</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>数值策划</tag>
      
      <tag>游戏设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏网络同步学习</title>
    <link href="/2024/01/18/%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/01/18/%E6%B8%B8%E6%88%8F%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习路径"><a href="#0-学习路径" class="headerlink" title="0. 学习路径"></a>0. 学习路径</h1><ol><li><strong>网络编程基础：</strong><ul><li>学习基本的网络通信概念，了解TCP/IP和UDP协议。</li><li>学习Socket编程，掌握套接字的使用和网络通信的基本原理。</li><li>了解网络模型和常见的网络通信模式。</li></ul></li><li><strong>游戏网络同步基础：</strong><ul><li>了解游戏网络同步的基本原理，包括客户端-服务器架构和点对点架构。</li><li>熟悉帧同步和状态同步的概念。</li></ul></li><li><strong>游戏引擎和框架：</strong><ul><li>学习一些流行的游戏引擎，如Unity或Unreal Engine。</li><li>掌握该引擎的网络模块和相关API。</li></ul></li><li><strong>多线程编程：</strong><ul><li>了解多线程编程的基本概念，学习如何使用线程来处理并发任务。</li><li>学习线程同步和互斥机制，以确保线程安全。</li></ul></li><li><strong>同步算法：</strong><ul><li>学习关于游戏同步的算法，如时间插值、状态插值、预测性同步等。</li><li>了解如何处理网络延迟和抖动。</li></ul></li><li><strong>网络优化：</strong><ul><li>学习网络优化技术，减少带宽占用和延迟。</li><li>了解并实践压缩和流量控制等技术。</li></ul></li><li><strong>实际项目经验：</strong><ul><li>参与小型游戏项目，实践所学知识。</li><li>阅读开源游戏项目的源代码，了解实际应用。</li></ul></li></ol><h1 id="1-网络编程基础"><a href="#1-网络编程基础" class="headerlink" title="1. 网络编程基础"></a>1. 网络编程基础</h1><h2 id="1-1-网络协议"><a href="#1-1-网络协议" class="headerlink" title="1.1 网络协议"></a>1.1 网络协议</h2><h2 id="1-2-TCP传输控制协议"><a href="#1-2-TCP传输控制协议" class="headerlink" title="1.2 TCP传输控制协议"></a>1.2 TCP传输控制协议</h2><ul><li><strong>特点：</strong><ul><li>提供可靠的数据传输，确保数据完整无误地到达。</li><li>有序传输数据包，维护数据顺序。</li><li>自动处理数据包重传和丢失问题。</li></ul></li><li><strong>适用场景：</strong><ul><li>当游戏需要可靠的数据传输时，例如在一些需要高度数据一致性的策略游戏或回合制游戏中。</li><li>客户端-服务器架构中，尤其是涉及到重要游戏状态和玩家数据的时候，经常使用TCP。</li></ul></li></ul><h2 id="1-3-UDP用户数据报协议"><a href="#1-3-UDP用户数据报协议" class="headerlink" title="1.3 UDP用户数据报协议"></a>1.3 UDP用户数据报协议</h2><ul><li><strong>特点：</strong><ul><li>提供快速的数据传输，但不保证数据包的可靠到达。</li><li>不保证数据包的顺序。</li><li>无连接，减少数据传输的延迟。</li></ul></li><li><strong>适用场景：</strong><ul><li>当游戏需要快速响应和实时更新时，例如在射击游戏或竞速游戏中。</li><li>在点对点架构中，尤其是对实时性要求较高的游戏，UDP经常被使用。</li></ul></li></ul><h2 id="1-4-结合TCP和UDP"><a href="#1-4-结合TCP和UDP" class="headerlink" title="1.4 结合TCP和UDP"></a>1.4 结合TCP和UDP</h2><p>有些游戏可能会同时使用TCP和UDP，根据不同的需求选择不同的协议。例如，使用TCP来处理登录、聊天和交易等需要高可靠性的数据传输，而使用UDP来处理实时的游戏状态更新。</p><h2 id="1-5-其它协议"><a href="#1-5-其它协议" class="headerlink" title="1.5 其它协议"></a>1.5 其它协议</h2><p>除了TCP和UDP，还存在其他一些网络通信协议，但在游戏开发中，TCP和UDP是最常用的。</p><p>以下是一些其他协议的简要介绍：</p><ol><li><strong>HTTP/HTTPS：</strong><ul><li>超文本传输协议（HTTP）和其安全版本（HTTPS）通常用于在Web浏览器和服务器之间传输数据。</li><li>虽然HTTP不适用于实时性要求高的游戏，但在一些需要通过Web进行访问的游戏和应用中可能会使用。</li></ul></li><li><strong>QUIC（Quick UDP Internet Connections）：</strong><ul><li>QUIC是一个基于UDP的传输协议，旨在提供更快的连接建立和更低的延迟。</li><li>由Google推出，适用于一些对延迟敏感的应用，但在游戏领域的应用尚不如TCP和UDP广泛。</li></ul></li><li><strong>SCTP（Stream Control Transmission Protocol）：</strong><ul><li>SCTP是一个支持可靠和不可靠传输的协议，同时具有多流和多宿主的特性。</li><li>SCTP被设计为提供比TCP更好的性能，并提供更好的消息边界控制。</li></ul></li><li><strong>RUDP（Reliable UDP）：</strong><ul><li>RUDP是对UDP的扩展，通过在应用层实现可靠性，使UDP具备了类似于TCP的可靠传输特性，但不同于TCP的有序传输。</li><li>一些游戏开发者选择在UDP基础上实现自定义的可靠性，以避免TCP的一些缺点，如拥塞控制导致的延迟增加。</li></ul></li></ol><h2 id="1-4-Socket"><a href="#1-4-Socket" class="headerlink" title="1.4 Socket"></a>1.4 Socket</h2><p>Socket（套接字）在严格意义上是一种编程接口（API），用于在网络中实现进程间的通信。<br>它可以被看作是一种在应用层和传输层之间的接口，使得程序可以通过网络发送和接收数据。<br>Socket并不是协议，而是一个用于进行网络编程的抽象接口。</p><p>在具体实现中，Socket可以使用不同的传输协议，最常见的是TCP和UDP。<br>通过使用Socket API，开发者可以创建套接字并使用它来建立网络连接、发送和接收数据。</p><p>在网络同步中，Socket扮演着关键的角色，特别是在实现客户端-服务器模型时。以下是Socket在网络同步中的一些关键作用：</p><ol><li><strong>建立连接：</strong> Socket用于建立客户端与服务器之间的连接。客户端和服务器分别创建套接字，然后通过Socket建立连接。</li><li><strong>数据传输：</strong> 通过Socket，程序可以使用不同的方法（如<code>send</code>和<code>recv</code>）发送和接收数据。这是网络同步中实现信息交换的关键。</li><li><strong>实时通信：</strong> 在实时多人游戏中，Socket负责实现玩家之间的实时通信。通过套接字，游戏客户端可以向服务器发送玩家的输入，服务器可以将更新的游戏状态广播给所有连接的客户端。</li><li><strong>协议选择：</strong> Socket API允许开发者选择不同的传输协议，如TCP或UDP，根据游戏的需求来确定数据传输的可靠性和效率。</li></ol><p>总的来说，Socket是一个在网络编程中用于实现通信的工具库（或者说是编程接口），它在网络同步中扮演着连接、数据传输和实时通信等关键角色。通过使用Socket，开发者可以在应用层进行网络编程，实现不同设备之间的数据交换。</p><h1 id="2-游戏网络同步基础"><a href="#2-游戏网络同步基础" class="headerlink" title="2. 游戏网络同步基础"></a>2. 游戏网络同步基础</h1><h2 id="2-1-网络同步架构"><a href="#2-1-网络同步架构" class="headerlink" title="2.1 网络同步架构"></a>2.1 网络同步架构</h2><h3 id="2-1-1-客户端-服务端架构"><a href="#2-1-1-客户端-服务端架构" class="headerlink" title="2.1.1 客户端-服务端架构"></a>2.1.1 客户端-服务端架构</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>游戏客户端和服务器之间存在中央服务器，负责处理游戏逻辑和同步状态。<br>客户端发送输入信息到服务器，服务器处理并更新游戏状态，然后将新的状态广播给所有连接的客户端。<br>客户端只负责输入处理和本地预测，而真正的游戏状态由服务器维护。<br>服务器是唯一的权威来源，决定游戏中的事件和状态变化。<br>通信通常使用可靠的传输协议（如TCP）以确保数据完整性。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ul><li>中央服务器可以处理作弊和安全性问题，因为它有权力验证和修正客户端的输入。</li><li>适用于大型多人在线游戏，可以管理数以千计的玩家。</li></ul><p><strong>缺点：</strong></p><ul><li>服务器压力大，可能成为性能瓶颈。</li><li>有较高的延迟，因为所有操作都需要经过服务器。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>大型多人在线游戏，需要中央权威来确保游戏状态的一致性和防止作弊。</p><h4 id="案例游戏"><a href="#案例游戏" class="headerlink" title="案例游戏"></a>案例游戏</h4><ul><li><strong>《魔兽世界》（World of Warcraft）</strong>：<br>作为一款经典的大型多人在线角色扮演游戏（MMORPG），《魔兽世界》使用客户端-服务器架构来处理大量玩家的交互和游戏状态更新。</li><li><strong>《反恐精英：全球攻势》（Counter-Strike: Global Offensive）</strong>：<br>这是一款流行的第一人称射击游戏，使用客户端-服务器模型来保证游戏的公平性和同步。</li><li><strong>《英雄联盟》（League of Legends）</strong>：<br>这款广受欢迎的多人在线战术竞技游戏也采用客户端-服务器架构，服务器负责处理游戏逻辑和同步玩家状态。</li></ul><h3 id="2-1-2-点对点架构"><a href="#2-1-2-点对点架构" class="headerlink" title="2.1.2 点对点架构"></a>2.1.2 点对点架构</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>每个玩家都有一个独立的客户端，彼此直接通信。<br>每个客户端处理自身的输入和状态更新，并将这些信息发送给其他玩家。<br>没有中央服务器，玩家直接交换信息，共同维护游戏状态。<br>每个客户端对自身状态的变化有权威性。<br>通信通常使用UDP</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ul><li>低延迟，因为信息直接从一个客户端传递到另一个客户端。</li><li>适用于小型游戏，不需要庞大的服务器支持。</li></ul><p><strong>缺点：</strong></p><ul><li>难以处理作弊，因为每个客户端都有权更改自己的状态。</li><li>对于大型多人在线游戏可能会导致网络流量激增。</li></ul><h4 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h4><p>小型游戏，例如局域网游戏或小团队合作游戏，不需要中央服务器来维护所有玩家的状态。</p><h4 id="案例游戏-1"><a href="#案例游戏-1" class="headerlink" title="案例游戏"></a>案例游戏</h4><ul><li><strong>《星际争霸》（StarCraft）</strong>：<br>早期的《星际争霸》在局域网游戏中主要使用点对点通信模型，每个客户端直接与其他客户端通信。</li><li><strong>《FIFA》系列（局域网模式）</strong>：<br>体育游戏如《FIFA》系列在其局域网对战模式中，通常使用点对点架构来实现玩家之间的连接。</li></ul><h3 id="2-1-3-混合型架构"><a href="#2-1-3-混合型架构" class="headerlink" title="2.1.3 混合型架构"></a>2.1.3 混合型架构</h3><p>客户端-服务器与点对点相结合，以兼顾两者的优点。</p><h4 id="案例游戏-2"><a href="#案例游戏-2" class="headerlink" title="案例游戏"></a>案例游戏</h4><ul><li><strong>《命令与征服》系列</strong>：<br>某些版本的《命令与征服》使用了混合型架构，结合了客户端-服务器和点对点的优势，使得游戏既可以在局域网中高效运行，又可以通过服务器进行更广泛的匹配和竞赛。</li><li><strong>《GTA在线》（Grand Theft Auto Online）</strong>：<br>这款游戏在某些方面使用了类似于客户端-服务器的架构，但在其他方面，如玩家间的直接交互，则采用了点对点通信。</li></ul><h2 id="2-2-同步方式"><a href="#2-2-同步方式" class="headerlink" title="2.2 同步方式"></a>2.2 同步方式</h2><p>在实际游戏开发中，有时也会采用帧同步和状态同步的混合策略，以平衡实时性和效率。</p><h3 id="2-2-1-帧同步-Frame-Synchronization"><a href="#2-2-1-帧同步-Frame-Synchronization" class="headerlink" title="2.2.1 帧同步 Frame Synchronization"></a>2.2.1 帧同步 Frame Synchronization</h3><p><strong>概念：</strong><br>在帧同步中，游戏被划分为一系列帧，每一帧都表示一个瞬间的游戏状态。<br>所有玩家在每一帧中发送他们的输入到服务器，服务器进行处理，然后将更新的游戏状态广播给所有玩家。<br>所有客户端根据接收到的状态更新来渲染下一帧。</p><p><strong>工作原理：</strong></p><ol><li><strong>输入收集：</strong> 每个客户端在每一帧中记录玩家的输入，例如键盘按键、鼠标移动等。</li><li><strong>输入发送：</strong> 客户端将输入信息发送到服务器。</li><li><strong>状态更新：</strong> 服务器根据接收到的所有玩家的输入，计算并更新游戏状态。</li><li><strong>状态广播：</strong> 服务器将新的游戏状态广播给所有连接的客户端。</li><li><strong>状态接收和渲染：</strong> 客户端接收新状态并使用它来渲染下一帧。</li></ol><p><strong>优点：</strong></p><ul><li>玩家在同一帧中看到相同的游戏状态，保持了实时性。</li><li>对于快节奏的游戏，帧同步能提供更好的玩家体验。</li></ul><p><strong>缺点：</strong></p><ul><li>需要较高的带宽和处理能力，尤其是在大规模多人在线游戏中。</li><li>对网络延迟和不稳定性敏感，可能导致不同玩家看到不同的游戏状态。</li></ul><p><strong>适用于：</strong></p><ul><li>快节奏的实时多人游戏，如射击游戏、格斗游戏等。</li><li>要求玩家在同一时刻看到相同状态的场景。</li></ul><p>应用场景和游戏案例：</p><ol><li><strong>实时射击游戏：</strong><br><strong>应用场景：</strong> 快节奏的射击游戏，玩家需要在同一时刻看到相同的敌人和环境状态。<br><strong>游戏案例：</strong> 如《Counter-Strike: Global Offensive》、《Overwatch》等。</li><li><strong>格斗游戏：</strong><br><strong>应用场景：</strong> 玩家进行实时对战，需要确保所有玩家看到相同的动作和攻击效果。<br><strong>游戏案例：</strong> 如《街头霸王》、《超级马里奥派对》等。</li><li><strong>赛车游戏：</strong><br><strong>应用场景：</strong> 在多人赛车比赛中，所有玩家需要在同一时刻看到相同的赛道和对手位置。<br><strong>游戏案例：</strong> 如《尘埃3》、《极品飞车》系列等。</li></ol><h3 id="2-2-2-状态同步-State-Synchronization"><a href="#2-2-2-状态同步-State-Synchronization" class="headerlink" title="2.2.2 状态同步 State Synchronization"></a>2.2.2 状态同步 State Synchronization</h3><p><strong>概念：</strong></p><ul><li>在状态同步中，服务器维护整个游戏世界的状态，而不是每一帧的状态。</li><li>客户端定期向服务器请求当前的游戏状态，然后使用接收到的状态更新本地渲染。</li><li>不同的客户端在不同的时间可能看到不同的状态，因为他们在不同的时刻请求了状态。</li></ul><p><strong>工作原理：</strong></p><ol><li><strong>定期状态请求：</strong> 客户端定期向服务器请求当前的游戏状态。</li><li><strong>状态发送：</strong> 服务器响应请求，将当前游戏状态发送给客户端。</li><li><strong>状态接收和渲染：</strong> 客户端接收到新状态并使用它来更新本地渲染。</li></ol><p><strong>优点：</strong></p><ul><li>相对较低的带宽需求，因为不需要每一帧都广播完整的游戏状态。</li><li>对于网络延迟和不稳定性的容忍度较高。</li></ul><p><strong>缺点：</strong></p><ul><li>状态同步引入了较大的延迟，因为客户端只能在定期请求状态时才能看到更新。</li><li>可能导致不同客户端之间的状态差异，影响玩家之间的互动。</li></ul><p><strong>适用于：</strong></p><ul><li>较为宽松的同步要求，例如策略游戏、角色扮演游戏等。</li><li>对带宽和延迟有较为严格的限制。</li></ul><p>应用场景和游戏案例：</p><ol><li><strong>策略游戏：</strong><br><strong>应用场景：</strong> 缓慢节奏、强调战略和决策的游戏类型，可以容忍一些同步延迟。<br><strong>游戏案例：</strong> 如《星际争霸》、《文明 VI》等。</li><li><strong>角色扮演游戏（RPG）：</strong><br><strong>应用场景：</strong> 单人或小型多人团队合作，玩家更注重故事和角色发展。<br><strong>游戏案例：</strong> 如《巫师 3：狂猎》、《上古卷轴 V：天际》等。</li><li><strong>虚拟世界游戏：</strong><br><strong>应用场景：</strong> 大型多人在线游戏，强调玩家自由探索和社交互动。<br><strong>游戏案例：</strong> 如《魔兽世界》、《黑色沙漠》等。</li></ol><h3 id="2-2-3-混合同步（Hybrid-Synchronization）"><a href="#2-2-3-混合同步（Hybrid-Synchronization）" class="headerlink" title="2.2.3 混合同步（Hybrid Synchronization）"></a>2.2.3 混合同步（Hybrid Synchronization）</h3><ul><li><strong>概念：</strong> 结合了多种同步技术，根据游戏的不同部分和需求选择不同的同步策略。</li><li><strong>适用场景：</strong> 复杂的多人游戏，其中不同游戏元素和互动可能需要不同的同步方法。</li><li><strong>优点：</strong> 灵活，可以针对不同游戏场景和需求优化。</li><li><strong>缺点：</strong> 实现复杂，需要精细调整和测试。</li></ul><h1 id="3-游戏引擎网络模块"><a href="#3-游戏引擎网络模块" class="headerlink" title="3. 游戏引擎网络模块"></a>3. 游戏引擎网络模块</h1><h2 id="3-1-Unity官方"><a href="#3-1-Unity官方" class="headerlink" title="3.1 Unity官方"></a>3.1 Unity官方</h2><h3 id="UNET（Unity-Networking）"><a href="#UNET（Unity-Networking）" class="headerlink" title="UNET（Unity Networking）"></a>UNET（Unity Networking）</h3><p>UNET是Unity的早期网络模块，旨在简化多人游戏的开发。然而，在Unity 2019.1版本后，Unity宣布停止对UNET的维护，将重心转向新一代的Networking。</p><p>UNET的主要特点和组件包括：</p><ul><li><strong>NetworkManager：</strong> 用于管理多人游戏的主要组件，处理连接、断开、玩家管理等。</li><li><strong>NetworkIdentity：</strong> 标识具有网络同步行为的对象。</li><li><strong>NetworkBehaviour：</strong> 通过继承该类，可以在脚本中实现网络同步的行为。</li><li><strong>SyncVar：</strong> 用于标记在客户端和服务器之间同步的变量。</li><li><strong>RPC（Remote Procedure Call）：</strong> 用于在客户端和服务器之间调用函数。</li></ul><p>UNET的主要缺点在于其设计相对复杂，可能会在大型项目中引起性能问题，并且在Unity版本升级后停止了官方维护。</p><h3 id="Networking（Multiplayer-HLAPI）："><a href="#Networking（Multiplayer-HLAPI）：" class="headerlink" title="Networking（Multiplayer HLAPI）："></a>Networking（Multiplayer HLAPI）：</h3><p>新一代的Networking模块是对UNET的改进和替代，它在Unity 2019.1版本后成为官方推荐的网络解决方案。它通过简化API、提高性能和引入新的概念来改进网络开发体验。</p><p>Networking的主要特点和组件包括：</p><ul><li><strong>NetworkManager：</strong> 与UNET中的NetworkManager类似，用于管理多人游戏的主要组件。</li><li><strong>NetworkIdentity：</strong> 标识具有网络同步行为的对象。</li><li><strong>NetworkBehaviour：</strong> 通过继承该类，可以在脚本中实现网络同步的行为。</li><li><strong>SyncVar：</strong> 仍然用于标记在客户端和服务器之间同步的变量。</li><li><strong>Command 和 ClientRpc：</strong> 取代了UNET中的RPC，用于在客户端和服务器之间调用函数。</li><li><strong>Spawnable Prefabs：</strong> 管理在不同客户端之间同步生成和销毁的物体。</li><li><strong>NetworkTransform：</strong> 管理物体的位置和旋转同步。</li><li><strong>NetworkAnimator：</strong> 用于同步动画状态。</li></ul><p>新一代的Networking模块在性能和易用性上有所提升，因此在选择网络模块时，推荐使用Unity的Networking。具体选择取决于项目需求、Unity版本以及个人或团队的熟悉程度。</p><h2 id="3-2-社区框架"><a href="#3-2-社区框架" class="headerlink" title="3.2 社区框架"></a>3.2 社区框架</h2><p>Mirror 是一个基于 Unity 的开源网络框架，专门用于简化和增强多人游戏的开发。它是从 Unity 的 Networking 模块中分离出来的独立项目，旨在提供更好的性能、更简单的 API 和更好的可维护性。</p><h1 id="4-多线程"><a href="#4-多线程" class="headerlink" title="4. 多线程"></a>4. 多线程</h1><h1 id="5-同步算法"><a href="#5-同步算法" class="headerlink" title="5. 同步算法"></a>5. 同步算法</h1><h1 id="6-网络优化"><a href="#6-网络优化" class="headerlink" title="6. 网络优化"></a>6. 网络优化</h1><h2 id="6-1-预测与回滚-Prediction-and-Rollback"><a href="#6-1-预测与回滚-Prediction-and-Rollback" class="headerlink" title="6.1 预测与回滚 Prediction and Rollback"></a>6.1 预测与回滚 Prediction and Rollback</h2><h3 id="2-锁步（Lockstep）机制："><a href="#2-锁步（Lockstep）机制：" class="headerlink" title="2. 锁步（Lockstep）机制："></a>2. 锁步（Lockstep）机制：</h3><ul><li><strong>概念：</strong> 在锁步机制中，所有的客户端必须在进入下一帧之前达成当前帧的一致状态。这通常通过交换和确认每个玩家的输入来实现。</li><li><strong>适用场景：</strong> 需要严格一致性的策略游戏和回合制游戏。</li><li><strong>优点：</strong> 确保了游戏状态的完全一致性。</li><li><strong>缺点：</strong> 对网络延迟非常敏感，可能导致游戏进度放慢。</li></ul><h3 id="4-区域同步（Area-of-Interest-Synchronization）："><a href="#4-区域同步（Area-of-Interest-Synchronization）：" class="headerlink" title="4. 区域同步（Area of Interest Synchronization）："></a>4. 区域同步（Area of Interest Synchronization）：</h3><ul><li><p><strong>概念：</strong> 只同步玩家当前所在区域或感兴趣区域的状态，而非整个游戏世界。</p></li><li><p><strong>适用场景：</strong> 大型多人在线游戏（MMORPGs）和广阔的开放世界游戏。</p></li><li><p><strong>优点：</strong> 减少了需要同步的数据量，提高了效率，特别是在大型游戏世界中。</p></li><li><p><strong>缺点：</strong> 需要复杂的管理逻辑来处理玩家移动和不同区域之间的交互。</p></li></ul><h1 id="7-项目实战"><a href="#7-项目实战" class="headerlink" title="7. 项目实战"></a>7. 项目实战</h1>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DoTween速成</title>
    <link href="/2023/01/01/DoTween%E9%80%9F%E6%88%90/"/>
    <url>/2023/01/01/DoTween%E9%80%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="0-简介"><a href="#0-简介" class="headerlink" title="0. 简介"></a>0. 简介</h1><p><a href="http://dotween.demigiant.com/documentation.php#controls">http://dotween.demigiant.com/documentation.php#controls</a></p><h1 id="普通版本内容"><a href="#普通版本内容" class="headerlink" title="普通版本内容"></a>普通版本内容</h1><h1 id="1-Unity常用组件拓展方法"><a href="#1-Unity常用组件拓展方法" class="headerlink" title="1. Unity常用组件拓展方法"></a>1. Unity常用组件拓展方法</h1><h2 id="1-1-Transform拓展方法"><a href="#1-1-Transform拓展方法" class="headerlink" title="1.1 Transform拓展方法"></a>1.1 Transform拓展方法</h2><h3 id="1-1-1-DoMove-移动"><a href="#1-1-1-DoMove-移动" class="headerlink" title="1.1.1 DoMove 移动"></a>1.1.1 DoMove 移动</h3><ul><li><p><strong>世界坐标：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOMove(Vector3 目标位置, <span class="hljs-built_in">float</span> 移动时间);<br>transform.DOMoveX(<span class="hljs-built_in">float</span>  目标位置, <span class="hljs-built_in">float</span> 移动时间);<span class="hljs-comment">// 按X轴线移动</span><br>transform.DOMoveY(<span class="hljs-built_in">float</span>  目标位置, <span class="hljs-built_in">float</span> 移动时间);<span class="hljs-comment">// 按Y轴线移动</span><br>transform.DOMoveZ(<span class="hljs-built_in">float</span>  目标位置, <span class="hljs-built_in">float</span> 移动时间);<span class="hljs-comment">// 按Z轴线移动</span><br></code></pre></td></tr></table></figure></li><li><p><strong>局部坐标:</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOLocalMove(Vector3 目标位置, <span class="hljs-built_in">float</span> 移动时间);<br>transform.DOLocalMoveX(<span class="hljs-built_in">float</span>  目标位置, <span class="hljs-built_in">float</span> 移动时间);<span class="hljs-comment">// 按X轴线移动</span><br>transform.DOLocalMoveY(<span class="hljs-built_in">float</span>  目标位置, <span class="hljs-built_in">float</span> 移动时间);<span class="hljs-comment">// 按Y轴线移动</span><br>transform.DOLocalMoveZ(<span class="hljs-built_in">float</span>  目标位置, <span class="hljs-built_in">float</span> 移动时间);<span class="hljs-comment">// 按Z轴线移动</span><br></code></pre></td></tr></table></figure><h3 id="1-1-2-DORotate-旋转"><a href="#1-1-2-DORotate-旋转" class="headerlink" title="1.1.2 DORotate 旋转"></a>1.1.2 DORotate 旋转</h3></li><li><p><strong>世界旋转</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DORotate(Vector3 目标欧拉角, <span class="hljs-built_in">float</span> 旋转时间);<br>transform.DORotateQuaternion(Quaternion 目标四元数, <span class="hljs-built_in">float</span> 旋转时间);<br></code></pre></td></tr></table></figure></li><li><p><strong>局部旋转</strong></p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOLocalRotate(Vector3 目标欧拉角, <span class="hljs-built_in">float</span> 旋转时间);<br>transform.DOLocalRotateQuaternion(Quaternion 目标四元数, <span class="hljs-built_in">float</span> 旋转时间);<br></code></pre></td></tr></table></figure></li><li><p><strong>朝向</strong><br>在给定时间内，平滑的让自身的z轴正方向指向目标点</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOLookAt(Vector3 目标位置, <span class="hljs-built_in">float</span> 旋转时间);<br></code></pre></td></tr></table></figure><h3 id="1-1-3-Scale-缩放"><a href="#1-1-3-Scale-缩放" class="headerlink" title="1.1.3 Scale 缩放"></a>1.1.3 Scale 缩放</h3></li></ul><p>在给定时间内，平滑的改变物体的缩放到目标值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOScale(Vector3 目标大小, <span class="hljs-built_in">float</span> 缩放时间);<br>transform.DOScaleX(<span class="hljs-built_in">float</span> 目标大小, <span class="hljs-built_in">float</span> 缩放时间);<span class="hljs-comment">// 按X轴线缩放</span><br>transform.DOScaleY(<span class="hljs-built_in">float</span> 目标大小, <span class="hljs-built_in">float</span> 缩放时间);<span class="hljs-comment">// 按Y轴线缩放</span><br>transform.DOScaleZ(<span class="hljs-built_in">float</span> 目标大小, <span class="hljs-built_in">float</span> 缩放时间);<span class="hljs-comment">// 按Z轴线缩放</span><br></code></pre></td></tr></table></figure><h3 id="1-1-4-Punch-震动"><a href="#1-1-4-Punch-震动" class="headerlink" title="1.1.4 Punch 震动"></a>1.1.4 Punch 震动</h3><p><code>transform.DOPunchXXX(Vector3 punch, float duration, int vibrato, float elascity)</code></p><ol><li><p>punch：表示方向及强度</p></li><li><p>duration：表示动画持续时间</p></li><li><p>vibrato：震动次数</p></li><li><p>elascity: 这个值是0到1的</p><p>当为0时，就是在起始点到目标点之间运动<br>不为0时，会把你赋的值乘上一个参数，作为你运动方向反方向的点，物体在这个点和目标点之间运动</p><blockquote><p>以position为例，elascity的取值是 0 到 1 的</p><ul><li>elascity为0时，物体就在起始点和目标点之间运动</li><li>elascity不为0时，会自动计算，产生一个反向点，数值越大方向点离的越远</li></ul></blockquote></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOPunchPosition(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.1f</span>);<br>transform.DOPunchRotation(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.1f</span>);<br>transform.DOPunchScale(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0.1f</span>);<br></code></pre></td></tr></table></figure><h3 id="1-1-4-Shake"><a href="#1-1-4-Shake" class="headerlink" title="1.1.4 Shake"></a>1.1.4 Shake</h3><p>参数：持续时间，力量，震动，随机性，淡出</p><ul><li>力量：实际就是震动的幅度,可以理解成相机施加的力的大小 使用Vector3可以选择每个轴向不同的强度</li><li>震动：震动次数</li><li>随机性：改变震动方向的随机值（大小：0~180）</li><li>淡出：就是运动最后是否缓慢移动回到原本位置</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOShakePosition(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-literal">true</span>);<br>transform.DOShakeRotation(<span class="hljs-number">3</span>);<br>transform.DOShakeScale(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="1-1-4-Blend"><a href="#1-1-4-Blend" class="headerlink" title="1.1.4 Blend"></a>1.1.4 Blend</h3><p>带Blend名称的方法，可以允许动画混合执行播放</p><p>原本同时执行两个Move方法，只会执行最新的一个动画命令<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOMove(Vector3.one, <span class="hljs-number">2</span>);<br>transform.DOMove(Vector3.one * <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>结果是物体运动到了（2,2,2）坐标上</p><p>而使用带Blend名称的方法，有以下两个特点：</p><ol><li><p>允许多个同时执行<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOBlendableMoveBy(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<br>transform.DOBlendableMoveBy(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>假设其实点为（0,0,0），最后动画停止时的坐标就是（0,1,1）</p></li><li><p>它是增量动画<br>   <code>transform.DOBlendableMoveBy(new Vector3(1, 1, 1), 1);</code><br>   假设其实点为（1,1,1），最后动画停止时的坐标就是（2,2,2）<br>   它的参数不是目标点，而是要移动的量</p></li></ol><p>以下三个函数同理</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">transform.DOBlendableRotateBy();<br>transform.DOBlendableScaleBy();<br>transform.DOBlendablePunchRotation();<br></code></pre></td></tr></table></figure><h2 id="1-2-Camera拓展方法"><a href="#1-2-Camera拓展方法" class="headerlink" title="1.2 Camera拓展方法"></a>1.2 Camera拓展方法</h2><ul><li>调整屏幕视角的宽高比 第一个参数是宽高的比值<br>  <code>camera.DOAspect(0.6f, 2);</code></li><li>改变相机background参数的颜色<br>  <code>camera.DOColor(Color.blue, 2);</code></li><li>改变相机近切面的值<br>  <code>camera.DONearClipPlane(200, 2);</code></li><li>改变相机远切面的值<br>  <code>camera.DOFarClipPlane(2000, 2);</code></li><li>改变相机FOV的值<br>  <code>camera.DOFieldOfView(30, 2);</code></li><li>改变相机正交大小<br>  <code>camera.DOOrthoSize(10, 2);</code></li><li>按照屏幕像素计算的显示范围<br>  <code>camera.DOPixelRect(new Rect(0f, 0f, 600f, 500f), 2);</code></li><li>按照屏幕百分比计算的显示范围<br>  <code>camera.DORect(new Rect(0.5f, 0.5f, 0.5f, 0.5f), 2);</code></li><li>相机震动<br>  <code>camera.DOShakePosition(1, 10, 10, 50, false);</code><br>  参数：持续时间，力量，震动，随机性，淡出<ul><li>力量：实际就是震动的幅度,可以理解成相机施加的力的大小 使用Vector3可以选择每个轴向不同的强度</li><li>震动：震动次数</li><li>随机性：改变震动方向的随机值（大小：0~180）</li><li>淡出：就是运动最后是否缓慢移动回到原本位置</li></ul></li></ul><h2 id="1-3Material拓展方法"><a href="#1-3Material拓展方法" class="headerlink" title="1.3Material拓展方法"></a>1.3Material拓展方法</h2><ul><li><p>改变颜色<br>  <code>material.DOColor(Color.black, 2);</code></p></li><li><p>按照shader的属性名，修改颜色<br>  <code>material.DOColor(Color.clear, &quot;_Color&quot;, 2);</code></p></li><li><p>修改alpha值<br>  <code>material.DOFade(0, 2);</code></p></li><li><p>颜色渐变</p><p>  <code>material.DOGradientColor(Gradient, &quot;_Color&quot;, 3);</code></p><blockquote><p>Gradient是unity的渐变编辑器</p></blockquote></li><li><p>改变材质offset的值<br>  <code>material.DOOffset(new Vector2(1, 1), 2);</code></p></li><li><p>改变提供的shader属性的名称对应的Vector4值<br>  <code>material.DOVector(new Vector4(0, 0, 0, 1), &quot;_Color&quot;, 3);</code></p></li><li><p>颜色混合变化<br>  跟位置混合动画同理，可以同时执行而不干扰，产生混合在一起的颜色<br>  <code>material.DOBlendableColor(Color.red, &quot;_Color&quot;, 3);</code></p></li></ul><h2 id="1-4-Text拓展方法"><a href="#1-4-Text拓展方法" class="headerlink" title="1.4 Text拓展方法"></a>1.4 Text拓展方法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">text.DOColor(Color.black, <span class="hljs-number">2</span>);<br>text.DOFade(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>text.DOBlendableColor(Color.black, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>是把第一个参数传入的内容按照时间，一个字一个字的输入到文本框中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">text.DOText(<span class="hljs-string">&quot;context&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h1 id="2-Sequence-动画队列"><a href="#2-Sequence-动画队列" class="headerlink" title="2. Sequence 动画队列"></a>2. Sequence 动画队列</h1><p><a href="https://www.azimiao.com/3835.html">https://www.azimiao.com/3835.html</a></p><ul><li>初始化动画队列<br><code>Sequence quence = DOTween.Sequence();</code></li><li>添加动画到队列中<br><code>quence.Append(transform.DOMove(Vector3.one, 2));</code></li><li>添加时间间隔<br><code>quence.AppendInterval(1);</code></li><li>按时间点插入动画<pre><code>第一个参数为时间，此方法把动画插入到规定的时间点以这句话为例，它把DORotate动画添加到此队列的0秒时执行，虽然它不是最先添加进队列的`quence.Insert(0, transform.DORotate(new Vector3(0, 90, 0), 1));`</code></pre></li><li>加入当前动画<pre><code>Join会加入和让动画与当前正在执行的动画一起执行如下两行代码，DOMove会和DOScale一起执行quence.Append(transform.DOScale(new Vector3(2, 2, 2), 2));quence.Join(transform.DOMove(Vector3.zero, 2));</code></pre></li><li>预添加动画<pre><code>预添加 会直接添加动画到Append的前面，也就是最开始的时候quence.Prepend(transform.DOScale(Vector3.one * 0.5f, 1));这里需要特别说一下预添加的执行顺序问题它这里也采取了队列的性质，不过，预添加与原本的的队列相比是一个反向队列例如： Sequence quence = DOTween.Sequence(); quence.Append(transform.DOMove(Vector3.one, 2)); quence.Prepend(transform.DOMove(-Vector3.one*2, 2)); quence.PrependInterval(1); 执行顺序是 PrependInterval----Prepend-----Append 就是最后添加的会在队列的最顶端</code></pre></li><li>预添加时间间隔<br><code>quence.PrependInterval(1);</code></li><li>回调函数<ul><li>预添加回调<br><code>quence.PrependCallback(PreCallBack);</code></li><li>在规定的时间点加入回调<br><code>quence.InsertCallback(0, InsertCallBack);</code></li><li>添加回调<br><code>quence.AppendCallback(CallBack);</code></li></ul></li></ul><h1 id="3-Tweener-补间"><a href="#3-Tweener-补间" class="headerlink" title="3. Tweener 补间"></a>3. Tweener 补间</h1><p><a href="https://blog.csdn.net/qq_40985921/article/details/88875338">https://blog.csdn.net/qq_40985921/article/details/88875338</a></p><p> TweenParams para = new TweenParams();</p><p>  1）设置动画循环<br>    第一个参数是循环次数  -1代表无限循环<br>    第二个参数是循环方式<br>     Restart  重新开始<br>     Yoyo   从起始点运动到目标点，再从目标点运动回来，这样循环<br>     Incremental   一直向着运动方向运动<br>    para.SetLoops(-1, LoopType.Yoyo);</p><p>  2）设置参数<br>    transform.DOMove(Vector3.one, 2).SetAs(para);</p><p>  3)设置自动杀死动画<br>    transform.DOMove(Vector3.one, 1).SetAutoKill(true);</p><p>  4)from补间<br>    例如;<br>    transform.DOMove(Vector3.one, 2).From(true);<br>      From参数 isRelative(相对的)：<br>       为true，传入的就是偏移量，即当前坐标 + 传入值 = 目标值<br>       为falese，传入的就是目标值，即传入值 = 目标值</p><p>  5)设置动画延时<br>    transform.DOMove(Vector3.one, 2).SetDelay(1);</p><p>  6）设置动画运动以速度为基准<br>     例如：<br>     transform.DOMove(Vector3.one, 1).SetSpeedBased();<br>      使用SetSpeedBased时，移动方式就变成以速度为基准<br>      原本表示持续时间的第二个参数，就变成表示速度的参数，每秒移动的单位数</p><p>  7）设置动画ID<br>    transform.DOMove(Vector3.one, 2).SetId(“Id”);</p><p>  8）设置是否可回收<br>    为true的话，动画播放完会被回收，缓存下来，不然播完就直接销毁<br>    transform.DOMove(Vector3.one, 2).SetRecyclable(true);</p><p>  9）设置动画为增量运动<br>      例如：<br>       transform.DOMove(Vector3.one, 2).SetRelative(true);<br>        SetRelative参数 isRelative(相对的)：<br>        为true，传入的就是偏移量，即当前坐标 + 传入值 = 目标值<br>        为falese，传入的就是目标值，即传入值 = 目标值</p><p>  10）设置动画的帧函数<br>   例如：<br>    transform.DOMove(Vector3.one, 2).SetUpdate(UpdateType.Normal, true);<br>     第一个参数 UpdateType :选择使用的帧函数<br>     UpdateType.Normal:更新每一帧中更新要求。<br>     UpdateType.Late:在LateUpdate调用期间更新每一帧。<br>     UpdateType.Fixed:使用FixedUpdate调用进行更新。<br>     UpdateType.Manual:通过手动DOTween.ManualUpdate调用进行更新。<br>     第二个参数：为TRUE，则补间将忽略Unity的Time.timeScale</p><h1 id="4-Ease-运动曲线"><a href="#4-Ease-运动曲线" class="headerlink" title="4. Ease 运动曲线"></a>4. Ease 运动曲线</h1><p> 1）以Ease枚举作为参数<br>          例如：<br>          transform.DOMove(Vector3.one, 2).SetEase(Ease.Flash, 3, 0f);<br>         第二个参数 Amplitude(振幅)：实际就是移动次数，起始点移动到目标算移动一次，再移动回来移动两次<br>         第三个参数 period 值的范围是 - 1~1<br>          值 &gt; 0时，为活动范围的衰减值，活动范围会由大变小<br>          值 = 0时，就是均匀的在起始坐标和目标坐标之间运动<br>          值 &lt; 0时，会施加一个向目标坐标的一个力，活动范围一点点增大，最后逼近目标点<br>         这两个参数只对Flash, InFlash, OutFlash, InOutFlash这四种曲线有用，其他的曲线起作用的就只有Ease枚举参数</p><pre><code>2）使用AnimationCurve当作参数  例如：   transform.DOMove(Vector3.one * 2, 1).SetEase(curve);  AnimationCurve 横轴是时间,不过不是具体的时间，而是时间比例  AnimationCurve 纵轴是倍数  假设纵轴的值为v，传入DOMove的第一个参数endValue是e，起始点坐标是s  此物体最后动画结束时的实际坐标即为 v* （e -s）+ s   3）以回调函数为参数  例如：   transform.DOMove(Vector3.one * 2, 1).SetEase(MyEaseFun);      //返回值是运动距离的百分比 值应为0~1之间，最后的值需为1,不然停留的位置不会是目标位置   private float MyEaseFun(float time, float duration, float overshootOrAmplitude, float period)   &#123;       return time / duration;   &#125;</code></pre><h1 id="5-回调函数"><a href="#5-回调函数" class="headerlink" title="5. 回调函数"></a>5. 回调函数</h1><p>​      1）动画完成回调<br>​        transform.DOMove(Vector3.one, 2).OnComplete(() =&gt; { });<br>​        </p><pre><code>  2）动画被杀死时回调    transform.DOMove(Vector3.one, 2).OnKill(() =&gt; &#123; &#125;);      3）动画播放时回调,暂停后重新播放也会调用    transform.DOMove(Vector3.one, 3).OnPlay(() =&gt; &#123; &#125;);      4）动画暂停时回调    transform.DOMove(Vector3.one, 2).OnPause(() =&gt; &#123; &#125;);      5）动画回退时回调    以下情况会被调用    使用DORestart重新播放时    使用Rewind倒播动画完成时    使用DOFlip翻转动画完成时    使用DOPlayBackwards反向播放动画完成时    transform.DOMove(Vector3.one, 2).OnRewind(() =&gt; &#123; &#125;);      6）只在第一次播放动画时调用，在play之前调用    transform.DOMove(Vector3.one, 2).OnStart(() =&gt; &#123; &#125;);      7）完成单个循环周期时触发    transform.DOMove(Vector3.one, 2).OnStepComplete(() =&gt; &#123; &#125;);  8）帧回调    transform.DOMove(Vector3.one, 2).OnUpdate(() =&gt; &#123; &#125;);      9）在路径动画时，改变目标点时的回调，参数为当前目标点的下标    transform.DOMove(Vector3.one, 2).OnWaypointChange((value) =&gt; &#123; &#125;);</code></pre><p>(5) 动画控制方法<br>      1)播放<br>        transform.DOPlay();</p><pre><code>  2)暂停    transform.DOPause();      3)重播    transform.DORestart();      4)倒播，此方法会直接退回起始点    transform.DORewind();      5)平滑倒播，此方法会按照之前的运动方式从当前位置退回起始点    transform.DOSmoothRewind();      6)杀死动画    transform.DOKill();      7)翻转补间的方向    transform.DOFlip();      8)跳转时间点    第一个参数跳转的时间点，第二个参数是跳转后是否播放动画    transform.DOGoto(1.5f, true);      9）反向播放动画    反向播放动画，在动画播放到一半时执行，会退回起始点，在一开始执行看不到效果是因为，物体本身就在起始点    transform.DOPlayBackwards();      10）正向播放动画    正向播放动画    transform.DOPlayForward();      11）TogglePause    当暂停时，执行就继续播放，播放时，执行就暂停    transform.DOTogglePause();</code></pre><h1 id="6-获取数据方法"><a href="#6-获取数据方法" class="headerlink" title="6. 获取数据方法"></a>6. 获取数据方法</h1><p>  一、类方法<br>      1）返回所有暂停的动画，没有则返回null<br>        DOTween.PausedTweens();</p><pre><code>  2）返回所有真正播放的动画，没有则返回null    DOTween.PlayingTweens();      3）获取给定ID的数组   例如：   DOTween.TweensById(&quot;id&quot;, true);    返回满足条件的动画数组    第一个参数是动画的ID    第二个参数是是否只收集正在播放的动画      4）返回给定对象的数组   例如：   DOTween.TweensByTarget(transform, true);     返回满足条件的动画数组     第一个参数是播放动画的对象     例如：transform.DOMove(Vector3.one, 2); 第一个参数就传入transform          material.DOColor(Color.White, 2); 第一个参数就传入材质对象material     第二个参数是是否只收集正在播放的动画      5）收集传入的对象是否有动画在活动   例如：   DOTween.IsTweening(transform);    第一个参数为检测的对象    第二个参数为是否检测动画在播放状态     为true时，给定对象在播放状态时 返回true     为false时，只检测给定对象是否有动画（在pause状态时也算）有则返回true      6）正在播放的动画的总数，目前处于延迟播放状态的动画也算    DOTween.TotalPlayingTweens();</code></pre><p>  二、实例方法<br>      _tweener = transform.DOMove(Vector3.one, 2)</p><pre><code>  1）表示动画执行时间的属性，可读可写    _tweener.fullPosition = 1;      2）表示动画执行完的次数   _tweener.CompletedLoops()      3）获取动画的延迟时间    _tweener.Delay();      4）获取动画的持续时间    参数为true 表示计算循环的时间，无限循环为Infinity    _tweener.Duration(false)      5）动画已播放的时间    参数为true 表示计算循环的时间    _tweener.Elapsed()      6）返回动画进度的百分比    起始点为0 目标点为1 当yoyo循环模式下，值会从0变到1再从1变到0    _tweener.ElapsedDirectionalPercentage()      7）返回动画区间已用的百分比    单次循环的数值为0到1    参数为 是否包含循环 为true时 返回值是循环总区间的已用百分比 若为无限循环 返回值为0    _tweener.ElapsedPercentage(true)      8）动画是否在活动    _tweener.IsActive();      9）是否是反向动画    _tweener.IsBackwards();      10）动画是否完成    _tweener.IsComplete();      11）是否以初始化    _tweener.IsInitialized();      12）是否正在播放    _tweener.IsPlaying();      13）返回循环次数，  无限循环为Infinity    _tweener.Loops();</code></pre><h1 id="7-携程方法"><a href="#7-携程方法" class="headerlink" title="7. 携程方法"></a>7. 携程方法</h1><p>​    private IEnumerator Wait()<br>​    {<br>​        _tweener = transform.DOMove(Vector3.one, 2);<br>​        </p><pre><code>  1)等待动画执行完    yield return _tweener.WaitForCompletion();      2）等待指定的循环次数    参数为执行次数，等待传入的循环次数后，继续执行    若是传入的次数大于动画的循环次数 则在动画结束时继续执行    yield return _tweener.WaitForElapsedLoops(2);      3）等待动画被杀死    yield return _tweener.WaitForKill();      4）等待动画执行指定时间    参数为时间，动画执行传入的时间之后或动画执行完毕，继续执行    yield return _tweener.WaitForPosition(0.5f);      5）等待动画回退    以下情况会继续执行函数    使用DORestart重新播放时    使用Rewind倒播动画完成时    使用DOFlip翻转动画完成时    使用DOPlayBackwards反向播放动画完成时    yield return _tweener.WaitForRewind();      6）等待Start执行后继续执行    yield return _tweener.WaitForStart();&#125;</code></pre><h1 id="Pro版本内容"><a href="#Pro版本内容" class="headerlink" title="Pro版本内容"></a>Pro版本内容</h1><h1 id="8-Path-路径动画"><a href="#8-Path-路径动画" class="headerlink" title="8. Path 路径动画"></a>8. Path 路径动画</h1><p><a href="https://blog.csdn.net/zcaixzy5211314/article/details/84988535">https://blog.csdn.net/zcaixzy5211314/article/details/84988535</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>DoTween</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DoTween</tag>
      
      <tag>Unity插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 2D射击小游戏瞄准线的实现</title>
    <link href="/2022/03/01/Unity3D%202D%E5%B0%84%E5%87%BB%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9E%84%E5%87%86%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/01/Unity3D%202D%E5%B0%84%E5%87%BB%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9E%84%E5%87%86%E7%BA%BF%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>本片文章是对<a href="https://www.bilibili.com/video/bv1sY411V7tx%E8%A7%86%E9%A2%91%E4%B8%AD%E7%9E%84%E5%87%86%E7%BA%BF%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AE%B2%E8%A7%A3%E6%95%99%E7%A8%8B%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%8E%BBB%E7%AB%99%E7%BB%99%E6%88%91%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%E9%B8%AD%EF%BC%81">https://www.bilibili.com/video/bv1sY411V7tx视频中瞄准线是如何实现的一个讲解教程，欢迎大家去B站给我一键三连鸭！</a></p><p>这个项目的整个代码和资源已经上传到了GitHub，大家可以去看一下<br>链接：<a href="https://github.com/MycroftCooper/TigerShooting2DGame">https://github.com/MycroftCooper/TigerShooting2DGame</a></p><h1 id="1-效果分析"><a href="#1-效果分析" class="headerlink" title="1. 效果分析"></a>1. 效果分析</h1><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220222715775.png" srcset="/img/loading.gif" alt="image-20220220222715775"></p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/%E7%9E%84%E5%87%86%E7%BA%BF.gif" srcset="/img/loading.gif" alt="瞄准线"></p><p>根据视频中的瞄准线效果，我们可以分析出，它应该具有以下几个功能：</p><ol><li>准星会时刻和玩家鼠标保持位置一致</li><li>瞄准线的另一头始终要在枪上</li><li>当准星放在敌人身上，瞄准线和准星会变红</li><li>当开火时准星会有所变化</li></ol><h1 id="2-素材准备"><a href="#2-素材准备" class="headerlink" title="2. 素材准备"></a>2. 素材准备</h1><p>根据以上四个功能，我们就可以知道，其实这个瞄准线的效果应该是分为瞄准线和准星两部分的<br>所以，我们分别准备好这两部分的素材：<br><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220223426285.png" srcset="/img/loading.gif" alt="image-20220220223426285"></p><p>其中Line为瞄准线，而Sight为准星。</p><h2 id="2-1-瞄准线-Line"><a href="#2-1-瞄准线-Line" class="headerlink" title="2.1 瞄准线 Line"></a>2.1 瞄准线 Line</h2><p>瞄准线的素材有两种：</p><ol><li>红线：瞄准敌人时使用</li><li>白线：没瞄上敌人时使用</li></ol><p>准线是要做成预制体放在游戏里的，所以一张图导入Unity后按照Sprite去切就没问题</p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220223646127.png" srcset="/img/loading.gif" alt="image-20220220223646127"></p><p>因为是像素游戏，所以记得正确设置<strong>单位像素数</strong>，<strong>网格类型</strong>和<strong>过滤模式</strong>，设置如下：<br><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220224440440.png" srcset="/img/loading.gif" alt="image-20220220224440440"></p><p>在切的时候需要注意的是，瞄准线的长度我们想让它是可变的，而且是从固定的一段开始伸缩。所以在用精灵切片的时候需要做两件事：设置<strong>平铺边界</strong>(绿色线)和<strong>锚点</strong>(设到左边)，如下图所示：<br><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220224315712.png" srcset="/img/loading.gif" alt="image-20220220224315712"></p><p>如此一来，瞄准线的素材图就导入成功了，接下来就是：</p><ol><li>创建一个预制体</li><li>添加一个精灵渲染器</li><li>将精灵设为刚刚切好的一个瞄准线的精灵图片</li><li>设置绘制模式(只有设置成平铺才能任意伸缩)</li><li>设置图层顺序(设成-2就能保证瞄准线总是在图层的最前面了)</li></ol><p>如下图所示：</p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220224836597.png" srcset="/img/loading.gif" alt="image-20220220224836597"></p><p>瞄准线的素材就准备完毕啦！</p><h2 id="2-2-准星Sight"><a href="#2-2-准星Sight" class="headerlink" title="2.2 准星Sight"></a>2.2 准星Sight</h2><p>准星有四种素材：</p><ol><li>Sight_Off：没瞄到敌人且没开火的准星</li><li>Sight_Off_Fire：没瞄到敌人还开火的准星</li><li>Sight_On：瞄到敌人但没开火的准星</li><li>Sight_On_Fire：瞄到敌人还开火的准星</li></ol><p>准星实际上有两种实现方法：</p><ol><li>也做成游戏物体加入场景中</li><li>切换游戏光标，让游戏的默认光标变为准星</li></ol><p>这里我们采用第二种方法吧，第一种大家肯定是会的。</p><p>准星的素材图片最好不要使用精灵，而是有一种专门给准星用的格式：光标(Texture 2D)<br>这种格式的图片无法切图，所以最好把准星的图片自己提前切好再导入，如下图所示：</p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220225325559.png" srcset="/img/loading.gif" alt="image-20220220225325559"></p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220225352696.png" srcset="/img/loading.gif" alt="image-20220220225352696"></p><p>这样准星的素材我们也导入完毕了！</p><h2 id="2-3-素材管理代码"><a href="#2-3-素材管理代码" class="headerlink" title="2.3 素材管理代码"></a>2.3 素材管理代码</h2><p>因为在游戏的过程中，我们会根据开火情况和瞄准情况来反复更换准星和瞄准线，所以可以写一份代码来专门管理这两种瞄准线和四种准星的素材。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SightResouses</span> &#123;<br>  <span class="hljs-comment">// 用List存储读取的瞄准线(精灵 Sprite)</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Sprite&gt; spritesList = <br>          <span class="hljs-keyword">new</span> List&lt;Sprite&gt;(Resources.LoadAll&lt;Sprite&gt;(<span class="hljs-string">&quot;Line&quot;</span>));<br>  <br>  <span class="hljs-comment">// 用字典存储读取的准星(2D纹理 Texture2D)</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Texture2D&gt; textureList = <br>          <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Texture2D&gt;&#123;<br>            &#123;<span class="hljs-string">&quot;Sight_On&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_On&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_Off&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_Off&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>)&#125;,<br>        &#125;;<br>  <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Sprite <span class="hljs-title">GetResouseSprite</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt;<br>            spritesList.Find(x =&gt; x.name == name);<br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_On &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_On&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_On_Fire &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_Off &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_Off&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_Off_Fire &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sprite Sight_On_Line &#123; <span class="hljs-keyword">get</span> =&gt; GetResouseSprite(<span class="hljs-string">&quot;Sight_On_Line&quot;</span>); &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sprite Sight_Off_Line &#123; <span class="hljs-keyword">get</span> =&gt; GetResouseSprite(<span class="hljs-string">&quot;Sight_Off_Line&quot;</span>); &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>放在预制体里的瞄准线是 <strong>精灵 Sprite</strong><br>作为光标素材的准星是 <strong>2D纹理 Texture2D</strong></p></blockquote><p>这样，通过静态类SightResouses，我们就可以轻松的拿到需要的素材了</p><h1 id="3-功能实现"><a href="#3-功能实现" class="headerlink" title="3. 功能实现"></a>3. 功能实现</h1><p>根据之前的效果分析，我们接下来拆分一下功能：</p><ol><li>我们需要知道鼠标当前的位置<br>让瞄准线伸缩到合适长度<br>让瞄准线指向光标(准星)</li><li>我们需要知道当前是否处于开火状态<br>并且根据开火状态改变瞄准线与准星的素材资源</li><li>我们需要知道当前是否处于瞄准敌人的状态<br>并且根据瞄准状态改变瞄准线与准星的素材资源</li></ol><p>那么我们就一个一个的去实现吧！</p><h2 id="3-1-伸缩并指向"><a href="#3-1-伸缩并指向" class="headerlink" title="3.1 伸缩并指向"></a>3.1 伸缩并指向</h2><p>要想正确的将瞄准线伸缩指向光标，我们需要一下信息：</p><ol><li>光标现在在哪(获取光标屏幕坐标-&gt;转换坐标得到世界坐标)</li><li>瞄准线现在的原点在哪(瞄准线会挂在枪上，所以直接取transform.position就好)</li></ol><p>有了两点就可以确定一条直线了！</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Vector2 MousePos;<span class="hljs-comment">// 光标世界坐标</span><br><span class="hljs-keyword">public</span> Vector2 SightPos;<span class="hljs-comment">// 准星原点坐标</span><br><span class="hljs-keyword">public</span> Vector2 StartPosOffset;<span class="hljs-comment">// 瞄准线起点偏移值</span><br><span class="hljs-keyword">public</span> Vector2 CollisionOffset;<span class="hljs-comment">// 光标与准星中心的偏移值</span><br><br><span class="hljs-comment">// 更新当前光标位置</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateMousePos</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 获取光标屏幕坐标</span><br>Vector3 screenMousePos = <span class="hljs-keyword">new</span> Vector3(Input.mousePosition.x, Input.mousePosition.y, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 转换坐标得到世界坐标</span><br>MousePos = Camera.main.ScreenToWorldPoint(screenMousePos);<br>  <span class="hljs-comment">// 光标坐标加上偏移值就是准星的中心</span><br>SightPos = MousePos + CollisionOffset;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> LineWide = <span class="hljs-number">0.15f</span>;<br><span class="hljs-keyword">private</span> SpriteRenderer sightLineRenderer;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateLine</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 根据当前瞄准线原点位置加上偏移量(从枪中间移到枪口),就是瞄准线的起点</span><br>  Vector2 pos = transform.parent.position + (Vector3)StartPosOffset;<br>  <span class="hljs-comment">// 获取两点间距离</span><br>  <span class="hljs-built_in">float</span> d = Vector2.Distance(pos, SightPos);<br>  <span class="hljs-comment">// 设置精灵渲染器的平铺尺寸来伸缩瞄准线</span><br>  sightLineRenderer.size = <span class="hljs-keyword">new</span> Vector2(d + <span class="hljs-number">0.2f</span>, LineWide);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：为什么要有两个偏移值？<br>StartPosOffset：<br>实际上是瞄准线的起点偏移值，瞄准线的父物体是枪，如果不设这个偏移值，瞄准线就会从枪中心而不是枪口延申出来<br>CollisionOffset：<br>实际上是瞄准线的终点偏移值，准星的锚点我们希望它在图片正中间，但是当它作为光标使用时，它的锚点在左上角，所以需要进行偏移</p></blockquote><p>现在我们可以做到瞄准线根据鼠标所在的位置来正确伸缩了！</p><p>那么，指向怎么实现？这里的代码我放在了瞄准线的父物体，枪的控制代码中了，但也不难，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lookAtSight</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 获取准星的世界坐标</span><br>Vector2 SightPos = SC.SightPos;<br>  <span class="hljs-comment">// 先让轴指向准星</span><br>transform.LookAt(<span class="hljs-keyword">new</span> Vector3(SightPos.x, SightPos.y));<br>  <span class="hljs-comment">// 再y轴旋转-90度</span><br>transform.Rotate(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">-90</span>, <span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:为什么要旋转-90度？<br>因为 transform.LookAt() 本质上是让本物体的Z轴正方向指向目标点<br>可我们是2D游戏，Z轴正方向会垂直于游戏画面，就看不见了，所以得旋转一下</p></blockquote><p>这样，我们就完成了指向</p><p>伸缩和指向两个功能都是实线啦！</p><h2 id="3-2-状态检测与素材替换"><a href="#3-2-状态检测与素材替换" class="headerlink" title="3.2 状态检测与素材替换"></a>3.2 状态检测与素材替换</h2><p>接下来我们需要实现的是：</p><ol><li>瞄准状态的检测:有没有瞄着敌人？</li><li>开火状态的检测:有没有在开火？</li><li>根据状态进行素材替换</li></ol><p>先看<strong>开火状态的检测</strong>，这个简单，看看鼠标的输入就行，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsOnFire;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateOnFire</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 判断有没有按着开火键</span><br><span class="hljs-keyword">if</span> (Input.GetButton(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>IsOnFire = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 更新瞄准器素材</span><br>updateSightResouses();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>  <span class="hljs-comment">// 没按着而且不在开火状态，就不重复换素材了</span><br><span class="hljs-keyword">if</span> (!IsOnFire) <span class="hljs-keyword">return</span>;<br>IsOnFire = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 更新瞄准器素材</span><br>updateSightResouses();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：为啥是Input.GetButton，不是说要看鼠标的输入吗？<br>这个啊，这个叫虚拟输入轴，快去我以前的文章学习一下吧：<br><a href="https://mycroftcooper.github.io/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/">https://mycroftcooper.github.io/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/</a></p></blockquote><p>再看<strong>瞄准状态的检测</strong>，这个得用到Physics2D.OverlapCircle，是一种简单的射线检测方式，API如下：<a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics2D.OverlapCircle.html">Physics2D.OverlapCircle</a><br>可以去看看这位老哥写的相关教程：<a href="http://www.voycn.com/article/unity2djiancefangfaoverlapcircleyuraycastxiangjie">http://www.voycn.com/article/unity2djiancefangfaoverlapcircleyuraycastxiangjie</a><br>如果想更加系统化的了解射线检测，可以取看看我之前写的这个文章：<br><a href="https://mycroftcooper.github.io/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/">https://mycroftcooper.github.io/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/</a></p><p>总而言之，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsOnEntity;<br><span class="hljs-keyword">public</span> LayerMask EnemiesLayer;<br><span class="hljs-keyword">public</span> Vector2 CollisionOffset;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> collisionRadius = <span class="hljs-number">0.25f</span>;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateOnEntity</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-comment">// 判断有没有瞄着敌人</span><br>Collider2D entity = Physics2D.OverlapCircle((Vector2)MousePos + CollisionOffset, collisionRadius, EnemiesLayer);<br><span class="hljs-keyword">if</span> (entity != <span class="hljs-literal">null</span> &amp;&amp; entity.tag == <span class="hljs-string">&quot;Enemies&quot;</span>) &#123;<br><span class="hljs-keyword">if</span> (IsOnEntity) <span class="hljs-keyword">return</span>;<br>IsOnEntity = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 更新瞄准器素材</span><br>updateSightResouses();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!IsOnEntity) <span class="hljs-keyword">return</span>;<br>IsOnEntity = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 更新瞄准器素材</span><br>updateSightResouses();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你想在编辑器中看到你的射线检测范围，可以使用如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span> &#123;<br>Gizmos.color = debugCollisionColor;<br>Gizmos.DrawWireSphere(SightPos, collisionRadius);<br>&#125;<br></code></pre></td></tr></table></figure><p>完成后如下图所示：<br><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220234824204.png" srcset="/img/loading.gif" alt="image-20220220234824204"></p><p>绿圈圈就是你的射线检测范围啦(我这里没改偏移量有点偏，你们记得根据自己的精度需要去设置哦)</p><p>这样以来，瞄准线状态的检测就算完成啦，接下来进行素材替换的实现，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSightResouses</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">if</span> (IsOnEntity) &#123;<br>sightLineRenderer.sprite = SightResouses.Sight_On_Line;<br><span class="hljs-keyword">if</span> (IsOnFire) &#123;<br>      Cursor.SetCursor(SightResouses.Sight_On_Fire, hotSpot, CursorMode.Auto);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Cursor.SetCursor(SightResouses.Sight_On, hotSpot, CursorMode.Auto);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    sightLineRenderer.sprite = SightResouses.Sight_Off_Line;<br>    <span class="hljs-keyword">if</span> (IsOnFire) &#123;<br>      Cursor.SetCursor(SightResouses.Sight_Off_Fire, hotSpot, CursorMode.Auto);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Cursor.SetCursor(SightResouses.Sight_Off, hotSpot, CursorMode.Auto);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之前写的素材管理代码用上了吧！</p><p>如此一来，整个瞄准线的功能就实现了，可以把它挂到枪上咯！</p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220235416020.png" srcset="/img/loading.gif" alt="image-20220220235416020"></p><p><img src="/images/2D%E7%9E%84%E5%87%86%E7%BA%BF/image-20220220235337492.png" srcset="/img/loading.gif" alt="image-20220220235337492"></p><h1 id="4-源代码"><a href="#4-源代码" class="headerlink" title="4. 源代码"></a>4. 源代码</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SightController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SightResouses</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">Sprite</span>&gt; spritesList</span> = <span class="hljs-keyword">new</span> List&lt;Sprite&gt;(Resources.LoadAll&lt;Sprite&gt;(<span class="hljs-string">&quot;Line&quot;</span>));<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Texture2D&gt; textureList = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, Texture2D&gt;&#123;<br>            &#123;<span class="hljs-string">&quot;Sight_On&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_On&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_Off&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_Off&quot;</span>)&#125;,<br>            &#123;<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>, Resources.Load&lt;Texture2D&gt;(<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>)&#125;,<br>        &#125;;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Sprite <span class="hljs-title">GetResouseSprite</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> =&gt;<br>            spritesList.Find(x =&gt; x.name == name);<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_On &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_On&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_On_Fire &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_On_Fire&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_Off &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_Off&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Texture2D Sight_Off_Fire &#123; <span class="hljs-keyword">get</span> =&gt; textureList[<span class="hljs-string">&quot;Sight_Off_Fire&quot;</span>]; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sprite Sight_On_Line &#123; <span class="hljs-keyword">get</span> =&gt; GetResouseSprite(<span class="hljs-string">&quot;Sight_On_Line&quot;</span>); &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sprite Sight_Off_Line &#123; <span class="hljs-keyword">get</span> =&gt; GetResouseSprite(<span class="hljs-string">&quot;Sight_Off_Line&quot;</span>); &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Vector2 MousePos;<br>    <span class="hljs-keyword">public</span> Vector2 SightPos;<br>    <span class="hljs-keyword">public</span> Vector2 StartPosOffset;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123;<br>        IsOnFire = <span class="hljs-literal">false</span>;<br>        IsOnEntity = <span class="hljs-literal">false</span>;<br>        sightLineRenderer = GetComponentInChildren&lt;SpriteRenderer&gt;();<br>        sightLineRenderer.sprite = SightResouses.Sight_Off_Line;<br>        Cursor.SetCursor(SightResouses.Sight_Off, hotSpot, CursorMode.Auto);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        updateSight();<br>        updateLine();<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 准星相关</span><br>    [<span class="hljs-meta">Header(<span class="hljs-meta-string">&quot;Sight&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Vector2 hotSpot;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsOnFire;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsOnEntity;<br><br>    [<span class="hljs-meta">Header(<span class="hljs-meta-string">&quot;Collision&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> LayerMask EnemiesLayer;<br>    <span class="hljs-keyword">public</span> Vector2 CollisionOffset;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> collisionRadius = <span class="hljs-number">0.25f</span>;<br>    <span class="hljs-keyword">private</span> Color debugCollisionColor = Color.green;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSight</span>(<span class="hljs-params"></span>)</span> &#123;<br>        updateMousePos();<br>        updateOnEntity();<br>        updateOnFire();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateMousePos</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Vector3 screenMousePos = <span class="hljs-keyword">new</span> Vector3(Input.mousePosition.x, Input.mousePosition.y, <span class="hljs-number">0</span>);<br>        MousePos = Camera.main.ScreenToWorldPoint(screenMousePos);<br>        SightPos = MousePos + CollisionOffset;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSightResouses</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (IsOnEntity) &#123;<br>            sightLineRenderer.sprite = SightResouses.Sight_On_Line;<br>            <span class="hljs-keyword">if</span> (IsOnFire) &#123;<br>                Cursor.SetCursor(SightResouses.Sight_On_Fire, hotSpot, CursorMode.Auto);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Cursor.SetCursor(SightResouses.Sight_On, hotSpot, CursorMode.Auto);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sightLineRenderer.sprite = SightResouses.Sight_Off_Line;<br>            <span class="hljs-keyword">if</span> (IsOnFire) &#123;<br>                Cursor.SetCursor(SightResouses.Sight_Off_Fire, hotSpot, CursorMode.Auto);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Cursor.SetCursor(SightResouses.Sight_Off, hotSpot, CursorMode.Auto);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateOnFire</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (Input.GetButton(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (IsOnFire) <span class="hljs-keyword">return</span>;<br>            IsOnFire = <span class="hljs-literal">true</span>;<br>            updateSightResouses();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!IsOnFire) <span class="hljs-keyword">return</span>;<br>        IsOnFire = <span class="hljs-literal">false</span>;<br>        updateSightResouses();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateOnEntity</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Collider2D entity = Physics2D.OverlapCircle((Vector2)MousePos + CollisionOffset, collisionRadius, EnemiesLayer);<br>        <span class="hljs-keyword">if</span> (entity != <span class="hljs-literal">null</span> &amp;&amp; entity.tag == <span class="hljs-string">&quot;Enemies&quot;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (IsOnEntity) <span class="hljs-keyword">return</span>;<br>            IsOnEntity = <span class="hljs-literal">true</span>;<br>            updateSightResouses();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!IsOnEntity) <span class="hljs-keyword">return</span>;<br>        IsOnEntity = <span class="hljs-literal">false</span>;<br>        updateSightResouses();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Gizmos.color = debugCollisionColor;<br>        Gizmos.DrawWireSphere(SightPos, collisionRadius);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 准线相关</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> LineWide = <span class="hljs-number">0.15f</span>;<br>    <span class="hljs-keyword">private</span> SpriteRenderer sightLineRenderer;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateLine</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Vector2 pos = transform.parent.position + (Vector3)StartPosOffset;<br><br>        <span class="hljs-built_in">float</span> d = Vector2.Distance(pos, SightPos);<br>        sightLineRenderer.size = <span class="hljs-keyword">new</span> Vector2(d + <span class="hljs-number">0.2f</span>, LineWide);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>别忘了父物体枪械上的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void look<span class="hljs-constructor">AtSight()</span> &#123;<br>  <span class="hljs-comment">// 获取准星的世界坐标</span><br>Vector2 SightPos = SC.SightPos;<br>  <span class="hljs-comment">// 先让轴指向准星</span><br>transform.<span class="hljs-constructor">LookAt(<span class="hljs-params">new</span> Vector3(SightPos.<span class="hljs-params">x</span>, SightPos.<span class="hljs-params">y</span>)</span>);<br>  <span class="hljs-comment">// 再y轴旋转-90度</span><br>transform.<span class="hljs-constructor">Rotate(<span class="hljs-params">new</span> Vector3(0, -90, 0)</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然想放在瞄准线的控制代码里也行，如果不需要枪械也同步旋转的话。</p><h1 id="5-后语"><a href="#5-后语" class="headerlink" title="5. 后语"></a>5. 后语</h1><p>这个小项目还有其它很多小技术点，感觉后面可以再跟大家分享一下！你们有说明想要交流的也可以直接跟我留言鸭！<br>B站账号：<a href="https://space.bilibili.com/172549987?spm_id_from=333.1007.0.0">https://space.bilibili.com/172549987?spm_id_from=333.1007.0.0</a><br>CSDN账号：<a href="https://blog.csdn.net/qq_44705559?spm=1001.2101.3001.5343">https://blog.csdn.net/qq_44705559?spm=1001.2101.3001.5343</a><br>GitHub账号：<a href="https://github.com/MycroftCooper">https://github.com/MycroftCooper</a><br>个人博客：<a href="https://mycroftcooper.github.io/">https://mycroftcooper.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>游戏实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D 2D射击小游戏移动幻影的实现</title>
    <link href="/2022/03/01/Unity3D%202D%E8%AE%BE%E8%AE%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%A7%BB%E5%8A%A8%E5%B9%BB%E5%BD%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/03/01/Unity3D%202D%E8%AE%BE%E8%AE%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%A7%BB%E5%8A%A8%E5%B9%BB%E5%BD%B1%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>本片文章是对<a href="https://www.bilibili.com/video/bv1sY411V7tx%E8%A7%86%E9%A2%91%E4%B8%AD%E7%A7%BB%E5%8A%A8%E5%B9%BB%E5%BD%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AE%B2%E8%A7%A3%E6%95%99%E7%A8%8B%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E5%8E%BBB%E7%AB%99%E7%BB%99%E6%88%91%E4%B8%80%E9%94%AE%E4%B8%89%E8%BF%9E%E9%B8%AD%EF%BC%81">https://www.bilibili.com/video/bv1sY411V7tx视频中移动幻影是如何实现的一个讲解教程，欢迎大家去B站给我一键三连鸭！</a></p><p>这个项目的整个代码和资源已经上传到了GitHub，大家可以去看一下<br>链接：<a href="https://github.com/MycroftCooper/TigerShooting2DGame">https://github.com/MycroftCooper/TigerShooting2DGame</a></p><h1 id="1-效果分析"><a href="#1-效果分析" class="headerlink" title="1. 效果分析"></a>1. 效果分析</h1><p>![移动拖影](/images/Unity3D 2D设计小游戏移动幻影的实现/移动拖影.gif)</p><p>![image-20220302233640359](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220302233640359.png)</p><p>根据上图的移动幻影效果，我们可以分析出，它应该具有以下几个功能：</p><ol><li>在小老虎冲刺的时候，产生幻影</li><li>幻影的精灵图片应该是那一帧小老虎的动作</li><li>幻影要能定时消失</li><li>幻影的透明度要低于正常的精灵</li></ol><h1 id="2-素材准备"><a href="#2-素材准备" class="headerlink" title="2. 素材准备"></a>2. 素材准备</h1><p>根据以上的四个功能，我们可以知道，实际上幻影的效果可以直接用精灵去实现。</p><p>首先我们需要准备好小老虎翻滚的帧动画，并且实现翻滚的功能(此处略过)<br>![image-20220305001822640](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220305001822640.png)然后我们创建一个幻影的预制体，并为它加上精灵渲染器组件，如下图所示(想要有几个幻影就复制几个预制体)</p><p>![image-20220303000051726](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220303000051726.png)</p><p>![image-20220303000107408](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220303000107408.png)</p><p>其中精灵是哪张图片无所谓，反正最后要用代码去动态的控制，其中的材质也是精灵图片的默认材质，如下图所示：<br>![image-20220304233846358](/images/Unity3D 2D设计小游戏移动幻影的实现/image-20220304233846358.png)</p><h1 id="2-功能实现"><a href="#2-功能实现" class="headerlink" title="2. 功能实现"></a>2. 功能实现</h1><h2 id="2-1-产生幻影"><a href="#2-1-产生幻影" class="headerlink" title="2.1 产生幻影"></a>2.1 产生幻影</h2><p>这个功能很简单，就是把预制体移动到小老虎的位置坐标，然后让材质的透明度提升到半透明状态即可：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 小老虎的动画控制器</span><br><span class="hljs-keyword">private</span> PlayerAnimaController anim;    <br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddGhost</span>(<span class="hljs-params">SpriteRenderer sr</span>)</span> &#123;<br>  <span class="hljs-comment">// 把幻影位置设置为小老虎的位置坐标</span><br>  sr.transform.position = anim.transform.position;<br>  <span class="hljs-comment">// 通过材质的颜色设置，使幻影半透明(更改透明度alpha值)</span><br>  sr.material.color = <span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0.6f</span>);<br>  <span class="hljs-comment">// 使幻影的反转与小老虎一样</span><br>  sr.flipX = anim.IsFlip;<br>  <span class="hljs-comment">// 使幻影的精灵图片与当前小老虎的一致</span><br>  sr.sprite = anim.sr.sprite;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-按时间产生与消失"><a href="#2-2-按时间产生与消失" class="headerlink" title="2.2 按时间产生与消失"></a>2.2 按时间产生与消失</h2><p>想要让三个幻影从小老虎翻滚开始，按照固定的时间间隔产生，再按照相同的时间间隔消失，这个有很多种方法可以做到。<br>能立马想到的有：协程，计时器(Timer)等等。<br>但实际上，我使用的是DoTween里的动画队列Sequence。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> DG.Tweening;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> ghostInterval;<span class="hljs-comment">// 幻影出现的时间间隙</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fadeTime;<span class="hljs-comment">// 幻影消失的时间间隙</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowGhost</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 初始化一个动画队列</span><br>Sequence s = DOTween.Sequence();<br>  <br>  <span class="hljs-comment">// 产生幻影的动画队列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>Transform currentGhost = transform.GetChild(i);<br>    SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>    s.AppendCallback(() =&gt; AddGhost(sr));<br>    s.AppendInterval(ghostInterval);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 幻影消失的动画队列</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>    Transform currentGhost = transform.GetChild(i);<br>    SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>    s.AppendCallback(() =&gt; sr.material.DOColor(<span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0</span>), fadeTime));<br>    s.AppendInterval(fadeTime);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>DoTween是一个非常好用且免费的Unity插件，它一般用于解决补间动画的程序控制，在Unity资源商店就可以获得，后面我也会出一期对应的教程！</p></blockquote><h1 id="3-源代码"><a href="#3-源代码" class="headerlink" title="3. 源代码"></a>3. 源代码</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> DG.Tweening;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GhostTrail</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">private</span> PlayerAnimaController anim;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> ghostInterval;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> fadeTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>            Transform currentGhost = transform.GetChild(i);<br>            SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>            sr.color = <span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">1f</span>);<br>            sr.material.color = <span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0f</span>);<br>        &#125;<br>        anim = FindObjectOfType&lt;PlayerAnimaController&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowGhost</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Sequence s = DOTween.Sequence();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>            Transform currentGhost = transform.GetChild(i);<br>            SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>            s.AppendCallback(() =&gt; AddGhost(sr));<br>            s.AppendInterval(ghostInterval);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; transform.childCount; i++) &#123;<br>            Transform currentGhost = transform.GetChild(i);<br>            SpriteRenderer sr = currentGhost.GetComponent&lt;SpriteRenderer&gt;();<br>            s.AppendCallback(() =&gt; sr.material.DOColor(<span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0</span>), fadeTime));<br>            s.AppendInterval(fadeTime);<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddGhost</span>(<span class="hljs-params">SpriteRenderer sr</span>)</span> &#123;<br>        sr.transform.position = anim.transform.position;<br>        sr.material.color = <span class="hljs-keyword">new</span> Color(sr.color.r, sr.color.g, sr.color.b, <span class="hljs-number">0.6f</span>);<br>        sr.flipX = anim.IsFlip;<br>        sr.sprite = anim.sr.sprite;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="5-后语"><a href="#5-后语" class="headerlink" title="5. 后语"></a>5. 后语</h1><p>这个小项目还有其它很多小技术点，感觉后面可以再跟大家分享一下！你们有说明想要交流的也可以直接跟我留言鸭！<br>B站账号：<a href="https://space.bilibili.com/172549987?spm_id_from=333.1007.0.0">https://space.bilibili.com/172549987?spm_id_from=333.1007.0.0</a><br>CSDN账号：<a href="https://blog.csdn.net/qq_44705559?spm=1001.2101.3001.5343">https://blog.csdn.net/qq_44705559?spm=1001.2101.3001.5343</a><br>GitHub账号：<a href="https://github.com/MycroftCooper">https://github.com/MycroftCooper</a><br>个人博客：<a href="https://mycroftcooper.github.io/">https://mycroftcooper.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>游戏实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏设计文档</title>
    <link href="/2021/12/12/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/"/>
    <url>/2021/12/12/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是游戏设计文档-GDD"><a href="#1-1-什么是游戏设计文档-GDD" class="headerlink" title="1.1 什么是游戏设计文档(GDD)"></a>1.1 什么是游戏设计文档(GDD)</h2><p><strong>游戏设计文档</strong> (game design document <strong>GDD</strong> )，是在游戏开发的筹备阶段，需要准备的一系列文档的统称。<br>一般是在确立项目时需要准备好GDD，是用来和同事，老板，乃至投资者画饼的有效工具。</p><p>GDD没有官方统一格式<br>每个游戏设计师都可以根据自己的喜好和项目的需要去编写GDD<br>本文只是对自己理解的GDD进行总结与分享</p><p><strong>组成:</strong><br>GDD一般分为以下三个部分：</p><ol><li>简要设计文档</li><li>详细设计文档</li><li>游戏流程表</li></ol><p>以上每种文档在游戏的筹备和开发阶段都各有自己的独特用处。<br>三种文档都是以前一种为基础，逐步编写，最后都汇总至GDD中。</p><h2 id="1-2-GDD的长度"><a href="#1-2-GDD的长度" class="headerlink" title="1.2 GDD的长度"></a>1.2 GDD的长度</h2><p>GDD的长度取决于游戏的复杂程度。<br>手机游戏的GDD 30 页就够了，但平台游戏GDD一般都会超过300页。<br>GDD的长度应该在正好能够精确地描述游戏的前提下尽量精简。</p><h2 id="1-3-基础注意事项"><a href="#1-3-基础注意事项" class="headerlink" title="1.3 基础注意事项"></a>1.3 基础注意事项</h2><p>你得保证文档的可读性</p><ul><li>使用正确的语法、别写错别字、用对标点符号等</li><li>正文要使用合适的字体<ul><li>一个文档里不要使用多于两种字体</li><li><strong>标题字号</strong> 最好别小于22<br><strong>正文字号</strong> 保持在12点上下比较合适</li><li>建议使用几种基本字体<br>比如宋体、黑体、雅黑等</li></ul></li><li>注意语义简单清晰，最好读起来像说明书</li><li>可以制作展示用幻灯片</li></ul><blockquote><p>请记住:<br>游戏文档的目的始终都是为了沟通: 和玩家沟通、和团队沟通，以及和发行商沟通。<br>沟通越明晰顺畅，同事和合伙人就越容易被你的创意鼓舞。</p></blockquote><h1 id="2-简要设计文档"><a href="#2-简要设计文档" class="headerlink" title="2. 简要设计文档"></a>2. 简要设计文档</h1><p>简要设计文档是游戏的一个概括总览。<br>它会让很多人过目，包括你工作室的同事和发行商那边的搭档。<br>所以这个单页文档既要充实，又要精彩生动，而且一定要简短(不超过一页纸)。</p><p>它一般会包含以下信息:</p><ul><li>游戏名称</li><li>游戏系统</li><li>目标玩家群体</li><li>游戏故事概要(着重描述可玩性)</li><li>游戏玩法的独特性</li><li>独特的卖点</li><li>竞品游戏</li></ul><h2 id="2-1-目标玩家群体"><a href="#2-1-目标玩家群体" class="headerlink" title="2.1 目标玩家群体"></a>2.1 目标玩家群体</h2><p>该内容可以按照ESRB分级对玩家群体的分类去讨论。</p><blockquote><p>ESRB委员会是美国一个非盈利性的独立机构<br>他们会强制对美国和加拿大的娱乐软件进行定级，并对广告和在线隐私保护进行审核。<br>类似于漫画业的漫画法典管理局，ESRB 的创立也是为了协同相关家长，针对游戏中的内容和道德水平提供定位准则。<br>不过ESRB的分级制度更加类似于MPAA(美国电影协会)的电影分级( G、PG、PG-13、 R、X)。<br>游戏在被ESRB审核之后，都会根据其内容获得一个字母分级。</p></blockquote><p>ESRB目前分以下6级。</p><ul><li>eC(幼儿):<br>此级别不会包含父母认为不合适的内容。</li><li>E(所有人):<br>此级别可能包含少量的幻想、卡通或者轻微的暴力，或者有轻度的不民管的。</li><li>E10(10岁以上的所有人):<br>此级别可能会包含更多的幻想、卡通或轻微的暴力，不良语言和暗示性主题。</li><li>T(青少年):<br>此级别通常会包含暴力、暗示性主题、粗鲁的幽默、极少的血，很少的粗话。</li><li>M(成熟，17岁以上):<br>此级别通常会有强烈的暴力、 血腥、性、粗话。</li><li>AO(仅限成人，18岁以上):<br>此级别通常有强烈的暴力、明显的性和裸体场景</li></ul><p>国内目前还没有对应的游戏分级机制。</p><h2 id="2-4-独特的卖点"><a href="#2-4-独特的卖点" class="headerlink" title="2.4 独特的卖点"></a>2.4 独特的卖点</h2><p>独特的卖点就是游戏包装盒背面那些“大圆点” 后面的宣传语。</p><p>一款游戏独特的卖点：<br>一般来说， 写5个卖点最合适<br><strong>不应该是：</strong></p><ul><li>“炫丽的图像”和“动人的故事”或“ 获奖游戏的续作”这种宣传语</li><li>详述游戏细节的长篇大论</li></ul><p><strong>应该是：</strong></p><ul><li>那些能让你的游戏脱颖而出的独特品质。</li><li>能让玩家对游戏产生兴奋感的简短明快的词句</li></ul><p>下面有一些 不错的例子。</p><ul><li>多人游戏模式，可进行多达256名玩家间的协同游戏。</li><li>收录1000多首流行乐队曲目。</li><li>开放的游戏世界，拥有200个关卡可供玩家任意探索。</li><li>用镭甲坦克、恶骨蝎、火蚁钢车来横扫你的敌人吧!</li><li>感受 虚幻5 引擎带来的无与伦比的物理仿真效果和前所未有的视觉特效!</li></ul><h2 id="2-3-竞品游戏"><a href="#2-3-竞品游戏" class="headerlink" title="2.3 竞品游戏"></a>2.3 竞品游戏</h2><p>竞品游戏是指：那些已经面世的和你的设计理念相似的游戏。</p><p>列出竞争产品有助于文档的阅读者理解游戏的大概方向。<br>不过，列出来的竞争游戏一定要是 非常有名的,或者是广受好评的,这样才能方便他人快速理解定位你设计的游戏</p><h1 id="3-详细设计文档"><a href="#3-详细设计文档" class="headerlink" title="3. 详细设计文档"></a>3. 详细设计文档</h1><p>详细设计文档是种重量级设计文档,它所展示的是整个游戏的精髓所在</p><blockquote><p>十页设计文档并不是硬性规定要求写正好10页,而是要覆盖十个方面<br>只要完整地呈现出游戏设计概要就成,少几页多几页都没问题</p></blockquote><p><strong>目的:</strong><br>为了让阅读者快速了解最终产品维形同时又不必为那些枯燥的细枝末节而分神。</p><p><strong>重要性:</strong><br>详细设计文档是GDD中最重要的部分因为那些潜在投资者会通过这份文档来判断游戏前景。</p><h2 id="3-1-内容概述"><a href="#3-1-内容概述" class="headerlink" title="3.1 内容概述"></a>3.1 内容概述</h2><ol><li><p>封面</p><ul><li>游戏Logo/宣传图</li><li>游戏名称</li><li>文档信息<ul><li>文档编号</li><li>更新日期</li><li>作者</li><li>联系方式</li></ul></li></ul></li><li><p>目录大纲</p></li><li><p>GDD版本记录<br>用来追踪日期更新和编辑者</p></li><li><p>游戏基础信息</p><ul><li>游戏名</li><li>游戏系统</li><li>目标游戏群体</li><li>目标平台(需要的硬件)</li><li>计划发行日期</li><li>游戏LOGO</li></ul></li><li><p>游戏总览</p><ul><li>故事背景概述<ul><li>世界观概述</li><li>游戏设定</li></ul></li><li>剧情概述</li><li>流程概述(玩家阶段性目标等)</li><li>游戏的核心思想</li></ul></li><li><p>游戏可玩性</p><ul><li>玩法分析<ul><li>核心玩法(最好有情景举例)</li><li>其他玩法</li></ul></li><li>游戏交互分析<br>玩家的操作概况，列举玩家要执行的特定操作。<br>可以展示一张图片，显示用到的手柄、触屏 或是 标记了对应操作键位的键盘</li><li>游戏系统分析</li><li>游戏成长性分析</li><li>技术要求<ul><li>需要的开发工具</li><li>技术难点</li><li>游戏硬件要求</li></ul></li></ul></li><li><p>游戏视听风格与体验分析</p><ul><li><p>游戏体验分析</p></li><li><p>美术风格类型</p><ul><li>同类型游戏/影视作品</li><li>风格参考图</li><li>技术难点</li></ul></li><li><p>音频风格</p><ul><li>同类型游戏/影视作品</li><li>风格参考音频</li><li>技术难点</li></ul></li></ul></li><li><p>游戏角色设计</p><ul><li>角色设定</li><li>角色概念图</li><li>角色背景故事</li><li>角色交互(操控方式)</li></ul></li><li><p>游戏场景设计</p><ul><li>游戏大地图</li><li>场景设计列表</li></ul></li><li><p>后续可扩展内容与计划</p></li><li><p>营利性分析</p></li></ol><h2 id="3-2-注意事项"><a href="#3-2-注意事项" class="headerlink" title="3.2 注意事项"></a>3.2 注意事项</h2><ul><li>给游戏玩法配上清晰图表</li><li>多用简短、有力的语句</li><li>借助专业术语清晰表答意图</li><li>和类似游戏进行比较，即使是些老游戏</li><li>把当下流行卖座的游戏作为竞品</li><li>多贴一些令人激动的概念图</li><li>多用PPT或类似软件来做<br>这样做出的文档容易分享，可以很方便地用于游戏宣讲会，或者打印出来作为会议参考资料。</li></ul><p>其实，不管做什么文档，能让人愿意读总是第一要务，所以一定要把文档写得妙趣横生。<br>在写详细设计文档时，要明确这么一点 <strong>“文档的受众是什么人?”</strong><br>给自己办公室同事看的文档和给市场部准备的文档，肯定会有天壤之别。</p><h1 id="4-游戏流程表"><a href="#4-游戏流程表" class="headerlink" title="4. 游戏流程表"></a>4. 游戏流程表</h1><p>游戏流程表( <strong>Beat chart</strong> )是一个针对游戏内关卡(场景，章节或者其它随便什么算得上是游戏阶段性的东西)的统计表格。<br>它个很称手的工具，除了能帮你完善GDD以外，更可作为游戏结构的“映射”表。<br>相较于文档，它其实更适合用电子表格去实现。</p><h2 id="4-1-内容概述"><a href="#4-1-内容概述" class="headerlink" title="4.1 内容概述"></a>4.1 内容概述</h2><p>以关卡制游戏来说，每一关的流程表都需要下面这些元素。<br>(当然可以根据具体的项目设置不同的字段)</p><ul><li><p>关卡名称</p></li><li><p>这一关涉及的剧情</p></li><li><p>这一关的主要玩法 </p></li><li><p>角色成长</p></li><li><p>大概过关时间</p></li><li><p>关卡的美术需求</p></li><li><p>关卡中出现的敌人或Boss</p></li><li><p>关卡的机关，陷阱</p></li><li><p>关卡里的奖励内容</p></li><li><p>新的技能、武器或者装备</p></li><li><p>关卡/场景背景音乐</p></li></ul><p>下面是《萤火》里第一关的流程表。</p><table><thead><tr><th>关卡名称</th><th>1-0 森林边缘</th></tr></thead><tbody><tr><td>剧情</td><td>Hannah离开奶奶家，进入妖精森林，踏上了寻找妖精的道路</td></tr><tr><td>成长</td><td>玩家学会游戏的基本操作，掌握萤火虫和相机的核心玩法</td></tr><tr><td>美术需求</td><td>前中后三层背景，关卡特殊瓦片地图</td></tr><tr><td>机关</td><td>妖精图腾，蒸汽弹簧，捕兽夹，地刺</td></tr><tr><td>技能</td><td>拍照技能，移动技能，旋转技能</td></tr><tr><td>背景音乐</td><td>森林边缘-1</td></tr></tbody></table><h2 id="4-2-注意事项"><a href="#4-2-注意事项" class="headerlink" title="4.2 注意事项"></a>4.2 注意事项</h2><ul><li>注意把控游戏内容的节奏<br>不能扎堆出现，也不能过于分散</li><li>当心单调感<br>关卡之间的内容不能高度重复<br>可以通过以下几种方式降低单调感：<ul><li>更改视听风格(美术，音频内容)</li><li>打乱内容随机组合</li></ul></li><li>出现的新机制需要有对应的提示</li><li>注意故事性与游戏性的平衡</li><li>关卡内的奖励需要合理<br>尽量让玩家在游戏进度75%的时候获得所有的内容</li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p><strong>GDD文档</strong> 会勾勒出游戏中将会呈现的方方面面，可以说，它定义了整个游戏。</p><p>技术团队根据 <strong>GDD文档</strong> 输出 <strong>TDD</strong>，也就是用来构建游戏的技术设计文档。<br>如果最开始GDD里就没提到某项功能，那么之后很可能就没办法轻松添加到游戏里了。</p><p>虽然写GDD需要耗费大量时间和精力，但没有人会想看它，甚至团队成员也不想读。<br>因为GDD又臭又长，里面的信息质量也良莠不齐一有的非常实用， 有的形同“天书”。</p><p>但是这份文档对你和同事都有帮助。<br>如果只用脑子来记这些方案，那么我敢保证，随着任务的不断增多，你会忙得无法实施它们，甚至完全忘了过去<br>这些精彩的创意。</p><p>无需多言，GDD 是个非常重要的文档，游戏开发过程中，整个团队都指着它呢。</p>]]></content>
    
    
    <categories>
      
      <category>游戏设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-编辑器扩展-辅助显示</title>
    <link href="/2021/11/07/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95-%E8%BE%85%E5%8A%A9%E7%BA%BF/"/>
    <url>/2021/11/07/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95-%E8%BE%85%E5%8A%A9%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>自定义编辑器相关类</p><ul><li><p>EditorGUI</p></li><li><p>EditorGUILayout</p></li><li><p>Handles扩展</p></li></ul><h1 id="2-Gizmos辅助线"><a href="#2-Gizmos辅助线" class="headerlink" title="2. Gizmos辅助线"></a>2. Gizmos辅助线</h1><p><a href="https://blog.csdn.net/dengshunhao/article/details/83001076">https://blog.csdn.net/dengshunhao/article/details/83001076</a></p><p><a href="https://docs.unity.cn/cn/current/Manual/GizmosAndHandles.html">https://docs.unity.cn/cn/current/Manual/GizmosAndHandles.html</a></p><h2 id="2-1-描述"><a href="#2-1-描述" class="headerlink" title="2.1 描述"></a>2.1 描述</h2><p>Gizmos辅助图标用于协助在 Scene 视图中进行视觉调试或设置。</p><p>Unity本身的编辑器中就自带很多Gizmos辅助线，详细的可以看<a href="https://docs.unity.cn/cn/current/Manual/GizmosMenu.html">Gizmos菜单官方文档</a></p><blockquote><p>注意：</p><ul><li>所有Gizmos辅助线的绘制都必须在 <a href="https://docs.unity.cn/cn/current/ScriptReference/MonoBehaviour.OnDrawGizmos.html">OnDrawGizmos</a> 或 <a href="https://docs.unity.cn/cn/current/ScriptReference/MonoBehaviour.OnDrawGizmosSelected.html">OnDrawGizmosSelected</a> 函数中实现</li><li>脚本必须继承Mono</li></ul></blockquote><p>这两个方法的区别是：</p><ul><li><a href="https://docs.unity.cn/cn/current/ScriptReference/MonoBehaviour.OnDrawGizmos.html">OnDrawGizmos</a><br>每一帧都会调用，其中渲染的所有辅助线都可以选择。</li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/MonoBehaviour.OnDrawGizmosSelected.html">OnDrawGizmosSelected</a><br>仅在选择了附加此脚本的对象时才调用</li></ul><h2 id="2-2-Gizmos-API"><a href="#2-2-Gizmos-API" class="headerlink" title="2.2 Gizmos API"></a>2.2 Gizmos API</h2><ul><li>常用静态变量</li></ul><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos-color.html">color</a></td><td>为接下来绘制的辅助图标设置颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos-exposure.html">exposure</a></td><td>设置包含 LightProbe 辅助图标的曝光校正的纹理。值从纹理中间的红色通道进行采样。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos-matrix.html">matrix</a></td><td>设置 Unity Editor 用于绘制 Gizmos 的 Matrix4x4。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos-probeSize.html">probeSize</a></td><td>设置灯光探测小控件的比例。此比例将用于渲染预览球体。</td></tr></tbody></table><ul><li>常用静态方法</li></ul><table><thead><tr><th>方法名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawCube.html">DrawCube</a></td><td>使用 center 和 size 绘制一个实心盒体。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawFrustum.html">DrawFrustum</a></td><td>绘制一个摄像机视锥体，并且将当前设置的 Gizmos.matrix 用于其位置和旋转。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawGUITexture.html">DrawGUITexture</a></td><td>在该场景中绘制一个纹理。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawIcon.html">DrawIcon</a></td><td>在 Scene 视图中的某个位置绘制一个图标。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawLine.html">DrawLine</a></td><td>绘制一条从 A坐标 到 B坐标 的线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawMesh.html">DrawMesh</a></td><td>绘制一个网格。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawRay.html">DrawRay</a></td><td>绘制一条从 from 开始到 from + direction 的射线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawSphere.html">DrawSphere</a></td><td>使用 center 和 radius 绘制一个实心球体。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawWireCube.html">DrawWireCube</a></td><td>使用 center 和 size 绘制一个线框盒体。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawWireMesh.html">DrawWireMesh</a></td><td>绘制一个线框网格。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Gizmos.DrawWireSphere.html">DrawWireSphere</a></td><td>使用 center 和 radius 绘制一个线框球体。</td></tr></tbody></table><h2 id="2-3-使用案例"><a href="#2-3-使用案例" class="headerlink" title="2.3 使用案例"></a>2.3 使用案例</h2><p>效果展示图：<br><img src="/images/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95-%E8%BE%85%E5%8A%A9%E7%BA%BF/image-20211108001109538.png" srcset="/img/loading.gif" alt="image-20211108001109538"></p><h3 id="2-3-1-绘制直线"><a href="#2-3-1-绘制直线" class="headerlink" title="2.3.1 绘制直线"></a>2.3.1 绘制直线</h3><p><code>Gizmos.DrawLine(Vector3 A , Vector B);</code><br>绘制一条从 A坐标 到 B坐标 的线</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.color = Color.green;<br>    Gizmos.DrawLine( obj1.transform.position , obj2.transform.position );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-2-绘制射线"><a href="#2-3-2-绘制射线" class="headerlink" title="2.3.2 绘制射线"></a>2.3.2 绘制射线</h3><p><code>Gizmos.DrawRay(Vector3 A, Vector3.up * 10);</code><br>绘制一条从A点出发，向上10个单位长度的射线</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.color = Color.gray;<br>    Gizmos.DrawRay(obj.transform.position, Vector3.up * <span class="hljs-number">10</span>);  <span class="hljs-comment">//10 是长度</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-2-绘制立方体"><a href="#2-3-2-绘制立方体" class="headerlink" title="2.3.2 绘制立方体"></a>2.3.2 绘制立方体</h3><p><code>Gizmos.DrawCube(Vector3 A , Vector3.one);</code></p><p> 在 坐标A 绘制一个（1,1,1）大小的立方体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.color = Color.red;<br>    Gizmos.DrawCube(Vector3.up , Vector3.one);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-6-绘制球体"><a href="#2-3-6-绘制球体" class="headerlink" title="2.3.6 绘制球体"></a>2.3.6 绘制球体</h3><p><code>Gizmos.DrawSphere(Vector A, float radius);</code><br>在 坐标A 绘制一个半径为 radius 的球体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.color = Color.red;<br>    Gizmos.DrawSphere(Vector3.zero , <span class="hljs-number">1f</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-5-绘制图片"><a href="#2-3-5-绘制图片" class="headerlink" title="2.3.5 绘制图片"></a>2.3.5 绘制图片</h3><p><code>Gizmos.DrawIcon(Vector3 A, string IconPath);</code><br>在坐标A处生成 IconPath 路径下的图片作为Icon</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Gizmos.DrawIcon(Vector3.zero , <span class="hljs-string">&quot;002IMgZLzy6Mro7r94Ka2&amp;690.jpg&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>此图片要放到Assets下的  Gizmos文件夹里才行。</p></blockquote><h1 id="3-Handles控制柄"><a href="#3-Handles控制柄" class="headerlink" title="3. Handles控制柄"></a>3. Handles控制柄</h1><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.html">https://docs.unity.cn/cn/current/ScriptReference/Handles.html</a></p><p><a href="https://qianxi.blog.csdn.net/article/details/83000972">https://qianxi.blog.csdn.net/article/details/83000972</a></p><h2 id="3-1-描述"><a href="#3-1-描述" class="headerlink" title="3.1 描述"></a>3.1 描述</h2><p>Handles控制柄是 Unity 用于操作场景视图中的项的 3D 控件。</p><p>内置的 Handle GUI 有很多，如通过变换组件定位、缩放和旋转对象的熟悉的工具。<br>不过，您也可以自行定义 Handle GUI，以与自定义组件编辑器结合使用。<br>此类 GUI 对于编辑以程序方式生成的场景内容、“不可见”项和相关对象的组（如路径点和位置标记）非常实用。</p><p>您还可以使用覆盖在场景视图上的 2D 按钮和其他控件来补充场景中的 3D 手柄 GUI。<br>这是通过将标准 Unity GUI 调用封装在 <a href="https://docs.unity.cn/cn/current/ScriptReference/Editor.OnSceneGUI.html">Editor.OnSceneGUI</a> 函数中的 <a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.BeginGUI.html">Handles.BeginGUI</a> 和 <a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.EndGUI.html">Handles.EndGUI</a> 对中完成的。</p><p>可以使用 <a href="https://docs.unity.cn/cn/current/ScriptReference/HandleUtility.GUIPointToWorldRay.html">HandleUtility.GUIPointToWorldRay</a> 和 <a href="https://docs.unity.cn/cn/current/ScriptReference/HandleUtility.WorldToGUIPoint.html">HandleUtility.WorldToGUIPoint</a> 在 2D GUI 与 3D 世界坐标之间转换坐标。</p><h2 id="3-2-Handles-API"><a href="#3-2-Handles-API" class="headerlink" title="3.2 Handles API"></a>3.2 Handles API</h2><ul><li>静态变量</li></ul><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-centerColor.html">centerColor</a></td><td>用于表示某物体中心的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-color.html">color</a></td><td>控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-inverseMatrix.html">inverseMatrix</a></td><td>所有控制柄操作的矩阵的逆矩阵。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-lighting.html">lighting</a></td><td>控制柄是否亮起</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-lineThickness.html">lineThickness</a></td><td>控制柄线厚度（只读）</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-matrix.html">matrix</a></td><td>所有控制柄的矩阵。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-preselectionColor.html">preselectionColor</a></td><td>用于突出显示鼠标指针下当前未选中的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-secondaryColor.html">secondaryColor</a></td><td>用于一般物体的柔和色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-selectedColor.html">selectedColor</a></td><td>用于当前处于活动状态的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-xAxisColor.html">xAxisColor</a></td><td>用于操纵某物体 X 坐标的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-yAxisColor.html">yAxisColor</a></td><td>用于操纵某物体 Y 坐标的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-zAxisColor.html">zAxisColor</a></td><td>用于操纵某物体 Z 坐标的控制柄的颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-zTest.html">zTest</a></td><td>控制柄的 zTest。</td></tr></tbody></table><ul><li>变量</li></ul><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles-currentCamera.html">currentCamera</a></td><td>当前摄像机(控制柄移动范围在摄像机视野内)</td></tr></tbody></table><ul><li>静态函数</li></ul><table><thead><tr><th>方法名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ArrowHandleCap.html">ArrowHandleCap</a></td><td>绘制一个类似于移动工具所用箭头的箭头。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.BeginGUI.html">BeginGUI</a></td><td>在 3D 手柄 GUI 内开始一个 2D GUI 块。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Button.html">Button</a></td><td>创建一个 3D 按钮。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.CircleHandleCap.html">CircleHandleCap</a></td><td>绘制一个圆形手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ClearCamera.html">ClearCamera</a></td><td>清除摄像机。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ConeHandleCap.html">ConeHandleCap</a></td><td>绘制一个锥体手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.CubeHandleCap.html">CubeHandleCap</a></td><td>绘制一个立方体手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.CylinderHandleCap.html">CylinderHandleCap</a></td><td>绘制一个圆柱体手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Disc.html">Disc</a></td><td>创建一个可使用鼠标拖动的 3D 圆盘。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DotHandleCap.html">DotHandleCap</a></td><td>绘制一个圆点手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawAAConvexPolygon.html">DrawAAConvexPolygon</a></td><td>绘制使用点数组指定的抗锯齿凸多边形。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawAAPolyLine.html">DrawAAPolyLine</a></td><td>绘制使用点数组和宽度指定的抗锯齿线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawBezier.html">DrawBezier</a></td><td>绘制通过给定切线的起点和终点的纹理化贝塞尔曲线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawCamera.html">DrawCamera</a></td><td>在矩形内绘制一个摄像机。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawDottedLine.html">DrawDottedLine</a></td><td>绘制一条从 p1 到 p2 的虚线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawDottedLines.html">DrawDottedLines</a></td><td>绘制一系列虚线段。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawGizmos.html">DrawGizmos</a></td><td>为给定摄像机绘制 Gizmos 的子集（在后处理之前或之后）。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawLine.html">DrawLine</a></td><td>从p1至p2绘制一条线段</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawLines.html">DrawLines</a></td><td>绘制一系列线段。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawPolyLine.html">DrawPolyLine</a></td><td>绘制一条穿过 points 列表的线。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawSelectionFrame.html">DrawSelectionFrame</a></td><td>绘制一个面向选择框的摄像机。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawSolidArc.html">DrawSolidArc</a></td><td>在 3D 空间中绘制一个圆扇形（饼图）。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawSolidDisc.html">DrawSolidDisc</a></td><td>在 3D 空间中绘制一个实心平面圆盘。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawSolidRectangleWithOutline.html">DrawSolidRectangleWithOutline</a></td><td>在 3D 空间中绘制一个实心轮廓矩形。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawTexture3DSDF.html">DrawTexture3DSDF</a></td><td>Draws a 3D texture using Signed Distance Field rendering mode in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawTexture3DSlice.html">DrawTexture3DSlice</a></td><td>Draws a 3D texture using Slice rendering mode in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawTexture3DVolume.html">DrawTexture3DVolume</a></td><td>Draws a 3D texture using Volume rendering mode in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawWireArc.html">DrawWireArc</a></td><td>Draws a circular arc in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawWireCube.html">DrawWireCube</a></td><td>使用 center 和 size 绘制一个线框盒体。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.DrawWireDisc.html">DrawWireDisc</a></td><td>Draws the outline of a flat disc in 3D space.</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.EndGUI.html">EndGUI</a></td><td>结束一个 2D GUI 块并返回到 3D 手柄 GUI。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.FreeMoveHandle.html">FreeMoveHandle</a></td><td>创建一个不受约束的移动手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.FreeRotateHandle.html">FreeRotateHandle</a></td><td>创建一个不受约束的旋转手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.GetMainGameViewSize.html">GetMainGameViewSize</a></td><td>获取主游戏视图的宽度和高度。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Label.html">Label</a></td><td>在 3D 空间中创建一个文本标签。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.MakeBezierPoints.html">MakeBezierPoints</a></td><td>返回表示贝塞尔曲线的点数组。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.PositionHandle.html">PositionHandle</a></td><td>创建一个位置手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.RadiusHandle.html">RadiusHandle</a></td><td>创建一个场景视图半径手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.RectangleHandleCap.html">RectangleHandleCap</a></td><td>绘制一个矩形手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.RotationHandle.html">RotationHandle</a></td><td>创建一个场景视图旋转手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ScaleHandle.html">ScaleHandle</a></td><td>创建一个场景视图缩放手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ScaleSlider.html">ScaleSlider</a></td><td>创建一个定向缩放滑动条。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ScaleValueHandle.html">ScaleValueHandle</a></td><td>创建一个缩放单个浮点的 3D 手柄。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.SetCamera.html">SetCamera</a></td><td>设置当前摄像机，以便所有手柄和辅助图标均使用相应设置进行绘制。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.ShouldRenderGizmos.html">ShouldRenderGizmos</a></td><td>确定是否绘制 Gizmos。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Slider.html">Slider</a></td><td>创建一个沿着一个轴移动的 3D 滑动条。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.Slider2D.html">Slider2D</a></td><td>创建一个沿两个轴定义的平面移动的 3D 滑动条。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.SnapToGrid.html">SnapToGrid</a></td><td>将每个 Transform.position 四舍五入到 EditorSnap.move 的最接近倍数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.SnapValue.html">SnapValue</a></td><td>如果对齐为 active，则将 value 四舍五入到 snap 的最接近倍数。注意，snap 只能为正数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.SphereHandleCap.html">SphereHandleCap</a></td><td>绘制一个球体手柄。将此手柄传递给 handle 函数。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Handles.TransformHandle.html">TransformHandle</a></td><td>创建变换手柄。</td></tr></tbody></table><h2 id="3-3-使用案例"><a href="#3-3-使用案例" class="headerlink" title="3.3 使用案例"></a>3.3 使用案例</h2><h3 id="3-3-0-准备"><a href="#3-3-0-准备" class="headerlink" title="3.3.0 准备"></a>3.3.0 准备</h3><p>Scripts文件夹中创建C#脚本”MyHandles”,在Editor文件夹中创建C#脚本”HandleInspector”,将下小图标保存到Img文件夹中。 </p><h3 id="3-3-1-绘制半径操作柄"><a href="#3-3-1-绘制半径操作柄" class="headerlink" title="3.3.1 绘制半径操作柄"></a>3.3.1 绘制半径操作柄</h3><ul><li><code>Handles.Label(Vector3 position,string name);</code><br>在position位置绘制内容为name的标签</li><li><code>float RadiusHandle (Quaternion rotation, Vector3 position, float radius);</code><br>在position位置以rotation为角度绘制半径为radius的半径操作柄</li></ul><p>在MyHandles.cs脚本中添加一个变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> areaRadius; <span class="hljs-comment">//半径</span><br></code></pre></td></tr></table></figure><p>然后打开HandlesInspector.cs脚本添加：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.<br><span class="hljs-keyword">using</span> UnityEditor;<br><br>[<span class="hljs-meta">CustomEditor(typeof(MyHandles))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HandlesInspector</span>:<span class="hljs-title">Editor</span><br>&#123;<br>    MyHandles myHandles;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        myHandles=(MyHandles)target;<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInspectorGUI</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        DrawDefaultInspector();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSceneGUI</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//第一个参数为在场景中显示的位置(以物体的中心位置为基准)</span><br>        <span class="hljs-comment">//第二个参数为显示的名字</span><br>        <span class="hljs-comment">//用于在场景中显示设置的名字</span><br>        Handles.Label(myHandles.transform.position+<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),<span class="hljs-string">&quot;MyHandles&quot;</span>);<br><br>        <span class="hljs-comment">//第一个参数为该旋转操作柄的初始旋转角度</span><br>        <span class="hljs-comment">//第二个参数为操作柄显示的位置(以物体的旋转位置为基准)</span><br>        <span class="hljs-comment">//第三个参数为设置操作柄的半径</span><br>        <span class="hljs-comment">//用于在场景中显示半径操作柄</span><br>        myHandles.areaRadius = Handles.RadiusHandle(Quaternion.identity,myHandles.transform.position,myHandles.areaRadius);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将这两个脚本保存，回到Unity中创建一个空物体，并为其添加 MyHandles.cs 脚本。就可以实现了</p><p><strong>作用：</strong><br>多用于制作AI，用于判断和指定AI影响范围用的。</p><h3 id="3-3-2-绘制缩放操作柄"><a href="#3-3-2-绘制缩放操作柄" class="headerlink" title="3.3.2 绘制缩放操作柄"></a>3.3.2 绘制缩放操作柄</h3><ul><li><code>float ScaleValueHandle (float value, Vector3 position, Quaternion rotation, float size, Handles.CapFunction capFunction, float snap);</code><ul><li>value 该操作柄操作的值</li><li>position 操作柄的绘制位置</li><li>rotation 操作柄的指向</li><li>size 操作柄的大小</li><li>操作柄的显示方式(本质上是个函数指针)：<ul><li>ArrowCap 箭头</li><li>RectangleCap 矩形</li><li>CircleCap 圆形</li><li>等等</li></ul></li><li>snap 对齐增量(可以理解为单位长度，不会有比该值还小的值变化)</li></ul></li></ul><p>打开 MyHandles.cs 脚本，添加如下变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> size;<span class="hljs-comment">//大小</span><br></code></pre></td></tr></table></figure><p>然后为 HandlesInspector.cs 脚本添加如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">myHandles.size = Handles.ScaleValueHandle(<br>myHandles.size,<br>myHandles.transform.position,<br>Quaternion.identity,<br>myHandles.size,<br>Handles.ArrowCap,<br><span class="hljs-number">0.5f</span><br>);<br></code></pre></td></tr></table></figure><p><strong>作用：</strong><br>多用于绘制一些自定义的操作，比如Unity的粒子系统就用到了好多自定义的操作柄，比如粒子系统的Shape参数就用到了该函数的第五个参数来绘制：</p><h3 id="3-3-3-绘制位置操作柄"><a href="#3-3-3-绘制位置操作柄" class="headerlink" title="3.3.3 绘制位置操作柄"></a>3.3.3 绘制位置操作柄</h3><p>MyHandles.cs 脚本，添加如下变量： </p><p>然后为 HandlesInspector.cs 脚本添加如下代码：</p><h3 id="3-3-4-绘制旋转操作柄"><a href="#3-3-4-绘制旋转操作柄" class="headerlink" title="3.3.4 绘制旋转操作柄"></a>3.3.4 绘制旋转操作柄</h3><h3 id="3-3-5-绘制连接线"><a href="#3-3-5-绘制连接线" class="headerlink" title="3.3.5 绘制连接线"></a>3.3.5 绘制连接线</h3><h3 id="3-3-6-绘制贝塞尔曲线"><a href="#3-3-6-绘制贝塞尔曲线" class="headerlink" title="3.3.6 绘制贝塞尔曲线"></a>3.3.6 绘制贝塞尔曲线</h3><p><img src="/images/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95-%E8%BE%85%E5%8A%A9%E7%BA%BF/image-20211108233412915.png" srcset="/img/loading.gif" alt="image-20211108233412915"></p><p>在Editor文件夹下创建脚本  HandlerTest  如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEditor;<br> <br>[<span class="hljs-meta">CustomEditor(typeof(Arraw))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HandlerTest</span> : <span class="hljs-title">Editor</span> &#123;<br> <br>    Vector3[] positions;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSceneGUI</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">float</span> width = HandleUtility.GetHandleSize(Vector3.zero) * <span class="hljs-number">0.5f</span>;<br>        Arraw arraw = (Arraw)target;<br> <br>        Handles.DrawBezier(arraw.transform.position, Vector3.zero, <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>), <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>), Color.yellow, <span class="hljs-literal">null</span>, width);<br>        <span class="hljs-comment">//参数1 开始点坐标， 参数2，结束点坐标， 参数3 开始切线位置， 参数 4，结束切线位置， 参数 5 线的颜色 ，参数六 线的宽度</span><br> <br> <br>        <span class="hljs-keyword">if</span> (GUI.changed)<br>        &#123;<br>            EditorUtility.SetDirty(arraw);<br>        &#125;<br> <br>    &#125;<br>&#125;<br> <br> <br>Arraw脚本如下，将其拖拽到需要画线的对象即可<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Arraw</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-7-控制操作柄的显示"><a href="#3-3-7-控制操作柄的显示" class="headerlink" title="3.3.7 控制操作柄的显示"></a>3.3.7 控制操作柄的显示</h3>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>编辑器扩展</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>编辑器扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp-反射</title>
    <link href="/2021/10/28/CSharp-%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/10/28/CSharp-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="0-基础概念"><a href="#0-基础概念" class="headerlink" title="0. 基础概念"></a>0. 基础概念</h1><h2 id="0-1-什么是反射"><a href="#0-1-什么是反射" class="headerlink" title="0.1 什么是反射"></a>0.1 什么是反射</h2><p>Reflection，中文翻译为反射。<br>这是.Net中获取运行时类型信息的方式。</p><blockquote><p>官方定义：<br>审查元数据并收集关于它的类型信息的能力。<br>元数据（编译以后的最基本数据单元）<br>就是一大堆的表，当编译程序集或者模块时，编译器会创建一个类定义表，一个字段定义表，和一个方法定义表等。</p></blockquote><p>.Net的应用程序的结构由以下几个部分组成：</p><ul><li><p>程序集(Assembly)</p></li><li><p>模块(Module)</p></li><li><p>类型(class)</p></li></ul><p><img src="/images/CSharp-%E5%8F%8D%E5%B0%84/image-20211028142215838.png" srcset="/img/loading.gif"></p><p>而反射的层次模型也类似上述结构：</p><ul><li>程序集反射</li><li>类型反射</li><li>类型成员反射</li></ul><p><img src="/images/CSharp-%E5%8F%8D%E5%B0%84/image-20211028142543443.png" srcset="/img/loading.gif"></p><p>而反射提供一种编程的方式，让程序员可以在程序运行期获得这几个组成部分的相关信息。</p><ul><li><p>Assembly类<br>可以获得正在运行的装配件信息，也可以动态的加载装配件，以及在装配件中查找类型信息，并创建该类型的实例。</p></li><li><p>Type类<br>可以获得对象的类型信息，此信息包含对象的所有要素：方法、构造器、属性等等<br>通过Type类可以得到这些要素的信息，并且调用。</p></li><li><p>MethodInfo<br>包含方法的信息，通过这个类可以得到方法的名称、参数、返回值等等<br>并且可以调用。</p></li></ul><p>诸如此类，还有FieldInfo、EventInfo等等，这些类都包含在System.Reflection命名空间下。</p><h2 id="0-2-命名空间与装配件的关系"><a href="#0-2-命名空间与装配件的关系" class="headerlink" title="0.2 命名空间与装配件的关系"></a>0.2 命名空间与装配件的关系</h2><ul><li>命名空间类似与Java的包，但又不完全等同<br>因为Java的包必须按照目录结构来放置，命名空间则不需要。</li><li>装配件是.Net应用程序执行的最小单位，编译出来的.dll、.exe都是装配件。</li></ul><p>装配件和命名空间的关系不是一一对应，也不互相包含<br>一个装配件里面可以有多个命名空间，一个命名空间也可以在多个装配件中存在。</p><p>例如：</p><p>装配件A：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span>  <span class="hljs-title">N1</span><br>&#123;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">AC1</span>  &#123;…&#125;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">AC2</span>  &#123;…&#125;<br>&#125;<br><span class="hljs-keyword">namespace</span>  <span class="hljs-title">N2</span><br>&#123;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">AC3</span>  &#123;…&#125;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">AC4</span>&#123;…&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>装配件B：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span>  <span class="hljs-title">N1</span><br>&#123;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">BC1</span>  &#123;…&#125;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">BC2</span>  &#123;…&#125;<br>&#125;<br><span class="hljs-keyword">namespace</span>  <span class="hljs-title">N2</span><br>&#123;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">BC3</span>  &#123;…&#125;<br>      <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">BC4</span>&#123;…&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个装配件中都有N1和N2两个命名空间，而且各声明了两个类，这样是完全可以的</p><p>然后我们在一个应用程序中引用装配件A<br>那么在这个应用程序中，我们能看到N1下面的类为AC1和AC2，N2下面的类为AC3和AC4。</p><p>接着我们去掉对A的引用，加上对B的引用<br>那么我们在这个应用程序下能看到的N1下面的类变成了BC1和BC2，N2下面也一样。</p><p>如果我们同时引用这两个装配件<br>那么N1下面我们就能看到四个类：AC1、AC2、BC1和BC2。</p><p>装配件是一个类型 “居住” 的地方，那么在一个程序中要使用一个类，就必须告诉编译器这个类住在哪儿，编译器才能找到它，也就是说必须引用该装配件。</p><p>那么如果在编写程序的时候，也许不确定这个类在哪里，仅仅只是知道它的名称，就不能使用了吗？<br>答案是可以，这就是反射了，就是在程序运行的时候提供该类型的地址，而去找到它。</p><h2 id="0-3-使用反射的情景"><a href="#0-3-使用反射的情景" class="headerlink" title="0.3 使用反射的情景"></a>0.3 使用反射的情景</h2><p>举个例子来说明：<br>很多软件开发者喜欢在自己的软件中留下一些接口，其他人可以编写一些插件来扩充软件的功能。</p><p>比如我有一个媒体播放器，我希望以后可以很方便的扩展识别的格式，那么我声明一个接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span>  <span class="hljs-title">IMediaFormat</span><br>&#123;<br>   <span class="hljs-built_in">string</span>  Extension  &#123;<span class="hljs-keyword">get</span>;&#125;<br>   <span class="hljs-function">Decoder  <span class="hljs-title">GetDecoder</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口中包含一个Extension属性，这个属性返回支持的扩展名。<br>另一个方法返回一个解码器的对象（这里我假设了一个Decoder的类，这个类提供把文件流解码的功能，扩展插件可以派生之），通过解码器对象我就可以解释文件流。</p><p>那么我规定所有的解码插件都必须派生一个解码器，并且实现这个接口，在GetDecoder方法中返回解码器对象，并且将其类型的名称配置到我的配置文件里面。</p><p>这样的话，我就不需要在开发播放器的时侯知道将来扩展的格式的类型，只需要从配置文件中获取现在所有解码器的类型名称，而动态的创建媒体格式的对象，将其转换为IMediaFormat接口来使用。</p><p>这就是一个反射的典型应用。</p><h1 id="1-反射的用途"><a href="#1-反射的用途" class="headerlink" title="1. 反射的用途"></a>1. 反射的用途</h1><p><strong>反射的作用：</strong></p><ul><li><p>它允许在运行时查看属性（attribute）信息。</p></li><li><p>它允许审查集合中的各种类型，以及实例化这些类型。</p></li><li><p>它允许延迟绑定的方法和属性（property）。</p></li><li><p>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</p></li><li><p>可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型</p></li><li><p>应用程序需要在运行时从某个特定的程序集中载入一个特定的类型，以便实现某个任务时可以用到反射。</p></li><li><p>反射主要应用于类库，这些类库需要知道一个类型的定义，以便提供更多的功能。</p></li></ul><p><strong>应用要点：</strong></p><ul><li>使用反射动态绑定需要牺牲 性能</li><li>有些元数据信息是不能通过反射获取的</li><li>某些反射类型是专门为那些clr 开发编译器的开发使用的<br>所以你要意识到不是所有的反射类型都是适合每个人的。</li></ul><h1 id="2-反射的使用"><a href="#2-反射的使用" class="headerlink" title="2. 反射的使用"></a>2. 反射的使用</h1><h2 id="2-1-使用反射-获取程序集"><a href="#2-1-使用反射-获取程序集" class="headerlink" title="2.1 使用反射 获取程序集"></a>2.1 使用反射 获取程序集</h2><p>该操作属于反射层级的第一层，程序集反射。</p><h2 id="2-2-使用反射-获取类型"><a href="#2-2-使用反射-获取类型" class="headerlink" title="2.2 使用反射 获取类型"></a>2.2 使用反射 获取类型</h2><p>该操作属于反射层级的第二层，类型反射。</p><h3 id="通过实例获取类型信息"><a href="#通过实例获取类型信息" class="headerlink" title="通过实例获取类型信息"></a>通过实例获取类型信息</h3><p>这个时侯我仅仅是得到这个实例对象<br>得到的方式也许是一个object的引用，也许是一个接口的引用<br>但是我并不知道它的确切类型，我需要了解<br>那么就可以通过调用System.Object上声明的方法GetType来获取实例对象的类型对象。</p><p>比如在某个方法内，我需要判断传递进来的参数是否实现了某个接口，如果实现了，则调用该接口的一个方法：</p><ul><li>判断是否是继承了某类</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> className = <span class="hljs-string">&quot;Text.TexeClass&quot;</span>;<br>Type myType = Type.GetType(className);<br><span class="hljs-keyword">if</span> (myType != <span class="hljs-literal">null</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;确实继承Text.TexeClass类&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断是否继承了某接口</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Process</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> processObj</span>)</span><br><span class="hljs-function"></span>&#123;<br>Type t  =  processsObj.GetType();<br><span class="hljs-keyword">if</span>(t.GetInterface(“ITest”)  !=<span class="hljs-literal">null</span>  )<br>        Console.WriteLine(<span class="hljs-string">&quot;确实实现了ITest接口&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过类型名称字符串获取类型信息"><a href="#通过类型名称字符串获取类型信息" class="headerlink" title="通过类型名称字符串获取类型信息"></a>通过类型名称字符串获取类型信息</h3><p> <code>Type t = Type.GetType(“System.String”);</code></p><p>在本装配件中类型可以只写类型名称</p><blockquote><p>注意<br>要查找一个类，必须指定它所在的装配件<br>或者在已经获得的Assembly实例上面调用GetType。</p></blockquote><p>一个例外是 <strong>mscorlib.dll</strong>，这个装配件中声明的类型也可以省略装配件名称。<br>.Net装配件编译的时候，默认都引用了mscorlib.dll，除非在编译的时候明确指定不引用它</p><p>比如：</p><ul><li><strong>System.String</strong> 是在 <strong>mscorlib.dll</strong> 中声明的<br><code>Type t = Type.GetType(“System.String”)</code>是正确的</li><li><strong>System.Data.DataTable</strong> 是在 <strong>System.Data.dll</strong> 中声明的<br><code>Type.GetType(“System.Data.DataTable”)</code>就只能得到空引用。<br><code>Type t = Type.GetType(&quot;System.Data.DataTable,System.Data,Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;);</code>这样才可以</li></ul><h2 id="2-3-使用反射-动态创建对象"><a href="#2-3-使用反射-动态创建对象" class="headerlink" title="2.3 使用反射 动态创建对象"></a>2.3 使用反射 动态创建对象</h2><p>该操作属于反射层级的第二层，类型反射。</p><p>使用反射动态创建对象有两种方法：</p><ul><li>使用 <strong>Activator.CreateInstance</strong></li><li>使用 <strong>Assembly.CreateInstance</strong></li></ul><p>但实际上在底层都是使用 <strong>Activator.CreateInstance</strong> 来动态创建对象，所以只需要掌握一种即可，下面的内容都是 使用 <strong>Activator.CreateInstance</strong> 来动态创建对象</p><h3 id="无参数构造"><a href="#无参数构造" class="headerlink" title="无参数构造"></a>无参数构造</h3><p>System.Activator提供了方法来根据类型动态创建对象</p><p>比如创建一个DataTable：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type t = Type.GetType(<span class="hljs-string">&quot;System.Data.DataTable,System.Data,Version=1.0.3300.0,  Culture=neutral,  PublicKeyToken=b77a5c561934e089&quot;</span>);<br>DataTable table = (DataTable)Activator.CreateInstance(t);<br></code></pre></td></tr></table></figure><h3 id="有参数构造"><a href="#有参数构造" class="headerlink" title="有参数构造"></a>有参数构造</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span>  <span class="hljs-title">TestSpace</span>  <br>&#123;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title">TestClass</span><br>    &#123;<br>        <span class="hljs-keyword">private</span>  <span class="hljs-built_in">string</span>  _value;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">TestClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>  <span class="hljs-keyword">value</span></span>)  </span><br><span class="hljs-function"></span>        &#123;<br>            _value=<span class="hljs-keyword">value</span>;<br>      &#125;<br>  &#125;<br>&#125;<br>Type t = Type.GetType(“TestSpace.TestClass”);<br>Object[] constructParms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123;“hello”&#125;;  <span class="hljs-comment">//构造器参数</span><br>TestClass obj = (TestClass)Activator.CreateInstance(t,constructParms);<br></code></pre></td></tr></table></figure><p>把参数按照顺序放入一个Object数组中即可</p><h2 id="2-4-使用反射-操作类成员"><a href="#2-4-使用反射-操作类成员" class="headerlink" title="2.4 使用反射 操作类成员"></a>2.4 使用反射 操作类成员</h2><p>该操作属于反射层级的第三层，类型成员反射。</p><p>该操作有三种方法</p><ol><li>使用Type类的InvokeMember()方法<br><a href="https://blog.csdn.net/zxcvb036/article/details/114693060">方法一案例</a></li><li>使用FieldInfo,MethodInfo…等类的Invoke方法</li><li>通过使用委托对反射进行优化</li><li>使用.NET 4.0出现了一个新的关键字：dynamic</li></ol><p>综合考虑下来，代码精简度以及耗费时间，建议尽量使用dynamic关键字来处理反射。</p><p>下面主要讨论 方法2 与 方法4</p><h3 id="2-4-1-方法2"><a href="#2-4-1-方法2" class="headerlink" title="2.4.1 方法2"></a>2.4.1 方法2</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">TestSpace</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span>  <br>    &#123;<br>        <span class="hljs-keyword">private</span>  <span class="hljs-built_in">string</span>  _value;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestClass</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br><span class="hljs-function"></span>            =&gt; _value = <span class="hljs-keyword">value</span>;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Value  <br>        &#123;<br>            <span class="hljs-keyword">set</span> &#123;_value=<span class="hljs-keyword">value</span>;&#125;<br>            <span class="hljs-keyword">get</span> <br>            &#123;<br>   <span class="hljs-keyword">if</span>(_value==<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;NULL&quot;</span>;<br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>  _value;<br>   &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetValue</span>(<span class="hljs-params">stringprefix</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span>(_value==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;NULL&quot;</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>  prefix+<span class="hljs-string">&quot; : &quot;</span>+_value;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一个简单的TestClass类，包含：</p><ul><li>一个默认构造函数</li><li>一个有参数的构造函数</li><li>一个_value字段</li><li>一个Value属性</li><li>一个GetValue的方法</li></ul><ol><li><p>获取程序集</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Assembly ass = Assembly.Load(<span class="hljs-string">&quot;TestDll&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取类型信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type myType = ass.GetType(<span class="hljs-string">&quot;TestSpace.TestClass&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>根据类型创建对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span>[] constuctParms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[]&#123;<span class="hljs-string">&quot;timmy&quot;</span>&#125;;<br><span class="hljs-built_in">object</span> dObj = Activator.CreateInstance(myType,constuctParms);<br></code></pre></td></tr></table></figure></li><li><p>操作类成员</p></li></ol><ul><li><p>类字段<br>使用 <strong>FieldInfo 类</strong> 访问修改类对象的字段<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.fieldinfo?view=net-5.0">官方文档</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 获取对象指定字段</span><br>FieldInfo mfi = myType.GetField(<span class="hljs-string">&quot;_value&quot;</span>);<br><span class="hljs-comment">// 获取字段值</span><br>mfi.GetVaL();<br><span class="hljs-comment">// 更改字段值</span><br>mfi.SetVal(dObj,<span class="hljs-string">&quot;ok&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>类属性<br>使用 <strong>PropertyInfo 类</strong> 访问修改类对象的属性<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.propertyinfo?view=net-5.0">官方文档</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">PropertyInfo mpi = myType.GetProperty(<span class="hljs-string">&quot;Value&quot;</span>,<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>));<br>mpi.SetValue(dObj,<span class="hljs-string">&quot;ok&quot;</span>,<span class="hljs-literal">null</span>);<br>PropertyInfo mpi2 = myType.GetProperty(<span class="hljs-string">&quot;Value&quot;</span>);<br>Console.WriteLine(mpi2.GetValue(dObj,<span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure></li><li><p>类方法<br>使用 <strong>MethodInfo 类</strong> 调用类对象的方法<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.methodinfo?view=net-5.0">官方文档</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//获取方法的信息</span><br>MethodInfo method = myType.GetMethod(<span class="hljs-string">&quot;GetValue&quot;</span>);<br><span class="hljs-comment">//调用方法的一些标志位，这里的含义是Public并且是实例方法，这也是默认的值</span><br>BindingFlags flag = BindingFlags.Public | BindingFlags.Instance;<br><span class="hljs-comment">//GetValue方法的参数</span><br><span class="hljs-built_in">object</span>[] parameters = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[]&#123;<span class="hljs-string">&quot;Hello&quot;</span>&#125;;<br><span class="hljs-comment">//调用方法，用一个object接收返回值</span><br><span class="hljs-built_in">object</span> returnValue = method.Invoke(dObj,flag,Type.DefaultBinder,parameters,<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h3 id="2-4-2-方法4-关键字dynamic"><a href="#2-4-2-方法4-关键字dynamic" class="headerlink" title="2.4.2 方法4 - 关键字dynamic"></a>2.4.2 方法4 - 关键字dynamic</h3></li></ul><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/using-type-dynamic">官方文档</a></p><p><a href="https://www.cnblogs.com/gygtech/p/9915367.html">教程</a></p><blockquote><p>性能较好，速度快</p></blockquote><ol><li><p>获取程序集</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Assembly ass = Assembly.Load(<span class="hljs-string">&quot;TestDll&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>获取类型信息</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Type myType = ass.GetType(<span class="hljs-string">&quot;TestSpace.TestClass&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>根据类型创建对象</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span>[] constuctParms = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[]&#123;<span class="hljs-string">&quot;timmy&quot;</span>&#125;;<br><span class="hljs-built_in">dynamic</span> dObj = Activator.CreateInstance(myType,constuctParms);<br></code></pre></td></tr></table></figure></li><li><p>操作类成员</p><p>使用了 dynamic 后可以和普通对象一样通过.使用类对象成员</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">dObj._value = <span class="hljs-string">&quot;good&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="2-6-动态创建委托"><a href="#2-6-动态创建委托" class="headerlink" title="2.6 动态创建委托"></a>2.6 动态创建委托</h2></li></ol><p>​    委托是C#中实现事件的基础，有时候不可避免的要动态的创建委托，实际上委托也是一种类型：System.Delegate，所有的委托都是从这个类派生的<br>​    System.Delegate提供了一些静态方法来动态创建一个委托，比如一个委托：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">TestSpace</span>  <br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">string</span> <span class="hljs-title">TestDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span>  <br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestClass</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetValue</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">value</span></span>)</span><br><span class="hljs-function"></span>            =&gt; <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">TestClass obj = <span class="hljs-keyword">new</span> TestClass();<br><span class="hljs-comment">//获取类型，实际上这里也可以直接用typeof来获取类型</span><br>Type t = Type.GetType(“TestSpace.TestClass”);<br><span class="hljs-comment">//创建代理，传入类型、创建代理的对象以及方法名称</span><br>TestDelegate method =(TestDelegate)Delegate.CreateDelegate(t,obj,”GetValue”);<br>String returnValue = method(“hello”);<br></code></pre></td></tr></table></figure><h1 id="3-反射中主要用到的类"><a href="#3-反射中主要用到的类" class="headerlink" title="3. 反射中主要用到的类"></a>3. 反射中主要用到的类</h1><p>System.reflection命名空间包含的几个类，允许你反射（解析）这些元数据表的代码  </p><ul><li><strong>System.Reflection.Assembly</strong><br>使用Assembly定义和加载程序集<br>加载在程序集清单中列出模块,以及从此程序集中查找类型并创建该类型的实例。</li><li><strong>System.Reflection.MemberInfo</strong></li><li><strong>System.Reflection.EventInfo</strong><br>了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等,添加或移除事件处理程序</li><li><strong>System.Reflection.FieldInfo</strong><br>了解字段的名称、访问修饰符(如public或private)和实现详细信息(如static)等<br>并获取或设置字段值。</li><li><strong>System.Reflection.MethodBase</strong></li><li><strong>System.Reflection.ConstructorInfo</strong><br>使用ConstructorInfo了解构造函数的名称、参数、访问修饰符(如pulic 或private)和实现详细信息(如abstract或virtual)等。</li><li><strong>System.Reflection.MethodInfo</strong><br>了解方法的名称、返回类型、参数、访问修饰符(如pulic 或private)和实现详细信息(如abstract或virtual)等。</li><li><strong>System.Reflection.PropertyInfo</strong><br>了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等,获取或设置属性值</li><li><strong>System.Type</strong></li><li><strong>ParameterInfo</strong><br>了解参数的名称、数据类型、是输入参数还是输出参数<br>以及参数在方法签名中的位置等。</li><li><strong>Module</strong><br>了解包含模块的程序集以及模块中的类等<br>还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。</li></ul><h2 id="3-1-System-Type-类"><a href="#3-1-System-Type-类" class="headerlink" title="3.1 System.Type 类"></a>3.1 System.Type 类</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.type?view=net-5.0#constructors">官方文档</a></p><p>通过这个类可以访问任何给定数据类型的信息。</p><p>System.Type 类对于反射起着核心的作用。<br>但它是一个抽象的基类,Type有与每种数据类型对应的派生类,我们使用这个派生类的对象的方法、字段、属性来查找有关该类型的所有信息。</p><h3 id="获取Type的方法"><a href="#获取Type的方法" class="headerlink" title="获取Type的方法"></a>获取Type的方法</h3><p>获取给定类型的Type引用有3种常用方式:</p><ul><li>使用 <strong>typeof运算符</strong><br><code>Type t = typrof(string);</code><br>该字符串必须指定类型的完整名称（包括其命名空间）</li><li>使用对象 <strong>GetType()方法</strong><br><code>string s; Type t = s.GetType();</code></li><li>使用Type <strong>静态方法GetType()</strong><br><code>Type t  = Type.GetType(&quot;System.String&quot;);</code></li></ul><h3 id="Type类的常用属性"><a href="#Type类的常用属性" class="headerlink" title="Type类的常用属性"></a>Type类的常用属性</h3><table><thead><tr><th>属性名称</th><th>属性类型</th><th>含义</th></tr></thead><tbody><tr><td>Name</td><td>string</td><td>数据类型名</td></tr><tr><td>FullName</td><td>string</td><td>数据类型的完全限定名(包括命名空间名)</td></tr><tr><td>Namespace</td><td>string</td><td>定义数据类型的命名空间名</td></tr><tr><td>IsAbstract</td><td>bool</td><td>指示该类型是否是抽象类型</td></tr><tr><td>IsArray</td><td>bool</td><td>指示该类型是否是数组</td></tr><tr><td>IsClass</td><td>bool</td><td>指示该类型是否是类</td></tr><tr><td>IsEnum</td><td>bool</td><td>指示该类型是否是枚举</td></tr><tr><td>IsInterface</td><td>bool</td><td>指示该类型是否是接口</td></tr><tr><td>IsPublic</td><td>bool</td><td>指示该类型是否是公有的</td></tr><tr><td>IsSealed</td><td>bool</td><td>指示该类型是否是密封类</td></tr><tr><td>IsValueType</td><td>bool</td><td>指示该类型是否是值类型</td></tr></tbody></table><h3 id="Type类的方法"><a href="#Type类的方法" class="headerlink" title="Type类的方法"></a>Type类的方法</h3><ul><li><code>GetConstructor()</code><br><code>GetConstructors()</code><br>返回ConstructorInfo类型,用于取得该类的构造函数的信息</li><li><code>GetEvent()</code><br><code>GetEvents()</code><br>返回EventInfo类型,用于取得该类的事件的信息</li><li><code>GetField()</code><br><code>GetFields()</code><br>返回FieldInfo类型,用于取得该类的字段(成员变量)的信息</li><li><code>GetInterface()</code><br><code>GetInterfaces()</code><br>返回InterfaceInfo类型,用于取得该类实现的接口的信息</li><li><code>GetMember()</code><br><code>GetMembers()</code><br>返回MemberInfo类型,用于取得该类的所有成员的信息</li><li><code>GetMethod()</code><br><code>GetMethods()</code><br>返回MethodInfo类型,用于取得该类的方法的信息</li><li><code>GetProperty()</code><br><code>GetProperties()</code><br>返回PropertyInfo类型,用于取得该类的属性的信息可以调用这些成员<br>其方式是调用Type的InvokeMember()方法,或者调用MethodInfo, PropertyInfo和其他类的Invoke()方法。</li></ul><h2 id="3-2-System-Reflection-Assembly类"><a href="#3-2-System-Reflection-Assembly类" class="headerlink" title="3.2 System.Reflection.Assembly类"></a>3.2 System.Reflection.Assembly类</h2><p>Assembly类可以获得程序集的信息,也可以动态的加载程序集,以及在程序集中查找类型信息,并创建该类型的实例。</p><p>使用Assembly类可以降低程序集之间的耦合,有利于软件结构的合理化。</p><h3 id="获取Assembly对象的方法"><a href="#获取Assembly对象的方法" class="headerlink" title="获取Assembly对象的方法"></a>获取Assembly对象的方法</h3><ul><li><p>通过程序集名称返回Assembly对象<br><code>Assembly ass = Assembly.Load(&quot;ClassLibrary831&quot;);</code><br>load方法有多个重载，还可以通过流的方式获取程序集</p></li><li><p>通过DLL文件名称返回Assembly对象<br><code>Assembly ass = Assembly.LoadFile(&quot;ClassLibrary831.dll&quot;);</code><br>LoadFile这个方法的参数是程序集的绝对路径，通过点击程序集shift+鼠标右键复制路径即可。<br>在项目中，主要用来取相对路径，因为很多项目的程序集会被生成在一个文件夹里，此时取相对路径不容易出错。</p></li><li><p>通过Assembly获取程序集中类<br><code>Type t = ass.GetType(&quot;ClassLibrary831.NewClass&quot;);</code></p><blockquote><p>//参数必须是完全类名：命名空间+类名</p></blockquote></li><li><p>通过Assembly获取程序集中所有的类<br><code>Type[] t = ass.GetTypes();</code></p></li></ul><h1 id="4-反射的性能"><a href="#4-反射的性能" class="headerlink" title="4. 反射的性能"></a>4. 反射的性能</h1><p><a href="https://zhuanlan.zhihu.com/p/268547492">反射性能测试</a></p><p>使用反射来调用类型或者触发方法，或者访问一个字段或者属性时clr 需要做更多的工作(校验参数，检查权限等等)所以速度是非常慢的。</p><p>所以尽量不要使用反射进行编程。</p><p>对于打算编写一个动态构造类型（晚绑定）的应用程序，可以采取以下的几种方式进行代替：</p><ul><li>通过类的继承关系。<br>让该类型从一个编译时可知的基础类型派生出来，在运行时生成该类型的一个实例，将对其的引用放到其基础类型的一个变量中，然后调用该基础类型的虚方法。</li><li>通过接口实现。<br>在运行时，构建该类型的一个实例，将对其的引用放到其接口类型的一个变量中，然后调用该接口定义的虚方法。</li><li>通过委托实现。<br>让该类型实现一个方法，其名称和原型都与一个在编译时就已知的委托相符。<br>在运行时先构造该类型的实例，然后在用该方法的对象及名称构造出该委托的实例，接着通过委托调用你想要的方法。<br>这个方法相对与前面两个方法所作的工作要多一些，效率更低一些。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/reflection">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/reflection</a></p><p><a href="https://zhuanlan.zhihu.com/p/41282759">https://zhuanlan.zhihu.com/p/41282759</a></p><p><a href="https://www.sohu.com/a/363591840_468635">https://www.sohu.com/a/363591840_468635</a></p><p><a href="https://www.cnblogs.com/vaevvaev/p/6995639.html">https://www.cnblogs.com/vaevvaev/p/6995639.html</a></p><p><a href="https://www.cnblogs.com/loveleaf/p/9923970.html">https://www.cnblogs.com/loveleaf/p/9923970.html</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGF学习-0入门</title>
    <link href="/2021/10/19/UGF%E5%AD%A6%E4%B9%A0-0%E5%85%A5%E9%97%A8/"/>
    <url>/2021/10/19/UGF%E5%AD%A6%E4%B9%A0-0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是UGF"><a href="#1-什么是UGF" class="headerlink" title="1. 什么是UGF"></a>1. 什么是UGF</h1><p><img src="/images/UGF%E5%AD%A6%E4%B9%A0-0%E5%85%A5%E9%97%A8/gameframework-16345550925232.png" srcset="/img/loading.gif"></p><h1 id="2-安装UGF包"><a href="#2-安装UGF包" class="headerlink" title="2. 安装UGF包"></a>2. 安装UGF包</h1><p>在<a href="https://gameframework.cn/download/">下载页面</a>下载最新版 Game Framework（说好不用 git 就不用），当前使用的版本是 2020.07.10，下载后，可以获得一个叫做 GameFramework_2020_07_10.unitypackage 的 Unity 插件包。</p><p><img src="/images/UGF%E5%AD%A6%E4%B9%A0-0%E5%85%A5%E9%97%A8/GameFrameworkUnityPackage.png" srcset="/img/loading.gif"></p><blockquote><p>建议时刻考虑使用较新版本的 Game Framework，较新的版本出了新增特性和修正一些 BUG 之外，还会不断地优化框架自身逻辑的内存开销。</p></blockquote><p>将插件的全部内容导入刚创建的工程。</p><p><img src="/images/UGF%E5%AD%A6%E4%B9%A0-0%E5%85%A5%E9%97%A8/ImportUnityPackage.png" srcset="/img/loading.gif"></p><h1 id="3-工程结构"><a href="#3-工程结构" class="headerlink" title="3. 工程结构"></a>3. 工程结构</h1><p>GameFramework 文件夹是框架的全部内容，其中：</p><ul><li>Libraries<br>存放 GameFramework.dll 核心框架和一些框架必需的第三方库（当前只有一个开源 zip 压缩算法库）</li><li>Prefabs<br>存放 GameFramework.prefab 预制体，用于快速创建一个游戏框架启动场景</li><li>Scripts<br>存放 UnityGameFramework 的全部 Runtime 和 Editor 代码</li></ul><p>Example 文件夹是一个示例目录，其中：</p><ul><li>Example.unity<br>是一个含有 GameFramework.prefab 预制体的空场景，作为游戏启动的场景</li><li>ProcedureExample.cs<br>是一个示例流程代码文件，示例将以这个流程作为启动流程。</li></ul><p>打开 Example/Example.unity 场景，此时 Hierarchy 窗口显示了 Game Framework 的各个组成组件。</p><p><img src="/images/UGF%E5%AD%A6%E4%B9%A0-0%E5%85%A5%E9%97%A8/HierarchyView.png" srcset="/img/loading.gif"></p><h1 id="4-组件的获取"><a href="#4-组件的获取" class="headerlink" title="4. 组件的获取"></a>4. 组件的获取</h1><p>在 Game Framework 中，获取一个内置组件的代码是这样的：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 获取 Base 组件</span><br>BaseComponent baseComponent = UnityGameFramework.Runtime.GameEntry.GetComponent&lt;BaseComponent&gt;(); <br><span class="hljs-comment">// 使用刚刚获取的 Base 组件</span><br>baseComponent.EditorResourceMode = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>每次这么用，有点繁琐。一般把 Game Framework 的组件封装为能够全局静态访问的属性。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">UnityGameFramework.Runtime</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameEntry</span><br>    &#123;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取游戏基础组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BaseComponent Base<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取配置组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigComponent Config<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取数据结点组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataNodeComponent DataNode<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取数据表组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataTableComponent DataTable<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取调试组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DebuggerComponent Debugger<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取下载组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DownloadComponent Download<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取实体组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EntityComponent Entity<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取事件组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EventComponent Event<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取文件系统组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FileSystemComponent FileSystem<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取有限状态机组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FsmComponent Fsm<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取本地化组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LocalizationComponent Localization<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取网络组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> NetworkComponent Network<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取对象池组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ObjectPoolComponent ObjectPool<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取流程组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcedureComponent Procedure<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取资源组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ResourceComponent Resource<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取场景组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SceneComponent Scene<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取配置组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SettingComponent Setting<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取声音组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SoundComponent Sound<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取界面组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UIComponent UI<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 获取网络组件。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebRequestComponent WebRequest<br>        &#123;<br>            <span class="hljs-keyword">get</span>;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitBuiltinComponents</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Base = GameEntry.GetComponent&lt;BaseComponent&gt;();<br>            Config = GameEntry.GetComponent&lt;ConfigComponent&gt;();<br>            DataNode = GameEntry.GetComponent&lt;DataNodeComponent&gt;();<br>            DataTable = GameEntry.GetComponent&lt;DataTableComponent&gt;();<br>            Debugger = GameEntry.GetComponent&lt;DebuggerComponent&gt;();<br>            Download = GameEntry.GetComponent&lt;DownloadComponent&gt;();<br>            Entity = GameEntry.GetComponent&lt;EntityComponent&gt;();<br>            Event = GameEntry.GetComponent&lt;EventComponent&gt;();<br>            FileSystem = GameEntry.GetComponent&lt;FileSystemComponent&gt;();<br>            Fsm = GameEntry.GetComponent&lt;FsmComponent&gt;();<br>            Localization = GameEntry.GetComponent&lt;LocalizationComponent&gt;();<br>            Network = GameEntry.GetComponent&lt;NetworkComponent&gt;();<br>            ObjectPool = GameEntry.GetComponent&lt;ObjectPoolComponent&gt;();<br>            Procedure = GameEntry.GetComponent&lt;ProcedureComponent&gt;();<br>            Resource = GameEntry.GetComponent&lt;ResourceComponent&gt;();<br>            Scene = GameEntry.GetComponent&lt;SceneComponent&gt;();<br>            Setting = GameEntry.GetComponent&lt;SettingComponent&gt;();<br>            Sound = GameEntry.GetComponent&lt;SoundComponent&gt;();<br>            UI = GameEntry.GetComponent&lt;UIComponent&gt;();<br>            WebRequest = GameEntry.GetComponent&lt;WebRequestComponent&gt;();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将其放到Assets/GameFramework/Scripts/Runtime/Base/GameEntryInit.cs路径下即可。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>框架</category>
      
      <category>UGF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UGF</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦片地图</title>
    <link href="/2021/10/15/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/"/>
    <url>/2021/10/15/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="0-瓦片地图基础知识"><a href="#0-瓦片地图基础知识" class="headerlink" title="0. 瓦片地图基础知识"></a>0. 瓦片地图基础知识</h1><h2 id="0-1-什么是瓦片地图"><a href="#0-1-什么是瓦片地图" class="headerlink" title="0.1 什么是瓦片地图"></a>0.1 什么是瓦片地图</h2><p><strong>TileMap</strong>是<strong>Unity5.5a实验版</strong>加入的新功能，就像他的字面意思「瓦片地图」。</p><p>但说起来这个技术并不“新”了，成熟的2D引擎（诸如gamemaker，RpgMaker），都带有自己自己的tile编辑器的，第三方的编辑工具如Tiled使用起来也是比较方便的，Tile编辑器界的老牌开源编辑器<strong>Tiled</strong>，很多引擎也提供Tiled导入的支持。</p><p>TileMap 是有助于快速搭建整体关卡的利器。如果没有它，开发者要么只有用最笨的方法手动逐一搭建，要么自己写编辑器，要么借助于第三方编辑软件，而这三种方法其实对初学者都不是很友好。</p><h2 id="0-2-瓦片地图的构成"><a href="#0-2-瓦片地图的构成" class="headerlink" title="0.2 瓦片地图的构成"></a>0.2 瓦片地图的构成</h2><p>Tilemap用起来其实就和现实中画画一样，它由以下五个基本部分组成：</p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/048ecfd4d364b947e663778075201a10.webp" srcset="/img/loading.gif" alt="教程｜Unity中使用Tilemap快速创建2D游戏世界"></p><ul><li>Sprite(精灵)：<br>纹理的容器。<br>大型纹理图集可以转换为精灵图集(Sprite Sheet)。</li><li>Tile(瓦片)：<br>包含一个精灵，以及二个属性，颜色和碰撞体类型。<br>使用瓦片就像在画布上画画一样，画画时可以设置一些颜色和属性。</li><li>Palette(调色板)：<br>当你在画布(Canvas)上画画时，会需要一个位置来保存绘画的结果。<br>类似地，调色板(Palette)的功能就是保存瓦片，将它们绘制到网格上。</li><li>Brush(笔刷)：<br>用于将画好的东西绘制到画布上。<br>使用Tilemap时，可以在多个笔刷中任意选择，绘制出线条、方块等各种形状。</li><li>Tilemap（瓦片地图）：<br>类似Photoshop中的图层，我们可以在Tilemap上画上Tile。</li></ul><p>Tilemap部分其它工具：</p><ul><li>Grid(网格)：<br>用于控制网格属性的组件。<br>Tilemap是Grid的子对象。<br>Grid类似于UI Canvas(UI画布)。</li><li>Tilemap渲染器(Tilemap Renderer)：<br>用于控制Tile在Tilemap上的渲染，控制诸如排序、材质和遮罩等。</li></ul><h1 id="1-瓦片地图的初级使用"><a href="#1-瓦片地图的初级使用" class="headerlink" title="1.  瓦片地图的初级使用"></a>1.  瓦片地图的初级使用</h1><h2 id="1-1-创建流程"><a href="#1-1-创建流程" class="headerlink" title="1.1 创建流程"></a>1.1 创建流程</h2><ol><li>创建瓦片地图：<br>在层级窗口中，依次点击Create-&gt;2D Object-&gt;Tilemap 新建Tilemap<br>这将自动创建两个GameObject对象，一个是名为Grid的父对象，上面带有Grid组件。<br>另一个是名为Tilemap的子对象，它在Grid对象下，带有Tilemap和Tilemap Renderer组件。</li><li>创建调色板<br>依次点击Window-&gt;Tile Palette打开调色板窗口。<br>在调色板窗口中，选择Create New Palette。设置名字和属性，然后指定保存位置。</li><li>创建笔刷<br>向调色板加入新瓦片，拖动精灵到调色板中，会打开一个新窗口，询问瓦片的保存位置。<br>你也可以通过精灵图集拖动多个瓦片。</li><li>创建完成，开始在场景中绘制:<br>瓦片加入调色板后，就可以用笔刷绘制场景了。</li></ol><h2 id="1-2-瓦片绘制工具"><a href="#1-2-瓦片绘制工具" class="headerlink" title="1.2 瓦片绘制工具"></a>1.2 瓦片绘制工具</h2><p>TilePalette(瓦片调色板) 中可以找到用来绘制Tile的绘图工具：</p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/v2-8a08957217a3f92111564ae63a2c95ca_1440w.jpg" srcset="/img/loading.gif" alt="img"></p><p>从左至右依次为：</p><ul><li>选择工具<br>用来选择Tile资源更改属性。</li><li>移动工具<br>用于移动选中的Tile资源。</li><li>矩形工具<br>用于绘制矩形块，并由选定的Tile资源来填充。</li><li>选取工具<br>用于选取要绘制的Tile资源，按下左键并拖拽可以一次选取多个Tile。</li><li>擦除工具<br>用于擦除Tile资源。</li><li>填充工具<br>用于将选定区域填充为选定的Tile资源。</li></ul><p>TilePalette面板上有一个Edit，如果选上的话可以编辑在TilePalette面板中的Tile资源。</p><h2 id="1-3-瓦片地图的物理碰撞"><a href="#1-3-瓦片地图的物理碰撞" class="headerlink" title="1.3 瓦片地图的物理碰撞"></a>1.3 瓦片地图的物理碰撞</h2><p>在Tilemap中添加碰撞体十分简单，只要给Tilemap对象加入一个Tilemap Collider 2D组件即可。<br>可以看到，这个组件自动为该Tilemap上的所有瓦片都加入了碰撞体。</p><p>我们可以通过再添加Composite Collider来优化这里的碰撞体，Rigidbody 2D组件会随着Composite Collider自动添加。<br>因为平台不会移动，所以要记得将Rigidbody 2D上的Body Type属性设置为Static。<br>最后在Tilemap Collider 2D上勾选Used By Composite，在整个平台周围生成一个复合碰撞体。<br>设置好后的检视窗口如下所示。</p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/9f55e8791de25dc19ee01f6e8f07721d.webp" srcset="/img/loading.gif" alt="教程｜Unity中使用Tilemap快速创建2D游戏世界"></p><p>这样我们的Tilemap部分就完成了。</p><h2 id="1-4-注意事项"><a href="#1-4-注意事项" class="headerlink" title="1.4 注意事项"></a>1.4 注意事项</h2><h3 id="1-4-1-瓦片匹配问题"><a href="#1-4-1-瓦片匹配问题" class="headerlink" title="1.4.1 瓦片匹配问题"></a>1.4.1 瓦片匹配问题</h3><ul><li><strong>发生情景：</strong><br>在创建Tilemap及一个palette后，我们想把已有的美术资源(Jungle_Tileset.png)做成瓦片，在对图片进行切片、拖入Palette后、进行绘制地图时会发现，<strong>瓦片并不与Scene场景内的unit单元格匹配</strong>。<br>例如下图:</li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/1688704-20190926162210739-1102159657.png" srcset="/img/loading.gif" alt="img"></p><ul><li><p><strong>问题原因：</strong><br>原因在于我们对图片进行切片时，<strong>Pixels Per Unit</strong> 数值的问题。</p></li><li><p><strong>问题分析：</strong><br>它的含义是<strong>每个unit单元格所能容纳该图片的多少个像素</strong>。上图依次为Pixels Per Unit为不同值时每个瓦片与Scene场景下一个Unit的比例。拿Pixels Per Unit=43来说，其含义是每个unit只够装下43个像素，而我们的美术图片（左）像素为1024x1024，算下来每个瓦片有128像素，我们却只给每个Unit43像素，所以从最右边图片我们可以看出大概9个unit才可以放下一个瓦片。</p></li><li><p><strong>如何解决：</strong><br>对每张将要被做成瓦片的美术资源进行Pixels Per Unit的计算。如本例最合理的数值为 1024/8 = 128</p><blockquote><p>非瓦片的Sprite直接拖拽进入Scene进行缩放操作即可。</p></blockquote></li></ul><h3 id="1-4-2-Tiles的选择问题"><a href="#1-4-2-Tiles的选择问题" class="headerlink" title="1.4.2 Tiles的选择问题"></a>1.4.2 Tiles的选择问题</h3><ul><li><strong>发生情景：</strong><br>在导入2d-extras包后，我们可以在Project内右键添加各类Tiles（见下图）。假如我们要做一个<strong>带有Animation的瓦片</strong>，是否直接可以直接使用AnimationTile类型呢？答案是肯定的，但完美的做法是按需使用。</li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/1688704-20190926162233932-2092282446.png" srcset="/img/loading.gif" alt="img"></p><ul><li><p><strong>问题原因：</strong></p><p>AnimatedTile的RuleTile的功能存在差异</p><ul><li><p>AnimatedTile：</p><ul><li>瓦片数目：对单块瓦片进行操作</li><li>动画速度：MinimumSpeed ~ MaximumSpeed</li><li>起始时间：Start Time</li></ul></li><li><p>RuleTile</p><p>(前提是设置瓦片output类型为Animation)：</p><ul><li>瓦片数目：多片，且能同时实现规则瓦片功能</li><li>动画速度：Speed</li><li>GameObject：同时实现PrefabBrush功能</li></ul></li></ul></li><li><p><strong>总结：</strong><br>对于带有Animation的瓦片，我们应该<strong>按需选择Tile的类型</strong>。<br>例如：不同启用时间的地刺，我们应当选择AnimatedTile进而调节StartTime参数；<br>例如：较长的瀑布，我们应该选用RuleTile，既能实现Animation效果又能方便画多个瓦片；<br>例如：蜡烛，我们想实现燃烧动画不一致，就应当采用AnimatedTile进而调节两个Speed参数等等。<br>但总的来说，<strong>RuleTile集成了几类extra瓦片的基础功能</strong>，较为常用。</p></li></ul><h3 id="1-4-3-快捷键"><a href="#1-4-3-快捷键" class="headerlink" title="1.4.3 快捷键"></a>1.4.3 快捷键</h3><ul><li>旋转绘制中的瓦片的方向：<br>[ ] 键</li><li>删除当前绘制的瓦片：<br>按住shift+左键点击</li></ul><h1 id="2-瓦片地图-的-API"><a href="#2-瓦片地图-的-API" class="headerlink" title="2. 瓦片地图 的 API"></a>2. 瓦片地图 的 API</h1><h2 id="2-1-编辑器中的属性"><a href="#2-1-编辑器中的属性" class="headerlink" title="2.1 编辑器中的属性"></a>2.1 编辑器中的属性</h2><h3 id="2-1-1-TileMap"><a href="#2-1-1-TileMap" class="headerlink" title="2.1.1 TileMap"></a>2.1.1 TileMap</h3><p>tilemap组件是一个存储和处理瓦片资源以便创建2D关卡系统。<br>此组件将所需信息放置在组件的瓦片上传输到其他相关组件。<br>例如Tilemap Render和Tilemap Colider2D。</p><ul><li>Animation Frame Rate：<br>unity播放图块的速率。（如果将其设置为2，则unity以2倍速度播放Tile动画）</li><li>Color：<br>使用选定的颜色在此Tilemap上为Tile着色。设置为白色时，unity渲染图块时不着色。</li><li>Tile Anchor：<br>Tile在此Tilemap上的锚定偏移。调整位置值以偏移图块 在关联网格上的像元位置。</li><li>Orientation：<br>Tilemap上Tile的方向。如果您需要在特定平面上（特别是在3D视图中）定向图块，使用此项。</li><li>Position：<br>显示当前方向矩阵的位置偏移。</li><li>Rotation：<br>当前方向矩阵的旋转。</li><li>Scale：<br>当前方向矩阵的比例。</li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/image-20211018225517471.png" srcset="/img/loading.gif" alt="image-20211018225517471"></p><h3 id="2-1-2-Tilemap-Renderer"><a href="#2-1-2-Tilemap-Renderer" class="headerlink" title="2.1.2 Tilemap Renderer"></a>2.1.2 Tilemap Renderer</h3><ul><li><p>Material：<br>定义用于渲染精灵纹理的材质。</p></li><li><p>Sort Order：<br>设置所选瓦片地图上的瓦片排序方向。</p></li><li><p>Mode：<br>设置渲染模式。</p><ul><li>Chunk ：<br>渲染器按位置对瓦片进行分组，并将瓦片的精灵一起批处理以进行渲染。可获得最佳渲染性能</li><li>Individual：<br>渲染器单独渲染每个瓦片，同时还会考虑他们的位置和排序顺序。<br>此模式使瓦片上的精灵能够与场景中的其他渲染器或与自定义排序轴进行交互</li></ul></li><li><p>Detect Chunk Culling Bounds：<br>确定渲染器如何检测用于剔除瓦片地图块的边界。<br>这些边界可扩展瓦片地图块的边界，以确保在剔除过程中不会裁剪过大的精灵。</p><ul><li>Auto：渲染器会自动检查瓦片使用的精灵，以确定要使用的扩展剔除边界</li><li>Manual：用于扩展边界与剔除瓦片地图块的值是手动设置的，而不使用Editor的自动检测功能</li></ul></li><li><p>Chunk Culling Bounds：<br>输入剔除边界的扩展值。</p></li><li><p>Sorting Layer：<br>设置瓦片地图的排序图层(sorting layer）。<br>从下拉框中选择现有的排序图层，或创建新的排序图层。</p></li><li><p>Order in Layer：<br>设置瓦片地图在其排序图层中的渲染优先级。首先渲染编号较低的图层。<br>编号较高的图层叠加在前者之上。</p></li><li><p>Mask Interaction：<br>设置地图渲染器在于精灵交互时的行为方式。</p><ul><li>None：<br>瓦片地图渲染器不与场景中的任何精灵遮罩交互</li><li>Visible Inside Mask：<br>瓦片地图在精灵遮罩覆盖瓦片地图的地方是可见的，而在遮罩外部不可见</li><li>Visible Outside Mask：<br>瓦片地图在精灵遮罩外部是不可见的，而在遮罩内部不可见。<br>精灵遮罩会隐藏其要覆盖的精灵部分</li></ul></li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/image-20211018225453019.png" srcset="/img/loading.gif" alt="image-20211018225453019"></p><h2 id="2-2-编程用API"><a href="#2-2-编程用API" class="headerlink" title="2.2 编程用API"></a>2.2 编程用API</h2><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.html">https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.html</a></p><h3 id="2-2-1-Tilemap"><a href="#2-2-1-Tilemap" class="headerlink" title="2.2.1 Tilemap"></a>2.2.1 Tilemap</h3><h4 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h4><table><thead><tr><th>变量名称</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Grid.html">Grid</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-layoutGrid.html">layoutGrid</a></td><td>获取与此Tilemap关联的网格。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/BoundsInt.html">BoundsInt</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-localBounds.html">localBounds</a></td><td>以本地空间大小返回 Tilemap 的边界。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/BoundsInt.html">BoundsInt</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-cellBounds.html">cellBounds</a></td><td>以单元格大小返回 Tilemap 的边界。</td></tr><tr><td>Vector3Int origin</td><td>Tilemap 的原点（以单元格位置为单位）。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Vector3Int.html">Vector3Int</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-size.html">size</a></td><td>Tilemap 的大小（以单元格为单位）。</td></tr><tr><td>Vector3 <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-tileAnchor.html">tileAnchor</a></td><td>Tilemap 的锚点。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-orientation.html">orientation</a></td><td>Tilemap 的排列方向。</td></tr><tr><td>bool enabled</td><td>启用的 Behaviour 可更新，禁用的 Behaviour 不可更新。</td></tr><tr><td>Vector3 <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout-cellGap.html">cellGap</a></td><td>布局中各个单元格之间的间隙大小。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout-cellLayout.html">cellLayout</a></td><td>单元格的布局。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout-cellSize.html">cellSize</a></td><td>布局中每个单元格的大小。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout-cellSwizzle.html">cellSwizzle</a></td><td>布局的单元格重排。</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Object-hideFlags.html">hideFlags</a></td><td>该对象应该隐藏、随场景一起保存还是由用户修改？</td></tr><tr><td><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Color.html">Color</a> <a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap-color.html">color</a></td><td>Tilemap 层的颜色</td></tr></tbody></table><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="添加瓦片"><a href="#添加瓦片" class="headerlink" title="添加瓦片"></a>添加瓦片</h5><ul><li><p><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.SetTile.html">SetTile</a><br>在Tilemap中指定的单元格添加瓦片。<br><code>void SetTile (Vector3Int position, Tilemaps.TileBase tile); </code></p></li><li><p><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.SetTiles.html">SetTiles</a><br>在Tilemap中指定的一组单元格添加一组瓦片。<br><code>void SetTiles(Vector3Int[] positionArray, TileBase[] tileArray);</code></p></li><li><p><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.SetTilesBlock.html">SetTilesBlock</a><br>在Tilemap中指定的一个范围块内添加一组瓦片。<br><code> void SetTilesBlock(BoundsInt position, TileBase[] tileArray);</code></p><blockquote><p>比SetTiles更有效率，是批处理</p></blockquote></li><li><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.BoxFill.html">BoxFill</a><br>在瓦片地图上使用给定瓦片进行框填。<br>从给定坐标开始，然后从开始到结束（含）填充边界。<br><code>void BoxFill (Vector3Int position, Tilemaps.TileBase tile, int startX, int startY, int endX, int endY);</code></p><table><thead><tr><th>参数名</th><th>含义</th></tr></thead><tbody><tr><td>position</td><td>瓦片在 <a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.html">Tilemap</a> 上的位置。</td></tr><tr><td>tile</td><td>要放置的 <a href="https://docs.unity.cn/cn/current/Manual/Tilemap-ScriptableTiles-TileBase.html">Tile</a>。</td></tr><tr><td>startX</td><td>填充范围的 X 坐标下限。</td></tr><tr><td>startY</td><td>填充范围的 Y 坐标下限。</td></tr><tr><td>endX</td><td>填充范围的 X 坐标上限。</td></tr><tr><td>endY</td><td>填充范围的 Y 坐标上限。</td></tr></tbody></table></li><li><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.FloodFill.html">FloodFill</a><br>从给定坐标开始，在瓦片地图上使用要放置的给定瓦片进行灌填(油漆桶)。<br><code>void FloodFill (Vector3Int position, Tilemaps.TileBase tile);</code></p><blockquote><p>BoxFill是范围内填充<br>FloodFill是剩下范围全部填充</p></blockquote></li><li><p><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.InsertCells.html">InsertCells</a><br>在Tilemap中指定位置插入很多瓦片<br><code>void InsertCells (Vector3Int position, Vector3Int insertCells);</code><br>参数:</p><ul><li>position 单元格坐标</li><li>Vector3Int insertCells 插入瓦片参数<ul><li> numColumns：插入列数</li><li> numRows：插入行数</li><li> numLayers：插入层数</li></ul></li></ul></li></ul><h5 id="查询瓦片"><a href="#查询瓦片" class="headerlink" title="查询瓦片"></a>查询瓦片</h5><ul><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.GetTile.html">GetTile</a><br>获取指定单元格的瓦片对象。<br><code> Tilemaps.TileBase GetTile(Vector3Int position);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.GetSprite.html">GetSprite</a><br>获取指定单元格的瓦片使用的精灵对象。<br><code> Sprite GetSprite(Vector3Int position);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.ContainsTile.html">ContainsTile</a><br>瓦片地图中是否存在该瓦片<br><code>bool ContainsTile(TileBase tileAsse);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.HasTile.html">HasTile</a><br>瓦片地图的指定位置是否存在该瓦片<br><code> bool HasTile(Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetCellCenterLocal.html">GetCellCenterLocal</a><br>获取瓦片地图逻辑中心的本地坐标。<br><code>Vector3 GetCellCenterLocal (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetCellCenterWorld.html">GetCellCenterWorld</a><br>获取瓦片地图逻辑中心的世界坐标。<br><code>Vector3 GetCellCenterWorld (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetColliderType.html">GetColliderType</a><br>根据给定的瓦片地图中某个单元格的 XYZ 坐标，获取瓦片的碰撞体类型。<br><code>Tilemaps.Tile.ColliderType GetColliderType (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetColor.html">GetColor</a><br>根据给定的瓦片地图中某个单元格的 XYZ 坐标，获取瓦片的颜色。<br><code>Color GetColor (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetTileFlags.html">GetTileFlags</a><br>获取给定位置处的 Tile 的 TileFlags。<br><code>Tilemaps.TileFlags GetTileFlags (Vector3Int position);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.GetUsedTilesCount.html">GetUsedTilesCount</a><br>获取 Tilemap 中使用的不同 tiles 的总数。<br><code>int GetUsedTilesCount ();</code></li></ul><h5 id="修改瓦片"><a href="#修改瓦片" class="headerlink" title="修改瓦片"></a>修改瓦片</h5><ul><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.SetColliderType.html">SetColliderType</a><br>根据给定的瓦片地图中某个单元格的 XYZ 坐标，设置瓦片的碰撞体类型。<br><code>void SetColliderType (Vector3Int position, Tilemaps.Tile.ColliderType colliderType);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.SetColor.html">SetColor</a><br>根据给定的瓦片地图中某个单元格的 XYZ 坐标，设置瓦片的颜色。<br><code>void SetColor (Vector3Int position, Color color);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tilemap.SetTileFlags.html">SetTileFlags</a><br>将 TileFlags 设置到给定位置处的 Tile 上。<br><code>void SetTileFlags (Vector3Int position, Tilemaps.TileFlags flags);</code></li></ul><h5 id="更新瓦片"><a href="#更新瓦片" class="headerlink" title="更新瓦片"></a>更新瓦片</h5><ul><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.RefreshTile.html">RefreshTile</a><br>更新指定位置的瓦片。<br><code>void RefreshTile(Vector3Int position);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.RefreshAllTiles.html">RefreshAllTiles</a><br>更新瓦片地图中的所有瓦片。<br><code>void RefreshAllTiles ();</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.SwapTile.html">SwapTile</a><br>将所有指定类型的瓦片置换为新的瓦片对象并刷新<br><code>void SwapTile(Tilemaps.TileBase changeTile, Tilemaps.TileBase newTile);</code><ul><li>changeTile：旧瓦片</li><li>newTile：新瓦片</li></ul></li></ul><h5 id="删除瓦片"><a href="#删除瓦片" class="headerlink" title="删除瓦片"></a>删除瓦片</h5><ul><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.ClearAllTiles.html">ClearAllTiles</a><br>清除瓦片地图内所有瓦片。<br><code>void ClearAllTiles();</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/Tilemaps.Tilemap.DeleteCells.html">DeleteCells</a><br>删除指定范围内的瓦片<br><code>void DeleteCells(Vector3Int position, Vector3Int deleteCells);</code><br>Vector3Int deleteCells:<ul><li>列数</li><li>行数</li><li>层级</li></ul></li></ul><h5 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h5><ul><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.CellToLocal.html">CellToLocal</a><br>将单元格位置转换为本地空间位置。<br><code> Vector3 CellToLocal(Vector3Int cellPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.CellToWorld.html">CellToWorld</a><br>将单元格位置转换为世界空间位置。<br><code>Vector3 CellToWorld (Vector3Int cellPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.LocalToCell.html">LocalToCell</a><br>将本地位置转换为单元格位置。<br><code>Vector3Int LocalToCell (Vector3 localPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.WorldToCell.html">WorldToCell</a><br>将世界位置转换为单元格位置。<br><code> Vector3Int WorldToCell (Vector3 worldPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.GetBoundsLocal.html">GetBoundsLocal</a><br>返回该位置的单元格的本地边界。<br><code>Bounds GetBoundsLocal (Vector3Int cellPosition);</code></li><li><a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.GetLayoutCellCenter.html">GetLayoutCellCenter</a><br>获取 Grid 的设置布局的单元格默认中心坐标(世界坐标)。<br><code>Vector3 GetLayoutCellCenter ();</code></li></ul><p><strong>注意</strong>：<br>所有坐标转换方法都是依赖于tilemap实例的父实例(<a href="https://docs.unity3d.com/cn/2021.2/ScriptReference/GridLayout.html">GridLayout</a>)<br>需要如下方法才能使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">GridLayout gridLayout = transform.parent.GetComponent&lt;GridLayout&gt;();<br>Vector3Int cellPosition = gridLayout.LocalToCell(transform.localPosition);<br>transform.localPosition = gridLayout.CellToLocal(cellPosition);<br></code></pre></td></tr></table></figure><h3 id="2-2-2-Tile"><a href="#2-2-2-Tile" class="headerlink" title="2.2.2 Tile"></a>2.2.2 Tile</h3><p>Tilemap 中默认瓦片的类。</p><p>该类从 TileBase 继承，代表将放置在 Tilemap 中的默认瓦片。它实现 TileBase.GetTileData，以在瓦片地图中简单渲染 Sprite。</p><h4 id="常用变量-1"><a href="#常用变量-1" class="headerlink" title="常用变量"></a>常用变量</h4><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-color.html">color</a></td><td>Tile 的 颜色。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-flags.html">flags</a></td><td>Tile 的 TileFlags。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-gameObject.html">gameObject</a></td><td>Tile 的 GameObject。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-sprite.html">sprite</a></td><td>要在 Tile 处渲染的 Sprite。</td></tr><tr><td><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile-transform.html">transform</a></td><td>Tile 的 Transform matrix。</td></tr></tbody></table><blockquote><p>注意：<br>transform是矩阵，不是一般游戏对象的transform组件</p></blockquote><p>以上五个属性合一块一封装就是<a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.TileData.html">TileData</a>了</p><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.Tile.GetTileData.html">GetTileData</a><br>检索 Tile 的瓦片渲染数据。<br><code>void GetTileData (Vector3Int position, Tilemaps.ITilemap tilemap, ref Tilemaps.TileData tileData);</code></li><li><a href="https://docs.unity.cn/cn/current/ScriptReference/Tilemaps.TileBase.RefreshTile.html">RefreshTile</a><br>瓦片刷新时调用<br><code>void RefreshTile (Vector3Int position, Tilemaps.ITilemap tilemap);</code></li></ul><blockquote><p>注意：<br>以上俩方法都是静态方法，不能通过实例调用，要通过类名调用</p></blockquote><h3 id="2-2-3-编程案例"><a href="#2-2-3-编程案例" class="headerlink" title="2.2.3 编程案例"></a>2.2.3 编程案例</h3><p>使用程序动态生成使用三种瓦片的瓦片地图</p><p><strong>瓦片种类有三种：</strong><br><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/image-20211018224634727.png" srcset="/img/loading.gif" alt="image-20211018224634727"></p><p>代码如下:</p><p><strong>瓦片地图生成：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Tilemaps;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MapSystem</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Vector2Int mapSize;<span class="hljs-comment">//瓦片地图大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> desertRate = <span class="hljs-number">0.2f</span>;<span class="hljs-comment">//沙漠地块所占比例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> gobiRate = <span class="hljs-number">0.4f</span>;<span class="hljs-comment">//戈壁地块所占比例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> oasisRate = <span class="hljs-number">0.4f</span>;<span class="hljs-comment">//绿洲地块所占比例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> mixingAreaSize = <span class="hljs-number">2</span>;<span class="hljs-comment">//交接混合地块宽度</span><br><br>    <span class="hljs-keyword">private</span> LandBlock[][] landBlocks;<br>    <span class="hljs-keyword">private</span> Tilemap tilemap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span>=&gt; tilemap = gameObject.GetComponent&lt;Tilemap&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span> =&gt; initMap();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//初始化地图</span></span><br><span class="hljs-function"></span>    &#123;<br>        tilemap.ClearAllTiles();<span class="hljs-comment">//先清空瓦片地图中的所有瓦片</span><br>        tilemap.size = <span class="hljs-keyword">new</span> Vector3Int(mapSize.x,mapSize.y,<span class="hljs-number">0</span>);<span class="hljs-comment">//设置瓦片地图大小</span><br>        landBlocks = <span class="hljs-keyword">new</span> LandBlock[mapSize.y][];<span class="hljs-comment">//准备数据结构与瓦片地图的瓦片绑定</span><br>        GridLayout gridLayout = transform.parent.GetComponentInParent&lt;GridLayout&gt;();<span class="hljs-comment">//获取瓦片地图的父对象，网格布局</span><br><br>        <span class="hljs-comment">//求三种地块(瓦片)所占的列数</span><br>        <span class="hljs-built_in">int</span> desertCol = (<span class="hljs-built_in">int</span>) (mapSize.x * desertRate);<br>        <span class="hljs-built_in">int</span> gobiCol = (<span class="hljs-built_in">int</span>)(mapSize.x * gobiRate);<br>        <span class="hljs-built_in">int</span> oasisCol = mapSize.x - desertCol - gobiCol;<br><br>        <span class="hljs-comment">//开始生成瓦片地图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;i&lt;mapSize.y;i++)<br>        &#123;<br>            landBlocks[i] = <span class="hljs-keyword">new</span> LandBlock[mapSize.x];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>;j&lt;mapSize.x;j++)<br>            &#123;<br>                <span class="hljs-comment">// 初始化瓦片</span><br>                Tile tile = ScriptableObject.CreateInstance&lt;Tile&gt;();<br>                <span class="hljs-comment">// 初始化瓦片单元格地址(逻辑地址)</span><br>                Vector3Int index = <span class="hljs-keyword">new</span> Vector3Int(i, j, <span class="hljs-number">0</span>);<br>                <span class="hljs-comment">// 将瓦片添加到瓦片地图中</span><br>                tilemap.SetTile(index, tile);<br>                <span class="hljs-comment">// 获取该瓦片的世界坐标</span><br>                Vector3 position = gridLayout.CellToWorld(index);<br>                <br>                <span class="hljs-comment">// 根据当前列数生成地块(地块数据与瓦片绑定)</span><br>                LandBlock landBlock;<br>                <span class="hljs-keyword">if</span>(j &lt; desertCol - mixingAreaSize)<br>                    landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Desert, tile);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &lt; desertCol)<br>                    <span class="hljs-keyword">if</span>(Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>) &lt; <span class="hljs-number">0.5</span>)<br>                        landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Desert, tile);<br>                    <span class="hljs-keyword">else</span><br>                        landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Gobi, tile);<br>                <br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &lt; desertCol + gobiCol - mixingAreaSize)<br>                    landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Gobi, tile);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &lt; desertCol + gobiCol)<br>                    <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>) &lt; <span class="hljs-number">0.5</span>)<br>                        landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Gobi, tile);<br>                    <span class="hljs-keyword">else</span><br>                        landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Oasis, tile);<br>                <br>                <span class="hljs-keyword">else</span><br>                    landBlock = <span class="hljs-keyword">new</span> LandBlock(index, position, LandBlock.BlockType.Oasis, tile);<br>                <br>                landBlocks[i][j] = landBlock;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 更新瓦片地图的所有瓦片，地图初始化完成</span><br>        tilemap.RefreshAllTiles();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>地块数据类:</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Tilemaps;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LandBlock</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">Sprite</span>&gt; spriteList</span> = <span class="hljs-keyword">new</span> List&lt;Sprite&gt;(Resources.LoadAll&lt;Sprite&gt;(<span class="hljs-string">&quot;img/Entity/LandBlocks&quot;</span>));<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BlockType &#123; Desert, Gobi, Oasis &#125;;<span class="hljs-comment">// 地块类型: 沙漠，戈壁，绿洲</span><br><br>    <span class="hljs-keyword">public</span> Vector3Int index;   <span class="hljs-comment">// 逻辑坐标</span><br>    <span class="hljs-keyword">public</span> Vector3 position; <span class="hljs-comment">// 位置</span><br>    <span class="hljs-keyword">public</span> Tile tile;<br><br>    <span class="hljs-keyword">private</span> BlockType type;<br>    <span class="hljs-keyword">public</span> BlockType Type &#123;<span class="hljs-keyword">get</span> =&gt; type;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LandBlock</span>(<span class="hljs-params">Vector3Int index, Vector3 position, BlockType type, Tile tile</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.index = index;<br>        <span class="hljs-keyword">this</span>.position = position;<br>        <span class="hljs-keyword">this</span>.type = type;<br>        <span class="hljs-keyword">this</span>.tile = tile;<br>        setSprite();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSprite</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//更改瓦片精灵</span></span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">string</span> spriteName = type.ToString() + <span class="hljs-string">&quot;Block&quot;</span>;<br>        tile.sprite = spriteList.Find(p =&gt; p.name == spriteName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>Tile 瓦片的实例化不能使用new，会报错。<br>需要使用 ScriptableObject.CreateInstance 才行，例如:<br>Tile tile = ScriptableObject.CreateInstance<Tile>();</p></blockquote><p><strong>效果如下:</strong><br><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/image-20211018224757712.png" srcset="/img/loading.gif" alt="image-20211018224757712"></p><p>这样就可以程序化生成地图了</p><h1 id="3-2d-extras中的高级瓦片"><a href="#3-2d-extras中的高级瓦片" class="headerlink" title="3. 2d-extras中的高级瓦片"></a>3. 2d-extras中的高级瓦片</h1><p><a href="https://github.com/Unity-Technologies/2d-extras">https://github.com/Unity-Technologies/2d-extras</a></p><p>为了提高开发速度，Unity创建了名为2d-extras的GitHub代码库，这里面的工具都是基于Tilemap制作，有很多实用的瓦片和笔刷，下面介绍几个2d-extras中的实用工具。</p><h2 id="3-1-规则瓦片-Rule-Tile"><a href="#3-1-规则瓦片-Rule-Tile" class="headerlink" title="3.1 规则瓦片(Rule Tile)"></a>3.1 规则瓦片(Rule Tile)</h2><p>2d-extras中最重要的工具之一就是规则瓦片(Rule Tile)。</p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/ec8959c409eb917d54061b5f05b8c566.webp" srcset="/img/loading.gif" alt="教程｜Unity中使用Tilemap快速创建2D游戏世界"></p><p>不用这个工具的话，我们每次在Tilemap上绘制时，都要从调色板选取特定瓦片再进行绘制。<br>如果你想要绘制相邻瓦片，例如一个拐角，你需要从调色板上一次次选取不同瓦片进行绘制。这种方法效率不高。但有了规则瓦片，你可以为相邻瓦片设置一组规则，它将自动选择最合适的瓦片进行绘制。</p><p><strong>规则瓦片属性：</strong></p><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/76bbd201-b852-4f4d-8bd5-08395bc2575e_image5.png" srcset="/img/loading.gif" alt="img"></p><p>规则图块属性包括：</p><ul><li><strong>默认精灵</strong></li><li><strong>默认游戏对象</strong>：<br>可以保留为空白</li><li><strong>默认碰撞器</strong>：<br>指定了瓦片的碰撞检测模式，有两种:<ul><li>精灵模式:按精灵形状进行碰撞检测</li><li>网格模式:按瓦片地图的单元网格形状进行碰撞检测</li></ul></li></ul><p>您添加的每个磁贴都有其他属性：</p><ul><li><strong>Rule</strong> ：<br>这决定了规则的类型。选项是<strong>固定</strong>（默认行为）、<strong>镜像</strong>（跨 X 或 Y 轴）或<strong>旋转</strong>。镜像和旋转是指 3x3 网格的配置，本节稍后会详细介绍。</li></ul><p><img src="/images/Unity-%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8c3a789f-e96e-4fec-85c8-04e0f8d9006d_image7.png" srcset="/img/loading.gif" alt="img"></p><p>上图的两个 Rotated 规则完成了 8 个 设定瓦片规则的工作。</p><ul><li><strong>游戏对象</strong></li><li><strong>碰撞器</strong>：<br>更改特定图块的碰撞器以覆盖默认碰撞器。</li><li><strong>输出</strong>：<br>这决定了瓷砖如何放置到场景中。<br>您可以从<strong>Single</strong> 、<strong>Random</strong>或<strong>Animation 中进行选择</strong>。<ul><li>Single ：单个瓦片(普通瓦片)。将使用选定的瓦片。</li><li>Random：随机瓦片。将在一组定义的瓦片之间进行选择</li><li>Animation ：动画瓦片。将播放指定图块的动画。</li></ul></li><li><strong>3x3 网格</strong>：<br>用于设定规则，规则可以根据周围瓦片的属性来决定中心瓦片的属性<br>比如说地块的拼接和转交等功能</li><li><strong>瓦片选择</strong>：<br>在该规则下使用的瓦片</li></ul><h2 id="3-2-预制件笔刷"><a href="#3-2-预制件笔刷" class="headerlink" title="3.2 预制件笔刷"></a>3.2 预制件笔刷</h2><p>在2d-extras中，还加入了预制件笔刷(Prefab Brush)。它能用预制件而不是瓦片来绘制画面。预制件可以是3D对象、粒子效果或是动画对象。要想创建自己的预制件笔刷，只要在项目窗口点击Create -&gt; Prefab Brush即可。然后选取刚创建的预制件笔刷，指定想要画出的预制件。如果你添加了不止一个预制件，它会在这些预制件中随机选取进行绘制。</p><h1 id="4-相关参考"><a href="#4-相关参考" class="headerlink" title="4. 相关参考"></a>4. 相关参考</h1><p><a href="https://zhuanlan.zhihu.com/p/34714804">https://zhuanlan.zhihu.com/p/34714804</a></p><p><a href="https://www.cnblogs.com/SouthBegonia/p/11592554.html">https://www.cnblogs.com/SouthBegonia/p/11592554.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>2D</tag>
      
      <tag>瓦片地图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯法</title>
    <link href="/2021/10/09/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2021/10/09/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0-回溯法理论基础"><a href="#0-回溯法理论基础" class="headerlink" title="0. 回溯法理论基础"></a>0. 回溯法理论基础</h1><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p><strong>回溯函数也就是递归函数，指的都是一个函数</strong>。</p><p><strong>回溯法的理解:</strong><br>回溯法解决的问题都可以抽象为树形结构。<br>回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。<br>递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。</p><p><strong>回溯法的效率：</strong><br>回溯法并不是什么高效的算法，因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。<br>如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h2 id="0-1-回溯法解决的问题"><a href="#0-1-回溯法解决的问题" class="headerlink" title="0.1 回溯法解决的问题"></a>0.1 回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li><strong>组合问题：</strong><br>N个数里面按一定规则找出k个数的集合</li><li><strong>切割问题：</strong><br>一个字符串按一定规则有几种切割方式</li><li><strong>子集问题：</strong><br>一个N个数的集合里有多少符合条件的子集</li><li><strong>排列问题：</strong><br>N个数按一定规则全排列，有几种排列方式</li><li><strong>棋盘问题：</strong><br>N皇后，解数独等等</li></ul><blockquote><p>排列与组合:</p><ul><li><strong>组合是不强调元素顺序的</strong></li><li><strong>排列是强调元素顺序</strong></li></ul><p>例如：<br>{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。</p><p><strong>组合无序，排列有序</strong></p></blockquote><h2 id="0-2-回溯法模板"><a href="#0-2-回溯法模板" class="headerlink" title="0.2 回溯法模板"></a>0.2 回溯法模板</h2><p><strong>回溯函数：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数)<br></code></pre></td></tr></table></figure><p><strong>函数终止条件：</strong></p><p>既然是树形结构，那么遍历树形结构一定要有终止条件，所以回溯也有要终止条件。</p><p>从树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p><p>所以回溯函数终止条件伪代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">if (终止条件) &#123;<br>    存放结果;<br>    return;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回溯搜索的遍历过程：</strong></p><p>回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p>如图：</p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95/20210130173631174.png" srcset="/img/loading.gif" alt="回溯算法理论基础"></p><p>注意图中，我特意举例集合大小和孩子的数量是相等的！</p><p>回溯函数遍历过程伪代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>    处理节点;<br>    backtracking(路径，选择列表); // 递归<br>    回溯，撤销处理结果<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p><p>backtracking这里自己调用自己，实现递归。</p><p><strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong><br>这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p><strong>最终模板:</strong><br>回溯算法模板框架如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">void backtracking(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        backtracking(路径，选择列表); // 递归<br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这份模板很重要，后面做回溯法的题目都靠它了！</strong></p><h2 id="0-3-回溯法相关题型目录"><a href="#0-3-回溯法相关题型目录" class="headerlink" title="0.3 回溯法相关题型目录"></a>0.3 回溯法相关题型目录</h2><h3 id="0-3-1-组合问题"><a href="#0-3-1-组合问题" class="headerlink" title="0.3.1 组合问题"></a>0.3.1 组合问题</h3><h3 id="0-3-2-切割问题"><a href="#0-3-2-切割问题" class="headerlink" title="0.3.2 切割问题"></a>0.3.2 切割问题</h3><h3 id="0-3-3-子集和问题"><a href="#0-3-3-子集和问题" class="headerlink" title="0.3.3 子集和问题"></a>0.3.3 子集和问题</h3><h3 id="0-3-4-排列问题"><a href="#0-3-4-排列问题" class="headerlink" title="0.3.4 排列问题"></a>0.3.4 排列问题</h3><h3 id="0-3-5-去重问题"><a href="#0-3-5-去重问题" class="headerlink" title="0.3.5 去重问题"></a>0.3.5 去重问题</h3><h3 id="0-3-6-棋盘问题"><a href="#0-3-6-棋盘问题" class="headerlink" title="0.3.6 棋盘问题"></a>0.3.6 棋盘问题</h3><ul><li>N皇后</li><li>解数独</li></ul><h1 id="1-组合问题"><a href="#1-组合问题" class="headerlink" title="1. 组合问题"></a>1. 组合问题</h1><h2 id="1-1-k个数的组合"><a href="#1-1-k个数的组合" class="headerlink" title="1.1 k个数的组合"></a>1.1 k个数的组合</h2><p><a href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a></p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p><strong>解:</strong></p><p>可剪枝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combine</span>(<span class="hljs-params">self,n, k</span>):</span><br>        self.output = <span class="hljs-built_in">list</span>()<br>        self.k = k<br>        self.n = n<br>        self.backtracking(<span class="hljs-built_in">list</span>(), <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> self.output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtracking</span>(<span class="hljs-params">self, resoult,index</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(resoult) == self.k:<br>           self.output.append(<span class="hljs-built_in">list</span>(resoult))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index, self.n+<span class="hljs-number">1</span>):<br>            resoult.append(i)<br>            self.backtracking(resoult, i+<span class="hljs-number">1</span>)<br>            resoult.pop()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2021/10/03/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2021/10/03/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0-贪心基础"><a href="#0-贪心基础" class="headerlink" title="0. 贪心基础"></a>0. 贪心基础</h1><h2 id="0-1-贪心理论入门"><a href="#0-1-贪心理论入门" class="headerlink" title="0.1 贪心理论入门"></a>0.1 贪心理论入门</h2><p>在贪心系列开篇词<a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于贪心算法，你该了解这些！ (opens new window)</a>中，我们就讲解了大家对贪心的普遍疑惑。</p><p><strong>什么是贪心算法:</strong><br>如果找出局部最优并可以推出全局最优，就是贪心，如果局部最优都没找出来，就不是贪心。</p><p><strong>贪心算法的套路:</strong><br>贪心无套路，也没有框架之类的，需要多看多练培养感觉才能想到贪心的思路。</p><p><strong>贪心算法的步骤:</strong><br>贪心算法一般分为如下三步：</p><ol><li>将问题分解为若干个子问题</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ol><h2 id="0-2-贪心题目目录"><a href="#0-2-贪心题目目录" class="headerlink" title="0.2 贪心题目目录"></a>0.2 贪心题目目录</h2><h3 id="0-2-1-贪心简单题"><a href="#0-2-1-贪心简单题" class="headerlink" title="0.2.1 贪心简单题"></a>0.2.1 贪心简单题</h3><p>以下三道题目就是简单题，靠常识。</p><ul><li>[分发饼干](# 1. 分发糖果)</li><li>[K次取反后最大化的数组和](# 2. K次取反后最大化的数组和)</li><li>[柠檬水找零](# 3. 柠檬水找零)</li></ul><h3 id="0-2-2-贪心中等题"><a href="#0-2-2-贪心中等题" class="headerlink" title="0.2.2 贪心中等题"></a>0.2.2 贪心中等题</h3><p>贪心中等题，靠常识可能就有点想不出来了。<br>开始初现贪心算法的难度与巧妙之处。</p><ul><li>[摆动序列](# 4. 摆动序列)</li><li>[单调递增的数字](# 5. 单调递增的数字)</li></ul><p><strong>两个维度权衡问题：</strong><br>在出现两个维度相互影响的情况时<br>两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。</p><ul><li>[分发糖果](# 6. 分发糖果)</li><li>[根据身高重建队列](# 7. 根据身高重建队列)</li></ul><h3 id="0-2-3-贪心难题"><a href="#0-2-3-贪心难题" class="headerlink" title="0.2.3 贪心难题"></a>0.2.3 贪心难题</h3><p>这里的题目如果没有接触过，其实是很难想到的，甚至接触过，也一时想不出来，所以题目不要做一遍，要多练！</p><p><strong>区间问题：</strong><br>关于区间问题，各种覆盖各种去重</p><ul><li>[用最少数量的箭引爆气球](# 8. 用最少数量的箭引爆气球)</li><li>[无重叠区间](# 9. 无重叠区间)</li><li>[合并区间](# 10. 合并区间)</li><li>[划分字母区间](# 11. 划分字母区间)</li></ul><p><strong>其他难题：</strong></p><p><a href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">贪心算法：最大子序和 (opens new window)</a><br>其实是动态规划的题目，但贪心性能更优，很多同学也是第一次发现贪心能比动规更优的题目。</p><p><a href="https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html">贪心算法：加油站 (opens new window)</a><br>可能以为是一道模拟题，但就算模拟其实也不简单，需要把while用的很娴熟。但其实是可以使用贪心给时间复杂度降低一个数量级。</p><p>最后贪心系列压轴题目<br><a href="https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html">贪心算法：我要监控二叉树！ (opens new window)</a><br>不仅贪心的思路不好想，而且需要对二叉树的操作特别娴熟，这就是典型的交叉类难题了。</p><h1 id="1-分发饼干"><a href="#1-分发饼干" class="headerlink" title="1. 分发饼干"></a>1. 分发饼干</h1><p><a href="https://leetcode-cn.com/problems/assign-cookies/">https://leetcode-cn.com/problems/assign-cookies/</a></p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。<br>但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；<br>并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。<br>如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。<br>你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2,3], s = [1,1]</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: </span><br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: g = [1,2], s = [1,2,3]</span><br><span class="hljs-section">输出: 2</span><br><span class="hljs-section">解释: </span><br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><p><strong>解:</strong></p><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20211004181228698.png" srcset="/img/loading.gif" alt="image-20211004181228698"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContentChildren</span>(<span class="hljs-params">self, g, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(g) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        g = <span class="hljs-built_in">sorted</span>(g)<br>        s = <span class="hljs-built_in">sorted</span>(s)<br>        output = <span class="hljs-number">0</span><br>        sP = <span class="hljs-number">0</span><br>        gP = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> gP &lt; <span class="hljs-built_in">len</span>(g) <span class="hljs-keyword">and</span> sP &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[sP] &gt;= g[gP]:<br>                output += <span class="hljs-number">1</span><br>                gP += <span class="hljs-number">1</span><br>            sP += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="2-K-次取反后最大化的数组和"><a href="#2-K-次取反后最大化的数组和" class="headerlink" title="2. K 次取反后最大化的数组和"></a>2. K 次取反后最大化的数组和</h1><p><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/</a></p><p>给定一个整数数组 A，我们<strong>只能</strong>用以下方法修改该数组：<br>我们选择某个索引 <code>i</code> 并将 <code>A[i]</code> 替换为 <code>-A[i]</code>，然后总共重复这个过程 <code>K</code> 次。<br>（我们可以多次选择同一个索引 <code>i</code>。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], K = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">5</span><br>解释：选择索引 (<span class="hljs-number">1</span>,) ，然后 <span class="hljs-keyword">A</span> 变为 [<span class="hljs-number">4</span>,-<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<span class="hljs-keyword">A</span> = [<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], K = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br>解释：选择索引 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>) ，然后 <span class="hljs-keyword">A</span> 变为 [<span class="hljs-number">3,1,0,2</span>]。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：A = [2,<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>,5,<span class="hljs-string">-4</span>], K = 2<br>输出：13<br>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,<span class="hljs-string">-1</span>,5,4]。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= K &lt;= 10000</code></li><li><code>-100 &lt;= A[i] &lt;= 100</code></li></ol><p><strong>解:</strong><br>贪心的思路</p><ul><li>局部最优：<br>让绝对值大的负数变为正数，当前数值达到最大</li><li>整体最优：<br>整个数组和达到最大。</li></ul><p>局部最优可以推出全局最优。</p><p>那么如果将负数都转变为正数了，K依然大于0，此时的问题是：<br>一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。</p><p>那么又是一个贪心：</p><ul><li>局部最优：<br>只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了）</li><li>全局最优：<br>整个 数组和 达到最大。</li></ul><p>那么本题的解题步骤为：</p><ul><li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li><li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li><li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li><li>第四步：求和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">largestSumAfterKNegations</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        output = <span class="hljs-number">0</span><br>        nums = <span class="hljs-built_in">sorted</span>(nums, key=<span class="hljs-built_in">abs</span>, reverse=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 将A按绝对值从大到小排列</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> k != <span class="hljs-number">0</span>:<br>                nums[i] = -nums[i]<br>                k -= <span class="hljs-number">1</span><br>            output += nums[i]<br>        <span class="hljs-keyword">if</span> k != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> k%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            output = output - nums[-<span class="hljs-number">1</span>]*<span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="3-柠檬水找零"><a href="#3-柠檬水找零" class="headerlink" title="3. 柠檬水找零"></a>3. 柠檬水找零</h1><p><a href="https://leetcode-cn.com/problems/lemonade-change/">https://leetcode-cn.com/problems/lemonade-change/</a></p><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。<br>顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。<br>你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bills = [5,5,5,10,20]<br>输出：true<br>解释：<br>前<span class="hljs-number"> 3 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 3 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>第<span class="hljs-number"> 4 </span>位顾客那里，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，并返还<span class="hljs-number"> 5 </span>美元。<br>第<span class="hljs-number"> 5 </span>位顾客那里，我们找还一张<span class="hljs-number"> 10 </span>美元的钞票和一张<span class="hljs-number"> 5 </span>美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bills = [5,5,10,10,20]<br>输出：false<br>解释：<br>前<span class="hljs-number"> 2 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 2 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>对于接下来的<span class="hljs-number"> 2 </span>位顾客，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，然后返还<span class="hljs-number"> 5 </span>美元。<br>对于最后一位顾客，我们无法退回<span class="hljs-number"> 15 </span>美元，因为我们现在只有两张<span class="hljs-number"> 10 </span>美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">bills</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">bills</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= bills.length &lt;= 105</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code> </li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lemonadeChange</span>(<span class="hljs-params">self, bills</span>):</span><br>        changeDict = &#123;<span class="hljs-number">5</span>:<span class="hljs-number">0</span>, <span class="hljs-number">10</span>:<span class="hljs-number">0</span>, <span class="hljs-number">20</span>:<span class="hljs-number">0</span>&#125;<br>        <span class="hljs-keyword">for</span> money <span class="hljs-keyword">in</span> bills:<br>            changeDict[money] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> money == <span class="hljs-number">5</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> money == <span class="hljs-number">10</span>:<br>                <span class="hljs-keyword">if</span> changeDict[<span class="hljs-number">5</span>] == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                changeDict[<span class="hljs-number">5</span>] -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> changeDict[<span class="hljs-number">5</span>] == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> changeDict[<span class="hljs-number">10</span>] &gt; <span class="hljs-number">0</span>:<br>                    changeDict[<span class="hljs-number">10</span>] -= <span class="hljs-number">1</span><br>                    changeDict[<span class="hljs-number">5</span>] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> changeDict[<span class="hljs-number">5</span>] &lt; <span class="hljs-number">3</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>                    changeDict[<span class="hljs-number">5</span>] -= <span class="hljs-number">3</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="4-摆动序列"><a href="#4-摆动序列" class="headerlink" title="4. 摆动序列"></a>4. 摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong><br>第一个差（如果存在的话）可能是正数或负数。<br>仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p><p><strong>解:</strong></p><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20211004181259464.png" srcset="/img/loading.gif" alt="image-20211004181259464"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wiggleMaxLengthByGreedy</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>        MaxLength = <span class="hljs-number">1</span><br>        state = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span>  state != <span class="hljs-number">1</span>:<br>                    MaxLength += <span class="hljs-number">1</span><br>                    state = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums[i] &lt; nums[i-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">if</span> state != -<span class="hljs-number">1</span>:<br>                    MaxLength += <span class="hljs-number">1</span><br>                    state = -<span class="hljs-number">1</span>           <br>        <span class="hljs-keyword">return</span> MaxLength<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    nums = [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>    s = Solution()<br>    print(s.wiggleMaxLengthByGreedy(nums))<br></code></pre></td></tr></table></figure><h1 id="5-单调递增的数字"><a href="#5-单调递增的数字" class="headerlink" title="5. 单调递增的数字"></a>5. 单调递增的数字</h1><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">https://leetcode-cn.com/problems/monotone-increasing-digits/</a></p><p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 10</span><br><span class="hljs-section">输出: 9</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 1234</span><br><span class="hljs-section">输出: 1234</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: N = 332</span><br><span class="hljs-section">输出: 299</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong> <code>N</code> 是在 <code>[0, 10^9]</code> 范围内的一个整数。</p><p><strong>解:</strong></p><p><strong>贪心算法三步走:</strong></p><ol><li><p>将问题分解为若干个子问题:<br>把求整个递增的数字这个全局问题，分解为求这个数字每位是什么的子问题</p></li><li><p>求解每一个子问题的最优解:<br>将传入数字n每位拆开放进数组<strong>numStr</strong>中 <strong>倒序</strong> 查看<br>当查看到第 [i] 位时：</p><ul><li>若 <strong>numStr[i] &gt;= numStr[i-1]</strong> ：<br>则仍满足递增<br>第i位不做修改</li><li>若 <strong>numStr[i] &lt; numStr[i-1]</strong> ：<br>则不满足递增<br>第[i]位取最大值9(贪心)<br>第[i-1]位值-1(满足该值 &lt;= n)</li></ul></li><li><p>将局部最优解堆叠成全局最优解<br>当 [i] 位发生改变时，要正序向后查看，之前已经求得的局部最优解是否仍然满足递增要求。<br>需要正序遍历 第 [i] 位 到 最后一位数</p><ul><li><p>若 <strong>numStr[j] &lt;= numStr[j-1]</strong> ：<br>则仍满足递增，第i位不做修改</p></li><li><p>若 <strong>numStr[j] &gt; numStr[j-1]</strong> ：<br>则不满足递增，第[i]位取最大值9(贪心)</p><p>最终把整个数组重新合并为数字，就是全局最优解</p></li></ul></li></ol><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">monotoneIncreasingDigits</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">10</span>:<br>            <span class="hljs-keyword">return</span> n<br>        numStr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(n))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(numStr)-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(numStr[i]) &gt;= <span class="hljs-built_in">int</span>(numStr[i-<span class="hljs-number">1</span>]):<br>                <span class="hljs-keyword">continue</span><br>            numStr[i] = <span class="hljs-string">&#x27;9&#x27;</span><br>            numStr[i-<span class="hljs-number">1</span>] = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(numStr[i-<span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(numStr)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(numStr[j]) &lt; <span class="hljs-built_in">int</span>(numStr[j-<span class="hljs-number">1</span>]):<br>                    numStr[j] = <span class="hljs-string">&#x27;9&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(numStr))<br></code></pre></td></tr></table></figure><h1 id="6-分发糖果"><a href="#6-分发糖果" class="headerlink" title="6. 分发糖果"></a>6. 分发糖果</h1><p><a href="https://leetcode-cn.com/problems/candy/">https://leetcode-cn.com/problems/candy/</a></p><p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,0,2]</span><br>输出：<span class="hljs-number">5</span><br>解释：你可以分别给这三个孩子分发 <span class="hljs-number">2</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span> 颗糖果。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：你可以分别给这三个孩子分发 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">1</span> 颗糖果。<br>     第三个孩子只得到 <span class="hljs-number">1</span> 颗糖果，这已满足上述两个条件。<br></code></pre></td></tr></table></figure><p><strong>解：</strong></p><p><strong>将问题分解为若干个子问题：</strong><br>设学生 A 和学生 B 左右相邻，A 在 B 左边；</p><ul><li>左规则：<br>当 ratings_B&gt;ratings_A 时，B 的糖比 A 的糖数量多</li><li>右规则：<br>当 ratings_A&gt;ratings_B时，A 的糖比 B 的糖数量多</li></ul><blockquote><p>相邻的学生中，评分高的学生必须获得更多的糖果 等价于 所有学生满足左规则且满足右规则。</p></blockquote><p><strong>求解每一个子问题的最优解：</strong></p><ol><li><p>从左至右遍(正序)历学生成绩 ratings<br>假设 第[i+1]个学生的成绩比第[i]个更高<br>则给第[i+1]个学生比第[i]个多一颗糖<br>否则都只给一颗糖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(ratings)):<br>    <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>]:<br>        rightOder[i] = rightOder[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>从右至左遍(倒序)历学生成绩 ratings<br>假设 第[j]个学生的成绩比第[j+1]个更高<br>则给第[j]个学生比第[j+1]个多一颗糖<br>否则都只给一颗糖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings)-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> ratings[j] &gt; ratings[j+<span class="hljs-number">1</span>]:<br>leftOder[j] = leftOder[j+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>将局部最优解堆叠成全局最优解:</strong><br>最终，取以上 2 轮遍历 <code>leftOder</code> 和 <code>rightOder</code> 对应学生糖果数的 <strong>最大值</strong> ，这样则 <strong>同时满足左规则和右规则</strong> ，即得到每个同学的最少糖果数量</p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)：<br>遍历三遍数组即可得到结果</li><li>空间复杂度 O(N)<br>需要借用left，right的线性额外空间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">candy</span>(<span class="hljs-params">self, ratings</span>):</span><br>        leftOder = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(ratings)<br>        rightOder = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(ratings)<br>        output = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(ratings)):<br>            <span class="hljs-keyword">if</span> ratings[i] &gt; ratings[i-<span class="hljs-number">1</span>]:<br>                rightOder[i] = rightOder[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings)-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> ratings[j] &gt; ratings[j+<span class="hljs-number">1</span>]:<br>                leftOder[j] = leftOder[j+<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(ratings)):<br>            output += <span class="hljs-built_in">max</span>(leftOder[k],rightOder[k])<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="7-根据身高重建队列"><a href="#7-根据身高重建队列" class="headerlink" title="7. 根据身高重建队列"></a>7. 根据身高重建队列</h1><p><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。<br>每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。<br>返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[5,2]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span><br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 <span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[7,0]</span>,<span class="hljs-comment">[5,2]</span>,<span class="hljs-comment">[6,1]</span>,<span class="hljs-comment">[4,4]</span>,<span class="hljs-comment">[7,1]</span>]</span> 是重新构造后的队列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：people = <span class="hljs-comment">[<span class="hljs-comment">[6,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[1,4]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[6,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 2000</code></li><li><code>0 &lt;= hi &lt;= 106</code></li><li><code>0 &lt;= ki &lt; people.length</code></li><li>题目数据确保队列可以被重建</li></ul><p><strong>解:</strong></p><p><strong>思路:</strong></p><ol><li>先由高到低排序<br>确定一个贪心维度 people [i][0]</li><li>再根据 people [i][1] 来插入数组<br>确定另一个贪心维度，满足前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人的要求</li></ol><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度O(nlogn + n^2)</li><li>空间复杂度O(n)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reconstructQueue</span>(<span class="hljs-params">self, people</span>):</span><br>        self.quickSort(people,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(people)-<span class="hljs-number">1</span>)<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(people)):<br>            <span class="hljs-keyword">if</span> people[i][<span class="hljs-number">1</span>] &gt; i:<br>                output.append(people[i])<br>            output.insert(people[i][<span class="hljs-number">1</span>] ,people[i])<br>        <span class="hljs-keyword">return</span> output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cmp</span> (<span class="hljs-params">self, A, B</span>):</span><br>        <span class="hljs-keyword">if</span> A[<span class="hljs-number">0</span>] &gt; B[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> A[<span class="hljs-number">0</span>] &lt; B[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> A[<span class="hljs-number">1</span>] &gt; B[<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">self, arr, left, right</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span><br>        l = left<br>        r = right<br>        t = arr[l]<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.cmp(arr[r], t):<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &gt;= r: <span class="hljs-keyword">break</span><br>            arr[l] = arr[r]<br>            l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> self.cmp(arr[l], t):<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &gt;= r: <span class="hljs-keyword">break</span><br>            arr[r] = arr[l]<br>            r -= <span class="hljs-number">1</span><br>        arr[l] = t<br>        self.quickSort(arr,left,l-<span class="hljs-number">1</span>)<br>        self.quickSort(arr,l+<span class="hljs-number">1</span>,right)<br></code></pre></td></tr></table></figure><h1 id="8-用最少数量的箭引爆气球"><a href="#8-用最少数量的箭引爆气球" class="headerlink" title="8. 用最少数量的箭引爆气球"></a>8. 用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><p>在二维空间中有许多球形的气球。<br>对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。<br>由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。<br>开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。<br>在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被引爆。<br>可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。<br>我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 <code>points</code> ，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[10,16]</span>,<span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span>,<span class="hljs-comment">[7,12]</span>]</span><br>输出：2<br>解释：对于该样例，x = 6 可以射爆 <span class="hljs-comment">[2,8]</span>,<span class="hljs-comment">[1,6]</span> 两个气球，以及 x = 11 射爆另外两个气球<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[5,6]</span>,<span class="hljs-comment">[7,8]</span>]</span><br>输出：4<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：points = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[4,5]</span>]</span><br>输出：2<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[1,2]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[2,3],[2,3]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 104</code></li><li><code>points[i].length == 2</code></li><li><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></li></ul><p><strong>解:</strong></p><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/image-20211005182117165.png" srcset="/img/loading.gif" alt="image-20211005182117165"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMinArrowShots</span>(<span class="hljs-params">self, points</span>):</span><br>        points.sort(key=<span class="hljs-keyword">lambda</span> x: [x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]])<br>        output = <span class="hljs-number">1</span><br>        rightBolder = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> left, right <span class="hljs-keyword">in</span> points[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> left &lt;= rightBolder: <span class="hljs-comment"># 有交集</span><br>                rightBolder = <span class="hljs-built_in">min</span>(rightBolder,right)<br>            <span class="hljs-keyword">else</span>:<br>                output += <span class="hljs-number">1</span><br>                rightBolder = right<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="9-无重叠区间"><a href="#9-无重叠区间" class="headerlink" title="9. 无重叠区间"></a>9. 无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意:</strong></p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span>, <span class="hljs-comment">[3,4]</span>, <span class="hljs-comment">[1,3]</span> ]</span><br><br>输出: 1<br><br>解释: 移除 <span class="hljs-comment">[1,3]</span> 后，剩下的区间没有重叠。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[1,2]</span> ]</span><br><br>输出: 2<br><br>解释: 你需要移除两个 <span class="hljs-comment">[1,2]</span> 来使剩下的区间没有重叠。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[ <span class="hljs-comment">[1,2]</span>, <span class="hljs-comment">[2,3]</span> ]</span><br><br>输出: 0<br><br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。<br></code></pre></td></tr></table></figure><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eraseOverlapIntervals</span>(<span class="hljs-params">self, intervals</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(intervals) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        intervals.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<br>        rightBolder = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        counter = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> left,right <span class="hljs-keyword">in</span> intervals[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> left &gt;= rightBolder:<br>                counter += <span class="hljs-number">1</span><br>                rightBolder = right<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(intervals) - counter<br></code></pre></td></tr></table></figure><h1 id="10-合并区间"><a href="#10-合并区间" class="headerlink" title="10. 合并区间"></a>10. 合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。<br>请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]<br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span><br>输出：<span class="hljs-string">[[1,5]]</span><br>解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, intervals</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(intervals) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [[]]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(intervals) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> intervals<br>        intervals.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])<br>        output = <span class="hljs-built_in">list</span>()<br>        leftBounder = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        rightBounder = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> left,right <span class="hljs-keyword">in</span> intervals[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> left &gt; rightBounder:<br>                output.append([leftBounder,rightBounder])<br>                leftBounder = left<br>            leftBounder = <span class="hljs-built_in">min</span>(leftBounder,left)<br>            rightBounder = <span class="hljs-built_in">max</span>(rightBounder,right)<br>        output.append([leftBounder,rightBounder])<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="11-划分字母区间"><a href="#11-划分字母区间" class="headerlink" title="11. 划分字母区间"></a>11. 划分字母区间</h1><p><a href="https://leetcode-cn.com/problems/partition-labels/">https://leetcode-cn.com/problems/partition-labels/</a></p><p>字符串 <code>S</code> 由小写字母组成。<br>我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。<br>返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">S</span> = <span class="hljs-string">&quot;ababcbacadefegdehijhklij&quot;</span><br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>解释：<br>划分结果为 <span class="hljs-string">&quot;ababcbaca&quot;</span>, <span class="hljs-string">&quot;defegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span>。<br>每个字母最多出现在一个片段中。<br>像 <span class="hljs-string">&quot;ababcbacadefegde&quot;</span>, <span class="hljs-string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><p><strong>解:</strong></p><p>先获得每个出现字符的区间，再将重合区间合并，最后剩下的区间数就是答案(同第十题合并区间)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionLabels</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> [[<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>]]<br>        charDict = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> charDict.keys():<br>                charDict[s[i]][<span class="hljs-number">1</span>] = i<br>            <span class="hljs-keyword">else</span>:<br>                charDict[s[i]] = [i,i]<br>        charInterval = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> charDict.values():<br>            charInterval.append(key)<br>        charInterval.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])<br>        leftBoundar = charInterval[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        rightBounder = charInterval[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> left,right <span class="hljs-keyword">in</span> charInterval[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-keyword">if</span> left &gt; rightBounder:<br>                output.append(rightBounder - leftBoundar + <span class="hljs-number">1</span>)<br>                leftBoundar = left<br>            rightBounder = <span class="hljs-built_in">max</span>(rightBounder,right)<br>        output.append(rightBounder - leftBoundar + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="12-最大子序和"><a href="#12-最大子序和" class="headerlink" title="12. 最大子序和"></a>12. 最大子序和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-100000</span>]<br>输出：<span class="hljs-string">-100000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>解:</strong></p><ul><li>局部最优：<br>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</li><li>全局最优：<br>选取最大“连续和”</li></ul><p><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums</span>):</span><br>        result = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            count += i<br>            <span class="hljs-keyword">if</span> count &gt; result:<br>                result = count<br>            <span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">0</span>:<br>                count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="13-加油站"><a href="#13-加油站" class="headerlink" title="13. 加油站"></a>13. 加油站</h1><p><a href="https://leetcode-cn.com/problems/gas-station/">https://leetcode-cn.com/problems/gas-station/</a></p><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong> </p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: <br>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]<br><br>输出: 3<br><br>解释:<br>从<span class="hljs-number"> 3 </span>号加油站(索引为<span class="hljs-number"> 3 </span>处)出发，可获得<span class="hljs-number"> 4 </span>升汽油。此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 4 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 8 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 8 </span>-<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 7 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 6 </span>升汽油<br>开往<span class="hljs-number"> 2 </span>号加油站，此时油箱有<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>升汽油<br>开往<span class="hljs-number"> 3 </span>号加油站，你需要消耗<span class="hljs-number"> 5 </span>升汽油，正好足够你返回到<span class="hljs-number"> 3 </span>号加油站。<br>因此，3 可为起始索引。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: <br>gas  = [2,3,4]<br>cost = [3,4,3]<br><br>输出: -1<br><br>解释:<br>你不能从<span class="hljs-number"> 0 </span>号或<span class="hljs-number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从<span class="hljs-number"> 2 </span>号加油站出发，可以获得<span class="hljs-number"> 4 </span>升汽油。 此时油箱有 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 4 </span>升汽油<br>开往<span class="hljs-number"> 0 </span>号加油站，此时油箱有<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 3 </span>升汽油<br>开往<span class="hljs-number"> 1 </span>号加油站，此时油箱有<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>升汽油<br>你无法返回<span class="hljs-number"> 2 </span>号加油站，因为返程需要消耗<span class="hljs-number"> 4 </span>升汽油，但是你的油箱只有<span class="hljs-number"> 3 </span>升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canCompleteCircuit</span>(<span class="hljs-params">self, gas, cost</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(gas) &lt; <span class="hljs-built_in">sum</span>(cost):<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        start = <span class="hljs-number">0</span><br>        curSum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gas)):<br>            curSum += gas[i] - cost[i]<br>            <span class="hljs-keyword">if</span> curSum &lt; <span class="hljs-number">0</span>:<br>                curSum = <span class="hljs-number">0</span><br>                start = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> start<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-堆</title>
    <link href="/2021/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
    <url>/2021/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-堆的简介"><a href="#1-堆的简介" class="headerlink" title="1. 堆的简介"></a>1. 堆的简介</h1><p><strong>堆的常用方法：</strong></p><ul><li>构建优先队列</li><li>支持堆排序<br><a href="https://mycroftcooper.github.io/2021/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">堆排序</a></li><li>快速找出一个集合中的最小值（或者最大值）</li></ul><p><strong>堆分为两种：</strong></p><ul><li>最大堆(大顶堆)<br>父节点的值比每一个子节点的值都要大<br>根节点总是最大值<br>可以用于降序排序</li><li>最小堆(小顶堆)<br>父节点的值比每一个子节点的值都要小<br>根节点总是最小值<br>可用于升序排序</li></ul><p>例子：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002013943710.png" srcset="/img/loading.gif" alt="image-20211002013943710"></p><p>这是一个最大堆，，因为每一个父节点的值都比其子节点要大。<code>10</code> 比 <code>7</code> 和 <code>2</code> 都大。<code>7</code> 比 <code>5</code> 和 <code>1</code>都大。</p><blockquote><p><strong>注意：</strong><br>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。<br>在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。<br>唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p></blockquote><h1 id="2-堆和树的区别"><a href="#2-堆和树的区别" class="headerlink" title="2. 堆和树的区别"></a>2. 堆和树的区别</h1><p>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。<br>我们来看一下两者的主要差别：</p><ul><li><p><strong>节点的顺序</strong></p><ul><li><p>二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。</p></li><li><p>在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p></li></ul></li><li><p><strong>内存占用</strong></p><ul><li>普通树占用的内存空间比它们存储的数据要多，必须为节点对象以及左/右子节点指针分配内存。</li><li>堆仅仅使用一个数据来存储数组，且不使用指针。</li></ul></li><li><p><strong>平衡</strong></p><ul><li>二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到**O(log n)**。</li><li>堆实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。<br>因为堆中数据的组织方式可以保证<strong>O(log n)</strong> 的性能。</li></ul></li><li><p><strong>搜索</strong></p><ul><li>在二叉树中搜索会很快</li><li>但是在堆中搜索会很慢<br>在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</li></ul></li></ul><h1 id="3-堆的存储-数组"><a href="#3-堆的存储-数组" class="headerlink" title="3. 堆的存储(数组)"></a>3. 堆的存储(数组)</h1><p>用数组来实现树相关的数据结构也许看起来有点古怪，但是它在时间和空间上都是很高效的。</p><p>我们准备将上面例子中的树这样存储：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[ <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span> ]<br></code></pre></td></tr></table></figure><p>就这么多！我们除了一个简单的数组以外，不需要任何额外的空间。</p><h2 id="3-1-索引公式"><a href="#3-1-索引公式" class="headerlink" title="3.1 索引公式"></a>3.1 索引公式</h2><p>节点在数组中的位置index 和它的父节点以及子节点的索引之间有一个映射关系。<br>如果 <code>i</code> 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：</p><p><strong>基础公式：</strong></p><ul><li>parent(i) = (i - 1) // 2</li><li>left(i)   = 2i + 1</li><li>right(i)  = 2i + 2</li></ul><blockquote><p><strong>使用公式时需要注意：</strong></p><ul><li><code>right(i)</code> 就是简单的 <code>left(i) + 1</code><br>左右节点总是处于相邻的位置。</li><li>根节点<code>(10)</code>没有父节点，因为 <code>-1</code> 不是一个有效的数组索引。<br>同样，节点 <code>(2)</code>，<code>(5)</code>和<code>(1)</code> 没有子节点，因为这些索引已经超过了数组的大小<br>所以我们在使用这些索引值的时候需要保证是有效的索引值。</li></ul></blockquote><p>这些公式允许我们不使用指针就可以找到任何一个节点的父节点或者子节点。</p><h2 id="3-2-节点数公式"><a href="#3-2-节点数公式" class="headerlink" title="3.2 节点数公式"></a>3.2 节点数公式</h2><p>理解数组索引和节点位置之间的关系非常重要。<br>这里有一个更大的堆，它有15个节点被分成了4层：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002013923396.png" srcset="/img/loading.gif" alt="image-20211002013923396"></p><p>由上图可以看到，数组中父节点总是在子节点的前面。</p><p><strong>公式:</strong></p><ul><li><strong>如果一个堆有 n 个节点，那么它的高度是</strong> </li></ul><p>​                        <img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002160854520.png" srcset="/img/loading.gif" alt="image-20211002160854520"></p><p>这是因为我们总是要将这一层完全填满以后才会填充新的一层。<br>上面的例子有 15 个节点，所以它的高度是 <code>floor(log2(15)) = floor(3.91) = 3</code>。</p><p>如果最下面的一层已经填满，那么那一层包含 <em>2^h</em> 个节点。</p><ul><li><p><strong>树中这一层以上所有的节点数目为</strong> </p><p>​    <img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002160918051.png" srcset="/img/loading.gif" alt="image-20211002160918051"></p></li></ul><p>同样是上面这个例子，最下面的一层有8个节点，实际上就是 <code>2^3 = 8</code>。<br>前面的三层一共包含7的节点，即：<code>2^3 - 1 = 8 - 1 = 7</code>。</p><ul><li><p><strong>所以整个堆中的节点数目为：</strong></p><p>​        <img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002160929502.png" srcset="/img/loading.gif" alt="image-20211002160929502"></p></li></ul><p>上面的例子中，<code>2^4 - 1 = 16 - 1 = 15</code></p><p><strong>叶节点总是位于数组的 <em>n//2</em> 和 <em>n-1</em> 之间</strong></p><p><strong>注意：</strong><br>你可以在普通二叉树中按照下面的方式组织数据，但是在堆中不可以：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014009799.png" srcset="/img/loading.gif" alt="image-20211002014009799"></p><p>在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014025394.png" srcset="/img/loading.gif" alt="image-20211002014025394"></p><blockquote><p><strong>注意：</strong></p><ul><li>你可以使用普通树来模拟堆，但是那对空间是极大的浪费。</li><li>并不是每一个堆都是一个有序数组！要将堆转换成有序数组，需要使用堆排序。</li></ul></blockquote><h1 id="4-堆的常用操作"><a href="#4-堆的常用操作" class="headerlink" title="4. 堆的常用操作"></a>4. 堆的常用操作</h1><p>有两个原始操作用于保证插入或删除节点以后堆是一个有效的最大堆或者最小堆：</p><ul><li><code>shiftUp()</code>:<br>如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。<br>这样是这个节点在数组的位置上升。</li><li><code>shiftDown()</code>:<br>如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。<br>这个操作也称作“堆化（heapify）”。</li></ul><p>shiftUp 或者 shiftDown 是一个递归的过程，所以它的时间复杂度是 **O(log n)**。</p><p>基于这两个原始操作还有一些其他的操作：</p><ul><li><p><code>peek()</code> ：<br>不用删除节点就返回最大值（最大堆）或者最小值（最小堆）。<br>时间复杂度 <strong>O(1)</strong> 。</p></li><li><p><code>insert(value)</code>:<br>在堆的尾部添加一个新的元素，然后使用 <code>shiftUp</code> 来修复对。</p></li><li><p><code>remove()</code>:<br>移除并返回最大值（最大堆）或者最小值（最小堆）。<br>为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，然后使用 <code>shiftDown</code> 方法来修复堆。</p></li><li><p><code>removeAtIndex(index)</code>:<br>和 <code>remove()</code> 一样，差别在于可以移除堆中任意节点，而不仅仅是根节点。<br>当它与子节点比较位置不时无序时使用 <code>shiftDown()</code>，如果与父节点比较发现无序则使用 <code>shiftUp()</code>。</p></li><li><p><code>replace(index, value)</code>：<br>将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点。<br>由于这个操作破坏了堆属性，所以需要使用 <code>shiftUp()</code> 来修复堆属性。</p></li></ul><p>上面所有的操作的时间复杂度都是 **O(log n)**，因为 shiftUp 和 shiftDown 都很费时。</p><p>还有少数一些操作需要更多的时间：</p><ul><li><code>search(value)</code>:<br>堆不是为快速搜索而建立的，但是 <code>replace()</code> 和 <code>removeAtIndex()</code> 操作需要找到节点在数组中的index，所以你需要先找到这个index。<br>时间复杂度：**O(n)**。</li><li><code>buildHeap(array)</code>:<br>通过反复调用 <code>insert()</code> 方法将一个（无序）数组转换成一个堆。<br>如果你足够聪明，你可以在 <strong>O(n)</strong> 时间内完成。</li><li>堆排序：<br>由于堆就是一个数组，我们可以使用它独特的属性将数组从低到高排序。<br>时间复杂度：**O(n lg n)**。</li></ul><blockquote><p><strong>注意：</strong><br>到目前为止，堆的常用操作还是使用 <code>insert()</code> 插入一个新的元素，和通过 <code>remove()</code>移除最大或者最小值。<br>两者的时间复杂度都是**O(log n)**。<br>其其他的操作是用于支持更高级的应用，比如说建立一个优先队列。</p></blockquote><h2 id="4-1-插入"><a href="#4-1-插入" class="headerlink" title="4.1 插入"></a>4.1 插入</h2><p>我们通过一个插入例子来看看插入操作的细节。<br>我们将数字 <code>16</code> 插入到这个堆中：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014040987.png" srcset="/img/loading.gif" alt="image-20211002014040987"></p><p>堆的数组是： <code>[ 10, 7, 2, 5, 1 ]</code>。</p><p>第一股是将新的元素插入到数组的尾部。<br>数组变成：<code>[ 10, 7, 2, 5, 1, 16 ]</code></p><p>相应的树变成了：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014105489.png" srcset="/img/loading.gif" alt="image-20211002014105489"></p><p><code>16</code> 被添加最后一行的第一个空位。</p><p>不行的是，现在堆属性不满足，因为 <code>2</code> 在 <code>16</code> 的上面，我们需要将大的数字在上面（这是一个最大堆）<br>为了恢复堆属性，我们需要交换 <code>16</code> 和 <code>2</code>。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014115401.png" srcset="/img/loading.gif" alt="image-20211002014115401"></p><p>现在还没有完成，因为 <code>10</code> 也比 <code>16</code> 小。<br>我们继续交换我们的插入元素和它的父节点，直到它的父节点比它大或者我们到达树的顶部。<br>这就是所谓的 <strong>shift-up</strong>，每一次插入操作后都需要进行。<br>它将一个太大或者太小的数字“浮起”到树的顶部。</p><p>最后我们得到的堆：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014125610.png" srcset="/img/loading.gif" alt="image-20211002014125610"></p><p>现在每一个父节点都比它的子节点大。</p><h2 id="4-2-删除根节点"><a href="#4-2-删除根节点" class="headerlink" title="4.2 删除根节点"></a>4.2 删除根节点</h2><p>我们将这个树中的 <code>(10)</code> 删除：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014040987.png" srcset="/img/loading.gif" alt="image-20211002014040987"></p><p>现在顶部有一个空的节点，怎么处理？</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014148719.png" srcset="/img/loading.gif" alt="image-20211002014148719"></p><p>当插入节点的时候，我们将新的值返给数组的尾部。现在我们来做相反的事情：我们取出数组中的最后一个元素，将它放到树的顶部，然后再修复堆属性。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014158542.png" srcset="/img/loading.gif" alt="image-20211002014158542"></p><p>现在来看怎么 <strong>shift-down</strong> <code>(1)</code>。为了保持最大堆的堆属性，我们需要树的顶部是最大的数据。现在有两个数字可用于交换 <code>7</code> 和 <code>2</code>。我们选择这两者中的较大者称为最大值放在树的顶部，所以交换 <code>7</code> 和 <code>1</code>，现在树变成了：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014205304.png" srcset="/img/loading.gif" alt="image-20211002014205304"></p><p>继续堆化直到该节点没有任何子节点或者它比两个子节点都要大为止。对于我们的堆，我们只需要再有一次交换就恢复了堆属性：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014212991.png" srcset="/img/loading.gif" alt="image-20211002014212991"></p><h2 id="4-3-删除任意节点"><a href="#4-3-删除任意节点" class="headerlink" title="4.3 删除任意节点"></a>4.3 删除任意节点</h2><p>绝大多数时候你需要删除的是堆的根节点，因为这就是堆的设计用途。<br>但是，删除任意节点也很有用。</p><p>这是 <code>remove()</code> 的通用版本，它可能会使用到 <code>shiftDown</code> 和 <code>shiftUp</code>。</p><p>我们还是用前面的例子，删除 <code>(7)</code>:</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014040987.png" srcset="/img/loading.gif" alt="image-20211002014040987"></p><p>对应的数组是：<code>[ 10, 7, 2, 5, 1 ]</code></p><p>移除一个元素会破坏最大堆或者最小堆属性，我们需要将删除的元素和最后一个元素交换：<br><code>[ 10, 1, 2, 5, 7 ]</code></p><p>最后一个元素就是我们需要返回的元素；然后调用 <code>removeLast()</code> 来将它删除。<br> <code>(1)</code> 比它的子节点小，所以需要 <code>shiftDown()</code> 来修复。</p><p>然而，shift down 不是我们要处理的唯一情况。也有可能我们需要 shift up。考虑一下从下面的堆中删除 <code>(5)</code> 会发生什么：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/image-20211002014236057.png" srcset="/img/loading.gif" alt="image-20211002014236057"></p><h1 id="5-代码实现堆"><a href="#5-代码实现堆" class="headerlink" title="5. 代码实现堆"></a>5. 代码实现堆</h1><p>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,isBigTop</span>):</span><br>        self.heapList = <span class="hljs-built_in">list</span>()<br>        self.isBigTop = isBigTop<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTop</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.heapList) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> self.heapList[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__swap</span>(<span class="hljs-params">self,index1,index2</span>):</span><br>        t = self.heapList[index1]<br>        self.heapList[index1] = self.heapList[index2]<br>        self.heapList[index2] = t<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__shitfUp</span>(<span class="hljs-params">self,index</span>):</span><br>        <span class="hljs-keyword">while</span> index &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> (self.heapList[(index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>] &lt; self.heapList[index] <span class="hljs-keyword">and</span> self.isBigTop)\<br>                <span class="hljs-keyword">or</span>\<br>                (self.heapList[(index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>] &gt; self.heapList[index] <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self.isBigTop):<br>                self.__swap((index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span>,index)<br>                index = (index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__shiftDown</span>(<span class="hljs-params">self,index</span>):</span><br>        <span class="hljs-keyword">if</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">len</span>(self.heapList):<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> self.isBigTop:<br>            <span class="hljs-keyword">while</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(self.heapList):<br>                <span class="hljs-keyword">if</span> self.heapList[index] &lt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span>\<br>                   self.heapList[index] &lt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]:<br>                    <span class="hljs-keyword">if</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span> &gt;= <span class="hljs-built_in">len</span>(self.heapList) <span class="hljs-keyword">or</span> \<br>                       self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] &gt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]:<br>                        self.__swap(index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,index)<br>                        index = index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        self.__swap(index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,index)<br>                        index = index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">while</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(self.heapList):<br>                <span class="hljs-keyword">if</span> self.heapList[index] &gt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] <span class="hljs-keyword">or</span>\<br>                   self.heapList[index] &gt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]:<br>                    <span class="hljs-keyword">if</span> index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span> &gt;= <span class="hljs-built_in">len</span>(self.heapList) <span class="hljs-keyword">or</span>\<br>                       self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] &lt; self.heapList[index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>]:<br>                        self.__swap(index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,index)<br>                        index = index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        self.__swap(index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>,index)<br>                        index = index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>: <span class="hljs-keyword">break</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, num</span>):</span><br>        self.heapList.append(num)<br>        self.__shitfUp(<span class="hljs-built_in">len</span>(self.heapList) - <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self, index</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.heapList) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> index &gt; <span class="hljs-built_in">len</span>(self.heapList)-<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(self.heapList)-<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> self.heapList.pop()<br>        self.__swap(index,<span class="hljs-built_in">len</span>(self.heapList) - <span class="hljs-number">1</span>)<br>        output = self.heapList.pop()<br>        <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span>:<br>            self.__shiftDown(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">else</span>:<br>            pIndex = (index-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>            lIndex = <span class="hljs-number">2</span>*index+<span class="hljs-number">1</span><br>            rIndex = lIndex + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> pIndex &gt;= <span class="hljs-number">0</span>:<br>                self.__shitfUp(index)<br>            <span class="hljs-keyword">if</span> lIndex &lt; <span class="hljs-built_in">len</span>(self.heapList) <span class="hljs-keyword">or</span> rIndex &lt; <span class="hljs-built_in">len</span>(self.heapList):<br>                self.__shiftDown(index)<br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    numList = [ <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span> ]<br>    h = Heap(<span class="hljs-literal">True</span>)<br>    h.heapList = numList<br>    h.push(<span class="hljs-number">10</span>)<br>    print(h.heapList)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2021/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h1><h2 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h2><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li></ul><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20190306165258970-1789860540.png" srcset="/img/loading.gif" alt="img"></p><h2 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h2><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20180402133438219-1946132192.png" srcset="/img/loading.gif" alt="img"></p><h2 id="0-3-相关概念"><a href="#0-3-相关概念" class="headerlink" title="0.3 相关概念"></a>0.3 相关概念</h2><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机</li></ul><p>内执行时所需存储空间的度量，它也是数据规模n的函数。 </p><h1 id="1-快速排序（Quick-Sort）"><a href="#1-快速排序（Quick-Sort）" class="headerlink" title="1. 快速排序（Quick Sort）"></a>1. 快速排序（Quick Sort）</h1><h2 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h2 id="1-2-动图演示"><a href="#1-2-动图演示" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h2><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20171015230936371-1413523412.gif" srcset="/img/loading.gif" alt="快速排序img"></p><h2 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr,left,right</span>):</span><br>    <span class="hljs-keyword">if</span> left &gt;= right:<br>        <span class="hljs-keyword">return</span><br>    l = left<br>    r = right<br>    t = arr[l]<br>    <span class="hljs-keyword">while</span> l &lt; r:<br>        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> arr[r] &gt; t:<br>            r -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> l &lt; r:<br>            arr[l] = arr[r]<br>            l += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> arr[l] &lt; t:<br>            l += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> l &lt; r:<br>            arr[r] = arr[l]<br>            r -= <span class="hljs-number">1</span><br>    arr[l] = t<br>    quickSort(arr,left,l-<span class="hljs-number">1</span>)<br>    quickSort(arr,l+<span class="hljs-number">1</span>,right)<br></code></pre></td></tr></table></figure><h2 id="1-4-相关题型"><a href="#1-4-相关题型" class="headerlink" title="1.4 相关题型"></a>1.4 相关题型</h2><p><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></p><h1 id="2-归并排序（Merge-Sort）"><a href="#2-归并排序（Merge-Sort）" class="headerlink" title="2. 归并排序（Merge Sort）"></a>2. 归并排序（Merge Sort）</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。</p><p>该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>将已有序的子序列合并，得到完全有序的序列；<br>即先使每个子序列有序，再使子序列段间有序。<br>若将两个有序表合并成一个有序表，称为2-路归并。 </p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p>归并排序是一种稳定的排序方法。<br>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。</p><p>代价是需要额外的内存空间。</p><h2 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a>2.2 动图演示</h2><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20171015230557043-37375010.gif" srcset="/img/loading.gif" alt="归并排序img"></p><h2 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>):</span><br>    <span class="hljs-comment"># 递归划分</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> arr<br>    mid = <span class="hljs-built_in">len</span>(arr)//<span class="hljs-number">2</span><br>    leftArr = mergeSort(arr[:mid])<br>    rightArr = mergeSort(arr[mid:])<br><br>    <span class="hljs-comment"># 回溯治理</span><br>    mergeArr = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(leftArr) != <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(rightArr) != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(leftArr) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(rightArr) != <span class="hljs-number">0</span>:<br>                mergeArr.append(rightArr.pop(<span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rightArr) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(leftArr) != <span class="hljs-number">0</span>:<br>                mergeArr.append(leftArr.pop(<span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> rightArr[<span class="hljs-number">0</span>] &gt; leftArr[<span class="hljs-number">0</span>]:<br>            mergeArr.append(rightArr.pop(<span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">else</span>:<br>            mergeArr.append(leftArr.pop(<span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> mergeArr<br></code></pre></td></tr></table></figure><h2 id="2-4-相关题型"><a href="#2-4-相关题型" class="headerlink" title="2.4 相关题型"></a>2.4 相关题型</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></p><h1 id="3-堆排序（Heap-Sort）"><a href="#3-堆排序（Heap-Sort）" class="headerlink" title="3. 堆排序（Heap Sort）"></a>3. 堆排序（Heap Sort）</h1><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p><p>关于堆的介绍请看：<br><a href="">数据结构-堆</a></p><p>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：<br>即子结点的键值或索引总是小于（或者大于）它的父节点。</p><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h2 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h2><p><img src="/images/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20171015231308699-356134237.gif" srcset="/img/loading.gif" alt="堆排序img"></p><h2 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap</span>(<span class="hljs-params">nums, indexA, indexB</span>):</span><br>    t = nums[indexA]<br>    nums[indexA] = nums[indexB]<br>    nums[indexB] = t<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildBigTopHeap</span>(<span class="hljs-params">nums</span>):</span><br>    index = (<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(index,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        shiftDown(nums,i,<span class="hljs-built_in">len</span>(nums))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shiftDown</span>(<span class="hljs-params">nums,index,lenth</span>):</span><br>    leftP = index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span><br>    rightP = leftP+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> leftP &gt;= lenth:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> rightP &gt;= lenth:<br>        maxNum = nums[leftP]<br>    <span class="hljs-keyword">else</span>:<br>        maxNum = <span class="hljs-built_in">max</span>(nums[leftP], nums[rightP])<br>    <span class="hljs-keyword">if</span> nums[index] &lt; maxNum:<br>        <span class="hljs-keyword">if</span> maxNum == nums[leftP]:<br>            swap(nums,index,leftP)<br>            shiftDown(nums,leftP,lenth)<br>        <span class="hljs-keyword">else</span>:<br>            swap(nums,index,rightP)<br>            shiftDown(nums,rightP,lenth)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">incHeapSort</span>(<span class="hljs-params">nums</span>):</span><br>    buildBigTopHeap(nums)<br>    lenth = <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">while</span> lenth &gt; <span class="hljs-number">1</span>:<br>        lenth -= <span class="hljs-number">1</span><br>        swap(nums,<span class="hljs-number">0</span>,lenth)<br>        shiftDown(nums,<span class="hljs-number">0</span>,lenth)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    nums = [<span class="hljs-number">16</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">20</span>,<span class="hljs-number">17</span>,<span class="hljs-number">8</span>]<br>    incHeapSort(nums)<br>    print(nums)<br></code></pre></td></tr></table></figure><h2 id="3-4-相关题型"><a href="#3-4-相关题型" class="headerlink" title="3.4 相关题型"></a>3.4 相关题型</h2><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer 41. 数据流中的中位数</a></p>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/09/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2021/09/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="0-动态规划理论基础"><a href="#0-动态规划理论基础" class="headerlink" title="0. 动态规划理论基础"></a>0. 动态规划理论基础</h1><h2 id="0-1-动态规划理论入门"><a href="#0-1-动态规划理论入门" class="headerlink" title="0.1 动态规划理论入门"></a>0.1 动态规划理论入门</h2><p><strong>定义:</strong><br>动态规划，英文：Dynamic Programming，简称DP。<br>如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p><strong>与贪心算法的区别:</strong></p><ul><li>动态规划:<br>每一个状态一定是由上一个状态推导出来的</li><li>贪心算法:<br>没有状态推导，从局部直接选最优的</li></ul><p>例如：<br>有N件物品和一个最多能背重量为W 的背包。<br>第i件物品的重量是weight[i]，得到的价值是value[i] 。<br><strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p><p>所以贪心解决不了动态规划的问题。</p><h2 id="0-2-动态规划的解题步骤"><a href="#0-2-动态规划的解题步骤" class="headerlink" title="0.2 动态规划的解题步骤"></a>0.2 动态规划的解题步骤</h2><p><strong>分为以下五步：</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="0-3-题目目录"><a href="#0-3-题目目录" class="headerlink" title="0.3 题目目录"></a>0.3 题目目录</h2><h3 id="0-3-1-一维动态规划"><a href="#0-3-1-一维动态规划" class="headerlink" title="0.3.1 一维动态规划"></a>0.3.1 一维动态规划</h3><ul><li>[斐波那契数列](# 1. 斐波那契数列)</li><li>[泰波那契数列](# 2. 泰波那契数列)</li><li>[爬楼梯 I](# 3. 爬楼梯 I)</li><li>[爬楼梯 II](# 4. 爬楼梯 II)</li><li>[跳跃问题 I](# 5. 跳跃问题 I)</li><li>[跳跃问题 II](# 6. 跳跃问题 II)</li><li><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍 I</a></li><li><a href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></li><li><a href="https://leetcode-cn.com/problems/delete-and-earn/">删除并获得点数</a></li><li><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">最佳观光组合</a></li></ul><h3 id="0-3-2-二维动态规划"><a href="#0-3-2-二维动态规划" class="headerlink" title="0.3.2 二维动态规划"></a>0.3.2 二维动态规划</h3><ul><li><a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a></li><li><a href="">下降路径最小和</a></li><li><a href="">不同路径 I</a></li><li><a href="">不同路径 II</a></li><li><a href="">杨辉三角</a></li><li><a href="">三角形最小路径和</a></li><li><a href="">摆动序列和</a></li></ul><h3 id="0-3-3-子序列问题"><a href="#0-3-3-子序列问题" class="headerlink" title="0.3.3 子序列问题"></a>0.3.3 子序列问题</h3><h3 id="0-3-4-回文串与编辑问题"><a href="#0-3-4-回文串与编辑问题" class="headerlink" title="0.3.4 回文串与编辑问题"></a>0.3.4 回文串与编辑问题</h3><h3 id="0-3-5-股票问题"><a href="#0-3-5-股票问题" class="headerlink" title="0.3.5 股票问题"></a>0.3.5 股票问题</h3><h3 id="0-3-6-背包问题"><a href="#0-3-6-背包问题" class="headerlink" title="0.3.6 背包问题"></a>0.3.6 背包问题</h3><h3 id="0-3-7-前缀和问题"><a href="#0-3-7-前缀和问题" class="headerlink" title="0.3.7 前缀和问题"></a>0.3.7 前缀和问题</h3><ul><li><p><a href="https://leetcode-cn.com/problems/matrix-block-sum/">1314. 矩阵区域和</a></p></li><li><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></p></li><li><p><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a></p></li></ul><h3 id="0-3-8-复合问题"><a href="#0-3-8-复合问题" class="headerlink" title="0.3.8 复合问题"></a>0.3.8 复合问题</h3><h1 id="1-一维动态规划"><a href="#1-一维动态规划" class="headerlink" title="1. 一维动态规划"></a>1. 一维动态规划</h1><h2 id="1-1-斐波那契数列"><a href="#1-1-斐波那契数列" class="headerlink" title="1.1 斐波那契数列"></a>1.1 斐波那契数列</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">https://leetcode-cn.com/problems/fibonacci-number/</a></p><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。<br>该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。<br>也就是：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">F(0)</span> = <span class="hljs-number">0</span>，<span class="hljs-constructor">F(1)</span> = <span class="hljs-number">1</span><br><span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span> = <span class="hljs-constructor">F(<span class="hljs-params">n</span> - 1)</span> + <span class="hljs-constructor">F(<span class="hljs-params">n</span> - 2)</span>，其中 n &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br>解释：F<span class="hljs-comment">(2)</span> = F<span class="hljs-comment">(1)</span> + F<span class="hljs-comment">(0)</span> = <span class="hljs-number">1</span> + <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span><br>解释：F<span class="hljs-comment">(3)</span> = F<span class="hljs-comment">(2)</span> + F<span class="hljs-comment">(1)</span> = <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h2 id="1-2-泰波那契数列"><a href="#1-2-泰波那契数列" class="headerlink" title="1.2 泰波那契数列"></a>1.2 泰波那契数列</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">https://leetcode-cn.com/problems/n-th-tribonacci-number/</a></p><p>泰波那契序列 Tn 定义如下： </p><p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4<br>输出：4<br>解释：<br>T_3 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 2<br>T_4 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>= 4<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">25</span><br>输出：<span class="hljs-number">1389537</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 37</code></li><li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tribonacci</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*(n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>,n+<span class="hljs-number">1</span>):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>] + dp[i-<span class="hljs-number">3</span>]<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h2 id="1-3-爬楼梯-I"><a href="#1-3-爬楼梯-I" class="headerlink" title="1.3 爬楼梯 I"></a>1.3 爬楼梯 I</h2><p><strong>描述：</strong><br>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><blockquote><p><strong>注意：</strong><br>给定 <em>n</em> 是一个正整数。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h2 id="1-4-爬楼梯-II"><a href="#1-4-爬楼梯-II" class="headerlink" title="1.4 爬楼梯 II"></a>1.4 爬楼梯 II</h2><p><strong>描述：</strong></p><p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>（下标从 <code>0</code> 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[10, 15, 20]</span><br>输出：15<br>解释：最低花费是从 cost<span class="hljs-comment">[1]</span> 开始，然后走两步即可到阶梯顶，一共花费 15 。<br></code></pre></td></tr></table></figure><p> <strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：cost = <span class="hljs-comment">[1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br>输出：6<br>解释：最低花费方式是从 cost<span class="hljs-comment">[0]</span> 开始，逐个经过那些 1 ，跳过 cost<span class="hljs-comment">[3]</span> ，一共花费 6 。<br></code></pre></td></tr></table></figure><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p><p><strong>提示：</strong></p><ul><li><code>cost</code> 的长度范围是 <code>[2, 1000]</code>。</li><li><code>cost[i]</code> 将会是一个整型数据，范围为 <code>[0, 999]</code> 。</li></ul><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minCostClimbingStairs</span>(<span class="hljs-params">self, cost</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cost) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> cost[-<span class="hljs-number">1</span>]<br>        cost.append(<span class="hljs-number">0</span>)<br>        dp = [<span class="hljs-number">0</span>]*(<span class="hljs-built_in">len</span>(cost))<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(dp)):<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1-5-跳跃游戏-I"><a href="#1-5-跳跃游戏-I" class="headerlink" title="1.5 跳跃游戏 I"></a>1.5 跳跃游戏 I</h2><p><strong>描述：</strong></p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳<span class="hljs-number"> 1 </span>步，从下标<span class="hljs-number"> 0 </span>到达下标 1, 然后再从下标<span class="hljs-number"> 1 </span>跳<span class="hljs-number"> 3 </span>步到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：无论怎样，总会到达下标为 <span class="hljs-number">3</span> 的位置。但该下标的最大跳跃长度是 <span class="hljs-number">0</span> ， 所以永远不可能到达最后一个下标。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canJump</span>(<span class="hljs-params">self, nums</span>) -&gt; bool:</span><br>        dp = [<span class="hljs-literal">False</span>]*<span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> dp[i-<span class="hljs-number">1</span>] == <span class="hljs-literal">False</span>:<br>                dp[i] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> nums[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>                    <span class="hljs-keyword">if</span> nums[j] &gt;= i - j:<br>                        dp[i] = <span class="hljs-literal">True</span><br>                        print(j,i)<br>                        <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                dp[i] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1-6-跳跃游戏-II"><a href="#1-6-跳跃游戏-II" class="headerlink" title="1.6 跳跃游戏 II"></a>1.6 跳跃游戏 II</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为<span class="hljs-number"> 0 </span>跳到下标为<span class="hljs-number"> 1 </span>的位置，跳<span class="hljs-number"> 1 </span>步，然后跳<span class="hljs-number"> 3 </span>步到达数组的最后一个位置。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,0,1,4]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">https://leetcode-cn.com/problems/jump-game-ii/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpByGreedy</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        p = <span class="hljs-number">0</span><br>        q = nums[p]<br>        <span class="hljs-keyword">if</span> p + q &gt;= <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        counter = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> p + q &lt; <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>:<br>            t = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p+<span class="hljs-number">1</span>,p+q+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[i] + i &gt;= t:<br>                    t = nums[i] + i<br>                    p = i<br>            q = nums[p]<br>            counter += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>  p + q &gt; <span class="hljs-built_in">len</span>(nums):<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> counter+<span class="hljs-number">1</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpByDP</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)))<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            t = nums[i-<span class="hljs-number">1</span>] + i-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>                dp[-<span class="hljs-number">1</span>] = dp[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,t+<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,dp[j])<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.jumpByDP([<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h2 id="1-7-打家劫舍I"><a href="#1-7-打家劫舍I" class="headerlink" title="1.7 打家劫舍I"></a>1.7 打家劫舍I</h2><p><strong>描述:</strong><br>你是一个专业的小偷，计划偷窃沿街的房屋。<br>每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpByGreedy</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        p = <span class="hljs-number">0</span><br>        q = nums[p]<br>        <span class="hljs-keyword">if</span> p + q &gt;= <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        counter = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> p + q &lt; <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>:<br>            t = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p+<span class="hljs-number">1</span>,p+q+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[i] + i &gt;= t:<br>                    t = nums[i] + i<br>                    p = i<br>            q = nums[p]<br>            counter += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>  p + q &gt; <span class="hljs-built_in">len</span>(nums):<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> counter+<span class="hljs-number">1</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jumpByDP</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)))<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            t = nums[i-<span class="hljs-number">1</span>] + i-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> t &gt;= <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>:<br>                dp[-<span class="hljs-number">1</span>] = dp[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,t+<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,dp[j])<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.jumpByDP([<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]))<br></code></pre></td></tr></table></figure><h2 id="1-8-打家劫舍II"><a href="#1-8-打家劫舍II" class="headerlink" title="1.8  打家劫舍II"></a>1.8  打家劫舍II</h2><p><strong>描述：</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。<br>这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。<br>同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 2），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 2）, 因为他们是相邻的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 3）。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/house-robber-ii/">https://leetcode-cn.com/problems/house-robber-ii/</a></p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span>(<span class="hljs-params">self, nums</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])<br>        a1 = self.fdp(nums[<span class="hljs-number">1</span>:])<br>        a2 = self.fdp(nums[:<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a1, a2)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fdp</span>(<span class="hljs-params">self, nums</span>):</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>((dp[i-<span class="hljs-number">2</span>]+nums[i]), dp[i-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1-9-删除并获得点数"><a href="#1-9-删除并获得点数" class="headerlink" title="1.9 删除并获得点数"></a>1.9 删除并获得点数</h2><p><a href="https://leetcode-cn.com/problems/delete-and-earn/">https://leetcode-cn.com/problems/delete-and-earn/</a></p><p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p><p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,4,2]<br>输出：6<br>解释：<br>删除<span class="hljs-number"> 4 </span>获得<span class="hljs-number"> 4 </span>个点数，因此<span class="hljs-number"> 3 </span>也被删除。<br>之后，删除<span class="hljs-number"> 2 </span>获得<span class="hljs-number"> 2 </span>个点数。总共获得<span class="hljs-number"> 6 </span>个点数。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数，接着要删除两个<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>。<br>之后，再次删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数，再次删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数。<br>总共获得<span class="hljs-number"> 9 </span>个点数。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteAndEarn</span>(<span class="hljs-params">self, nums</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br><br>        maxNum = self.getMaxNum(nums)<br>        numsList = [<span class="hljs-number">0</span>]*(maxNum+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            numsList[i] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.fdp(numsList)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMaxNum</span>(<span class="hljs-params">self, arr</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>]<br>        t = arr[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>            <span class="hljs-keyword">if</span> i &gt; t:<br>                t = i<br>        <span class="hljs-keyword">return</span> t<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fdp</span>(<span class="hljs-params">self, arr</span>):</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(arr)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = arr[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(arr)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], (dp[i-<span class="hljs-number">2</span>]+i * arr[i]))<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="1-10-最佳观光组合"><a href="#1-10-最佳观光组合" class="headerlink" title="1.10 最佳观光组合"></a>1.10 最佳观光组合</h2><p><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">https://leetcode-cn.com/problems/best-sightseeing-pair/</a></p><p>给你一个正整数数组 <code>values</code>，其中 <code>values[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>j - i</code>。</p><p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为 <code>values[i] + values[j] + i - j</code> ，也就是景点的评分之和 <strong>减去</strong> 它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：values = <span class="hljs-selector-attr">[8,1,5,2,6]</span><br>输出：<span class="hljs-number">11</span><br>解释：<span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>, j = <span class="hljs-number">2</span>, values<span class="hljs-selector-attr">[i]</span> + values<span class="hljs-selector-attr">[j]</span> + <span class="hljs-selector-tag">i</span> - j = <span class="hljs-number">8</span> + <span class="hljs-number">5</span> + <span class="hljs-number">0</span> - <span class="hljs-number">2</span> = <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：values </span>=<span class="hljs-string"> [1,2]</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= values.length &lt;= 5 * 104</code></li><li><code>1 &lt;= values[i] &lt;= 1000</code></li></ul><p>解:<br>动态规划和贪心算法都可解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># https://leetcode-cn.com/problems/best-sightseeing-pair/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxScoreSightseeingPairByDP</span>(<span class="hljs-params">self, values</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> values[<span class="hljs-number">0</span>] + values[<span class="hljs-number">1</span>] -<span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>] *<span class="hljs-built_in">len</span>(values)<br>        dp[<span class="hljs-number">0</span>] = values[<span class="hljs-number">0</span>]<br>        maxValue = dp[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(values)):<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, dp[i-<span class="hljs-number">1</span>]+values[i]-i)<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>],values[i]+i)<br>        <span class="hljs-keyword">return</span> maxValue<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxScoreSightseeingPairByGreedy</span>(<span class="hljs-params">self, values</span>):</span><br>        maxValue = <span class="hljs-number">0</span><br>        lastMVPIndex = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(values)):<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, values[lastMVPIndex]+lastMVPIndex+values[i]-i)<br>            <span class="hljs-keyword">if</span> values[i] &gt;= values[lastMVPIndex]+lastMVPIndex-i:<br>                lastMVPIndex = i<br>        <span class="hljs-keyword">return</span> maxValue<br></code></pre></td></tr></table></figure><h2 id="1-11-丑数-II"><a href="#1-11-丑数-II" class="headerlink" title="1.11 丑数-II"></a>1.11 丑数-II</h2><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">12</span><br>解释：<span class="hljs-string">[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]</span> 是由前 <span class="hljs-number">10</span> 个丑数组成的序列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：<span class="hljs-number">1</span> 通常被视为丑数。<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/ugly-number-ii/">https://leetcode-cn.com/problems/ugly-number-ii/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1690</code></li></ul><p><strong>解：</strong><br>同剑指-49</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthUglyNumber</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>]*n<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        a,b,c = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            n2,n3,n5 = dp[a]*<span class="hljs-number">2</span>,dp[b]*<span class="hljs-number">3</span>,dp[c]*<span class="hljs-number">5</span><br>            dp[i] = <span class="hljs-built_in">min</span>(n2,n3,n5)<br>            <span class="hljs-keyword">if</span> dp[i] == n2:<br>                a += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dp[i] == n3:<br>                b += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dp[i] == n5:<br>                c += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="2-二维动态规划"><a href="#2-二维动态规划" class="headerlink" title="2. 二维动态规划"></a>2. 二维动态规划</h1><h2 id="2-1-最小路径和"><a href="#2-1-最小路径和" class="headerlink" title="2.1 最小路径和"></a>2.1 最小路径和</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/minpath.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><p>解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minPathSum</span>(<span class="hljs-params">self, grid: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; int:</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(grid)):<br>            grid[i][<span class="hljs-number">0</span>] += grid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>            grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>                grid[i][j] += <span class="hljs-built_in">min</span>(grid[i-<span class="hljs-number">1</span>][j],grid[i][j-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> grid[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="2-2-下降路径最小和"><a href="#2-2-下降路径最小和" class="headerlink" title="2.2 下降路径最小和"></a>2.2 下降路径最小和</h2><p>给你一个 <code>n x n</code> 的 <strong>方形</strong> 整数数组 <code>matrix</code> ，请你找出并返回通过 <code>matrix</code> 的<strong>下降路径</strong> 的 <strong>最小和</strong> 。</p><p><strong>下降路径</strong> 可以从第一行中的任何元素开始，并从每一行中选择一个元素。<br>在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。</p><p>具体来说，位置 <code>(row, col)</code> 的下一个元素应当是 <code>(row + 1, col - 1)</code>、<code>(row + 1, col)</code> 或者 <code>(row + 1, col + 1)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[6,5,4]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：13<br>解释：下面是两条和最小的下降路径，用加粗+斜体标注：<br><span class="hljs-comment">[<span class="hljs-comment">[2,1,3]</span>,      <span class="hljs-comment">[<span class="hljs-comment">[2,1,3]</span>,</span></span><br><span class="hljs-comment"><span class="hljs-comment"> <span class="hljs-comment">[6,5,4]</span>,       <span class="hljs-comment">[6,5,4]</span>,</span></span><br><span class="hljs-comment"><span class="hljs-comment"> <span class="hljs-comment">[7,8,9]</span>]</span>       <span class="hljs-comment">[7,8,9]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[-19,57],[-40,-5]]</span><br>输出：<span class="hljs-number">-59</span><br>解释：下面是一条和最小的下降路径，用加粗+斜体标注：<br><span class="hljs-string">[[-19,57],</span><br><span class="hljs-string"> [-40,-5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[-48]]</span><br>输出：<span class="hljs-number">-48</span><br></code></pre></td></tr></table></figure><p> **链接:</p><p>**<a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">https://leetcode-cn.com/problems/minimum-falling-path-sum/</a></p><p><strong>提示：</strong></p><ul><li><code>n == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minFallingPathSum</span>(<span class="hljs-params">self, matrix</span>):</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(matrix)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                    matrix[i][<span class="hljs-number">0</span>] += <span class="hljs-built_in">min</span>(matrix[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],matrix[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">elif</span> j == <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>:<br>                    matrix[i][-<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(matrix[i-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>],matrix[i-<span class="hljs-number">1</span>][-<span class="hljs-number">2</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    matrix[i][j] += <span class="hljs-built_in">min</span>(matrix[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],matrix[i-<span class="hljs-number">1</span>][j],matrix[i-<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(matrix[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="2-3-不同路径-I"><a href="#2-3-不同路径-I" class="headerlink" title="2.3 不同路径 I"></a>2.3 不同路径 I</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。<br>机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？</p><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/robot_maze.png" srcset="/img/loading.gif" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">7</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">m</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="2-4-不同路径-II"><a href="#2-4-不同路径-II" class="headerlink" title="2.4 不同路径 II"></a>2.4 不同路径 II</h2><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/unique-paths-ii/">https://leetcode-cn.com/problems/unique-paths-ii/</a></p><p><strong>描述:</strong><br>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/robot_maze-16333302399772.png" srcset="/img/loading.gif" alt="img"></p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/robot1.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：obstacleGrid = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">2</span><br>解释：<br><span class="hljs-number">3</span>x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 <span class="hljs-number">2</span> 条不同的路径：<br><span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/robot2.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniquePathsWithObstacles</span>(<span class="hljs-params">self, obstacleGrid</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(obstacleGrid) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(obstacleGrid)):<br>            <span class="hljs-keyword">if</span> obstacleGrid[i][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>                obstacleGrid[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                obstacleGrid[i][<span class="hljs-number">0</span>] = obstacleGrid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> obstacleGrid[<span class="hljs-number">0</span>][j] == <span class="hljs-number">1</span>:<br>                obstacleGrid[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                obstacleGrid[<span class="hljs-number">0</span>][j] = obstacleGrid[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(obstacleGrid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(obstacleGrid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> obstacleGrid[i][j] == <span class="hljs-number">1</span>:<br>                    obstacleGrid[i][j] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    obstacleGrid[i][j] = obstacleGrid[i-<span class="hljs-number">1</span>][j] + obstacleGrid[i][j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> obstacleGrid[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="2-5-杨辉三角"><a href="#2-5-杨辉三角" class="headerlink" title="2.5 杨辉三角"></a>2.5 杨辉三角</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle/">https://leetcode-cn.com/problems/pascals-triangle/</a></p><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1626927345-DZmfxB-PascalTriangleAnimated2.gif" srcset="/img/loading.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: numRows = 5<br>输出: <span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[1,3,3,1]</span>,<span class="hljs-comment">[1,4,6,4,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: numRows = <span class="hljs-number">1</span><br>输出: <span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate</span>(<span class="hljs-params">self, numRows</span>):</span><br>        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>]]<br>        <span class="hljs-keyword">if</span> numRows == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> [[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>        dp = [<span class="hljs-literal">None</span>]*numRows<br>        dp[<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>]<br>        dp[<span class="hljs-number">1</span>] = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,numRows):<br>            dp[i] = [<span class="hljs-number">0</span>]*(i+<span class="hljs-number">1</span>)<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            dp[i][-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i):<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][j]<br>        <span class="hljs-keyword">return</span> dp<br></code></pre></td></tr></table></figure><h2 id="2-6-三角形最小路径和"><a href="#2-6-三角形最小路径和" class="headerlink" title="2.6 三角形最小路径和"></a>2.6 三角形最小路径和</h2><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。<br><strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。<br>也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br> <span class="hljs-number"> 3 </span>4<br><span class="hljs-number"> 6 </span>5 7<br>4<span class="hljs-number"> 1 </span>8 3<br>自顶向下的最小路径和为 11（即，2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>= 11）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：triangle = <span class="hljs-string">[[-10]]</span><br>输出：<span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/triangle/">https://leetcode-cn.com/problems/triangle/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= triangle.length &lt;= 200</code></li><li><code>triangle[0].length == 1</code></li><li><code>triangle[i].length == triangle[i - 1].length + 1</code></li><li><code>-104 &lt;= triangle[i][j] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minimumTotal</span>(<span class="hljs-params">self, triangle</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(triangle) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(triangle)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(triangle[i])):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                    triangle[i][<span class="hljs-number">0</span>] += triangle[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">elif</span> j == <span class="hljs-built_in">len</span>(triangle[i])-<span class="hljs-number">1</span>:<br>                    triangle[i][-<span class="hljs-number">1</span>] += triangle[i-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    triangle[i][j] += <span class="hljs-built_in">min</span>(triangle[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],triangle[i-<span class="hljs-number">1</span>][j])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(triangle[-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="2-7-摆动序列"><a href="#2-7-摆动序列" class="headerlink" title="2.7 摆动序列"></a>2.7 摆动序列</h2><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong><br>第一个差（如果存在的话）可能是正数或负数。<br>仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度完成此题?</p><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wiggleMaxLengthByDP</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            sub = nums[i] - nums[i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> sub &gt; <span class="hljs-number">0</span>:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">elif</span> sub &lt; <span class="hljs-number">0</span>:<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    nums = [<span class="hljs-number">1</span>,<span class="hljs-number">17</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">16</span>,<span class="hljs-number">8</span>]<br>    s = Solution()<br>    print(s.wiggleMaxLengthByDP(nums))<br></code></pre></td></tr></table></figure><h2 id="2-8-单词拆分"><a href="#2-8-单词拆分" class="headerlink" title="2.8 单词拆分"></a>2.8 单词拆分</h2><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p><strong>说明：</strong></p><ul><li>拆分时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;applepenapple&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;applepenapple&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;apple pen apple&quot;</span>。<br>     注意你可以重复使用字典中的单词。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;catsandog&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordBreak</span>(<span class="hljs-params">self, s, wordDict</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        strList = <span class="hljs-built_in">list</span>(s)<br>        dp = [<span class="hljs-literal">False</span>] * (<span class="hljs-built_in">len</span>(s))<br>        <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> wordDict:<br>            dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;&#x27;</span>.join(strList[:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">in</span> wordDict:<br>                dp[i] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> dp[j] == <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;&#x27;</span>.join(strList[j+<span class="hljs-number">1</span>:i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">in</span> wordDict:<br>                    dp[i] = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.wordBreak(<span class="hljs-string">&quot;applepenapple&quot;</span>,[<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;pen&quot;</span>]))<br></code></pre></td></tr></table></figure><h1 id="3-子数组问题"><a href="#3-子数组问题" class="headerlink" title="3. 子数组问题"></a>3. 子数组问题</h1><h2 id="3-1-子数组最大和"><a href="#3-1-子数组最大和" class="headerlink" title="3.1 子数组最大和"></a>3.1 子数组最大和</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-100000</span>]<br>输出：<span class="hljs-string">-100000</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        maxSum = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            nums[i] = <span class="hljs-built_in">max</span>(nums[i],nums[i-<span class="hljs-number">1</span>]+nums[i])<br>            <span class="hljs-keyword">if</span> nums[i] &gt; maxSum:<br>                maxSum = nums[i]<br>        <span class="hljs-keyword">return</span> maxSum<br></code></pre></td></tr></table></figure><h2 id="3-2-环形子数组最大和"><a href="#3-2-环形子数组最大和" class="headerlink" title="3.2 环形子数组最大和"></a>3.2 环形子数组最大和</h2><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">https://leetcode-cn.com/problems/maximum-sum-circular-subarray/</a></p><p>给定一个由整数数组 <code>A</code> 表示的**环形数组 <code>C</code>**，求 <code>**C**</code> 的非空子数组的最大可能和。</p><p>在此处，<em>环形数组</em>意味着数组的末端将会与开头相连呈环状。（形式上，当<code>0 &lt;= i &lt; A.length</code> 时 <code>C[i] = A[i]</code>，且当 <code>i &gt;= 0</code> 时 <code>C[i+A.length] = C[i]</code>）</p><p>此外，子数组最多只能包含固定缓冲区 <code>A</code> 中的每个元素一次。（形式上，对于子数组 <code>C[i], C[i+1], ..., C[j]</code>，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % A.length = k2 % A.length</code>）</p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,-2,3,-2]</span><br>输出：<span class="hljs-number">3</span><br>解释：从子数组 <span class="hljs-selector-attr">[3]</span> 得到最大和 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<span class="hljs-comment">[5,-3,5]</span><br>输出：10<br>解释：从子数组 <span class="hljs-comment">[5,5]</span> 得到最大和 5 + 5 = 10<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：[3,<span class="hljs-string">-1</span>,2,<span class="hljs-string">-1</span>]<br>输出：4<br>解释：从子数组 [2,<span class="hljs-string">-1</span>,3] 得到最大和 2 + (<span class="hljs-string">-1</span>) + 3 = 4<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,-2,2,-3]</span><br>输出：<span class="hljs-number">3</span><br>解释：从子数组 <span class="hljs-selector-attr">[3]</span> 和 <span class="hljs-selector-attr">[3,-2,2]</span> 都可以得到最大和 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：[<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-1</span>]<br>输出：<span class="hljs-string">-1</span><br>解释：从子数组 [<span class="hljs-string">-1</span>] 得到最大和 <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>-30000 &lt;= A[i] &lt;= 30000</code></li><li><code>1 &lt;= A.length &lt;= 30000</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubarraySumCircular</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        dp1 = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        dp2 = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        maxSum1 = minSum = <span class="hljs-built_in">sum</span> = dp1[<span class="hljs-number">0</span>] = dp2[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            dp1[i] = <span class="hljs-built_in">max</span>(dp1[i-<span class="hljs-number">1</span>]+nums[i],nums[i])<br>            maxSum1 = <span class="hljs-built_in">max</span>(dp1[i], maxSum1)<br><br>            <span class="hljs-built_in">sum</span> += nums[i]<br>            dp2[i] = <span class="hljs-built_in">min</span>(dp2[i-<span class="hljs-number">1</span>]+nums[i],nums[i])<br>            minSum = <span class="hljs-built_in">min</span>(dp2[i], minSum)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> == minSum:<br>            <span class="hljs-keyword">return</span> maxSum1<br>        maxSum2 = <span class="hljs-built_in">sum</span> - minSum<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxSum1,maxSum2)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.maxSubarraySumCircular([-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><h2 id="3-3-乘积最大子数组"><a href="#3-3-乘积最大子数组" class="headerlink" title="3.3 乘积最大子数组"></a>3.3 乘积最大子数组</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: [<span class="hljs-string">-2</span>,0,<span class="hljs-string">-1</span>]<br>输出: 0<br>解释: 结果不能为 2, 因为 [<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>] 不是子数组。<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProduct</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        dpMax = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        dpMin = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        dpMax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dpMin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        maxMulti = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            dpMin[i] = <span class="hljs-built_in">min</span>(nums[i] * dpMin[i-<span class="hljs-number">1</span>], nums[i] * dpMax[i-<span class="hljs-number">1</span>], nums[i])<br>            dpMax[i] = <span class="hljs-built_in">max</span>(nums[i] * dpMax[i-<span class="hljs-number">1</span>], nums[i] * dpMin[i-<span class="hljs-number">1</span>], nums[i])<br>            maxMulti = <span class="hljs-built_in">max</span>(dpMax[i], maxMulti)<br>        print(dpMin,dpMax)<br>        <span class="hljs-keyword">return</span> maxMulti<br></code></pre></td></tr></table></figure><h2 id="3-4-乘积为正的最长子串长度"><a href="#3-4-乘积为正的最长子串长度" class="headerlink" title="3.4 乘积为正的最长子串长度"></a>3.4 乘积为正的最长子串长度</h2><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/">https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/</a></p><p>给你一个整数数组 <code>nums</code> ，请你求出乘积为正数的最长子数组的长度。</p><p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p><p>请你返回乘积为正数的最长子数组长度。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,4]<br>输出：4<br>解释：数组本身乘积就是正数，值为 24 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [0,1,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,<span class="hljs-string">-4</span>]<br>输出：3<br>解释：最长乘积为正数的子数组为 [1,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>] ，乘积为 6 。<br>注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>,0,1]<br>输出：2<br>解释：乘积为正数的最长子数组是 [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>] 或者 [<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [-1,2]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,5</span>,-<span class="hljs-number">6,4,0,10</span>]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMaxLen</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &gt;=<span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        positiveDP = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        negativeDP = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>:<br>            positiveDP[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            negativeDP[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>:<br>            positiveDP[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            negativeDP[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            positiveDP[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>            negativeDP[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        longestLne = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span>:<br>                positiveDP[i] = <span class="hljs-number">0</span><br>                negativeDP[i] = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">elif</span> nums[i] &gt; <span class="hljs-number">0</span>:<br>                positiveDP[i] = positiveDP[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> negativeDP[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                    negativeDP[i] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    negativeDP[i] = negativeDP[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                negativeDP[i] = positiveDP[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> negativeDP[i-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                    positiveDP[i] = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">else</span>:<br>                    positiveDP[i] = negativeDP[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            longestLne = <span class="hljs-built_in">max</span>(longestLne,positiveDP[i])<br>        <span class="hljs-keyword">return</span> longestLne<br><br></code></pre></td></tr></table></figure><h2 id="3-5-最长递增子序列"><a href="#3-5-最长递增子序列" class="headerlink" title="3.5 最长递增子序列"></a>3.5 最长递增子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。<br>例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p> <strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLIS</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums)<br>        dp = [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(nums)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><h2 id="3-6-摆动序列"><a href="#3-6-摆动序列" class="headerlink" title="3.6 摆动序列"></a>3.6 摆动序列</h2><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">https://leetcode-cn.com/problems/wiggle-subsequence/</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong><br>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, <span class="hljs-string">-3</span>, 5, <span class="hljs-string">-7</span>, 3) 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, <span class="hljs-string">-7</span>, 3, <span class="hljs-string">-3</span>, 6, <span class="hljs-string">-8</span>) 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,8</span>,<span class="hljs-number">9</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>解:</strong></p><p>可贪心可动态规划</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wiggleMaxLength</span>(<span class="hljs-params">self, nums</span>):</span><br>        dp = [[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[i-<span class="hljs-number">1</span>]:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">elif</span> nums[i] &lt; nums[i-<span class="hljs-number">1</span>]:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="3-7-等差数列划分"><a href="#3-7-等差数列划分" class="headerlink" title="3.7 等差数列划分"></a>3.7 等差数列划分</h2><p><strong>描述:</strong><br>如果一个数列 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><ul><li>例如，<code>[1,3,5,7,9]</code>、<code>[7,7,7,7]</code> 和 <code>[3,-1,-5,-9]</code> 都是等差数列。</li></ul><p>给你一个整数数组 <code>nums</code> ，返回数组 <code>nums</code> 中所有为等差数组的 <strong>子数组</strong> 个数。</p><p><strong>子数组</strong> 是数组中的一个连续序列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3,4]</span><br>输出：3<br>解释：nums 中有三个子等差数组：<span class="hljs-comment">[1, 2, 3]</span>、<span class="hljs-comment">[2, 3, 4]</span> 和 <span class="hljs-comment">[1,2,3,4]</span> 自身。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/arithmetic-slices/">https://leetcode-cn.com/problems/arithmetic-slices/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numberOfArithmeticSlices</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(nums)<br>        output = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] - nums[i-<span class="hljs-number">1</span>] == nums[i+<span class="hljs-number">1</span>] - nums[i]:<br>                dp[i] = dp[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                output += dp[i]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="4-回文串与编辑问题"><a href="#4-回文串与编辑问题" class="headerlink" title="4. 回文串与编辑问题"></a>4. 回文串与编辑问题</h1><h2 id="4-1-最长回文子串"><a href="#4-1-最长回文子串" class="headerlink" title="4.1 最长回文子串"></a>4.1 最长回文子串</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>与<a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a>类似</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;babad&quot;</span><br>输出：<span class="hljs-string">&quot;bab&quot;</span><br>解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-string">&quot;bb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-comment">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aa&quot;</span><br>输出：<span class="hljs-string">&quot;aa&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母（大写和/或小写）组成</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-comment"># 双指针中心扩散法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeByCD</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> s<br>        self.longestStr = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> center <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>):<br>            self.centralDiffusion(s,center,center)<br>            self.centralDiffusion(s,center,center + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> self.longestStr<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">centralDiffusion</span>(<span class="hljs-params">self,s,leftP,rightP</span>):</span><br>        <span class="hljs-keyword">while</span> leftP &gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> rightP &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[leftP] != s[rightP]:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> rightP - leftP +<span class="hljs-number">1</span> &gt; <span class="hljs-built_in">len</span>(self.longestStr):<br>                self.longestStr = s[leftP:rightP+<span class="hljs-number">1</span>]<br>            leftP  -= <span class="hljs-number">1</span><br>            rightP += <span class="hljs-number">1</span><br>            <br>    <span class="hljs-comment"># 动态规划</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeByDP</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> s<br>        longestLen = <span class="hljs-number">1</span><br>        leftP = <span class="hljs-number">0</span><br>        rightP = <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> col &lt; row:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> col == row:<br>                    dp[row][col] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">elif</span> s[col] == s[row] <span class="hljs-keyword">and</span> (col - row == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> dp[row+<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>]):<br>                    dp[row][col] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[row][col] = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> dp[row][col] == <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> col - row + <span class="hljs-number">1</span> &gt; longestLen:<br>                    longestLen = col - row + <span class="hljs-number">1</span><br>                    leftP = row<br>                    rightP = col<br>        <span class="hljs-keyword">return</span> s[leftP:rightP+<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    s.longestPalindromeByDP(<span class="hljs-string">&quot;aa&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-2-最长回文子序列"><a href="#4-2-最长回文子序列" class="headerlink" title="4.2 最长回文子序列"></a>4.2 最长回文子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;bbbab&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bbbb&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bb&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li><li>与16题不同点在于，16题的子串必须连续，本题则不需要</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeSubseq</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            dp[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> s[col] == s[row]:<br>                    dp[row][col] = dp[row+<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>] + <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[row][col] = <span class="hljs-built_in">max</span>(dp[row+<span class="hljs-number">1</span>][col], dp[row][col-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="4-3-最长公共子序列"><a href="#4-3-最长公共子序列" class="headerlink" title="4.3 最长公共子序列"></a>4.3 最长公共子序列</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：最长公共子序列是 <span class="hljs-string">&quot;abc&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;def&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：两个字符串没有公共子序列，返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonSubsequence</span>(<span class="hljs-params">self, text1: <span class="hljs-built_in">str</span>, text2: <span class="hljs-built_in">str</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(text1) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> text2 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(text1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(text2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> text1[i-<span class="hljs-number">1</span>] == text2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j])<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="4-4-编辑距离"><a href="#4-4-编辑距离" class="headerlink" title="4.4 编辑距离"></a>4.4 编辑距离</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span>(<span class="hljs-params">self, word1: <span class="hljs-built_in">str</span>, word2: <span class="hljs-built_in">str</span></span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> word1 == word2:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> word1 == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> word2 == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(word1) + <span class="hljs-built_in">len</span>(word2)<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>):<br>            dp[i][<span class="hljs-number">0</span>] = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">0</span>][j] = j<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> word1[i-<span class="hljs-number">1</span>] == word2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j], dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]) +<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="5-股票问题"><a href="#5-股票问题" class="headerlink" title="5. 股票问题"></a>5. 股票问题</h1><h2 id="5-1-买卖股票的最佳时机I"><a href="#5-1-买卖股票的最佳时机I" class="headerlink" title="5.1 买卖股票的最佳时机I"></a>5.1 买卖股票的最佳时机I</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(prices)<br>        dp[<span class="hljs-number">0</span>] = prices[<span class="hljs-number">0</span>]<br>        maxValue = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>], prices[i])<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, prices[i] - dp[i])<br>        <span class="hljs-keyword">return</span> maxValue<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfitByGreedy</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        maxProfit = <span class="hljs-number">0</span><br>        minValue = prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prices)):<br>            minValue = <span class="hljs-built_in">min</span>(minValue, prices[i])<br>            maxProfit = <span class="hljs-built_in">max</span>(maxProfit, prices[i]-minValue)<br>        <span class="hljs-keyword">return</span> maxProfit<br></code></pre></td></tr></table></figure><h2 id="5-2-买卖股票的最佳时机II"><a href="#5-2-买卖股票的最佳时机II" class="headerlink" title="5.2 买卖股票的最佳时机II"></a>5.2 买卖股票的最佳时机II</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><blockquote><p><strong>注意：</strong><br>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: prices = [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: prices = [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfitByGreedy</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        maxProfit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            profit = prices[i] - prices[i-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> profit &gt; <span class="hljs-number">0</span>:<br>                maxProfit += profit<br>        <span class="hljs-keyword">return</span> maxProfit<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfitByDP</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(prices)<br>        dp[<span class="hljs-number">0</span>] = prices[<span class="hljs-number">0</span>]<br>        maxValue = <span class="hljs-number">0</span><br>        maxProfit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>], prices[i])<br>            <span class="hljs-keyword">if</span> prices[i] - dp[i] &lt; maxValue:<br>                maxProfit += maxValue<br>                dp[i] = prices[i]<br>                maxValue = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                maxValue = prices[i] - dp[i]<br>        maxProfit += maxValue<br>        <span class="hljs-keyword">return</span> maxProfit<br></code></pre></td></tr></table></figure><h2 id="5-3-买卖股票的最佳时机III"><a href="#5-3-买卖股票的最佳时机III" class="headerlink" title="5.3 买卖股票的最佳时机III"></a>5.3 买卖股票的最佳时机III</h2><p><strong>描述:</strong><br>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,0,2]</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></code></pre></td></tr></table></figure><p><strong>链接:</strong></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prices))] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]-prices[<span class="hljs-number">1</span>])<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]+prices[<span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">2</span>]-prices[i])<br>            dp[<span class="hljs-number">1</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]+prices[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h2 id="5-4-买卖股票的最佳时机IV"><a href="#5-4-买卖股票的最佳时机IV" class="headerlink" title="5.4 买卖股票的最佳时机IV"></a>5.4 买卖股票的最佳时机IV</h2><p><strong>描述:</strong><br>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。<br>如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><blockquote><p><strong>注意：</strong><br>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p></blockquote><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：prices = <span class="hljs-comment">[1, 3, 2, 8, 4, 9]</span>, fee = 2<br>输出：8<br>解释：能够达到的最大利润:  <br>在此处买入 prices<span class="hljs-comment">[0]</span> = 1<br>在此处卖出 prices<span class="hljs-comment">[3]</span> = 8<br>在此处买入 prices<span class="hljs-comment">[4]</span> = 4<br>在此处卖出 prices<span class="hljs-comment">[5]</span> = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">prices</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">fee</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5 * 104</code></li><li><code>1 &lt;= prices[i] &lt; 5 * 104</code></li><li><code>0 &lt;= fee &lt; 5 * 104</code></li></ul><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices, fee</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prices))]<span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>],dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]-prices[i])<br>            dp[<span class="hljs-number">1</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>],dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>]+prices[i]-fee)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><h1 id="6-背包问题"><a href="#6-背包问题" class="headerlink" title="6. 背包问题"></a>6. 背包问题</h1><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009155910693.png" srcset="/img/loading.gif" alt="背包问题分类"></p><h2 id="6-1-0-1背包问题"><a href="#6-1-0-1背包问题" class="headerlink" title="6.1 0/1背包问题"></a>6.1 0/1背包问题</h2><h3 id="6-1-0-原型"><a href="#6-1-0-原型" class="headerlink" title="6.1.0 原型"></a>6.1.0 原型</h3><h4 id="6-1-0-1-题目描述"><a href="#6-1-0-1-题目描述" class="headerlink" title="6.1.0.1 题目描述"></a>6.1.0.1 题目描述</h4><p>有N件物品和一个最多能被重量为W 的背包。<br>第i件物品的重量是weight[i]，得到的价值是value[i] 。<br><strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>**例如:**背包最大重量为4。<br>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><h4 id="6-1-0-2-题目分析"><a href="#6-1-0-2-题目分析" class="headerlink" title="6.1.0.2 题目分析"></a>6.1.0.2 题目分析</h4><ol><li><p><strong>确定dp数组以及下标的含义</strong><br>使用二维数组，即:<br><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。<br><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009160154930.png" srcset="/img/loading.gif" alt="image-20211009160154930"></p></li><li><p><strong>确定递推公式</strong><br>两种情况:</p></li></ol><ul><li><p><strong>不放物品i</strong>：<br>由 dp[i - 1][j] 推出，即背包容量为 j ，里面不放物品 i 的最大价值，此时 dp[i][j] 就是 dp[i - 1][j] 。<br>(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</p></li><li><p><strong>放物品i</strong>：<br>由 dp[i - 1][j - weight[i]] 推出， dp[i - 1][j - weight[i]] 为背包容量为 j - weight[i] 的时候不放物品i的最大价值，那么 dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</p><p>所以递归公式：<br>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</p></li></ul><ol start="3"><li><p><strong>dp数组如何初始化</strong></p><ul><li><p>首先从dp[i][j]的定义出发<br>如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。</p></li><li><p>状态转移方程 :dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])<br>可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p></li></ul><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009160811954.png" srcset="/img/loading.gif" alt="image-20211009160811954"></p></li><li><p><strong>确定遍历顺序</strong><br>递推方向如下</p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009161003391.png" srcset="/img/loading.gif" alt="image-20211009161003391"><br>所以：<br>先遍历物品还是先遍历背包重量其实都可以<br>但是先遍历物品更好理解</p></li><li><p><strong>举例推导dp数组</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20211009161539532.png" srcset="/img/loading.gif" alt="image-20211009161539532"></p></li></ol><h4 id="6-1-0-3-代码实现"><a href="#6-1-0-3-代码实现" class="headerlink" title="6.1.0.3 代码实现"></a>6.1.0.3 代码实现</h4><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zero_oneBackpackProblem</span>(<span class="hljs-params">self, weight, value, volume</span>):</span><br>        dp = [<span class="hljs-number">0</span>] * (volume + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(dp)):<br>            <span class="hljs-keyword">if</span> j &gt;= weight[<span class="hljs-number">0</span>]:<br>                dp[j] = value[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>            print(dp)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(volume,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> weight[i] &gt; j:<br>                    <span class="hljs-keyword">break</span><br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-weight[i]]+value[i])<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    wight = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>    value = [<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]<br>    volume = <span class="hljs-number">4</span><br>    s = Solution()<br>    print(s.zero_oneBackpackProblem(wight,value,volume))<br></code></pre></td></tr></table></figure><h2 id="6-2-完全背包问题"><a href="#6-2-完全背包问题" class="headerlink" title="6.2 完全背包问题"></a>6.2 完全背包问题</h2><h3 id="6-2-0-原型"><a href="#6-2-0-原型" class="headerlink" title="6.2.0 原型"></a>6.2.0 原型</h3><h4 id="6-2-0-1-题目描述"><a href="#6-2-0-1-题目描述" class="headerlink" title="6.2.0.1 题目描述"></a>6.2.0.1 题目描述</h4><p>有N件物品和一个最多能背重量为W的背包。<br>第i件物品的重量是weight[i]，得到的价值是value[i] 。<br><strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><blockquote><p>完全背包和01背包问题唯一不同的地方就是: 每种物品有无限件</p></blockquote><p><strong>例如:</strong><br>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p><strong>每件商品都有无限个！</strong></p><p>问背包能背的物品最大价值是多少？</p><h4 id="6-2-0-2-题目分析"><a href="#6-2-0-2-题目分析" class="headerlink" title="6.2.0.2 题目分析"></a>6.2.0.2 题目分析</h4><p>和01背包问题不同的地方就是: <strong>每种物品有无限件</strong><br>这导致了在实现上有两点不同:</p><ul><li><p>dp初始化不同</p><ul><li>0-1背包的物体只能使用一次，所以初始化第一排(物体0)时：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dp = [<span class="hljs-number">0</span>] * (volume + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(weight[<span class="hljs-number">0</span>],<span class="hljs-built_in">len</span>(dp)):<br>dp[j] = value[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>​    只需要装入一次，然后价值就不变了，都是value[0]</p><ul><li><p>完全背包的物体可以多次使用，因此初始化第一排(物体0)时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dp = [<span class="hljs-number">0</span>] * (volume + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(weight[<span class="hljs-number">0</span>],<span class="hljs-built_in">len</span>(dp)):<br>dp[j] = dp[j-weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>要考虑多次装入，更新价值</p></li></ul></li><li><p>dp迭代顺序不同</p><ul><li><p>01背包物体只能使用一次，迭代时为了保证不重复装入，需要逆序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(volume,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> weight[i] &gt; j:<br>            <span class="hljs-keyword">break</span><br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-weight[i]]+value[i])<br></code></pre></td></tr></table></figure></li><li><p>完全背包的物体可以多次使，正序遍历即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(weight)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(wight[i],volume+<span class="hljs-number">1</span>):<br>dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-weight[i]]+value[i])<br></code></pre></td></tr></table></figure><p>剩下的就完全一样了。</p></li></ul></li></ul><h4 id="6-2-0-3-代码实现"><a href="#6-2-0-3-代码实现" class="headerlink" title="6.2.0.3 代码实现"></a>6.2.0.3 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">completeBackpack</span>(<span class="hljs-params">self, weight, value, volume</span>):</span><br>        dp = [<span class="hljs-number">0</span>] * (volume + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(weight[<span class="hljs-number">0</span>],<span class="hljs-built_in">len</span>(dp)):<br>            dp[j] = dp[j-weight[<span class="hljs-number">0</span>]] + value[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(weight)):<br>            print(dp)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(wight[i],volume+<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-weight[i]]+value[i])<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    wight = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>    value = [<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]<br>    volume = <span class="hljs-number">4</span><br>    s = Solution()<br>    print(s.completeBackpack(wight,value,volume))<br></code></pre></td></tr></table></figure><h3 id="6-2-1-零钱兑换-I"><a href="#6-2-1-零钱兑换-I" class="headerlink" title="6.2.1 零钱兑换 I"></a>6.2.1 零钱兑换 I</h3><p><a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。<br>如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">11</span><br>输出：<span class="hljs-number">3</span> <br>解释：<span class="hljs-number">11</span> = <span class="hljs-number">5</span> + <span class="hljs-number">5</span> + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">2</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">3</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coinChange</span>(<span class="hljs-params">self, coins, amount</span>):</span><br>        <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(coins) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        dp = [amount+<span class="hljs-number">1</span>] * (amount+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(coins)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(coins[i],amount+<span class="hljs-number">1</span>):<br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j-coins[i]]+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> dp[-<span class="hljs-number">1</span>] == amount+<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="6-2-2-零钱兑换-II"><a href="#6-2-2-零钱兑换-II" class="headerlink" title="6.2.2 零钱兑换 II"></a>6.2.2 零钱兑换 II</h3><p><a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币<strong>组合数</strong>。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span><br>5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br>5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">amount</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">coins</span> = [<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">0</span><br>解释：只用面额 <span class="hljs-number">2</span> 的硬币不能凑成总金额 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">amount</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">coins</span> = [<span class="hljs-number">10</span>] <br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span>(<span class="hljs-params">self, amount, coins</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(coins) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> amount == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        dp = [<span class="hljs-number">0</span>] * (amount+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> coin <span class="hljs-keyword">in</span> coins:<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(coin,amount+<span class="hljs-number">1</span>):<br>                dp[j] += dp[j-coin]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="6-2-3-组合总和-Ⅳ"><a href="#6-2-3-组合总和-Ⅳ" class="headerlink" title="6.2.3 组合总和 Ⅳ"></a>6.2.3 组合总和 Ⅳ</h3><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a></p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。<br>请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">9</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><p><strong>进阶：</strong><br>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><p><strong>解:</strong></p><p>与 <strong>6.2.2 零钱兑换</strong> 同类型，完全背包下：</p><ul><li>求组和：背包在内，物品在外</li><li>求排列：背包在外，物品在内</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combinationSum4</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        dp = [<span class="hljs-number">0</span>] * (target+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,target+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">if</span> num &lt;= i:<br>                    dp[i] += dp[i - num]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="6-2-4-整数拆分"><a href="#6-2-4-整数拆分" class="headerlink" title="6.2.4 整数拆分"></a>6.2.4 整数拆分</h3><p><a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。<br>返回你可以获得的最大乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 2<br>输出: 1<br>解释:<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 1 </span>+ 1,<span class="hljs-number"> 1 </span>×<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: 10<br>输出: 36<br>解释:<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+ 4,<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 3 </span>×<span class="hljs-number"> 4 </span>= 36。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong> 你可以假设 <em>n</em> 不小于 2 且不大于 58。</p><p><strong>解:</strong></p><p><strong>状态定义：</strong><br>dp[i]： n=i 时的最大乘积</p><p><strong>状态转移：</strong><br>遍历1~i之间所有的因子j,则i可以被拆为 j 与 i-j两数的和, 其中i-j假设也可以被拆分，则取dp[i-j]，遍历j，取最大的dp[i]<br>dp[i] = max(dp[i],j*(i-j), dp[j]*(i-j))</p><p><strong>边界条件：</strong><br>dp[0]=dp[1]=0<br><strong>时间：</strong>O(n)<br><strong>空间：</strong>O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">integerBreak</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i):<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],j*(i-j), dp[j]*(i-j))<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="6-2-5-完全平方数"><a href="#6-2-5-完全平方数" class="headerlink" title="6.2.5 完全平方数"></a>6.2.5 完全平方数</h1><p><a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 12<br>输出：3 <br>解释：12 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 4 </span>+ 4<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">13</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numSquares</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>        dp = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>        <span class="hljs-comment"># dp[0] = 0 无意义，只是为了方便记录特殊情况:</span><br>        <span class="hljs-comment"># n本身就是完全平方数，dp[n] = min(dp[n], dp[n - n] + 1) = 1</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n): <span class="hljs-comment"># 遍历物品</span><br>            <span class="hljs-keyword">if</span> i * i &gt; n:<br>                <span class="hljs-keyword">break</span><br>            num = i * i<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num, n + <span class="hljs-number">1</span>): <span class="hljs-comment"># 遍历背包</span><br>                dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - num] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> dp[n]<br></code></pre></td></tr></table></figure><h1 id="7-复合问题"><a href="#7-复合问题" class="headerlink" title="7. 复合问题"></a>7. 复合问题</h1><h2 id="7-1-接雨水"><a href="#7-1-接雨水" class="headerlink" title="7.1 接雨水"></a>7.1 接雨水</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/rainwatertrap.png" srcset="/img/loading.gif" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/trapping-rain-water/">https://leetcode-cn.com/problems/trapping-rain-water/</a></p><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trap</span>(<span class="hljs-params">self, height</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(height) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(height))] <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        dp[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>        lenth = <span class="hljs-built_in">len</span>(height)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,lenth):<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>],height[i-<span class="hljs-number">1</span>])<br>            dp[<span class="hljs-number">1</span>][lenth-<span class="hljs-number">1</span>-i] = <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][lenth-i],height[lenth-i])<br>        output = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,lenth-<span class="hljs-number">1</span>):<br>            rain = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][i],dp[<span class="hljs-number">1</span>][i]) - height[i]<br>            <span class="hljs-keyword">if</span> rain &gt; <span class="hljs-number">0</span>:<br>                output += rain<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h2 id="7-2-不同的二叉搜索树"><a href="#7-2-不同的二叉搜索树" class="headerlink" title="7.2 不同的二叉搜索树"></a>7.2 不同的二叉搜索树</h2><p><strong>描述:</strong><br>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？<br>返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/uniquebstn3.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> <strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><p><strong>解：</strong><br>卡特兰公式<br>明确：<br>二叉搜索树序列的个数与其值无关，只与区间长度有关</p><p>例如：我们在计算序列长度为 4 的二叉搜索树[1 , 2 , 3 , 4 ]。<br>假设以 1 作为根结点，则左子树序列长度为 0 ，右子树序列长度为 3 ，而我们之前就已经计算过序列长度为 3 的总个数了，没有必要再算一次，且当前状态受上一个状态的影响，因此我们就可以从这里入手，进行下一步优化——动态规划。</p><p>定义两个函数：</p><ul><li><p>G(n)：<br>长度为 n 的序列能构成的不同二叉搜索树的个数</p></li><li><p>F(i,n)：<br>以 i 为根、序列长度为 n 的不同二叉搜索树的个数(1≤i≤n)。</p></li></ul><p>首先，根据方法一的思路可以知道，对于不同的二叉搜索树的总数G(n) ，是所有F(i,n) 之和：</p><p>$G(n)=\displaystyle\sum^n_{i=0} F(i,n)$</p><p>对于边界情况，当序列长度为$ 1 $( 只有根 ) 或为 0 ( 空树 ) 时，只有一种情况，即：</p><p>G(0) = 1，G(1) = 1</p><p>举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 [1, 2, 3, 4, 5, 6, 7]，我们需要从左子序列 [1, 2][1,2] 构建左子树，从右子序列 [4, 5, 6, 7]构建右子树，然后将它们组合（即笛卡尔积）。</p><p>对于这个例子，不同二叉搜索树的个数为 F(3, 7)。<br>我们将 [1,2] 构建不同左子树的数量表示为 G(2), 从 [4, 5, 6, 7]构建不同右子树的数量表示为 G(4)，注意到G(n) 和序列的内容无关，只和序列的长度有关。<br>于是，$F(3,7) = G(2) \cdot G(4)$。<br>因此，我们可以得到以下公式：</p><p>$F(i,n) = G(i-1) \cdot G(n-i)$</p><p>因此，结合上述公式可以得出递归表达式：</p><p>$G(n) = \displaystyle \sum^{n}_{i=1}{G(i-1) \cdot G(n-i)}$</p><p>于是，我们可以从小到大计算GG函数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numTrees</span>(<span class="hljs-params">self, n</span>):</span><br>        dp = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>):<br>                dp[i] += dp[j-<span class="hljs-number">1</span>] * dp[i-j]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="22-解码方法"><a href="#22-解码方法" class="headerlink" title="22. 解码方法"></a>22. 解码方法</h1><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span><br>...<br><span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;12&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（<span class="hljs-number">1</span> <span class="hljs-number">2</span>）或者 <span class="hljs-string">&quot;L&quot;</span>（<span class="hljs-number">12</span>）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;226&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> <span class="hljs-comment">(2 26)</span>, <span class="hljs-string">&quot;VF&quot;</span> <span class="hljs-comment">(22 6)</span>, 或者 <span class="hljs-string">&quot;BBF&quot;</span> <span class="hljs-comment">(2 2 6)</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：没有字符映射到以 <span class="hljs-number">0</span> 开头的数字。<br>含有 <span class="hljs-number">0</span> 的有效映射是 <span class="hljs-string">&#x27;J&#x27;</span> -&gt; <span class="hljs-string">&quot;10&quot;</span> 和 <span class="hljs-string">&#x27;T&#x27;</span>-&gt; <span class="hljs-string">&quot;20&quot;</span> 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;06&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-string">&quot;06&quot;</span> 不能映射到 <span class="hljs-string">&quot;F&quot;</span> ，因为字符串含有前导 <span class="hljs-number">0</span>（<span class="hljs-string">&quot;6&quot;</span> 和 <span class="hljs-string">&quot;06&quot;</span> 在映射中并不等价）。<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/decode-ways/">https://leetcode-cn.com/problems/decode-ways/</a></p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DinoParkour开发文档</title>
    <link href="/2021/09/11/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/"/>
    <url>/2021/09/11/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="DinoParkour开发文档"><a href="#DinoParkour开发文档" class="headerlink" title="DinoParkour开发文档"></a>DinoParkour开发文档</h1><p><strong>项目信息：</strong><br>项目负责人：买烤麸烤饼<br>程序：买烤麸烤饼<br>美工：买烤麸烤饼，一周<br>音效：洛一<br>项目开发周期：2021.9.1- 2021.9.10</p><p><strong>版本信息：</strong></p><ul><li><p>v1.0  完成小恐龙跑酷的基本玩法</p></li><li><p>v1.5</p><ul><li>将操作按钮放到了屏幕两侧</li><li>解决了摄像头无法归位的BUG</li><li>重置了所有碰撞器，精细化了碰撞检测</li><li>增加了全新的翼龙模式与全新的BUG</li></ul></li><li><p>v2.0</p><ul><li>降低了翼龙的敏感度</li><li>修复了翼龙模式天空块之间会有缝隙的bug</li></ul></li></ul><h1 id="1-玩法分析"><a href="#1-玩法分析" class="headerlink" title="1. 玩法分析"></a>1. 玩法分析</h1><p><strong>游戏原型：</strong><br>chrome://dino/</p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909224440720.png" srcset="/img/loading.gif" alt="游戏原型"></p><p>该游戏是谷歌浏览器自带的一款恐龙跑酷小游戏。<br>当在无网络的情况下使用谷歌浏览器访问网站时会出现一个小恐龙，再按下空格就可以触发这个小游戏了。</p><p>在该游戏中，玩家通过键盘操控小恐龙进行跑酷，躲避各种沙漠上的障碍物来取得高分。</p><p><strong>游戏目标：</strong><br>躲过更多障碍，跑的更远以取得更高的分数</p><p><strong>得分计算：</strong><br>小恐龙存活时间就是得分</p><p><strong>玩家操作：</strong><br>玩家可以通过按钮(移动端)键盘(pc)端等方式来操控小恐龙进行跑酷。<br>可以操作的动作：</p><ul><li>下箭头：低头</li><li>上箭头：跳跃</li></ul><p><strong>失败判定：</strong><br>小恐龙碰到任何障碍物就触发游戏失败</p><h1 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h1><h2 id="2-1-游戏实体分析"><a href="#2-1-游戏实体分析" class="headerlink" title="2.1 游戏实体分析"></a>2.1 游戏实体分析</h2><h3 id="2-1-1-总分析"><a href="#2-1-1-总分析" class="headerlink" title="2.1.1 总分析"></a>2.1.1 总分析</h3><p><strong>主要实体：</strong></p><ul><li>小恐龙Dino 1个</li><li>陆地Land 动态生成</li><li>背景墙TimeRing 1个</li></ul><p>其中动态生成的陆地中应该动态生成多个障碍实体</p><p><strong>障碍实体：</strong></p><ul><li>仙人掌Cactu 共10种<ul><li>单体仙人掌 5种</li><li>双体仙人掌 3种</li><li>三体仙人掌 1种</li><li>四体仙人掌 1种</li></ul></li><li>翼龙Pterosaur 1种</li></ul><p>每种障碍实体的碰撞体积均不相同</p><p><strong>其它实体：</strong></p><ul><li>灯光Light</li><li>摄影机MainCamera</li></ul><h3 id="2-1-2-实体动画分析"><a href="#2-1-2-实体动画分析" class="headerlink" title="2.1.2 实体动画分析"></a>2.1.2 实体动画分析</h3><p>应当设计动画的实体主要是小恐龙与翼龙：</p><h4 id="2-1-2-1-小恐龙动画分析"><a href="#2-1-2-1-小恐龙动画分析" class="headerlink" title="2.1.2.1 小恐龙动画分析"></a>2.1.2.1 小恐龙动画分析</h4><p><strong>状态分析：</strong></p><ul><li>开始状态Start:0 (1帧)</li><li>奔跑状态Run:1 (2帧)</li><li>跳跃状态Jump:2 (1帧)</li><li>低头状态DownRun:3 (2帧)</li><li>死亡状态Dead:4 (1帧)</li></ul><p><strong>状态机</strong>如下图所示：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909223752586.png" srcset="/img/loading.gif" alt="Dino状态机"></p><blockquote><p>其中:</p><ul><li>实线为可打断当前状态进行状态转换</li><li>虚线为当前状态执行完毕前不可打断</li></ul></blockquote><p><strong>需求：</strong>6张美术素材<br>小恐龙共需要6张美术素材用于制作帧动画，其中跳跃帧和开始帧可共用一张</p><h4 id="2-1-2-2-翼龙动画分析"><a href="#2-1-2-2-翼龙动画分析" class="headerlink" title="2.1.2.2 翼龙动画分析"></a>2.1.2.2 翼龙动画分析</h4><p><strong>状态分析：</strong><br>仅需要一种状态</p><ul><li>奔跑状态 2帧</li></ul><p><strong>需求：</strong>2张美术素材<br>翼龙共需要2张美术素材</p><h3 id="2-1-3-障碍实体动态生成分析"><a href="#2-1-3-障碍实体动态生成分析" class="headerlink" title="2.1.3 障碍实体动态生成分析"></a>2.1.3 障碍实体动态生成分析</h3><p>障碍实体应当动态生成在陆地实体上，而陆地实体也是动态生成的，所以这两者用预制体实现比较合适。</p><p><strong>障碍实体动态生成需求：</strong></p><ul><li>随机生成种类</li><li>随机生成个数</li><li>随机生成的障碍实体的碰撞体积要与种类相关有所变化</li></ul><p><strong>陆地实体动态生成需求：</strong></p><ul><li>同一时间游戏内应当有三个陆地实体<ul><li>正在运行的陆地实体 (1个)</li><li>准备运行的陆地实体 (2个)</li></ul></li><li>运行到指定位置自动销毁</li><li>运行到指定位置自动启动下一个陆地实体</li><li>陆地上动态生成的障碍实体数量应该在0-2之间随机</li><li>陆地上动态生成的障碍实体的位置应该是固定的<br>如果随机位置，容易挨在一起造成死局</li><li>陆地的运动速度应该随着分数的提高而提高</li></ul><h3 id="2-1-4-背景墙分析"><a href="#2-1-4-背景墙分析" class="headerlink" title="2.1.4 背景墙分析"></a>2.1.4 背景墙分析</h3><p><strong>背景墙需求：</strong></p><ul><li>是个时间环，通过转动来展示昼夜变化</li><li>时间环的转动要与灯光配合，展示昼夜光线变化</li></ul><h2 id="2-2-美术需求分析"><a href="#2-2-美术需求分析" class="headerlink" title="2.2 美术需求分析"></a>2.2 美术需求分析</h2><p><strong>美术风格：</strong><br>彩色像素风格</p><p><strong>美术需求清单：</strong>(按优先级排序)</p><ol><li>小恐龙的六张帧序列用于制作各种状态的动画</li><li>多种障碍实体(详见实体分析)<ul><li>仙人掌 十张</li><li>翼龙 两张</li></ul></li><li>陆地</li><li>背景时间环</li><li>各种UI制作</li><li>游戏LOGO</li></ol><h2 id="2-3-UI需求分析"><a href="#2-3-UI需求分析" class="headerlink" title="2.3 UI需求分析"></a>2.3 UI需求分析</h2><h3 id="2-3-1-UI需求树"><a href="#2-3-1-UI需求树" class="headerlink" title="2.3.1 UI需求树"></a>2.3.1 UI需求树</h3><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909231310761.png" srcset="/img/loading.gif" alt="UI需求树"></p><h3 id="2-3-2-细节需求"><a href="#2-3-2-细节需求" class="headerlink" title="2.3.2 细节需求"></a>2.3.2 细节需求</h3><ul><li><p>开始界面</p><ul><li>三个主要按钮需要支持键盘选择</li><li>三个主要按钮需要支持选中提示(键盘与鼠标)</li></ul></li><li><p>游戏界面</p><ul><li>当前分数需要实时刷新</li><li>最佳分数在每次开始游戏时需要读取</li></ul></li><li><p>游戏失败界面</p><ul><li>当玩家取得更高的分数时，需要弹出提示并保存新最佳分数</li></ul></li></ul><h2 id="2-4-音效分析"><a href="#2-4-音效分析" class="headerlink" title="2.4 音效分析"></a>2.4 音效分析</h2><ul><li>游戏BGM<br>8bit音乐</li><li>小恐龙音效<ul><li>跳跃音效</li><li>死亡音效</li></ul></li><li>游戏音效<ul><li>开始游戏音效</li><li>每百分音效</li><li>新分数音效</li></ul></li></ul><p>共需要8bit风格音效6段。</p><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h1><h2 id="3-1-工程类图"><a href="#3-1-工程类图" class="headerlink" title="3.1 工程类图"></a>3.1 工程类图</h2><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/Dino%E5%B7%A5%E7%A8%8B%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="Dino工程类图"></p><h2 id="3-2-UI实现"><a href="#3-2-UI实现" class="headerlink" title="3.2 UI实现"></a>3.2 UI实现</h2><p><strong>开始界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160306730.png" srcset="/img/loading.gif" alt="image-20210910160306730"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910153817356.png" srcset="/img/loading.gif" alt="开始界面"></p><p><strong>关于界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160422573.png" srcset="/img/loading.gif" alt="image-20210910160422573"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154143211.png" srcset="/img/loading.gif" alt="关于界面"></p><p><strong>游戏界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160454308.png" srcset="/img/loading.gif" alt="image-20210910160454308"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910153929870.png" srcset="/img/loading.gif" alt="游戏界面"></p><p><strong>暂停界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160519755.png" srcset="/img/loading.gif" alt="image-20210910160519755"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154116353.png" srcset="/img/loading.gif" alt="暂停界面"></p><p><strong>失败界面UI：</strong></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910160553087.png" srcset="/img/loading.gif" alt="image-20210910160553087"></p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910154015705.png" srcset="/img/loading.gif" alt="失败界面"></p><h2 id="3-3-技术实现亮点与难点"><a href="#3-3-技术实现亮点与难点" class="headerlink" title="3.3 技术实现亮点与难点"></a>3.3 技术实现亮点与难点</h2><h3 id="3-3-1-开始界面UI的多种响应方式"><a href="#3-3-1-开始界面UI的多种响应方式" class="headerlink" title="3.3.1 开始界面UI的多种响应方式"></a>3.3.1 开始界面UI的多种响应方式</h3><h4 id="3-3-1-1-效果描述"><a href="#3-3-1-1-效果描述" class="headerlink" title="3.3.1.1 效果描述"></a>3.3.1.1 效果描述</h4><p>根据UI需求分析中的细节部分对于开始界面UI的描述，我们可以知道，该UI需要支持三种操作方式：</p><ul><li>鼠标操作</li><li>键盘方向键操作</li><li>移动端触摸操作</li></ul><p>其中鼠标操作与键盘方向键操作时，会有一个选中的按钮变色的效果。</p><p><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910163606363.png" srcset="/img/loading.gif" alt="image-20210910163606363"><br>当使用键盘选中about按钮或者光标落在上面时，颜色变浅。</p><p>该效果实现的难点主要在鼠标与键盘两种操作方式上，移动端的触摸输入使用普通的按钮响应函数即可</p><h4 id="3-3-1-2-键盘方向键操作"><a href="#3-3-1-2-键盘方向键操作" class="headerlink" title="3.3.1.2 键盘方向键操作"></a>3.3.1.2 键盘方向键操作</h4><p>在该操作模式下，会默认选中第一个Start Game按钮并使其变色，按上下键可以变更选中的按钮。</p><p>想要实现这种效果，我想到了使用双向循环链表，将三个按钮按顺序放入循环链表中，每次按下方向就到下一个节点的按钮，以此类推。</p><p>在C#中，可以使用LinkedList(双向链表)加一点小改动，就能成满足我们需求的双向循环链表，代码如下：</p><p><strong>初始化双向循环链表：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//循环链表，里面装的是每个按钮的背景图片组件</span><br><span class="hljs-keyword">private</span> LinkedList&lt;Image&gt; startPageBtnImg;<br><span class="hljs-comment">//当前选中的链表节点</span><br><span class="hljs-keyword">private</span> LinkedListNode&lt;Image&gt; onBtnImg;<br><span class="hljs-comment">//普通按钮背景图片精灵</span><br><span class="hljs-keyword">private</span> Sprite btnBGSprite;<br><span class="hljs-comment">//被选中的按钮背景图片精灵</span><br><span class="hljs-keyword">private</span> Sprite onBtnBGSprite;<br><br><span class="hljs-comment">// 初始化循环链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initBtnLinkedList</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    startPageBtnImg = <span class="hljs-keyword">new</span> LinkedList&lt;Image&gt;();<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;StartBtn&quot;</span>).GetComponent&lt;Image&gt;());<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;AboutBtn&quot;</span>).GetComponent&lt;Image&gt;());<br>startPageBtnImg.AddLast(GameObject.Find(<span class="hljs-string">&quot;ExitBtn&quot;</span>).GetComponent&lt;Image&gt;());<br><span class="hljs-comment">//设置当前选中的按钮为 StartBtn</span><br>onBtnImg = startPageBtnImg.First;<br>&#125;<br><br><span class="hljs-comment">// 玩家键盘输入监听函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.Return))<br>        OnTheBtn();<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.UpArrow))<br>        lastBtn();<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.DownArrow))<br>        nextBtn();<br>&#125;<br><br><span class="hljs-comment">// 按钮的切换函数</span><br><span class="hljs-comment">// 按下下方向箭头时选中下一个按钮并更改按钮背景</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    onBtnImg.Value.sprite = btnBGSprite;<span class="hljs-comment">//将当前按钮背景图改为普通背景图</span><br>    onBtnImg = onBtnImg.Next;<span class="hljs-comment">//将当前被选中按钮改为下一个按钮</span><br>    <span class="hljs-keyword">if</span> (onBtnImg == <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果倒了链表尾</span><br>        onBtnImg = startPageBtnImg.First;<span class="hljs-comment">//手动循环链表</span><br>    onBtnImg.Value.sprite = onBtnBGSprite;<span class="hljs-comment">//将更改后的选中按钮的背景图改为选中背景图</span><br>&#125;<br><span class="hljs-comment">// 按下上方向箭头时选中上一个按钮并更改按钮背景</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    onBtnImg.Value.sprite = btnBGSprite;<br>    onBtnImg = onBtnImg.Previous;<br>    <span class="hljs-keyword">if</span> (onBtnImg == <span class="hljs-literal">null</span>)<span class="hljs-comment">//手动循环链表</span><br>        onBtnImg = startPageBtnImg.Last;<br>    onBtnImg.Value.sprite = onBtnBGSprite;<br>&#125;<br><br><span class="hljs-comment">// 按钮执行的函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTheBtn</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">string</span> btnName = onBtnImg.Value.gameObject.name;<br><span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">&quot;StartBtn&quot;</span>)<br>        OnStartGame();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (btnName == <span class="hljs-string">&quot;AboutBtn&quot;</span>)<br>        OnAboutGame();<br>    <span class="hljs-keyword">else</span><br>        OnExitGame();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-1-3-鼠标操作模式"><a href="#3-3-1-3-鼠标操作模式" class="headerlink" title="3.3.1.3 鼠标操作模式"></a>3.3.1.3 鼠标操作模式</h4><p>在鼠标操作模式下，则需要使鼠标放在哪个按钮上，哪个按钮就成为选中按钮。<br>所以实现的关键就在于检测鼠标是否在按钮上，鼠标在哪个按钮上。</p><p>这就需要用到Unity封装好的一些UI事件接口了。<br>详细内容可以看：<a href="https://mycroftcooper.github.io/2021/09/07/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/">UI事件接口</a></p><p>在这里需要用到的只有两个接口：</p><ul><li><strong>IPointerEnterHandler</strong><br>鼠标移入对象时触发响应函数</li><li><strong>IPointerExitHandler</strong><br>鼠标移出对象时触发响应函数</li></ul><p>因为这两个接口是面对对象的，使用应该写一个脚本挂到对应的按钮上去。<br>脚本代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StartPageBtnController</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerEnterHandler</span>, <span class="hljs-title">IPointerExitHandler</span><br>&#123;<br>    <span class="hljs-comment">//UI控制器，管理所有按钮响应函数</span><br>    UIManager UIM;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; UIM = GameObject.Find(<span class="hljs-string">&quot;UI&quot;</span>).GetComponent&lt;UIManager&gt;();<br>    <span class="hljs-comment">// 鼠标移入按钮时触发该响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerEnter</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"><span class="hljs-comment">// 将该按钮的背景图片组件发送至UI控制器</span></span><br><span class="hljs-function"></span>        =&gt; UIM.setSelectBtn(gameObject.GetComponent&lt;Image&gt;());<br><span class="hljs-comment">// 鼠标移出按钮时触发该响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerExit</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>        =&gt; UIM.setSelectBtn(<span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将这个写好的StartPageBtnController挂在到需要该功能的那三个按钮上后，再去UI控制器里编写响应函数setSelectBtn。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSelectBtn</span>(<span class="hljs-params">Image btnImg</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (btnImg == onBtnImg.Value)<span class="hljs-comment">//如果选中按钮没变，就啥也不干</span><br>        <span class="hljs-keyword">return</span>;<br>    onBtnImg.Value.sprite = btnBGSprite;<span class="hljs-comment">//先将当前的选中按钮背景图复原</span><br>    <span class="hljs-keyword">if</span> (btnImg != <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果没有按钮被选中，就选中默认按钮</span><br>    &#123;<br>        onBtnImg = startPageBtnImg.Find(btnImg);<br>        onBtnImg.Value.sprite = onBtnBGSprite;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//有选中按钮，就把选中的按钮赋值给当前选中按钮节点</span><br>    &#123;<br>        onBtnImg = startPageBtnImg.First;<br>        onBtnImg.Value.sprite = onBtnBGSprite;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个功能就这样实现了。</p><h3 id="3-3-2-动画器与状态机的使用"><a href="#3-3-2-动画器与状态机的使用" class="headerlink" title="3.3.2 动画器与状态机的使用"></a>3.3.2 动画器与状态机的使用</h3><h4 id="3-3-2-1-状态机的设置"><a href="#3-3-2-1-状态机的设置" class="headerlink" title="3.3.2.1 状态机的设置"></a>3.3.2.1 状态机的设置</h4><p>根据实体分析中对小恐龙Dino的状态机分析图(下图)<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210909223752586.png" srcset="/img/loading.gif" alt="Dino状态机"></p><p>可以在Unity中制作动画器，并设置好状态机<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910201330605.png" srcset="/img/loading.gif" alt="动画器"></p><p>动画转变的判断参数是 int DinoState</p><h4 id="3-3-2-2-代码实现"><a href="#3-3-2-2-代码实现" class="headerlink" title="3.3.2.2 代码实现"></a>3.3.2.2 代码实现</h4><p>将动画器结合使用简单状态模式的脚本DinoController一起使用，就完成了对小恐龙的状态控制与动画播放。<br>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DinoController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> DinoState &#123; Start, Run, Jump, Down, Dead &#125;<br>    <span class="hljs-comment">//小恐龙状态：0:开始 1:跑 2:跳 3:低头 4:死亡</span><br>    <span class="hljs-keyword">public</span> DinoState state;<br>    <span class="hljs-comment">// 利用属性来完成简单的状态改变响应函数</span><br>    <span class="hljs-keyword">public</span> DinoState State<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            state = (DinoState)animator.GetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>);<br>            <span class="hljs-keyword">return</span> state; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            state = <span class="hljs-keyword">value</span>;<br>            animator.SetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>, (<span class="hljs-built_in">int</span>)<span class="hljs-keyword">value</span>);<br>            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">value</span>)<br>            &#123;<br>                <span class="hljs-keyword">case</span> DinoState.Run:<br>                    run();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Jump:<br>                    jump();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Down:<br>                    down();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> DinoState.Dead:<br>                    dead();<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> GameController GC;<br>    <span class="hljs-keyword">public</span> Animator animator;<br>    <span class="hljs-keyword">private</span> List&lt;Vector3&gt; dinoBoxColliderSize<br>        = <span class="hljs-keyword">new</span> List&lt;Vector3&gt; &#123; <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">2.5f</span>, <span class="hljs-number">3f</span>, <span class="hljs-number">1f</span>), <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">4f</span>, <span class="hljs-number">2f</span>, <span class="hljs-number">1f</span>) &#125;;<br>    <span class="hljs-keyword">public</span> Rigidbody dinoRigidbody;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        GC = GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;GameController&gt;();<br>        animator = gameObject.GetComponent&lt;Animator&gt;();<br>        dinoRigidbody = gameObject.GetComponent&lt;Rigidbody&gt;();<br>    &#125;<br>    <span class="hljs-comment">// 监听用户输入来改变小恐龙状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (GC.gameState != <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.UpArrow))<br>            State = DinoState.Jump;<br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.DownArrow))<br>            State = DinoState.Down;<br>        <span class="hljs-keyword">if</span> (Input.GetKeyUp(KeyCode.DownArrow))<br>            State = DinoState.Run;<br>    &#125;<br><br>    <span class="hljs-comment">// 当状态改变后更改小恐龙碰撞体积</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBoxCollider</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDown</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        BoxCollider bc = gameObject.GetComponent&lt;BoxCollider&gt;();<br>        <span class="hljs-keyword">if</span> (isDown)<br>            bc.size = dinoBoxColliderSize[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span><br>            bc.size = dinoBoxColliderSize[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-comment">//状态改变响应函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; setBoxCollider(<span class="hljs-literal">false</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jump</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (transform.position.y &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        setBoxCollider(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; setBoxCollider(<span class="hljs-literal">true</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dead</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        =&gt; dinoRigidbody.isKinematic = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 碰撞检测响应函数，发送碰撞后将小恐龙状态设置为死亡</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collisionInfo</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (collisionInfo.gameObject.name == <span class="hljs-string">&quot;LandPrefab&quot;</span> || collisionInfo.gameObject.name == <span class="hljs-string">&quot;LandPrefab(Clone)&quot;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        State = DinoState.Dead;<br>        GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;GameController&gt;().GameOver(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-3-需要注意的点"><a href="#3-3-2-3-需要注意的点" class="headerlink" title="3.3.2.3 需要注意的点"></a>3.3.2.3 需要注意的点</h4><h5 id="状态的可打断性："><a href="#状态的可打断性：" class="headerlink" title="状态的可打断性："></a>状态的可打断性：</h5><p>在状态机分析图中分两种箭头：</p><ul><li>实线箭头<br>该状态的转换过程可以打断当前状态</li><li>虚线箭头<br>该状态的转换过程不可以打断当前状态，只能等当前状态的动画播放完毕才能进行状态转换</li></ul><p>想在Unity的状态机中实现这种设定，需要更改<strong>有退出时间</strong>属性：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910203147899.png" srcset="/img/loading.gif" alt="image-20210910203147899"></p><ul><li>可打断则不勾选</li><li>不可打断则勾选</li></ul><blockquote><p>如果不做此调整会导致用户输入被延迟到状态动画播放完后执行，导致输入延迟验证，影响玩家体验</p></blockquote><h5 id="状态的自动转换："><a href="#状态的自动转换：" class="headerlink" title="状态的自动转换："></a>状态的自动转换：</h5><p>当跳远状态的动画播放完毕后，应当自动切换至奔跑状态。</p><p>为了实现这个功能，就需要使用动画的回调函数接口了。<br>详细可以阅读我的个人博客：[Unity-动画-回调函数接口](<a href="https://mycroftcooper.github.io/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"> - Mycroft’s Blog (mycroftcooper.github.io)</a>****)</p><p>而在这里只需要使用两个个接口：</p><ul><li><p><strong>OnStateEnter</strong><br>进入该状态时调用</p></li><li><p><strong>OnStateExit</strong><br>在该状态结束退出时调用</p></li></ul><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JumpCallBack</span> : <span class="hljs-title">StateMachineBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// 进入该状态时播放跳跃音效</span><br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateEnter</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        GameObject.Find(<span class="hljs-string">&quot;GameController&quot;</span>).GetComponent&lt;SoundsController&gt;().PlayVoice(<span class="hljs-string">&quot;Sounds/Jump&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 退出该状态时自动转换到奔跑状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateUpdate</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">int</span> stateIndex = animator.GetInteger(<span class="hljs-string">&quot;DinoState&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateIndex != <span class="hljs-number">1</span> &amp;&amp; stateIndex != <span class="hljs-number">4</span>)<br>            GameObject.Find(<span class="hljs-string">&quot;DinoPrefab&quot;</span>).GetComponent&lt;DinoController&gt;().State = DinoController.DinoState.Run;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将该脚本挂到状态机中对应的状态(Run)上，就实现了目标</p><h5 id="按键连续按下时状态的连贯性："><a href="#按键连续按下时状态的连贯性：" class="headerlink" title="按键连续按下时状态的连贯性："></a>按键连续按下时状态的连贯性：</h5><p>当玩家连续按下跳跃键时，小恐龙应该持续保持在跳跃状态<br>当玩家持续按下低头键时，小恐龙应该持续保持在低头状态</p><p>要想实现这两个功能，这就需要用到Unity封装好的一些UI事件接口了。<br>详细内容可以看：<a href="https://mycroftcooper.github.io/2021/09/07/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/">UI事件接口</a></p><p>在这里需要用到的只有两个接口：</p><ul><li><strong>IPointerDownHandler</strong><br>鼠标在对象范围内按下时触发响应函数</li><li><strong>IPointerUpHandler</strong><br>鼠标在对象范围内抬起时触发响应函数</li></ul><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GamePageBtnController</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span><br>&#123;<br>    <span class="hljs-keyword">private</span> DinoController DC;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isDown = <span class="hljs-literal">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    =&gt; DC = GameObject.Find(<span class="hljs-string">&quot;DinoPrefab&quot;</span>).GetComponent&lt;DinoController&gt;();<br><br>    <span class="hljs-comment">// 按钮按下回调函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>        =&gt; isDown = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 按钮松开回调函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        isDown = <span class="hljs-literal">false</span>;<br>        DC.State = DinoController.DinoState.Run;<br>    &#125;<br><br>    <span class="hljs-comment">//每帧检测是否按钮按下</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span>(isDown)<br>        &#123;<br>            <span class="hljs-comment">//判断按钮种类，根据种类改变小恐龙状态</span><br>            <span class="hljs-keyword">if</span> (gameObject.name == <span class="hljs-string">&quot;UpBtn&quot;</span>)<br>                DC.State = DinoController.DinoState.Jump;<br>            <span class="hljs-keyword">if</span> (gameObject.name == <span class="hljs-string">&quot;DownBtn&quot;</span>)<br>                DC.State = DinoController.DinoState.Down;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了以上代码，就可以正常实现功能了</p><h3 id="3-3-3-背景时间环与灯光的配合"><a href="#3-3-3-背景时间环与灯光的配合" class="headerlink" title="3.3.3 背景时间环与灯光的配合"></a>3.3.3 背景时间环与灯光的配合</h3><h4 id="3-3-3-1-效果描述"><a href="#3-3-3-1-效果描述" class="headerlink" title="3.3.3.1 效果描述"></a>3.3.3.1 效果描述</h4><p>根据实体分析中对背景时间环的分析可以知道，时间环以一定的速度转动来表达昼夜变化。而想用灯光来配合时间环的转动，来将昼夜变化更加自然的体现出来。</p><p>灯光主要可以通过以下两个方面来体现时间的变化：</p><ul><li>光照强度<ul><li>正午时光照强度最强</li><li>午夜时光照强度最弱</li></ul></li><li>光照颜色<ul><li>正午时光照颜色为橘黄色</li><li>午夜时光照颜色为暗蓝色</li></ul></li></ul><p>光照的变化应当是随着背景时间环而渐变的。</p><p>表现如下图所示：<br><strong>正午时：</strong><br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910183325819.png" srcset="/img/loading.gif" alt="image-20210910183325819"></p><p><strong>午夜时：</strong><br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910183450256.png" srcset="/img/loading.gif" alt="image-20210910183450256"></p><h4 id="3-3-3-2-解决思路"><a href="#3-3-3-2-解决思路" class="headerlink" title="3.3.3.2 解决思路"></a>3.3.3.2 解决思路</h4><p>背景时间环是一直在转动的，可以根据当前的转动角度来决定灯光的强度与颜色属性。<br>分析可得以下映射表：</p><table><thead><tr><th>时间</th><th>角度a</th><th>灯光强度s</th><th>灯光颜色c</th></tr></thead><tbody><tr><td>正午</td><td>0°</td><td>1.5</td><td>255，244，214</td></tr><tr><td>午夜</td><td>-180°</td><td>0.25</td><td>144，259，204</td></tr></tbody></table><p>可以看出输入值是角度，输出值是灯光强度与灯光颜色，而这两个输出值都是在一定范围内周期性变化。<br>由此可想到使用三角函数公式。</p><p><strong>灯光强度公式如下：</strong><br>$s=0.625cos(a)+0.65$</p><p>因为开始旋转角度为0时是正午，灯光强度为最大值1.5，所以使用cos函数<br>其中振幅A = 0.625 是根据(1.5-0.25)/2得到的。</p><h4 id="3-3-3-3-代码实现"><a href="#3-3-3-3-代码实现" class="headerlink" title="3.3.3.3 代码实现"></a>3.3.3.3 代码实现</h4><p>时间环控制代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TimeRingController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> LightController LC;<br>    <span class="hljs-keyword">public</span> Vector3 playSpeed;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isDayTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> isPlaying;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsDayTime &#123; <span class="hljs-keyword">get</span> =&gt; isDayTime; <span class="hljs-keyword">set</span> =&gt; setTime(<span class="hljs-keyword">value</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> IsPlaying &#123; <span class="hljs-keyword">get</span> =&gt; isPlaying; <span class="hljs-keyword">set</span> =&gt; isPlaying = <span class="hljs-keyword">value</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        LC = GameObject.Find(<span class="hljs-string">&quot;Light&quot;</span>).GetComponent&lt;LightController&gt;();<br>        isDayTime = <span class="hljs-literal">true</span>;<br>        isPlaying = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//转动时间环函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (isPlaying)<br>        &#123;<br>            transform.Rotate(playSpeed, Space.Self);<br>            <span class="hljs-comment">//根据当前角度设置灯光属性</span><br>            LC.setTimeByAngle(transform.rotation.eulerAngles.z);<br>        &#125;<br>            <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDayTime</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.isDayTime = isDayTime;<br>        <span class="hljs-keyword">if</span> (isDayTime)<br>        &#123;<br>            transform.rotation = Quaternion.Euler(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>            LC.setTime(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            transform.rotation = Quaternion.Euler(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">180</span>, <span class="hljs-number">0</span>));<br>            LC.setTime(<span class="hljs-literal">false</span>);<br>        &#125;<br>            <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>灯光控制代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LightController</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Light theLight;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> maxInstensity;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> minInstensity;<br>    <span class="hljs-keyword">public</span> Color dayTimeColor;<br>    <span class="hljs-keyword">public</span> Color nightTimeColor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> speed;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        theLight = gameObject.GetComponent&lt;Light&gt;();<br>    &#125;<br>    <span class="hljs-comment">//三角函数的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> <span class="hljs-title">trigonometric</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> min, <span class="hljs-built_in">float</span> max,<span class="hljs-built_in">float</span> angle</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-built_in">float</span> rad = angle * Mathf.Deg2Rad;<br>        <span class="hljs-built_in">float</span> A = (max - min) / <span class="hljs-number">2.0f</span>;<br>        <span class="hljs-built_in">float</span> fai = min + A;<br>        <span class="hljs-keyword">return</span> A * Mathf.Cos(rad) + fai;<br>    &#125;<br>    <span class="hljs-comment">//根据角度转换灯光属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTimeByAngle</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> angle</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        theLight.intensity = trigonometric(minInstensity,maxInstensity,angle);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">100</span>&lt;angle &amp;&amp; angle&lt;<span class="hljs-number">200</span>)<br>            theLight.color = nightTimeColor;<br>        <span class="hljs-keyword">else</span><br>            theLight.color = dayTimeColor;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTime</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> isDayTime</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (isDayTime)<br>        &#123;<br>            theLight.intensity = maxInstensity;<br>            theLight.color = dayTimeColor;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            theLight.intensity = minInstensity;<br>            theLight.color = nightTimeColor;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-3-4-需要注意的点"><a href="#3-3-3-4-需要注意的点" class="headerlink" title="3.3.3.4 需要注意的点"></a>3.3.3.4 需要注意的点</h4><ul><li>GameObject的transform.rotation属性是四元数，得转换为欧拉角然后再转换为弧度制才能使用</li><li>2D精灵是无法对3D的灯光有反应的<br>因为2D精灵使用的是默认的2D图片材质<br>想要让3D灯光在2D精灵图片上有效果，需要自定义材质<br>如下图所示：<br><img src="/images/DinoParkour%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/image-20210910200427517.png" srcset="/img/loading.gif" alt="image-20210910200427517"><br>其中渲染模式(RenderingMode)要设置为：Cutout，其它设置根据需求进行更改。</li></ul><h3 id="3-3-4-不同画面比的自适应匹配"><a href="#3-3-4-不同画面比的自适应匹配" class="headerlink" title="3.3.4 不同画面比的自适应匹配"></a>3.3.4 不同画面比的自适应匹配</h3><h4 id="3-3-4-1-效果描述"><a href="#3-3-4-1-效果描述" class="headerlink" title="3.3.4.1 效果描述"></a>3.3.4.1 效果描述</h4><p>当游戏打包发布到安卓端时，需要解决目前市场上各式各样屏幕比例的自适应问题。<br>UI方面只要在编辑器中设置好就问题不大，主要是游戏实体的缩放与生成和销毁位置的问题。</p><p>需求如下：</p><ul><li>陆地块的生成位置必须在屏幕外</li><li>陆地块的开始运动位置必须在屏幕右侧边缘</li><li>陆地块运动至屏幕外需要销毁</li><li>陆地块右侧边缘位于屏幕右侧边缘时，需要启动下一个陆地块</li><li>时间环无论在什么屏幕下都应该充满背景</li></ul><h4 id="3-3-4-2-代码实现"><a href="#3-3-4-2-代码实现" class="headerlink" title="3.3.4.2 代码实现"></a>3.3.4.2 代码实现</h4><p>想要实现如上需求，就必须要知道屏幕的边缘在哪里，也就是将屏幕的边缘坐标从屏幕坐标转化为世界坐标。可以通过如下代码实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> leftBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> rightBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> topBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> downBorder;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> height;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> width;<br><span class="hljs-keyword">public</span> Vector3 scale;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBorder</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//世界坐标的右上角  因为视口坐标右上角是1,1,点</span><br>    Vector3 cornerPos = Camera.main.ViewportToWorldPoint(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>,Mathf.Abs(-Camera.main.transform.position.z)));<br>    <span class="hljs-comment">//世界坐标左边界</span><br>    leftBorder = Camera.main.transform.position.x - (cornerPos.x - Camera.main.transform.position.x);<br>    <span class="hljs-comment">//世界坐标右边界</span><br>    rightBorder = cornerPos.x;<br>    <span class="hljs-comment">//世界坐标上边界</span><br>    topBorder = cornerPos.y;<br>    <span class="hljs-comment">//世界坐标下边界</span><br>    downBorder = Camera.main.transform.position.y - (cornerPos.y - Camera.main.transform.position.y);<br>    width = rightBorder - leftBorder;<br>    height = topBorder - downBorder;<br>    <span class="hljs-comment">//在默认比例:16:9下的宽高</span><br>    <span class="hljs-built_in">float</span> deffultH = <span class="hljs-number">13.85643f</span>;<br>    <span class="hljs-built_in">float</span> deffultW = <span class="hljs-number">24.60183f</span>;<br>    <span class="hljs-comment">//缩放求出比例</span><br>    scale = <span class="hljs-keyword">new</span> Vector3(width/deffultW, height/deffultH, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>把上述代码挂在到摄像机上，当摄像机就位后运行，就能得到：</p><ul><li>画面四个边界的世界坐标</li><li>当前画面比例下与默认画面比例的缩放比</li></ul><p>其中物体运行到视野外销毁还可以使用另一种方法：<br>使用 <strong>OnBecameInvisible()</strong> 函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//物体进入视野内触发响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBecameVisible</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-comment">//物体离开视野内触发响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBecameInvisible</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="4-附录"><a href="#4-附录" class="headerlink" title="4. 附录"></a>4. 附录</h1><p>GitHub链接：<a href="https://github.com/MycroftCooper/DinoParkour">https://github.com/MycroftCooper/DinoParkour</a></p>]]></content>
    
    
    <categories>
      
      <category>项目开发文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGUI详解-事件接口</title>
    <link href="/2021/09/10/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/09/10/Unity-UGUI-%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>UGUI 系统虽然提供了很多封装好的组件，但是要实现一些特定的功能还是显得非常有限，这时候就需要使用事件接口来完成UI功能的实现。</p><p>比如我们想实现鼠标移动到图片上时自动显示图片的文字介绍，一般思路会想到写个射线来检测。<br>但其实这样的检测UGUI已经替我们完成了，我们只需要实现检测到目标对象后所要执行的代码即可！</p><p><strong>事件系统：UnityEngine.EventSystems;</strong></p><p>UI 组件都是基于 UGUI 封装好的类和接口以及一些 Editor 文件来进行封装制作供开发者使用的，开发者利用这些封装好的工具，只需更专注于功能开发即可。</p><h1 id="2-事件系统的前置条件"><a href="#2-事件系统的前置条件" class="headerlink" title="2. 事件系统的前置条件"></a>2. 事件系统的前置条件</h1><h2 id="2-1-使用该事件系统的条件"><a href="#2-1-使用该事件系统的条件" class="headerlink" title="2.1 使用该事件系统的条件"></a>2.1 使用该事件系统的条件</h2><ul><li>对象必须是 Canvas 的子对象；</li><li>对象必须有 Rect 范围；</li><li>鼠标的操作不分左键 中键 右键；</li></ul><h2 id="2-2-事件触发条件"><a href="#2-2-事件触发条件" class="headerlink" title="2.2 事件触发条件"></a>2.2 事件触发条件</h2><ul><li><p>对象或其子对象所附加的 UI 组件含有 Raycast Target 属性（为 true）</p></li><li><p>鼠标光标进入该对象的 Rect 范围时</p></li></ul><h2 id="2-3-事件系统的特殊情况"><a href="#2-3-事件系统的特殊情况" class="headerlink" title="2.3 事件系统的特殊情况"></a>2.3 事件系统的特殊情况</h2><ul><li><p><strong>若：</strong>该对象实现事件接口，而其子对象所附加的 UI 组件含有 Raycast Target         属性且没有实现事件接口<br><strong>则：</strong>只有该对象会触发事件，而其子对象不会触发事件</p></li><li><p><strong>当：</strong>该对象和其子对象同时具有触发事件接口的条件时：<br><strong>若：</strong>该对象的 Rect 范围被其子对象的 Rect 范围完全覆盖掉<br><strong>则：</strong>该对象不会触发事件，只有其子对象会触发事件。</p></li></ul><h1 id="3-事件接口一览"><a href="#3-事件接口一览" class="headerlink" title="3. 事件接口一览"></a>3. 事件接口一览</h1><ul><li><p><strong>IPointerEnterHandler</strong></p><p><strong>功能：</strong><br>鼠标移入对象时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerEnter</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerExitHandler</strong><br><strong>功能：</strong><br>鼠标移出对象时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerExit</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerDownHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IPointerUpHandler</strong><br><strong>功能</strong>：<br>鼠标在对象范围内抬起时触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>无论鼠标在何处抬起（即不在A对象中）都会在A对象中响应此事件</li><li>响应此事件的前提是A对象必须响应过OnPointerDown事件</li></ul></blockquote></li><li><p><strong>IPointerClickHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下并抬起后触发响应函数</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerClick</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>按下和抬起时鼠标要处于同一对象上</p></blockquote></li><li><p><strong>IDragHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下并拖拽时，对象每帧响应一次此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>如果不实现此接口，则后面的四个接口方法都不会触发</p></blockquote></li><li><p><strong>IInitializePotentialDragHandler</strong><br><strong>功能：</strong><br>鼠标在对象范围内按下还没开始拖拽时，对象响应此事件</p><blockquote><p>与IPointerDownHandler接口事件类似</p></blockquote><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInitializePotentialDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IBeginDragHandler</strong><br><strong>功能：</strong><br>当鼠标在对象范围内按下并开始拖拽时，对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnBeginDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：<br>此事件在OnInitializePotentialDrag之后响应 OnDrag之前响应</p></blockquote></li><li><p><strong>IEndDragHandler</strong><br><strong>功能：</strong><br>当鼠标完成拖拽抬起时，对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEndDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>IDropHandler</strong><br><strong>功能：</strong><br>当鼠标从A对象上开始拖拽，在B对象上抬起时，B对象响应此事件</p><p><strong>实现方法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrop</span>(<span class="hljs-params">PointerEventData eventData</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><pre><code>A、B对象必须均实现IDropHandler接口，且A至少实现IDragHandler接口</code></pre></li><li><pre><code>此时eventData.pointerDrag.name获取到的是B对象的name属性</code></pre></li><li><pre><code>eventData.pointerDrag表示发起拖拽的对象（GameObject）</code></pre></li></ul></blockquote></li></ul><h1 id="4-参考链接"><a href="#4-参考链接" class="headerlink" title="4. 参考链接"></a>4. 参考链接</h1><p>总结整理自：<br><a href="https://blog.csdn.net/eazey_wj/article/details/65632664">https://blog.csdn.net/eazey_wj/article/details/65632664</a></p><p>他这还有很多案例和代码，建议去看看</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>UGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>UGUI</tag>
      
      <tag>事件接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-动画-回调函数接口</title>
    <link href="/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/09/07/Unity-%E5%8A%A8%E7%94%BB-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>当你想在状态机的某个状态执行中干些什么的时候(增加状态机行为)<br>比如：播放音效，添加粒子特效，增加逻辑代码等等操作。<br>那么就可以试一试Unity封装好的回调函数接口：<strong>StateMachineBehaviour</strong></p><p>想要添加（State machine behaviours）状态机行为到状态或子状态机，可以选中某个状态后在inspector中的Add Behaviour按钮。</p><h1 id="2-使用该动画回调接口的前置条件"><a href="#2-使用该动画回调接口的前置条件" class="headerlink" title="2. 使用该动画回调接口的前置条件"></a>2. 使用该动画回调接口的前置条件</h1><ul><li>必须继承StateMachineBehaviour</li><li>脚本必须挂在到状态上</li></ul><h1 id="3-回调函数接口一览"><a href="#3-回调函数接口一览" class="headerlink" title="3. 回调函数接口一览"></a>3. 回调函数接口一览</h1><ul><li><p><strong>OnStateEnter</strong><br>进入该状态时调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateEnter</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateUpdate</strong><br>在该状态下每帧调用<br>(MonoBehaviour Updates 更新后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateUpdate</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateExit</strong><br>在该状态结束退出时调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateExit</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>OnStateMove</strong><br>在Animator.OnAnimatorMove()执行后调用(普通动画开始播放后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateMove</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>用于实现处理和影响根运动的代码</p></blockquote></li><li><p><strong>OnStateIK</strong><br>在Animator.OnAnimatorIK()执行后调用(骨骼动画开始播放后)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStateIK</span>(<span class="hljs-params">Animator animator, AnimatorStateInfo stateInfo, <span class="hljs-built_in">int</span> layerIndex</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="4-参数解释"><a href="#4-参数解释" class="headerlink" title="4. 参数解释"></a>4. 参数解释</h1></li><li><p><strong>Animator animator</strong><br>当前动画器，是这个状态机行为的引用。</p></li><li><p><strong>AnimatorStateInfo stateInfo</strong><br>当前状态的详细信息</p><ul><li>int fullPathHash<br>当前状态的全路径哈希值</li><li>int nameHash<br>当前状态名称的哈希值</li><li>int shortNameHash<br>不包括父层名称的短名称哈希值</li><li>float normalizedTime<br>状态的标准化时间</li><li>float length<br>状态当前已经持续的时间</li><li>float speed<br>动画播放速度(1为正常速度)</li><li>float speedMultiplier<br>动画播放倍速</li><li>int tagHash<br>标签的哈希值</li><li>bool loop<br>当前状态是否循环</li><li>bool IsName(string name)</li><li>bool IsTag(string tag)</li></ul></li><li><p><strong>int layerIndex</strong><br>是状态机行为状态的layer 层</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>动画</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动画</tag>
      
      <tag>Unity</tag>
      
      <tag>接口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-射线检测</title>
    <link href="/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/"/>
    <url>/2021/09/04/Unity-%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>射线是3D世界中一个点向一个方向发射的一条无终点的线。在发射的轨迹中，一旦与其他物体发生碰撞，它就会停止。</p><p>在游戏中，射线检测可以有如下用途：</p><ul><li>检测光标位置的三维物体</li><li>检测角色前面的物体（自动开门）</li><li>从空中向下检测（凹凸不平的地形的瞬移）</li><li>测量距离（激光测距）</li></ul><p>等等，可以说是相当重要了。</p><h1 id="2-Ray射线"><a href="#2-Ray射线" class="headerlink" title="2. Ray射线"></a>2. Ray射线</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>要想使用射线检测，就要先定义一条射线。而Ray就是Unity提供的一个封装好的射线结构体。</p><p>一条无穷的线，开始于origin点，朝向direction方向</p><blockquote><p>根据项目验证来看:其默认长度为单位向量，只有对direction进行乘以倍率，才可实现延长射线，而非无穷</p></blockquote><h2 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h2><p>Ray是一个结构体：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Ray</span> (<span class="hljs-params">Vector3 origin,Vector3 direction</span>)</span><br></code></pre></td></tr></table></figure><p>其中参数为：</p><ul><li>Origin： 射线的起点    </li><li>direction：射线的方向</li></ul><p>初始化方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Ray ray = <span class="hljs-keyword">new</span> Ray(Vector3 origin,Vector3 direction)<br></code></pre></td></tr></table></figure><h2 id="2-3-常见用法"><a href="#2-3-常见用法" class="headerlink" title="2.3 常见用法"></a>2.3 常见用法</h2><ul><li><p>从物体中心创建一条指向前方的射线:<br><code>Ray ray = new Ray(transform.position,transform.forward)</code></p></li><li><p>从摄像机产生、指向屏幕上光标的射线<br><code>Ray camerRay = Camera.main.ScreenPointToRay(Input.mousePosition)</code>：。</p><blockquote><p>相机为perspective模式:<br>射线在相机梯形视野内发散；<br>相机为orthoGraphic模式:<br>则为垂直与相机面的直线段;</p></blockquote></li></ul><h1 id="3-RaycastHit-光线投射碰撞信息"><a href="#3-RaycastHit-光线投射碰撞信息" class="headerlink" title="3. RaycastHit 光线投射碰撞信息"></a>3. RaycastHit 光线投射碰撞信息</h1><p><strong>定义：</strong><br>通过射线检测得到的碰撞信息。</p><p>常用信息如下：</p><p><strong>常用参数：</strong></p><ul><li>collider<br>射线检测到的collider，这个非常常用，因为能根据collider.gameObject获取到对应GameObject</li><li>distance<br>射线发射源与检测到的位置的距离</li><li>normal<br>射线碰撞位置的法线</li><li>point<br>射线碰撞位置的世界坐标</li><li>transform<br>射线碰撞物体的transform组件</li></ul><h1 id="4-LayerMask-层级蒙版"><a href="#4-LayerMask-层级蒙版" class="headerlink" title="4. LayerMask 层级蒙版"></a>4. LayerMask 层级蒙版</h1><p><strong>Layer与LayerMask的关系:</strong></p><ul><li>Layer是0-31的数字</li><li>LayerMask是按位对应0-31</li></ul><blockquote><p>如&gt;<br>Layer9：Enemy<br>LayerMask用二进制表示：<br>00000000 00000000 000000<strong>1</strong>0 00000000<br>从右往左第10位，等于表达式：1&lt;&lt;9</p></blockquote><p>这是一种二进制思想，使用mask(掩码)表示时，可以同时表示多个状态的有无。</p><p><strong>根据Layer获取LayerMask:</strong></p><ul><li><p>如果你知道Layer的名字:<br>可以通过LayerMask.GetMask()方法获取<br><code>int mask = LayerMask.GetMask(&quot;Player&quot;, &quot;NPC&quot;);</code></p><blockquote><p>注意这个方法可以传入一个或多个string类型参数。</p></blockquote></li><li><p>如果你知道Layer的数字:<br>比如Layer9，可以通过移位操作1&lt;&lt;9来获取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> playerMask = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">9</span>;<br><span class="hljs-built_in">int</span> npcMask = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span> mask = playerMask | npcMask; <span class="hljs-comment">// 通过位操作“或(|)”同时检测player 和 npc层</span><br><span class="hljs-built_in">int</span> reverse = ~mask; <span class="hljs-comment">// 通过位操作&quot;求反(~)&quot;，检测除了player 和 npc的其他层</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="5-检测方法"><a href="#5-检测方法" class="headerlink" title="5. 检测方法"></a>5. 检测方法</h1><h2 id="5-1-线型检测"><a href="#5-1-线型检测" class="headerlink" title="5.1 线型检测"></a>5.1 线型检测</h2><p>在使用射线检测时，调用的是<code>public static bool Physics.Raycast()</code>函数</p><h3 id="5-1-1-Physics-Raycast-光线投射"><a href="#5-1-1-Physics-Raycast-光线投射" class="headerlink" title="5.1.1 Physics.Raycast 光线投射"></a>5.1.1 Physics.Raycast 光线投射</h3><h4 id="5-1-1-1-功能"><a href="#5-1-1-1-功能" class="headerlink" title="5.1.1.1 功能"></a>5.1.1.1 功能</h4><p>在已有一条射线（也可无）的基础上，使用射线（新建射线）进行一定距离内的定向检测。</p><ul><li>可修改射线长度</li><li>可限制其检测的Layer层</li><li>可得到射线检测到的碰撞信息</li></ul><blockquote><p>仅能检测到<strong>第一个被射线碰撞的物体</strong>，后面的物体无法被检测到</p></blockquote><p><strong>适用场合：</strong><br>配合相机坐标转换实现各类交互</p><h4 id="5-1-1-2-用法"><a href="#5-1-1-2-用法" class="headerlink" title="5.1.1.2 用法"></a>5.1.1.2 用法</h4><p><strong>用法一：</strong></p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br> transform.position, <br>     Vector.forward, <br>     distance, <br>     LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li><p><code>transform.position</code>：<br>从物体中心点起</p></li><li><p><code>Vector.forward</code>：<br>朝向该方向发射一条射线</p></li><li><p><code>distance</code>：<br>该射线长度为distance</p></li><li><p><code>LayerMask.GetMask(&quot;Enemy&quot;)</code>：<br>射线可检测到的层为Enemy层</p></li><li><p>返回bool类型</p></li></ul><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>    transform.position, <br>    Vector.forward, <br>    distance, <br>    <span class="hljs-keyword">out</span> RaycastHitInformation ,<br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)；<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li><li><code>out RaycastHitInformation</code>：<br>将碰撞信息反馈到RaycastHitInformation上</li></ul><p><strong>用法三：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>    MyRay, <br>    distance, <br>    LayerMash.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li><li><code>MyRay</code><br>从已有的射线MyRay出发</li><li><code>distance</code><br>长度延伸至distance</li></ul><p><strong>用法四：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Raycast(<br>MyRay, <br>    <span class="hljs-keyword">out</span> RaycastHitInformation, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>相同参数同上</li></ul><h3 id="5-1-2-Physics-RaycastAll-所有光线投射"><a href="#5-1-2-Physics-RaycastAll-所有光线投射" class="headerlink" title="5.1.2 Physics.RaycastAll 所有光线投射"></a>5.1.2 Physics.RaycastAll 所有光线投射</h3><h4 id="5-1-2-1-功能"><a href="#5-1-2-1-功能" class="headerlink" title="5.1.2.1 功能"></a>5.1.2.1 功能</h4><p>机理用法大致同Raycast，区别在于可检测射线路径上的<strong>所有物体</strong>，<strong>返回RaycastHit[]</strong> 。<br>其他带All后缀的方法也同理</p><p><strong>适用场合：</strong><br>穿透性检测</p><h4 id="5-1-2-2-用法"><a href="#5-1-2-2-用法" class="headerlink" title="5.1.2.2 用法"></a>5.1.2.2 用法</h4><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">RaycastHit[] hits = RaycastAll(<br>    Vector3.zero, <br>    Vector.forward, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">RaycastHit[] hits = RaycastAll(<br>    MyRay, <br>    distance, <br>    LayerMash.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-1-3-线段投射"><a href="#5-1-3-线段投射" class="headerlink" title="5.1.3 线段投射"></a>5.1.3 线段投射</h3><h4 id="5-1-3-1-功能"><a href="#5-1-3-1-功能" class="headerlink" title="5.1.3.1 功能"></a>5.1.3.1 功能</h4><p>建立<strong>某两点之间</strong>的射线进行检测，返回bool类型</p><p><strong>适用场合：</strong><br>特定地点局部距离射线检测</p><h4 id="5-1-3-2-用法"><a href="#5-1-3-2-用法" class="headerlink" title="5.1.3.2 用法"></a>5.1.3.2 用法</h4><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Linecast(<br>    startPos, <br>    endPos, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Linecast(<br>startPos, <br>    endPos, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h2 id="5-2-体型检测"><a href="#5-2-体型检测" class="headerlink" title="5.2 体型检测"></a>5.2 体型检测</h2><h3 id="5-2-1-Physics-XXXCast-体投射"><a href="#5-2-1-Physics-XXXCast-体投射" class="headerlink" title="5.2.1 Physics.XXXCast 体投射"></a>5.2.1 Physics.XXXCast 体投射</h3><h4 id="5-2-1-1-BoxCast-立方体投射"><a href="#5-2-1-1-BoxCast-立方体投射" class="headerlink" title="5.2.1.1 BoxCast 立方体投射"></a>5.2.1.1 BoxCast 立方体投射</h4><p><strong>功能：</strong><br>检测范围是正立方，返回bool。</p><p><strong>适用场合：</strong><br>检测目的地是否可抵达，从而判断可移动性</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">BoxCast(<br>    originPos, <br>    halfExtents, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li>originPos, halfExtents：<br>在originPos点创建半径halfBoxLength的立方体<br>（Vector3型，代表为正立方体在三个方向上的大小，一般用localScale/2）</li><li>direction, distance:<br>以朝向direction方向的平面为起始面（另一面舍弃）<br>移动distance距离，期间经过的区域即为检测区域。</li></ul><h4 id="5-2-1-2-SphereCast-球体投射"><a href="#5-2-1-2-SphereCast-球体投射" class="headerlink" title="5.2.1.2 SphereCast 球体投射"></a>5.2.1.2 SphereCast 球体投射</h4><p><strong>功能：</strong><br>扩展检测范围为球形，返回bool类型。</p><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">SphereCast(<br>    originPos, <br>    originPos, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li><p>originPos, originPos:<br>在originPos点创建半径为radius的球体</p></li><li><p>direction, distance:<br>以朝向direction方向的球面为起始面（另一面舍弃）<br>移动distance距离<br>期间半球面经过的区域即为检测区域。</p></li></ul><p>那么originPos到originPos+radius内的半球区域呢？<br>答案是舍弃，用官方的话来说，<strong>是边界而不是包围体</strong> 。</p><blockquote><p>立体结构：<br>以左右球球心为轴线，建立半径为radius、高为distance的圆柱体<br>左球挖去右半体积，右球添加右半体积</p></blockquote><p><strong>用法二：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">SphereCast (<br>    Ray, <br>    radius, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    distance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-1-3-CapsuleCast-胶囊体投射"><a href="#5-2-1-3-CapsuleCast-胶囊体投射" class="headerlink" title="5.2.1.3 CapsuleCast 胶囊体投射"></a>5.2.1.3 CapsuleCast 胶囊体投射</h4><p><strong>功能：</strong><br>检测范围是胶囊体，返回bool</p><p><strong>用法一：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">Physics.CapsuleCast(<br>    pos1, <br>    pos2, <br>    radius, <br>    direction, <br>    <span class="hljs-keyword">out</span> RaycastHit, <br>    maxDistance, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Anchor&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li><p>机理和SphereCast类似</p></li><li><p>pos1, pos2, radius:<br>在pos1、pos2两点创建半径为0.5f的球体，以此作为胶囊体模型两端；</p></li><li><p>direction, maxDistance:<br>以朝向direction方向的半胶囊体面为起始面，移动maxDistance距离<br>期间该面经过的区域即为检测区域。</p><blockquote><p>注：<br>maxDistance和上面的distance必须非0否则无用</p></blockquote></li></ul><h5 id="5-2-1-4-XXXCastAll-穿透投射"><a href="#5-2-1-4-XXXCastAll-穿透投射" class="headerlink" title="5.2.1.4 XXXCastAll 穿透投射"></a>5.2.1.4 XXXCastAll 穿透投射</h5><p><strong>功能：</strong><br>上述三种投射都只返回bool，只能检测单个物体，但是All方法的可检测射线上的所有物体，返回 <strong>RaycastHit[]</strong></p><blockquote><p>慎用，<strong>产生GC极多</strong></p></blockquote><h3 id="5-2-2-Physics-OverlapXXX-相交体"><a href="#5-2-2-Physics-OverlapXXX-相交体" class="headerlink" title="5.2.2 Physics.OverlapXXX 相交体"></a>5.2.2 Physics.OverlapXXX 相交体</h3><h4 id="5-2-2-1-OverlapBox-相交盒"><a href="#5-2-2-1-OverlapBox-相交盒" class="headerlink" title="5.2.2.1 OverlapBox 相交盒"></a>5.2.2.1 OverlapBox 相交盒</h4><p><strong>功能：</strong><br>检测与正立方体接触、重叠、或者处于其内的所有collider</p><p><strong>适用场合：</strong><br>检测挂载物体范围内是否存在碰撞，常用方法</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = OverlapBox(<br>    Pos, <br>    halfExtents, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>Pos, halfExtents:<br>以Pos点为中心创建三维半径halfExtents的正立方体</li><li>Quaternion.identity：<br>不对其进行旋转</li></ul><h4 id="5-2-2-2-OverlapSphere-相交球"><a href="#5-2-2-2-OverlapSphere-相交球" class="headerlink" title="5.2.2.2 OverlapSphere 相交球"></a>5.2.2.2 OverlapSphere 相交球</h4><p><strong>功能：</strong><br>检测与球体接触、重叠、或者处于其内的所有collider，即<strong>包围体</strong>。</p><blockquote><p>注意:<br><strong>自身collider也会被检测</strong>到（下列Overlap方法都是）</p></blockquote><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = Physics.OverlapSphere(<br>    Pos, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li><p>Pos, radius：<br>以Pos为原点，创建半径为radius的球形<br>检测区域为整个球形包围体（实心）<br>返回所有碰撞物体的collider而不是RaycastHit</p><blockquote><p>注意：<br>存在于球内部的物体也会被检测到</p></blockquote></li></ul><h4 id="5-2-2-3-OverlapCapsule-相交胶囊体"><a href="#5-2-2-3-OverlapCapsule-相交胶囊体" class="headerlink" title="5.2.2.3 OverlapCapsule 相交胶囊体"></a>5.2.2.3 OverlapCapsule 相交胶囊体</h4><p><strong>功能：</strong><br>检测与胶囊体接触、重叠、或者处于其内的所有collider</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">Collider[] hits = OverlapCapsule(<br>    pos1, <br>    pos2, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>在pos1、pos2两点创建半径为radius的球体，加上中间部分组成胶囊体</li></ul><h3 id="5-2-3-Physics-OverlapXXXNonAlloc-无GC相交体"><a href="#5-2-3-Physics-OverlapXXXNonAlloc-无GC相交体" class="headerlink" title="5.2.3 Physics.OverlapXXXNonAlloc 无GC相交体"></a>5.2.3 Physics.OverlapXXXNonAlloc 无GC相交体</h3><h4 id="5-2-3-1-OverlapBoxNonAlloc-无GC相交盒"><a href="#5-2-3-1-OverlapBoxNonAlloc-无GC相交盒" class="headerlink" title="5.2.3.1 OverlapBoxNonAlloc 无GC相交盒"></a>5.2.3.1 OverlapBoxNonAlloc 无GC相交盒</h4><p><strong>功能：</strong><br>实现OverlapBox的所有功能，但是另<strong>传递进colliders[]</strong> ，<strong>返回相交物体数量</strong>，从而<strong>杜绝GC的产生</strong></p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = Physics.OverlapBoxNonAlloc(<br>    Pos, <br>    halfExtents, <br>    colliders, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-3-2-OverlapSphereNonAlloc-无GC相交球"><a href="#5-2-3-2-OverlapSphereNonAlloc-无GC相交球" class="headerlink" title="5.2.3.2 OverlapSphereNonAlloc 无GC相交球"></a>5.2.3.2 OverlapSphereNonAlloc 无GC相交球</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = OverlapSphereNonAlloc(<br>    Pos, <br>    radius, <br>    colliders, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-3-3-OverlapCapsuleNonAlloc-无GC相交胶囊体"><a href="#5-2-3-3-OverlapCapsuleNonAlloc-无GC相交胶囊体" class="headerlink" title="5.2.3.3 OverlapCapsuleNonAlloc 无GC相交胶囊体"></a>5.2.3.3 OverlapCapsuleNonAlloc 无GC相交胶囊体</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">CollAmount = OverlapCapsuleNonAlloc(<br>    pos1, <br>    pos2, <br>    radius, <br>    colliders, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-2-4-Physics-CheckXXX-检验体"><a href="#5-2-4-Physics-CheckXXX-检验体" class="headerlink" title="5.2.4 Physics.CheckXXX 检验体"></a>5.2.4 Physics.CheckXXX 检验体</h3><h4 id="5-2-4-1-CheckBox-检验盒"><a href="#5-2-4-1-CheckBox-检验盒" class="headerlink" title="5.2.4.1 CheckBox 检验盒"></a>5.2.4.1 CheckBox 检验盒</h4><p><strong>功能：</strong><br>创建检测盒，检测是否被碰撞。<br>较比与上面的检测方法，该类方法特点在于:<br>    <strong>检验是否发生了碰撞</strong>，而<strong>不是取得碰撞体信息</strong>，效率最高。</p><blockquote><p>注:<br>此方法同样也会检验自身collider</p></blockquote><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckBox(<br>    transform.position, <br>    transform.localScale / <span class="hljs-number">2</span>, <br>    Quaternion.identity, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><ul><li>在物体中心创建检验盒，一定大小，不旋转，检测Enemy层，若有检测到碰撞则返回True</li></ul><h4 id="5-2-4-2-CheckSphere-检验球"><a href="#5-2-4-2-CheckSphere-检验球" class="headerlink" title="5.2.4.2 CheckSphere 检验球"></a>5.2.4.2 CheckSphere 检验球</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckSphere(<br>transform.position, <br>    radius, <br>    LayerMask.GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-2-4-3-CheckCapsule-检验胶囊体"><a href="#5-2-4-3-CheckCapsule-检验胶囊体" class="headerlink" title="5.2.4.3 CheckCapsule 检验胶囊体"></a>5.2.4.3 CheckCapsule 检验胶囊体</h4><p><strong>功能：</strong>同上</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">IsOverlapAnyCollider = Physics.CheckCapsule(<br>pos1, <br>pos2，<br>    radius, <br>    LayerMask.<br>    GetMask(<span class="hljs-string">&quot;Enemy&quot;</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="5-2-5-Physics-IgnoreCollision-忽略碰撞"><a href="#5-2-5-Physics-IgnoreCollision-忽略碰撞" class="headerlink" title="5.2.5 Physics.IgnoreCollision 忽略碰撞"></a>5.2.5 Physics.IgnoreCollision 忽略碰撞</h3><p><strong>功能：</strong><br>屏蔽两个collider的碰撞，第三个参数为bool</p><p><strong>用法：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">IgnoreCollision (collider1, collider2, ignore)<br></code></pre></td></tr></table></figure><h1 id="6-调试小技巧"><a href="#6-调试小技巧" class="headerlink" title="6. 调试小技巧"></a>6. 调试小技巧</h1><h2 id="6-1-绘制线段"><a href="#6-1-绘制线段" class="headerlink" title="6.1 绘制线段"></a>6.1 绘制线段</h2><ul><li><code>DrawLine(startPos, endPos, color)</code>：<br>绘制一条从startPos到endPos点、颜色为color的线段</li></ul><h2 id="6-2-绘制射线"><a href="#6-2-绘制射线" class="headerlink" title="6.2 绘制射线"></a>6.2 绘制射线</h2><p>使用Debug.DrawRay()方法可以在Scene中画出射线或者检测到的位置，更好的方便调试。</p><ul><li><p><code>DrawRay(startPos, direction, color)</code>：<br>绘制一条从startPos出发，指向direction的、颜色color的射线</p><blockquote><p>默认长度为单位向量，再乘以倍率即可边长<br>在下一次绘制才会覆盖上一次的射线</p></blockquote></li><li><p><code>Debug.DrawRay(startPos , direction, color, duration)</code> ：<br>同理绘制一定方向射线，但射线持续时间为duration </p></li></ul><h2 id="6-3-Gimos-DrawXXX方法"><a href="#6-3-Gimos-DrawXXX方法" class="headerlink" title="6.3 Gimos.DrawXXX方法"></a>6.3 Gimos.DrawXXX方法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123; <br>    Gizmos.DrawCube(transform.position, transform.localScale);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-GC开销问题"><a href="#7-GC开销问题" class="headerlink" title="7. GC开销问题"></a>7. GC开销问题</h1><p>从上面对几种检测方法的分析及对比其<strong>返回值</strong>不难发现：<br><strong>不同方法产生GC情况相差甚远</strong></p><p>因此在工程项目上应该慎重使用。</p><p>此处引用网友 <a href="https://www.cnblogs.com/hont/p/6180822.html">HONT</a>的测试作为GC情况参考：</p><ul><li>同方法下不同模型GC开销：<strong>Box &lt; Sphere &lt; Capsule</strong></li><li>同模型下不同方法GC开销：<strong>CheckXXX &lt; OverlapXXX &lt; XXXCast</strong></li></ul><h1 id="8-参考"><a href="#8-参考" class="headerlink" title="8. 参考"></a>8. 参考</h1><ul><li><a href="https://www.cnblogs.com/SouthBegonia/p/11732340.html">https://www.cnblogs.com/SouthBegonia/p/11732340.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>射线检测</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-状态模式</title>
    <link href="/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>当对象可能会根据不同的情况做出不同的行为，我们就把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。</p><p>当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变。</p><p>对这种有状态的对象编程有两种解决方法：</p><p><strong>传统的解决方案</strong>：<br>使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理。<br>但是显然这种做法存在弊端：<br>条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。</p><p><strong>状态模式的解决方案：</strong><br>当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理。<br>这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><blockquote><p>状态模式<br>允许对象在内部状态改变时改变它的行为，对象看起来好像被修改了它的类</p></blockquote><h1 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h1><p>通常在以下情况下可以考虑使用状态模式。</p><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><blockquote><p>Unity中的动画控制器本质上来讲就是个使用状态模式的有限状态机</p></blockquote><h1 id="4-模式结构"><a href="#4-模式结构" class="headerlink" title="4. 模式结构"></a>4. 模式结构</h1><p>状态模式包含以下主要角色。</p><ul><li>环境类（Context）角色：<br>也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li><li>抽象状态（State）角色：<br>定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li><li>具体状态（Concrete State）角色：<br>实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li></ul><p>类图如下图所示：<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831211640607.png" srcset="/img/loading.gif" alt="image-20210831211640607"></p><h1 id="5-状态机"><a href="#5-状态机" class="headerlink" title="5. 状态机"></a>5. 状态机</h1><p>为了能够更好的描述状态模式中各种状态之间的转换关系，我们一般会使用有限状态机来更加具体的描述它。</p><h2 id="5-1-什么是状态机"><a href="#5-1-什么是状态机" class="headerlink" title="5.1 什么是状态机"></a>5.1 什么是状态机</h2><p><strong>定义:</strong><br>有限状态机是一种用来进行对象行为建模的工具，其作用主要是描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。</p><p><strong>要素：</strong></p><ul><li>现态：<br>是指当前所处的状态。</li><li>条件：<br>又称为“事件”。当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li><li>动作：<br>条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。</li><li>次态：<br>条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li></ul><h2 id="5-2-如何实现状态机"><a href="#5-2-如何实现状态机" class="headerlink" title="5.2 如何实现状态机"></a>5.2 如何实现状态机</h2><p>实现状态机主要体现在两部:<br>画出状态转换图和将有限状态机用代码实现。<br>其中代码实现部分其实就是状态模式的实现。</p><ol><li><p>画出状态转换图</p><ol><li>找出所有状态(圆圈表示)</li><li>找出所有状态间的转换条件(圆圈间的线段表示)</li><li>分析每个状态需要执行的策略(圆圈边的大括号表示)</li></ol></li><li><p>将有限状态机用代码实现</p><ol><li>定义一个状态机类</li><li>根据状态转换图的<strong>状态节点(圆圈)**，定义</strong>状态**(可使用类(推荐)，枚举或无符号整数)</li><li>根据状态转换图的<strong>转换条件(边)**，实现</strong>转换动作**方法</li></ol></li></ol><h1 id="6-模式案例"><a href="#6-模式案例" class="headerlink" title="6. 模式案例"></a>6. 模式案例</h1><h2 id="6-1-案例分析"><a href="#6-1-案例分析" class="headerlink" title="6.1 案例分析"></a>6.1 案例分析</h2><p><strong>案例描述：</strong><br>用状态模式设计一个多线程的状态转换程序</p><p><strong>状态分析：</strong><br>多线程存在 5 种状态，分别为：</p><ul><li>新建状态（New）</li><li>就绪状态（Runnable ）</li><li>运行状态（Running）</li><li>阻塞状态（Blocked）</li><li>死亡状态（Dead）</li></ul><p>各个状态当遇到相关方法调用或事件触发时会转换到其他状态。</p><p><strong>状态转换图：</strong><br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831223512143.png" srcset="/img/loading.gif" alt="image-20210831223512143"></p><h2 id="6-2-类定义"><a href="#6-2-类定义" class="headerlink" title="6.2 类定义"></a>6.2 类定义</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/image-20210831223846969.png" srcset="/img/loading.gif" alt="image-20210831223846969"></p><h2 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScoreStateTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ThreadContext context = <span class="hljs-keyword">new</span> ThreadContext();<br>        context.start();<br>        context.getCPU();<br>        context.suspend();<br>        context.resume();<br>        context.getCPU();<br>        context.stop();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//环境类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadContext</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ThreadState state;<br>    ThreadContext() &#123;<br>        state = <span class="hljs-keyword">new</span> New();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(ThreadState state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadState <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        ((New) state).start(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCPU</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Runnable) state).getCPU(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Running) state).suspend(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Running) state).stop(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>&#123;<br>        ((Blocked) state).resume(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//抽象状态类：线程状态</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String stateName; <span class="hljs-comment">//状态名</span><br>&#125;<br><span class="hljs-comment">//具体状态类：新建状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">New</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">New</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;新建状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：新建状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用start()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;新建状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Runnable());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是新建状态，不能调用start()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：就绪状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runnable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Runnable</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;就绪状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：就绪状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCPU</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;获得CPU时间--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;就绪状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Running());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是就绪状态，不能获取CPU.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：运行状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Running</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Running</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;运行状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：运行状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用suspend()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;运行状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Blocked());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是运行状态，不能调用suspend()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用stop()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;运行状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Dead());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是运行状态，不能调用stop()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：阻塞状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blocked</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Blocked</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;阻塞状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：阻塞状态.&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">(ThreadContext hj)</span> </span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;调用resume()方法--&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (stateName.equals(<span class="hljs-string">&quot;阻塞状态&quot;</span>)) &#123;<br>            hj.setState(<span class="hljs-keyword">new</span> Runnable());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前线程不是阻塞状态，不能调用resume()方法.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体状态类：死亡状态</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dead</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadState</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dead</span><span class="hljs-params">()</span> </span>&#123;<br>        stateName = <span class="hljs-string">&quot;死亡状态&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;当前线程处于：死亡状态.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">当前线程处于：新建状态.<br>调用<span class="hljs-built_in">start</span>()方法<span class="hljs-comment">--&gt;当前线程处于：就绪状态.</span><br>获得CPU时间<span class="hljs-comment">--&gt;当前线程处于：运行状态.</span><br>调用suspend()方法<span class="hljs-comment">--&gt;当前线程处于：阻塞状态.</span><br>调用resume()方法<span class="hljs-comment">--&gt;当前线程处于：就绪状态.</span><br>获得CPU时间<span class="hljs-comment">--&gt;当前线程处于：运行状态.</span><br>调用<span class="hljs-built_in">stop</span>()方法<span class="hljs-comment">--&gt;当前线程处于：死亡状态.</span><br></code></pre></td></tr></table></figure><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><h2 id="7-2-优缺点"><a href="#7-2-优缺点" class="headerlink" title="7.2 优缺点"></a>7.2 优缺点</h2><p><strong>优点：</strong></p><ul><li>结构清晰：<br>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将状态转换显示化，减少对象间的相互依赖：<br>将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，有利于程序的扩展：<br>通过定义新的子类很容易地增加新的状态和转换。</li></ul><p><strong>缺点：</strong></p><ul><li>状态模式的使用必然会增加系统的类与对象的个数。 </li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。 </li><li>状态模式对开闭原则的支持并不太好:<br>对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li></ul><h2 id="7-3-与其他模式的区别"><a href="#7-3-与其他模式的区别" class="headerlink" title="7.3 与其他模式的区别"></a>7.3 与其他模式的区别</h2><p>状态模式与策略模式看起来像双胞胎，但他们还是不相同的。</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>策略模式</td><td>将可以互换的行为封装，使用委托的方法决定使用哪个行为</td></tr><tr><td>状态莫斯</td><td>封装基于状态的行为，将行为委托至当前状态</td></tr><tr><td>模板方法</td><td>由子类决定如何实现算法中的某些步骤</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2021/07/15/%E5%89%91%E6%8C%87offer/"/>
    <url>/2021/07/15/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h1 id="03-找出数组中重复的数字"><a href="#03-找出数组中重复的数字" class="headerlink" title="03. 找出数组中重复的数字"></a>03. 找出数组中重复的数字</h1><p>21-7-15</p><p><strong>描述：</strong><br>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。<br>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。<br>请找出数组中任意一个重复的数字。</p><p><strong>示例：</strong><br>输入：<br>    [2, 3, 1, 0, 2, 5, 3]<br>输出：<br>    2 或 3<br>限制：<br>    2 &lt;= n &lt;= 100000</p><p><strong>解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber1</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//哈希表法 时间复杂度o(n) 空间复杂度o(n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; numMap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (numMap.find(nums[i]) == numMap.end())<br>                numMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(nums[i], <span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//原地置换法 </span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] != nums[nums[i]])<br>                swap(nums[i], nums[nums[i]]);<br>            <span class="hljs-keyword">if</span> (nums[i] != i) <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-keyword">int</span> output;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(&#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span> &#125;)</span></span>;<br>    output =s.findRepeatNumber1(v);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    output = s.findRepeatNumber2(v);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><ul><li>要求空间复杂度低<ul><li>先排序，然后看相邻元素是否有相同的，有直接return。<br>时间复杂度O(nlogn)，空间复杂度O(1)</li><li>原地置换<br>题目说明尚未被充分使用<br>即：在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内<br>此说明含义：数组元素的 索引 和 值 是 一对多 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = inums[i]=i ）。<br>因而，就能通过索引映射对应的值，起到与字典等价的作用。</li></ul></li><li>均衡的方法<br>使用哈希表(map)<br>时间复杂度O(n)，空间复杂度O（n）</li></ul><h1 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a>04. 二维数组中的查找</h1><p>21-7-15</p><p><strong>描述：</strong><br>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p><p><strong>示例：</strong><br>现有矩阵 matrix 如下：<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p><p><strong>限制：</strong><br>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p><p><strong>解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].size()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (col &gt; <span class="hljs-number">-1</span> &amp;&amp; row&lt;matrix.size())<br>        &#123;<br>            <span class="hljs-keyword">if</span> (target == matrix[row][col])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (target &gt; matrix[row][col])<br>                row++;<br>            <span class="hljs-keyword">else</span><br>                col--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a1(&#123; <span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a2(&#123; <span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a3(&#123; <span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a4(&#123; <span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;a5(&#123; <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span> &#125;);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; inputMatrix(&#123;a1,a2,a3,a4,a5&#125;);<br>    <span class="hljs-keyword">int</span> target;<br>    <span class="hljs-keyword">bool</span> output;<br><br>    target = <span class="hljs-number">5</span>;<br>    output =s.findNumberIn2DArray(inputMatrix,target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br>    target = <span class="hljs-number">20</span>;<br>    output = s.findNumberIn2DArray(inputMatrix, target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>线性查找</p><p>从二维数组的右上角开始查找。</p><ul><li>如果当前元素等于目标值，则返回 true。</li><li>如果当前元素大于目标值，则移到左边一列。</li><li>如果当前元素小于目标值，则移到下边一行。</li><li>若数组为空，返回 false</li><li>循环体执行完毕仍未找到元素等于 target ，说明不存在这样的元素，返回 false</li></ul><p>可以证明这种方法不会错过目标值。</p><ul><li>如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值<br>因此往下查找不可能找到目标值，往左查找可能找到目标值。</li><li>如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值<br>因此往左查找不可能找到目标值，往下查找可能找到目标值。</li></ul><h1 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a>05. 替换空格</h1><p>21-7-15</p><p><strong>描述：</strong><br>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。<br>链接：<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof</a></p><p><strong>示例：</strong></p><p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p><p><strong>限制：</strong><br>0 &lt;= s 的长度 &lt;= 10000</p><p><strong>解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">string</span> output=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>                output += <span class="hljs-string">&quot;%20&quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                output += s[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">string</span> target = <span class="hljs-string">&quot;We are happy.&quot;</span>;<br>    <span class="hljs-built_in">string</span> output = s.replaceSpace(target);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串拼接或转为字符数组操作</p><h1 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a>06. 从尾到头打印链表</h1><p>21-7-15</p><p><strong>描述：</strong></p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>链接：<a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</a></p><p><strong>示例：</strong><br>输入：head = [1,3,2]<br>输出：[2,3,1]</p><p><strong>限制：</strong><br>0 &lt;= 链表长度 &lt;= 10000</p><p><strong>解：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* next;<br>    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint1</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-comment">//利用vector的insert特性</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<br>        ListNode* p = head;<br>        <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            output.insert(output.begin(),p-&gt;val);<br>            p = p-&gt;next;<br>        &#125; <br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint2</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-comment">//回溯法</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output;<br>        ListNode* p = head;<br>        flashBack(p, output);<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flashBack</span><span class="hljs-params">(ListNode* p, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp;output)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;next!= <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ListNode* q = p-&gt;next;<br>            flashBack(q, output);<br>        &#125;<br>        output.push_back(p-&gt;val);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    ListNode *target=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    target-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>    target-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; output = s.reversePrint2(target);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; output.size(); i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; output[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>法一：回溯法<br>法二：用栈<br>法三：利用vector的insert特性</p><h1 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07. 重建二叉树"></a>07. 重建二叉树</h1><p>21-7-16</p><p><strong>描述：</strong><br>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>相关知识点：</p><ul><li><a href="https://www.cnblogs.com/jpfss/p/11141956.html">树的三种遍历与推导</a></li></ul><p>链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a></p><p><strong>示例1：</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210716143123077.png" srcset="/img/loading.gif" alt="image-20210716143123077"></p><p><strong>Input:</strong><br>preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</p><p><strong>Output:</strong><br> [3,9,20,null,null,15,7]</p><p><strong>示例2：</strong><br><strong>Input:</strong><br>preorder = [-1], inorder = [-1]</p><p><strong>Output:</strong><br>[-1]</p><p><strong>限制：</strong><br>0 &lt;= 节点个数 &lt;= 5000</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    TreeNode(<span class="hljs-keyword">int</span> x) : val(x), left(<span class="hljs-literal">NULL</span>), right(<span class="hljs-literal">NULL</span>) &#123;&#125;   <br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;preMap;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;inoMap;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; preorder;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; inorder;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorder.size() == <span class="hljs-number">0</span> || inorder.size() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; preorder.size(); i++)<br>        &#123;<br>            preMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; (preorder[i],i));<br>            inoMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; (inorder[i], i));<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;preorder = preorder;<br>        <span class="hljs-keyword">this</span>-&gt;inorder = inorder;<br>        treeBuilder(<span class="hljs-number">0</span>,inorder.size()<span class="hljs-number">-1</span>, root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">treeBuilder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inorderBegin, <span class="hljs-keyword">int</span> inorderEnd, TreeNode* nowRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> boundary;<br>        boundary = inoMap[nowRoot-&gt;val];<br><br>        <span class="hljs-keyword">int</span> leftBegin = inorderBegin;<br>        <span class="hljs-keyword">int</span> leftEnd = boundary - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (leftEnd &lt; inorderBegin)leftEnd = inorderBegin;<br>        <span class="hljs-keyword">int</span> rightBegin = boundary + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (rightBegin &gt; inorderEnd)rightBegin = inorderEnd;<br>        <span class="hljs-keyword">int</span> rightEnd = inorderEnd;<br>        <span class="hljs-keyword">if</span> (leftBegin == rightEnd)<span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (inorder[leftBegin] != nowRoot-&gt;val)<br>        &#123;<br>            nowRoot-&gt;left=findRootNode(leftBegin, leftEnd);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (inorder[rightBegin] != nowRoot-&gt;val)<br>        &#123;<br>            nowRoot-&gt;right = findRootNode(rightBegin,rightEnd);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nowRoot-&gt;left !=<span class="hljs-literal">NULL</span>)<br>            treeBuilder(leftBegin, leftEnd, nowRoot-&gt;left);<br>        <span class="hljs-keyword">if</span> (nowRoot-&gt;right !=<span class="hljs-literal">NULL</span>)<br>            treeBuilder(rightBegin, rightEnd, nowRoot-&gt;right);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">findRootNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> root_p = preMap[inorder[begin]];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = begin; j &lt;= end; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (preMap[inorder[j]] &lt; root_p)<br>            &#123;<br>                root_p = preMap[inorder[j]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(preorder[root_p]);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(&#123; <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span> &#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorder</span><span class="hljs-params">(&#123; <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span> &#125;)</span></span>;<br>    TreeNode* output = s.buildTree(preorder,inorder);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路:</strong></p><p><strong>二叉树的遍历:</strong></p><p>二叉树前序遍历的顺序为：</p><ul><li>先遍历根节点；</li><li>随后递归地遍历左子树；</li><li>最后递归地遍历右子树。</li></ul><p>二叉树中序遍历的顺序为：</p><ul><li>先递归地遍历左子树；</li><li>随后遍历根节点；</li><li>最后递归地遍历右子树。</li></ul><p>在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。<br>挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。</p><p><strong>方法一：递归</strong></p><p>对于任意一颗树而言，前序遍历的形式总是</p><p>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br>即根节点总是前序遍历中的第一个节点。</p><p>而中序遍历的形式总是</p><p>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</p><p>只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><blockquote><p>注意：<br>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。<br>我们可以考虑使用哈希表来帮助我们快速地定位根节点。<br>对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。<br>在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。<br>在此后构造二叉树的过程中，我们就只需要 O(1)O(1) 的时间对根节点进行定位了。</p></blockquote><p>复杂度分析：</p><ul><li>时间复杂度：O(n)O(n)<br>其中 nn 是树中的节点个数。</li><li>空间复杂度：O(n)O(n)<br>除去返回的答案需要的 O(n)O(n) 空间之外，我们还需要使用 O(n)O(n) 的空间存储哈希映射，以及 O(h)O(h)（其中 hh 是树的高度）的空间表示递归时栈空间。<br>这里 h &lt; nh&lt;n，所以总空间复杂度为 O(n)O(n)。</li></ul><p><strong>方法二：迭代</strong></p><p>略，详见：链接：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/</a></p><h1 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09. 用两个栈实现队列"></a>09. 用两个栈实现队列</h1><p>21-7-16</p><p><strong>描述:</strong><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。<br>(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a></p><p><strong>示例 1：</strong></p><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[<span class="hljs-number">3</span>],[],[]]<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-string">&quot;CQueue&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;appendTail&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>,<span class="hljs-string">&quot;deleteHead&quot;</span>]<br>[[],[],[<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>],[],[]]<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-literal">null</span>,<span class="hljs-number">-1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong><br>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p><p><strong>解:</strong><br><a href="https://blog.csdn.net/cherrydreamsover/article/details/80466781">队列与栈的互相实现</a></p><p>复杂度分析</p><ul><li>时间复杂度：<br>对于插入和删除操作，时间复杂度均为 O(1)O(1)。<br>插入不多说，对于删除操作，虽然看起来是 O(n)O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 stack2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)O(1)。</li><li>空间复杂度：<br>O(n)O(n)。<br>需要使用两个栈存储已有的元素。</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CQueue</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;a;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt;b;<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;<br><span class="hljs-keyword">public</span>:<br>    CQueue() <br>    &#123;<br>        <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">appendTail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        a.push(value);<br>        <span class="hljs-built_in">size</span>++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteHead</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (b.empty())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (!a.empty())<br>            &#123;<br>                b.push(a.top());<br>                a.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> value = b.top();<br>        b.pop();<br>        <span class="hljs-built_in">size</span>--;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10-1. 斐波那契数列"></a>10-1. 斐波那契数列</h1><p>21-7-17</p><p><strong>描述:</strong><br>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。</p><p>斐波那契数列的定义如下：<br>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1</p><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a></p><p><strong>示例 1：</strong><br>输入：n = 2<br>输出：1</p><p><strong>示例 2：</strong><br>输入：n = 5<br>输出：5</p><p><strong>提示：</strong><br>0 &lt;= n &lt;= 100</p><p><strong>解:</strong></p><p>斐波那契数列的定义是 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ，生成第 nn 项的做法有以下几种：</p><ul><li><strong>递归法：</strong><br><strong>原理：</strong><br>把 f(n)f(n) 问题的计算拆分成 f(n-1)f(n−1) 和 f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0)f(0) 和 f(1)f(1) 为终止条件。<br><strong>缺点：</strong><br>大量重复的递归计算，例如 f(n)f(n) 和 f(n - 1)f(n−1) 两者向下递归需要 各自计算 f(n - 2)f(n−2) 的值。</li><li><strong>记忆化递归法：</strong><br><strong>原理：</strong><br>在递归法的基础上，新建一个长度为 nn 的数组，用于在递归时存储 f(0)f(0) 至 f(n)f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。<br><strong>缺点：</strong><br>记忆化存储需要使用 O(N)O(N) 的额外空间。</li><li><strong>动态规划：</strong><br><strong>原理：</strong><br>以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) 为转移方程。<br>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;fibMap;<br>    <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    Solution()<br>    &#123;<br>        fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//纯递归</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">return</span> fib1(n<span class="hljs-number">-1</span>) + fib1(n<span class="hljs-number">-2</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//带记录的递归</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">if</span> (fibMap.find(n) == fibMap.end())<br>        &#123;<br>            fibMap.insert(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(n, (fib2(n - <span class="hljs-number">1</span>) + fib2(n - <span class="hljs-number">2</span>)) % mod));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (fibMap[n - <span class="hljs-number">1</span>] + fibMap[n - <span class="hljs-number">2</span>]) % mod;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//动态规划</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>        *p = <span class="hljs-number">0</span>;<br>        *(p + <span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        &#123;<br>            *(p + i) = (*(p + i - <span class="hljs-number">1</span>) + *(p + i - <span class="hljs-number">2</span>))%mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *(p + n);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.fib3(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="10-2-青蛙跳台阶"><a href="#10-2-青蛙跳台阶" class="headerlink" title="10-2. 青蛙跳台阶"></a>10-2. 青蛙跳台阶</h1><p>21-7-17</p><p><strong>描述:</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a></p><p><strong>示例 1：</strong><br>输入：n = 2<br>输出：2</p><p><strong>示例 2：</strong><br>输入：n = 7<br>输出：21</p><p><strong>示例 3：</strong><br>输入：n = 0<br>输出：1</p><p><strong>提示：</strong><br>0 &lt;= n &lt;= 100</p><p><strong>解:</strong><br>同10-2动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        *p = <span class="hljs-number">1</span>;<br>        *(p + <span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br>        *(p + <span class="hljs-number">2</span>) = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>        &#123;<br>            *(p + i) = (*(p + i - <span class="hljs-number">1</span>) + *(p + i - <span class="hljs-number">2</span>)) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *(p + n);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.numWays(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h1><p>21-7-17</p><p><strong>描述:</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a></p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray1</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span><span class="hljs-comment">//线性查找</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers[<span class="hljs-number">0</span>]&lt;numbers[numbers.size() - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = numbers.size() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (numbers[i - <span class="hljs-number">1</span>] &gt; numbers[i])<br>                <span class="hljs-keyword">return</span> numbers[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minArray2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers)</span><span class="hljs-comment">//二分法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> size = numbers.size();<br>        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = size - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;<br>                <span class="hljs-comment">// [3, 4, 5, 1, 2]，mid 以及 mid 的左边一定不是最小数字</span><br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid + 1, right]</span><br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[mid] == numbers[right]) &#123;<br>                <span class="hljs-comment">// 只能把 right 排除掉，下一轮搜索区间是 [left, right - 1]</span><br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 此时 numbers[mid] &lt; numbers[right]</span><br>                <span class="hljs-comment">// mid 的右边一定不是最小数字，mid 有可能是，下一轮搜索区间是 [left, mid]</span><br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[left];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>&#125;<br></code></pre></td></tr></table></figure><p>二分查找（减治思想）<br>题目中给出的是半有序数组，虽然传统二分告诉我们二分只能用在有序数组中，但事实上，只要是可以减治的问题，仍然可以使用二分思想。</p><p><strong>思路：</strong><br>数组中最特殊的位置是左边位置 left 和右边位置 right，将它们与中间位置 mid 的值进行比较，进而判断最小数字出现在哪里。</p><p>用左边位置 left 和中间位置 mid 的值进行比较是否可以？<br>举例：[3, 4, 5, 1, 2] 与 [1, 2, 3, 4, 5] ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不能有效地减治。</p><p>用右边位置 right 和中间位置 mid 的值进行比较是否可以？<br>举例：[1, 2, 3, 4, 5]、[3, 4, 5, 1, 2]、[2, 3, 4, 5 ,1]，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。</p><p>补充说明：遇到 nums[mid] == nums[right] 的时候，不能草率地下定结论最小数字在哪一边，但是可以确定的是，把 right 舍弃掉，并不影响结果。</p><h1 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a>12. 矩阵中的路径</h1><p>21-7-18</p><p><strong>描述:</strong><br>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。<br>如果 word 存在于网格中，返回 true ；<br>否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。<br>同一个单元格内的字母不允许被重复使用。</p><p>例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。</p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210717130732349.png" srcset="/img/loading.gif" alt="image-20210717130732349"><br>链接：<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p><p><strong>示例 1：</strong><br>输入：<br>board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br>输出：<br>true</p><p><strong>示例 2：</strong><br>输入：board = [[“a”,”b”],[“c”,”d”]], word = “abcd”<br>输出：false</p><p><strong>提示：</strong><br>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200<br>board 和 word 仅由大小写英文字母组成</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-built_in">string</span> word;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;board;<br>    <span class="hljs-keyword">int</span> rowNum,colNum;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-built_in">string</span> word)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        rowNum = board.size();<br>        colNum = board[<span class="hljs-number">0</span>].size();<br>        <br>        <span class="hljs-keyword">this</span>-&gt;word = word;<br>        <span class="hljs-keyword">this</span>-&gt;board = board;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rowNum; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; colNum; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (dfs(i, j, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i&gt;=rowNum || j&gt;=colNum)<span class="hljs-comment">//越界判断</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (board[i][j]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (board[i][j] != word[k])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (k == word.size() - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            board[i][j] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dfs(i + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || dfs(i - <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>) || dfs(i, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>) || dfs(i, j - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                board[i][j] = word[k];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;  <br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>&#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(&#123; <span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span> &#125;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(&#123; <span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span> &#125;)</span></span>;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&gt; board(&#123;a,b,c&#125;);<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.exist(board,<span class="hljs-string">&quot;ABCCED&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路:</strong></p><p>本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。<br><img src="/images/%E5%89%91%E6%8C%87offer/image-20210718125453317.png" srcset="/img/loading.gif" alt="image-20210718125453317"></p><p><strong>深度优先搜索：</strong><br>可以理解为暴力法遍历矩阵中所有字符串可能性。<br>DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p><p><strong>剪枝：</strong><br>在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况<br>（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p><p><strong>DFS 解析：</strong></p><ul><li><p>递归参数：<br>当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</p></li><li><p>终止条件：</p><ul><li><p>返回 false：<br> (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过<br>（ (3) 可合并至 (2) ） </p></li><li><p>返回 true：<br>k = len(word) - 1 ，即字符串 word 已全部匹配。</p></li></ul></li><li><p>递推工作：</p><ul><li>标记当前矩阵元素：<br>将 board[i][j] 修改为 空字符 ‘’ ，代表此元素已访问过，防止之后搜索时重复访问。</li><li>搜索下一单元格：<br>朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。</li><li>还原当前矩阵元素：<br>将 board[i][j] 元素还原至初始值，即 word[k] 。</li><li>返回值：<br>返回布尔量 res ，代表是否搜索到目标字符串。</li></ul></li></ul><blockquote><p>使用空字符（Python: ‘’ , Java/C++: ‘\0’ ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。</p></blockquote><p><strong>复杂度分析：</strong><br>M, NM,N 分别为矩阵行列大小， KK 为字符串 word 长度。</p><ul><li><strong>时间复杂度</strong>$O(3^KMN)$：<br>最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为$O(3^K)$；<br>矩阵中共有 MN个起点，时间复杂度为 O(MN) 。</li><li><strong>方案数计算：</strong><br>设字符串长度为 KK ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 33 种选择，因此方案数的复杂度为 $O(3^K)$。</li><li><strong>空间复杂度</strong> O(K) ：<br>搜索过程中的递归深度不超过 KK ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。<br>最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN)的额外空间。</li></ul><h1 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a>13. 机器人的运动范围</h1><p>21-7-18</p><p><strong>描述:</strong><br>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。<br>一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。<br>例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。<br>但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p><p><strong>示例 1：</strong><br>输入：m = 2, n = 3, k = 1<br>输出：3</p><p><strong>示例 2：</strong><br>输入：m = 3, n = 1, k = 0<br>输出：1</p><p><strong>提示：</strong><br>1 &lt;= n,m &lt;= 100<br>0 &lt;= k &lt;= 20</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> rowNum,colNum;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> s1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> s2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i != <span class="hljs-number">0</span> || j!=<span class="hljs-number">0</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>)<br>            &#123;<br>                s1 += i % <span class="hljs-number">10</span>;<br>                i = i / <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>)<br>            &#123;<br>                s2 += j % <span class="hljs-number">10</span>;<br>                j = j / <span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s1+s2&lt;=k;<br>    &#125;<br>    <span class="hljs-keyword">int</span> m, n, k;<br>    <span class="hljs-keyword">int</span> counter;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;* visited;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        rowNum = m;<br>        colNum = n;<br>        <span class="hljs-keyword">this</span>-&gt;k=k;<br>        counter = <span class="hljs-number">0</span>;<br>        visited=<span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-number">0</span>));<br>        bfs();<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>*&gt;q;<br>        q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;);<br>        <span class="hljs-keyword">while</span> (!q.empty())<br>        &#123;<br>            <span class="hljs-keyword">int</span>* p = q.front();<br>            <span class="hljs-keyword">int</span> i = p[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> j = p[<span class="hljs-number">1</span>];<br>            q.pop();<br><br>            <span class="hljs-keyword">if</span> (i &gt;= rowNum || j &gt;= colNum || !sums(i, j) || visited-&gt;at(i).at(j))<br>                <span class="hljs-keyword">continue</span>;<br>            counter++;<br>            visited-&gt;at(i).at(j) = <span class="hljs-literal">true</span>;<br><br>            q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; i + <span class="hljs-number">1</span>,j &#125;); <br>            q.push(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>]&#123; i,j + <span class="hljs-number">1</span> &#125;);     <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= rowNum || j &gt;= colNum)<span class="hljs-comment">//越界判断</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (visited-&gt;at(i).at(j))<br>            <span class="hljs-keyword">return</span>;<br>        visited-&gt;at(i).at(j) = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!sums(i, j))<br>            <span class="hljs-keyword">return</span>;<br>        counter++;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        dfs(i + <span class="hljs-number">1</span>, j);<br>        dfs(i, j + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.movingCount(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">17</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似与12题，深搜与广搜两种解法</p><h1 id="14-剪绳子1"><a href="#14-剪绳子1" class="headerlink" title="14. 剪绳子1"></a>14. 剪绳子1</h1><p>21-7-19</p><p><strong>描述:</strong><br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。<br>请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？</p><p>例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p><p><strong>示例 1：</strong><br>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p><p><strong>示例 2:</strong><br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p><p><strong>提示：</strong><br>2 &lt;= n &lt;= 58</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dpf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//动态规划</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>* dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> max_val = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)<br>            &#123;<br>                max_val = max(max_val, dp[i - j] * dp[j]);<br>            &#125;<br>            dp[i] = max_val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">greedy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//贪心算法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-comment">//能全部拆成3</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a);<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>) <span class="hljs-comment">//余1，少拆个3，换成3+1=4</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a - <span class="hljs-number">1</span>) * <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, a) * <span class="hljs-number">2</span>;<span class="hljs-comment">//余2，直接乘2</span><br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.dpf(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.greedy(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路:</strong><br><strong>动态规划</strong><br><strong>算法流程：</strong></p><ul><li>我们想要求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来</li><li>用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1</li><li>我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪</li><li>剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]。取两者最大值max(j * (i - j), j * dp[i - j])</li><li>第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为<br>dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</li><li>最后返回dp[n]即可</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n ^ 2)<em>O</em>(<em>n</em>2)</li><li>空间复杂度：O(n)<em>O</em>(<em>n</em>)</li></ul><p><strong>贪心算法:</strong></p><p>找规律或数学证明可知： <strong>尽可能将绳子以长度 3 等分为多段时，乘积最大。</strong></p><p><strong>算法流程：</strong><br>当 n≤3 时，按照规则应不切分，但由于题目要求必须剪成 m&gt;1 段，因此必须剪出一段长度为 1 的绳子，即返回 n - 1。<br>当 n&gt;3时，求 n除以 3 的 整数部分 a 和 余数部分 b（即 n = 3a + b），并分为以下三种情况：</p><ul><li>当 b = 0时，直接返回 pow(3,a)；</li><li>当 b = 1时，要将一个 1 + 3 转换为 2+2，因此返回pow(3,a-1)*4；</li><li>当 b = 2b=2 时，返回 pow(3,a)*2 ;</li></ul><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1)：<br>仅有求整、求余、次方运算。<ul><li>求整和求余运算：<br>资料提到不超过机器数的整数可以看作是 O(1)O(1) ；</li><li>幂运算：<br>查阅资料，提到浮点取幂为 O(1)O(1) 。</li></ul></li><li>空间复杂度 O(1)： 变量 a 和 b 使用常数大小额外空间。</li></ul><h1 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a>15. 二进制中1的个数</h1><p>21-7-19</p><p><strong>描述:</strong><br>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p><blockquote><p>提示：<br>请注意，在某些语言（如 Java）中，没有无符号整数类型。<br>在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。<br>因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p></blockquote><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a></p><p><strong>示例 1：</strong><br>输入：n = 11<br>(控制台输入 00000000000000000000000000001011)<br>输出：3<br>解释：<br>输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p><p><strong>示例 2：</strong><br>输入：n = 128<br>(控制台输入 00000000000000000000000010000000)<br>输出：1<br>解释：<br>输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p><p><strong>示例 3：</strong><br>输入：n = 4294967293<br> (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）<br>输出：31<br>解释：<br>输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><p><strong>提示：</strong><br>输入必须是长度为 32 的 二进制串 。</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>)<br>                counter++;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.hammingWeight(<span class="hljs-number">4294967293</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单位运算，略</p><h1 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a>16. 数值的整数次方</h1><p>21-7-26</p><p><strong>描述:</strong><br>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。</p><p>不得使用库函数，同时不需要考虑大数问题。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p><p><strong>示例 1：</strong><br>输入：x = 2.00000, n = 10<br>输出：1024.00000</p><p><strong>示例 2：</strong><br>输入：x = 2.10000, n = 3<br>输出：9.26100</p><p><strong>示例 3：</strong><br>输入：x = 2.00000, n = -2<br>输出：0.25000<br>解释：2-2 = 1/22 = 1/4 = 0.25</p><p><strong>提示：</strong><br>-100.0 &lt; x &lt; 100.0<br>-231 &lt;= n &lt;= 231-1<br>-104 &lt;= xn &lt;= 104</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow1</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span> </span><br><span class="hljs-function">        <span class="hljs-comment">//递归快速幂+位运算(会爆栈)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>/myPow1(x, -n);<br><br>        <span class="hljs-keyword">if</span>((n&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> myPow1(x, n<span class="hljs-number">-1</span>)*x;<br>        n = n &gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">double</span> t = myPow1(x, n);<br>        <span class="hljs-keyword">return</span> t * t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow2</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//迭代快速幂</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / x;<br><br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            n = -n;<br>            x = <span class="hljs-number">1.0</span> / x;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> output = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>                output *= x;<br>            x *= x;<br>            n = n &gt;&gt; <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">myPow3</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span></span><br><span class="hljs-function">        <span class="hljs-comment">//2分法</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / x;<br>        <span class="hljs-keyword">double</span> half = myPow3(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">double</span> mod = myPow3(x, n % <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> half * half * mod;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.myPow2(<span class="hljs-number">2.00000</span>, <span class="hljs-number">-2147483648</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>快速幂</li><li>二分法</li><li>位运算</li><li>int类型边界<br>-2147483648</li></ul><h1 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17. 打印从1到最大的n位数"></a>17. 打印从1到最大的n位数</h1><p>21-7-26</p><p><strong>描述:</strong><br>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。</p><p>比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>链接：<a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</a></p><p><strong>示例 1:</strong><br>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p><p><strong>说明：</strong><br>用返回一个整数列表来代替打印<br>n 为正整数</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">char</span> numChar[<span class="hljs-number">10</span>] = &#123; <span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span> &#125;;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; output;<br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        dfs(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;intOutput;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; output.size(); i++)<br>        &#123;<br>            intOutput.push_back(atoi(output[i].c_str()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> intOutput;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == n)<br>        &#123;<br>            output.push_back(num);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> str = num+numChar[i];<br>            dfs(str, x + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;intOutput=s.printNumbers(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intOutput.size(); i++)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; intOutput[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的主要考点是大数越界情况下的打印。</p><p>需要解决以下三个问题：</p><ul><li>表示大数的变量类型：<br>无论是 short / int / long … 任意变量类型，数字的取值范围都是有限的。因此，大数的表示应用字符串 String 类型。</li><li>生成数字的字符串集：<br>使用 int 类型时，每轮可通过 +1+1 生成下个数字，而此方法无法应用至 String 类型。<br>并且， String 类型的数字的进位操作效率较低，例如 “9999” 至 “10000” 需要从个位到千位循环判断，进位 4 次。<br>观察可知，生成的列表实际上是 nn 位 00 - 99 的 全排列 ，因此可避开进位操作，通过递归生成数字的 String 列表。</li><li>递归生成全排列：<br>基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。<br>例如当 n = 2n=2 时（数字范围 1 - 991−99 ），固定十位为 00 - 99 ，按顺序依次开启递归，固定个位 00 - 99 ，终止递归并添加数字字符串。</li></ul><p><img src="../images/%E5%89%91%E6%8C%87offer/image-20210726150257820.png" srcset="/img/loading.gif" alt="image-20210726150257820"></p><p>即：使用深度优先搜索算法(dfs)。</p><h1 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h1><p>21-7-26</p><p><strong>描述:</strong><br>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a></p><p><strong>示例 1:</strong><br>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><strong>示例 2:</strong><br>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p><p><strong>说明：</strong><br>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode* next;<br>    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (head-&gt;val == val)<span class="hljs-keyword">return</span> head-&gt;next;<br>        ListNode* p, * q;<br>        p = head;<br>        q = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (q-&gt;next!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (q-&gt;val == val)<br>            &#123;<br>                p-&gt;next = q-&gt;next;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            p = p-&gt;next;<br>            q = p-&gt;next;<br>        &#125;<br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br>    <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    ListNode* head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>    ListNode* p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        p-&gt;next = <span class="hljs-keyword">new</span> ListNode(i);<br>        p = p-&gt;next;<br>    &#125;<br>    p = s.deleteNode(head, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (p!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; p-&gt;val &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        p = p-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的链表删除节点，双指针操作</p><h1 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19.正则表达式匹配"></a>19.正则表达式匹配</h1><p>21-7-26</p><p><strong>描述:</strong><br>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。</em></p><p><em>模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。</p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。<br>例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p><p><strong>示例 1:</strong><br>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p><p><strong>示例 2:</strong><br>输入:<br>s = “aa”<br>p = “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p><p><strong>示例 3:</strong><br>输入:<br>s = “ab”<br>p = “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。</p><p><strong>示例 4:</strong><br>输入:<br>s = “aab”<br>p = “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p><p><strong>示例 5:</strong><br>输入:<br>s = “mississippi”<br>p = “mis<em>is</em>p*.”<br>输出: false</p><p><strong>注意：</strong></p><ul><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘\</em>’。</li></ul><p><strong>解:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> m = s.size()+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n = p.size()+<span class="hljs-number">1</span>;<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; dp(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 初始化首行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j &lt; n; j += <span class="hljs-number">2</span>)<br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">2</span>] &amp;&amp; p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (dp[i][j - <span class="hljs-number">2</span>] ||<br>                        (dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">2</span>]) ||<br>                        (dp[i - <span class="hljs-number">1</span>][j] &amp;&amp; p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>))<br>                    &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> ((dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>]) ||<br>                        dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span><br>                        )<br>                    &#123;<br>                        dp[i][j] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;   <br>                &#125;<br>                dp[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br>    <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Solution s;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; s.isMatch(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路:</strong></p><ul><li><p>状态数组：设二维数组</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dp</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>，m和n是s、p的长度</p><ul><li>特殊说明：<code>dp[i][j]</code>表示s下标为<code>s[i-1]</code>的字符，p下标为<code>p[j-1]</code>字符</li></ul></li><li><p>初始化：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span><br></code></pre></td></tr></table></figure><p>表示 s的前i个字符和p的前j个字符是否匹配</p><ul><li><code>dp[0][0]=true</code>，表示s和p的前0个字符均为空串肯定匹配</li><li>若s是空串且p 的偶数次下标为$*$,那也是匹配的</li></ul></li><li><p>状态转移：</p><ul><li><pre><code>p.charAt(j - 1) == &#39;*&#39;<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>  ,有三种情况匹配<br><br>  - `dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j - 2]</span>`，既是`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>`出现<span class="hljs-number">0</span>次<br>  - `(dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> &amp;&amp; s<span class="hljs-selector-class">.charAt</span>(<span class="hljs-selector-tag">i</span> - <span class="hljs-number">1</span>) == <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">2</span>)`，`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>`出现<span class="hljs-number">1</span>次 且 当前i-<span class="hljs-number">1</span>和j-<span class="hljs-number">2</span>指向的字符相同<br>  - `dp<span class="hljs-selector-attr">[i - 1]</span><span class="hljs-selector-attr">[j]</span> &amp;&amp; <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>`，最特殊情况:`<span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-2]</span>=. <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j-1]</span>=*`时，根据条件知是万能匹配<br><br>- ```<br>  <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.charAt</span>(j - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span><br></code></pre></td></tr></table></figure>,有两种情况匹配- `dp[i - 1][j - 1] &amp;&amp; s.charAt(i - 1) == p.charAt(j - 1)`，前面元素之前都匹配 且 当前元素也相容- `dp[i - 1][j - 1] &amp;&amp; p.charAt(j - 1) == &#39;.&#39;`，前面元素之前都匹配 且 p的当期元素是`.`</code></pre></li></ul></li><li><p>返回值：<code>dp[m-1][n-1]</code></p></li></ul><h1 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串#"></a>20. 表示数值的字符串#</h1><p>21-7-26</p><p><strong>描述:</strong><br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p><p>数值（按顺序）可以分成以下几个部分：</p><ul><li><p>若干空格</p></li><li><p>一个 小数 或者 整数</p></li><li><p>（可选）一个 ‘e’ 或 ‘E’ ，后面跟着一个 整数</p></li><li><p>若干空格</p></li></ul><p>小数（按顺序）可以分成以下几个部分：</p><ul><li>（可选）一个符号字符（’+’ 或 ‘-‘）</li><li>下述格式之一：<ul><li>至少一位数字，后面跟着一个点 ‘.’</li><li>至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字</li><li>一个点 ‘.’ ，后面跟着至少一位数字</li></ul></li></ul><p>整数（按顺序）可以分成以下几个部分：</p><ul><li><p>（可选）一个符号字符（’+’ 或 ‘-‘）</p></li><li><p>至少一位数字</p></li></ul><p>部分数值列举如下：</p><ul><li>[“+100”, “5e2”, “-123”, “3.1416”, “-1E-16”, “0123”]</li></ul><p>部分非数值列举如下：</p><ul><li>[“12e”, “1a3.14”, “1.2.3”, “+-5”, “12e+5.4”]</li></ul><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof</a></p><p><strong>示例 1：</strong><br>输入：s = “0”<br>输出：true</p><p><strong>示例 2：</strong><br>输入：s = “e”<br>输出：false</p><p><strong>示例 3：</strong><br>输入：s = “.”<br>输出：false</p><p><strong>示例 4：</strong><br>输入：s = “    .1  “<br>输出：true</p><p><strong>提示：</strong><br>1 &lt;= s.length &lt;= 20<br>s 仅含英文字母（大写和小写），数字（0-9），加号 ‘+’ ，减号 ‘-‘ ，空格 ‘ ‘ 或者点 ‘.’ 。</p><h1 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h1><p><strong>描述:</strong><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof</a></p><p><strong>示例：</strong><br>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。</p><p><strong>提示：</strong><br>0 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p><p><strong>解:</strong></p><p>双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; List[int]:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums)==<span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> nums<br>        iStart = <span class="hljs-number">0</span><br>        iEnd = <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> iStart != iEnd:<br>            <span class="hljs-keyword">if</span> nums[iStart] % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                iStart += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> nums[iEnd] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                iEnd -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            t = nums[iStart]<br>            nums[iStart] = nums[iEnd]<br>            nums[iEnd] = t<br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure><h1 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22. 链表中倒数第k个节点"></a>22. 链表中倒数第k个节点</h1><p><strong>描述：</strong><br>输入一个链表，输出该链表中倒数第k个节点。<br>为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。<br>这个链表的倒数第 3 个节点是值为 4 的节点。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a></p><p><strong>示例：</strong><br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2。<br>返回链表 4-&gt;5。</p><p><strong>解：</strong><br>快慢双指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">self, head: ListNode, k: <span class="hljs-built_in">int</span></span>) -&gt; ListNode:</span><br>        <span class="hljs-keyword">if</span> head == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        first = head<br>        last = head<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k-<span class="hljs-number">1</span>):<br>            first = first.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> first == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> first.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            first = first.<span class="hljs-built_in">next</span><br>            last = last.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> last<br></code></pre></td></tr></table></figure><h1 id="24-反转列表"><a href="#24-反转列表" class="headerlink" title="24.  反转列表"></a>24.  反转列表</h1><p><strong>描述:</strong><br>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a></p><p><strong>示例:</strong><br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p>限制：<br>0 &lt;= 节点个数 &lt;= 5000</p><p><strong>解:</strong><br>快慢三指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>         self.val = x<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head</span>):</span><br>        <span class="hljs-keyword">if</span> head == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> head.<span class="hljs-built_in">next</span> == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> head<br>        <br>        first = head<br>        last = <span class="hljs-literal">None</span><br>        t = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> t <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            first.<span class="hljs-built_in">next</span> = last<br>            last = first<br>            first = t<br>            t = t.<span class="hljs-built_in">next</span><br>        first.<span class="hljs-built_in">next</span> = last<br>        <span class="hljs-keyword">return</span> first<br>        <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    head = ListNode(<span class="hljs-number">1</span>)<br>    Node1 = ListNode(<span class="hljs-number">2</span>)<br>    head.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">3</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br>    s = Solution()<br>    output = s.reverseList(head)<br>    <span class="hljs-keyword">while</span> output <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        print(output.val)<br>        output = output.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="25-合并两个排序的列表"><a href="#25-合并两个排序的列表" class="headerlink" title="25. 合并两个排序的列表"></a>25. 合并两个排序的列表</h1><p><strong>描述:</strong></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong><br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p><strong>限制：</strong><br>0 &lt;= 链表长度 &lt;= 1000</p><p><strong>解:</strong></p><p>归并排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>         self.val = x<br>         self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br>        <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> l2<br>        <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> l1<br>        p1 = l1<br>        p2 = l2<br>        head = ListNode(-<span class="hljs-number">1</span>)<br>        p3 = head<br>        <span class="hljs-keyword">while</span> p1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> p2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> p1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                p3.<span class="hljs-built_in">next</span> = p2<br>                p2 = p2.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> p2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                p3.<span class="hljs-built_in">next</span> = p1<br>                p1 = p1.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> p1.val &lt; p2.val:<br>                p3.<span class="hljs-built_in">next</span> = p1<br>                p1 = p1.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">else</span>:<br>                p3.<span class="hljs-built_in">next</span> = p2<br>                p2 = p2.<span class="hljs-built_in">next</span><br>                p3 = p3.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br>        <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    head1 = ListNode(<span class="hljs-number">1</span>)<br>    Node1 = ListNode(<span class="hljs-number">3</span>)<br>    head1.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">5</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br><br>    head2 = ListNode(<span class="hljs-number">2</span>)<br>    Node1 = ListNode(<span class="hljs-number">4</span>)<br>    head2.<span class="hljs-built_in">next</span> = Node1<br>    Node2 = ListNode(<span class="hljs-number">6</span>)<br>    Node1.<span class="hljs-built_in">next</span> = Node2<br><br>    s = Solution()<br>    output = s.mergeTwoLists(head1, head2)<br>    <span class="hljs-keyword">while</span> output <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        print(output.val)<br>        output = output.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h1><p><strong>描述:</strong><br>输入两棵二叉树A和B，判断B是不是A的子结构。<br>(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p><strong>例如:</strong><br>给定的树 A:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">   <span class="hljs-number"> 3 </span> <br>   / \  <br> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 5 </span><br> / \ <br>1  2<br></code></pre></td></tr></table></figure><p>给定的树 B：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-number">4</span>  <br> / <br><span class="hljs-number">1</span><br>返回 true，因为 <span class="hljs-selector-tag">B</span> 与 <span class="hljs-selector-tag">A</span> 的一个子树拥有相同的结构和节点值。<br></code></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 节点个数 &lt;= <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p><strong>解:</strong><br>简单的树的搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubStructure</span>(<span class="hljs-params">self, A, B</span>):</span><br>        <span class="hljs-keyword">if</span> A <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> B <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        self.targetNodeList = <span class="hljs-built_in">list</span>()<br>        self.dfs(A,B)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.targetNodeList) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        output = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> targetNode <span class="hljs-keyword">in</span> self.targetNodeList:<br>            <span class="hljs-keyword">if</span> self.isSubTree(targetNode,B):<br>                output = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> output<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self,root,target</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> root.val == target.val:<br>            self.targetNodeList.append(root)<br>        <span class="hljs-keyword">return</span> self.dfs(root.left,target) <span class="hljs-keyword">or</span> self.dfs(root.right,target)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSubTree</span>(<span class="hljs-params">self,a,b</span>):</span><br>        <span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> a.val != b.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.isSubTree(a.left,b.left) <span class="hljs-keyword">and</span> self.isSubTree(a.right,b.right)<br></code></pre></td></tr></table></figure><h1 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h1><p><strong>描述:</strong><br>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof</a></p><p><strong>示例:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">例如输入：<br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span><br><br>镜像输出：<br>     <span class="hljs-number">4</span><br>   /   <span class="hljs-string">\</span><br>  <span class="hljs-number">7</span>     <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p><p><strong>限制：</strong></p><p>0 &lt;= 节点个数 &lt;= 1000</p><p><strong>解:</strong></p><p>递归与深度优先搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        self.dfs(root)<br>        <span class="hljs-keyword">return</span> root<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self,root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <br>        t = root.left<br>        root.left = root.right<br>        root.right = t<br>        self.dfs(root.left)<br>        self.dfs(root.right)<br></code></pre></td></tr></table></figure><h1 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a>28. 对称的二叉树</h1><p><strong>描述：</strong><br>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br>    1<br>   / <br>  2   2<br> / \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:<br>    1<br>   / <br>  2   2<br>   \   <br>   3    3</p><p>链接：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof</a></p><p><strong>示例 1：</strong><br>输入：root = [1,2,2,3,4,4,3]<br>输出：true</p><p><strong>示例 2：</strong><br>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p><p><strong>限制：</strong><br>0 &lt;= 节点个数 &lt;= 1000</p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.left = None</span><br><span class="hljs-comment">#         self.right = None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSymmetric</span>(<span class="hljs-params">self, root: TreeNode</span>) -&gt; bool:</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> self.dfs(root.left,root.right)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self,L,R</span>):</span><br>        <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> R <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> R <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> L.val != R.val:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.dfs(L.left,R.right) <span class="hljs-keyword">and</span> self.dfs(L.right,R.left)<br></code></pre></td></tr></table></figure><h1 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[4,5,6]</span>,<span class="hljs-comment">[7,8,9]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,6,9,8,7,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：matrix = [[<span class="hljs-number">1,2,3,4</span>],[<span class="hljs-number">5,6,7,8</span>],[<span class="hljs-number">9,10,11,12</span>]]<br>输出：[<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">8,12,11,10</span>,<span class="hljs-number">9,5,6,7</span>]<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><p><strong>解：</strong><br>模拟法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spiralOrder</span>(<span class="hljs-params">self, matrix</span>):</span><br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> output<br>        l = <span class="hljs-number">0</span> <br>        r = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span><br>        t = <span class="hljs-number">0</span><br>        b = <span class="hljs-built_in">len</span>(matrix) - <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> l &gt; r:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l, r + <span class="hljs-number">1</span>):<br>                output.append(matrix[t][i])<br>            t += <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> t &gt; b:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t ,b + <span class="hljs-number">1</span>):<br>                output.append(matrix[j][r])<br>            r -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> l &gt; r:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r, l - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                output.append(matrix[b][i])<br>            b -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span>  t &gt; b:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(b, t - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                output.append(matrix[j][l])<br>            l += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    matrix = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br>    print(s.spiralOrder(matrix))<br></code></pre></td></tr></table></figure><h1 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30. 包含min函数的栈"></a>30. 包含min函数的栈</h1><p><strong>描述：</strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><strong>示例:</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">M<span class="hljs-keyword">in</span>Stack <span class="hljs-keyword">min</span>Stack = new M<span class="hljs-keyword">in</span>Stack();<br><span class="hljs-keyword">min</span>Stack.push(-<span class="hljs-number">2</span>);<br><span class="hljs-keyword">min</span>Stack.push(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">min</span>Stack.push(-<span class="hljs-number">3</span>);<br><span class="hljs-keyword">min</span>Stack.<span class="hljs-keyword">min</span>();   --&gt; 返回 -<span class="hljs-number">3</span>.<br><span class="hljs-keyword">min</span>Stack.pop();<br><span class="hljs-keyword">min</span>Stack.top();      --&gt; 返回 <span class="hljs-number">0</span>.<br><span class="hljs-keyword">min</span>Stack.<span class="hljs-keyword">min</span>();   --&gt; 返回 -<span class="hljs-number">2</span>.<br></code></pre></td></tr></table></figure><p> <a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/</a></p><p><strong>提示：</strong></p><ol><li>各函数的调用总次数不超过 20000 次</li></ol><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.stack = <span class="hljs-built_in">list</span>()<br>        self.minStack = <span class="hljs-built_in">list</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.stack.append(x)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.minStack) == <span class="hljs-number">0</span>:<br>            self.minStack.append(x)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> x &lt;= self.<span class="hljs-built_in">min</span>():<br>                self.minStack.append(x)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stack) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        x = self.stack.pop(<span class="hljs-built_in">len</span>(self.stack)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> x == self.<span class="hljs-built_in">min</span>():<br>            self.minStack.pop(<span class="hljs-built_in">len</span>(self.minStack)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">min</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> self.minStack[-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = MinStack()<br>    s.push(-<span class="hljs-number">2</span>)<br>    s.push(<span class="hljs-number">0</span>)<br>    s.push(-<span class="hljs-number">3</span>)<br>    print(s.<span class="hljs-built_in">min</span>())<br>    print(s.pop())<br>    print(s.top())<br>    print(s.<span class="hljs-built_in">min</span>())<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>使用辅助栈</p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210921114403708.png" srcset="/img/loading.gif" alt="image-20210921114403708"></p><h1 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a>31. 栈的压入、弹出序列</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。<br>例如：<br>序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，<br>但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入：pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], popped = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：我们可以按以下顺序执行：<br>push<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>, <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>, <span class="hljs-title">pop</span><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">4</span>,<br>push<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">pop</span><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">5</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">3</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">2</span>, pop<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">pushed</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">popped</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-number">1</span> 不能在 <span class="hljs-number">2</span> 之前弹出。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li><li><code>pushed</code> 是 <code>popped</code> 的排列。</li></ol><p><strong>解：</strong></p><p>模拟法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validateStackSequences</span>(<span class="hljs-params">self, pushed, popped</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pushed) == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(popped) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <br>        queue = <span class="hljs-built_in">list</span>()<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> pushed:<br>            queue.append(num)<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> queue[-<span class="hljs-number">1</span>] == popped[i]:<br>                queue.pop()<br>                i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    pushed = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>    popped = [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>    s = Solution()<br>    print(s.validateStackSequences(pushed,popped))<br></code></pre></td></tr></table></figure><h1 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32-I. 从上到下打印二叉树"></a>32-I. 从上到下打印二叉树</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</a></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p><strong>例如:</strong><br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>解：</strong></p><p>简单的广度优先搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            r = queue.pop(<span class="hljs-number">0</span>)<br>            output.append(r.val)<br>            <span class="hljs-keyword">if</span> r.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                queue.append(r.left)<br>            <span class="hljs-keyword">if</span> r.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                queue.append(r.right)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="32-II-从上到下打印二叉树"><a href="#32-II-从上到下打印二叉树" class="headerlink" title="32-II. 从上到下打印二叉树"></a>32-II. 从上到下打印二叉树</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a></p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>例如:</strong><br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>解：</strong><br>同上题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            t = <span class="hljs-built_in">list</span>()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                r = queue.pop(<span class="hljs-number">0</span>)<br>                t.append(r.val)<br>                <span class="hljs-keyword">if</span> r.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    queue.append(r.left)<br>                <span class="hljs-keyword">if</span> r.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    queue.append(r.right)            <br>            output.append(t)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="32-III-从上到下打印二叉树"><a href="#32-III-从上到下打印二叉树" class="headerlink" title="32-III. 从上到下打印二叉树"></a>32-III. 从上到下打印二叉树</h1><p><strong>描述:</strong><br>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p> <strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a>)</p><p><strong>例如:</strong><br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">20</span>,<span class="hljs-number">9</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        output = <span class="hljs-built_in">list</span>()<br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        isBackWord = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            t = <span class="hljs-built_in">list</span>()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queue)):<br>                r = queue.pop(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isBackWord:<br>                    t.append(r.val)<br>                <span class="hljs-keyword">else</span>:<br>                    t.insert(<span class="hljs-number">0</span>,r.val)<br>                <span class="hljs-keyword">if</span> r.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    queue.append(r.left)<br>                <span class="hljs-keyword">if</span> r.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    queue.append(r.right)<br>            isBackWord = <span class="hljs-keyword">not</span> isBackWord<br>            output.append(t)<br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    head = TreeNode(<span class="hljs-number">1</span>)<br>    head.left = TreeNode(<span class="hljs-number">2</span>)<br>    head.right = TreeNode(<span class="hljs-number">3</span>)<br>    head.left.left = TreeNode(<span class="hljs-number">4</span>)<br>    head.right.right = TreeNode(<span class="hljs-number">5</span>)<br>    output = s.levelOrder(head)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> output:<br>        print(i)<br></code></pre></td></tr></table></figure><h1 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h1><p><strong>描述:</strong><br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">6</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,6,3,2,5]</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,3,2,6,5]</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p><p><strong>提示：</strong></p><ol><li><code>数组长度 &lt;= 1000</code></li></ol><p><strong>解：</strong></p><p>辅助单调栈:<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">verifyPostorder</span>(<span class="hljs-params">self, postorder</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(postorder) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        postorder = postorder[::-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(postorder) == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">if</span> postorder[<span class="hljs-number">0</span>] &gt; postorder[<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">return</span>  <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        incStack = <span class="hljs-built_in">list</span>()<br>        root = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(postorder)):<br>            <span class="hljs-keyword">if</span> postorder[i] &gt;= root:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(incStack) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> postorder[i] &lt; incStack[-<span class="hljs-number">1</span>]:<br>                root = incStack.pop()<br>            incStack.append(postorder[i])<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.二叉树中和为某一值的路径</h1><p><strong>描述:</strong><br>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>target = 22</code>，</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">      5<br>     / \<br>   <span class="hljs-number"> 4 </span>  8<br>   /   / \<br> <span class="hljs-number"> 11 </span><span class="hljs-number"> 13 </span> 4<br> /  \    / \<br>7   <span class="hljs-number"> 2 </span><span class="hljs-number"> 5 </span>  1<br></code></pre></td></tr></table></figure><p>返回:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>   [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>],<br>   [<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>]<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/</a></p><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p><strong>解：</strong><br>深度优先搜索+回溯法<br>注意，是到叶节点，中间的不算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>        self.val = val<br>        self.left = left<br>        self.right = right<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pathSum</span>(<span class="hljs-params">self, root, target</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> []<br>        self.pathList = <span class="hljs-built_in">list</span>()<br>        path = <span class="hljs-built_in">list</span>()<br>        self.dfs(root,target,path)<br>        <span class="hljs-keyword">return</span> self.pathList<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, root, target, path</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        path.append(root.val)<br>        <span class="hljs-keyword">if</span> root.val == target <span class="hljs-keyword">and</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.pathList.append(<span class="hljs-built_in">list</span>(path))<br>        target -= root.val<br>        self.dfs(root.left, target, path)<br>        self.dfs(root.right, target, path)<br>        path.pop()<br></code></pre></td></tr></table></figure><h1 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a>35. 复杂链表的复制</h1><p><strong>描述:</strong><br>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p><p><strong>示例 1：</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/e1.png" srcset="/img/loading.gif" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/e2.png" srcset="/img/loading.gif" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="/images/%E5%89%91%E6%8C%87offer/e3.png" srcset="/img/loading.gif" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</a></p><p><strong>提示：</strong></p><ul><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li><li>节点数目不超过 1000 。</li></ul><p><strong>解：</strong><br>利用字典把新旧链表对应起来再复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, <span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>, random = <span class="hljs-literal">None</span></span>):</span><br>        self.val = <span class="hljs-built_in">int</span>(x)<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        self.random = random<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copyRandomList</span>(<span class="hljs-params">self, head: <span class="hljs-string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head: <span class="hljs-keyword">return</span><br>        dic = &#123;&#125;<br>        <span class="hljs-comment"># 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span><br>        cur = head<br>        <span class="hljs-keyword">while</span> cur:<br>            dic[cur] = Node(cur.val)<br>            cur = cur.<span class="hljs-built_in">next</span><br>        cur = head<br>        <span class="hljs-comment"># 4. 构建新节点的 next 和 random 指向</span><br>        <span class="hljs-keyword">while</span> cur:<br>            dic[cur].<span class="hljs-built_in">next</span> = dic.get(cur.<span class="hljs-built_in">next</span>)<br>            dic[cur].random = dic.get(cur.random)<br>            cur = cur.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 5. 返回新链表的头节点</span><br>        <span class="hljs-keyword">return</span> dic[head]<br></code></pre></td></tr></table></figure><h1 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h1><p><strong>描述:</strong><br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p> 为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="/images/%E5%89%91%E6%8C%87offer/bstdlloriginalbst.png" srcset="/img/loading.gif" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="/images/%E5%89%91%E6%8C%87offer/bstdllreturndll.png" srcset="/img/loading.gif" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</a></p><p><strong>解:</strong><br>中序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, val, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span><br>        self.val = val<br>        self.left = left<br>        self.right = right<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">treeToDoublyList</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        self.midOrderList = <span class="hljs-built_in">list</span>()<br>        self.dfs(root)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(self.midOrderList)):<br>            self.midOrderList[i].left = self.midOrderList[i-<span class="hljs-number">1</span>]<br>            self.midOrderList[i-<span class="hljs-number">1</span>].right = self.midOrderList[i] <br>        self.midOrderList[<span class="hljs-number">0</span>].left = self.midOrderList[-<span class="hljs-number">1</span>]<br>        self.midOrderList[-<span class="hljs-number">1</span>].right = self.midOrderList[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> self.midOrderList[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        self.dfs(root.left)<br>        self.midOrderList.append(root)<br>        self.dfs(root.right)<br></code></pre></td></tr></table></figure><h1 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h1><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= 数组长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-comment"># 摩尔投票法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElementByMooreVote</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        t = nums[<span class="hljs-number">0</span>]<br>        v = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> i == t:<br>                v += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                v -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> v &lt; <span class="hljs-number">0</span>:<br>                t = i<br>                v = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> t<br><br>    <span class="hljs-comment">#快排中位数法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElementByQuickSort</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        self.quickSort(nums,left,right)<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">len</span>(nums)//<span class="hljs-number">2</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">self, arr,left,right</span>):</span><br>        <span class="hljs-keyword">if</span> arr <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span><br>        l = left<br>        r = right<br>        p = arr[l]<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> arr[r] &gt;= p <span class="hljs-keyword">and</span> l &lt; r:<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[l] = arr[r]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> arr[l] &lt;= p <span class="hljs-keyword">and</span> l &lt; r:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[r] = arr[l]<br>                r -= <span class="hljs-number">1</span><br>        arr[l] = p<br>        self.quickSort(arr,left,l-<span class="hljs-number">1</span>)<br>        self.quickSort(arr,l+<span class="hljs-number">1</span>,right)<br><br>    <span class="hljs-comment"># 哈希地图法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElementByHashMap</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        hashMap = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> hashMap.get(i) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                hashMap[i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                hashMap[i] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> hashMap[i] &gt;= <span class="hljs-built_in">len</span>(nums)/<span class="hljs-number">2</span>:<br>                    <span class="hljs-keyword">return</span> i<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.majorityElementByMooreVote([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]))<br></code></pre></td></tr></table></figure><h1 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37. 序列化二叉树"></a>37. 序列化二叉树</h1><p><strong>描述:</strong><br>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示：</strong><br>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://support.leetcode-cn.com/hc/kb/article/1194353/">LeetCode 序列化二叉树的格式</a>。<br>你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例：</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/serdeser.jpg" srcset="/img/loading.gif" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/</a></p><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[]&#x27;</span><br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        strList = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            r = queue.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                strList.append(<span class="hljs-string">&quot;null&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                strList.append(<span class="hljs-built_in">str</span>(r.val))<br>                queue.append(r.left)<br>                queue.append(r.right)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;[&#x27;</span> + <span class="hljs-string">&#x27;,&#x27;</span>.join(strList) + <span class="hljs-string">&#x27;]&#x27;</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span>(<span class="hljs-params">self, data</span>):</span><br>        <span class="hljs-keyword">if</span> data == <span class="hljs-string">&#x27;[]&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        strList = data[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        root = TreeNode(<span class="hljs-built_in">int</span>(strList[<span class="hljs-number">0</span>]))<br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        p = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            r = queue.pop(<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> strList[p] != <span class="hljs-string">&#x27;null&#x27;</span>:<br>                r.left = TreeNode(<span class="hljs-built_in">int</span>(strList[p]))<br>                queue.append(r.left)<br>            <span class="hljs-keyword">if</span> strList[p+<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;null&#x27;</span>:<br>                r.right = TreeNode(<span class="hljs-built_in">int</span>(strList[p+<span class="hljs-number">1</span>]))<br>                queue.append(r.right)<br>            p += <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> root<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Codec()<br>    head = TreeNode(<span class="hljs-number">1</span>)<br>    head.left = TreeNode(<span class="hljs-number">2</span>)<br>    head.right = TreeNode(<span class="hljs-number">3</span>)<br>    head.right.left = TreeNode(<span class="hljs-number">4</span>)<br>    head.right.right = TreeNode(<span class="hljs-number">5</span>)<br>    data = s.serialize(head)<br>    root = s.deserialize(data)<br>    print(s.serialize(root))<br></code></pre></td></tr></table></figure><h1 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a>38. 字符串的排列</h1><p><strong>描述:</strong><br>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p><p><strong>示例:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= s 的长度 &lt;= <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">permutation</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> [s]<br>        self.lenth = <span class="hljs-built_in">len</span>(s)<br>        self.resultSet = <span class="hljs-built_in">list</span>()<br>        self.backtracking(<span class="hljs-built_in">list</span>(),<span class="hljs-built_in">list</span>(s))<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(self.resultSet)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtracking</span>(<span class="hljs-params">self,accStr,unaccStr</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(accStr) == self.lenth:<br>            self.resultSet.append(<span class="hljs-string">&#x27;&#x27;</span>.join(accStr))<br>            <span class="hljs-keyword">return</span><br>        cutUnaccSet = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(unaccStr)):<br>            <span class="hljs-keyword">if</span> unaccStr[i] <span class="hljs-keyword">in</span> cutUnaccSet:<br>                <span class="hljs-keyword">continue</span><br>            cutUnaccSet.add(unaccStr[i])<br>            newAccStr = <span class="hljs-built_in">list</span>(accStr)<br>            newUnaccStr = <span class="hljs-built_in">list</span>(unaccStr)<br>            newAccStr.append(unaccStr[i])<br>            newUnaccStr.pop(i)<br>            self.backtracking(newAccStr,newUnaccStr)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.permutation(<span class="hljs-string">&quot;abc&quot;</span>))<br></code></pre></td></tr></table></figure><h1 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40. 最小的k个数"></a>40. 最小的k个数</h1><p><strong>描述：</strong><br>输入整数数组 arr ，找出其中最小的 k 个数。</p><p>例如：<br>输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong><br>输入：arr = [3,2,1], k = 2<br>输出：[1,2] 或者 [2,1]</p><p><strong>示例 2：</strong><br>输入：arr = [0,1,2,1], k = 1<br>输出：[0]</p><p><strong>限制：</strong><br>0 &lt;= k &lt;= arr.length &lt;= 10000<br>0 &lt;= arr[i] &lt;= 10000</p><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">链接</a></p><p><strong>解：</strong></p><p>普通解法：<br>使用双数组，第二个新数组从大到小排列，将旧数组中的数遍历插入到新数组中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getNumArr</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):</span><br>        inputNumStrList = <span class="hljs-built_in">str</span>.split(<span class="hljs-built_in">input</span>,<span class="hljs-string">&#x27;,&#x27;</span>)<br>        numList = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(inputNumStrList)):<br>            numList.append(<span class="hljs-built_in">int</span>(inputNumStrList[i]))<br>        <span class="hljs-keyword">return</span> numList<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLeastNumbers</span>(<span class="hljs-params">self, arr, k</span>):</span><br>        self.outputList = <span class="hljs-built_in">list</span>()<br>        self.k = k<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(arr) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> self.outputList<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br>            self.pushNum(arr[i])<br>        <span class="hljs-keyword">return</span> self.outputList<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pushNum</span>(<span class="hljs-params">self, num</span>):</span><br>        print(<span class="hljs-string">&quot;+++&quot;</span>+<span class="hljs-built_in">str</span>(num))<br>        print(self.outputList)<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.outputList) == <span class="hljs-number">0</span>:<br>            self.outputList.append(num)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(self.outputList) &lt; self.k):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.outputList)):<br>                <span class="hljs-keyword">if</span> num &gt; self.outputList[j]:<br>                    self.outputList.insert(j,num)<br>                    <span class="hljs-keyword">return</span><br>            self.outputList.append(num)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> num &gt;= self.outputList[<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(self.outputList)):<br>            <span class="hljs-keyword">if</span> num &lt; self.outputList[j-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> num &gt;= self.outputList[j]:<br>                self.outputList.insert(j, num)<br>                self.outputList = self.outputList[<span class="hljs-number">1</span>:]<br>                <span class="hljs-keyword">return</span><br>        self.outputList.append(num)<br>        self.outputList = self.outputList[<span class="hljs-number">1</span>:]<br>            <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    inputNumList = s.getNumArr(<span class="hljs-string">&quot;0,1,1,2,4,4,2,3,3,2&quot;</span>)<br>    outputNumList = s.getLeastNumbers(inputNumList,<span class="hljs-number">6</span>)<br>    print(outputNumList)<br></code></pre></td></tr></table></figure><p>快速排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLeastNumbers</span>(<span class="hljs-params">self, arr, k</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> arr<br>        self.k = k<br>        self.halfQuickSort(arr,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> arr[:k]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">halfQuickSort</span>(<span class="hljs-params">self,arr,left,right</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span><br>        l = left<br>        r = right<br>        p = arr[l]<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> arr[r] &gt;= p:<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[l] = arr[r]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> arr[l] &lt;= p:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[r] = arr[l]<br>                r -= <span class="hljs-number">1</span><br>        arr[l] = p<br>        <span class="hljs-keyword">if</span> l == self.k:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> l &lt; self.k:<br>            self.halfQuickSort(arr,l+<span class="hljs-number">1</span>,right)<br>        <span class="hljs-keyword">else</span>:<br>            self.halfQuickSort(arr,left,l-<span class="hljs-number">1</span>)<br>            <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    NumList = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]<br>    s = Solution()<br>    outputNumList = s.getLeastNumbers(NumList,<span class="hljs-number">8</span>)<br>    print(NumList)<br>    print(outputNumList)<br></code></pre></td></tr></table></figure><h1 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41. 数据流中的中位数"></a>41. 数据流中的中位数</h1><p><strong>描述:</strong><br>如何得到一个数据流中的中位数？<br>如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。<br>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p><strong>例如:</strong><br>[2,3,4] 的中位数是 3<br>[2,3] 的中位数是 (2 + 3) / 2 = 2.5<br>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]<br>输出：[null,null,null,<span class="hljs-number">1.50000</span>,null,<span class="hljs-number">2.00000</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MedianFinder&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>,<span class="hljs-string">&quot;addNum&quot;</span>,<span class="hljs-string">&quot;findMedian&quot;</span>]<br>[[],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]<br>输出：[null,null,<span class="hljs-number">2.00000</span>,null,<span class="hljs-number">2.50000</span>]<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</a></p><p><strong>限制：</strong></p><ul><li>最多会对 <code>addNum、findMedian</code> 进行 <code>50000</code> 次调用。</li></ul><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">```<br><br><br><br><span class="hljs-comment"># 42连续子数组的最大和</span><br><br>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。<br>求所有子数组的和的最大值。<br><br>要求时间复杂度为O(n)。<br><br>**示例<span class="hljs-number">1</span>:**<br><br></code></pre></td></tr></table></figure><p>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs vim"><br>**提示：**<br><br>- `<span class="hljs-number">1</span> &lt;= arr.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span>`<br>- `-<span class="hljs-number">100</span> &lt;= arr[i] &lt;= <span class="hljs-number">100</span>`<br><br>(http<span class="hljs-variable">s:</span>//leetcode-<span class="hljs-keyword">cn</span>.<span class="hljs-keyword">com</span>/problems/lian-<span class="hljs-keyword">xu</span>-zi-shu-zu-de-zui-da-he-lcof/)<br><br>**解：**<br><br>简单的动态规划<br>**状态定义：** <br>设动态规划列表 <span class="hljs-keyword">dp</span> ，<span class="hljs-keyword">dp</span>[i]代表以元素 nums[i]为结尾的连续子数组最大和。<br><br>**转移方程：**<br><br>- 若nums[i] &gt; <span class="hljs-keyword">dp</span>[i-<span class="hljs-number">1</span>]+nums[i]<br>  则取nums[i]<br>- 若nums[i] &lt; <span class="hljs-keyword">dp</span>[i-<span class="hljs-number">1</span>]+nums[i]<br>  则取<span class="hljs-keyword">dp</span>[i-<span class="hljs-number">1</span>]+nums[i]<br><br>**初始状态：** <br><span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]，即以 nums[<span class="hljs-number">0</span>]结尾的连续子数组最大和为nums[<span class="hljs-number">0</span>] 。<br><br>**返回值：** <br>返回 <span class="hljs-keyword">dp</span>列表中的最大值，代表全局最大值。<br><br>```<span class="hljs-keyword">python</span><br>class Solution:<br>    def maxSubArray(self, nums):<br>        <span class="hljs-keyword">if</span> nums <span class="hljs-keyword">is</span> None:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br><br>        output = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">dp</span> = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">dp</span>[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span>  i in <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">dp</span>[i] = <span class="hljs-built_in">max</span>(nums[i],<span class="hljs-keyword">dp</span>[i-<span class="hljs-number">1</span>]+nums[i])<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">dp</span>[i] &gt; outpu<span class="hljs-variable">t:</span><br>                output = <span class="hljs-keyword">dp</span>[i]<br>        <span class="hljs-keyword">return</span> output<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-keyword">c</span> = Solution()<br>    <span class="hljs-keyword">print</span>(str(<span class="hljs-keyword">c</span>.maxSubArray([-<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">5</span>,<span class="hljs-number">4</span>])))<br></code></pre></td></tr></table></figure><h1 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a>46.把数字翻译成字符串</h1><p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/</a></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。<br>一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入: <span class="hljs-number">12258</span><br>输出: <span class="hljs-number">5</span><br>解释: <span class="hljs-number">12258</span>有<span class="hljs-number">5</span>种不同的翻译，分别是<span class="hljs-string">&quot;bccfi&quot;</span>, <span class="hljs-string">&quot;bwfi&quot;</span>, <span class="hljs-string">&quot;bczi&quot;</span>, <span class="hljs-string">&quot;mcfi&quot;</span>和<span class="hljs-string">&quot;mzi&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= num &lt; 231</code></li></ul><p><strong>解：</strong></p><p>一维动态规划稍稍变形题</p><p>动态规划解析：</p><p><strong>转移方程：</strong><br><img src="/images/%E5%89%91%E6%8C%87offer/image-20210922201844462.png" srcset="/img/loading.gif" alt="image-20210922201844462"></p><p><strong>初始状态：</strong><br>dp[0] = 1<br>dp[1] 也需要求出来</p><p><strong>返回值：</strong><br>dp[n]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">translateNum</span>(<span class="hljs-params">self, num</span>):</span><br>        <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">10</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        numList = self.numToNumList(num)<br>        <span class="hljs-keyword">return</span> self.dpf(numList)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dpf</span>(<span class="hljs-params">self, arr</span>):</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(arr)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> self.possibilityAnalysis(arr,<span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span>:<br>            dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(arr)):<br>            <span class="hljs-keyword">if</span> self.possibilityAnalysis(arr,i):<br>                dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">else</span>:<br>                dp[i] = dp[i-<span class="hljs-number">1</span>]<br>        print(dp)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">possibilityAnalysis</span>(<span class="hljs-params">self, arr, index</span>):</span><br>        <span class="hljs-keyword">if</span> arr[index-<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            n = <span class="hljs-built_in">int</span>(arr[index-<span class="hljs-number">1</span>]) * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(arr[index])<br>            <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &lt; <span class="hljs-number">26</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>: <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numToNumList</span>(<span class="hljs-params">self, num</span>):</span><br>        numList = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:<br>            numList.insert(<span class="hljs-number">0</span>,num%<span class="hljs-number">10</span>)<br>            num = num // <span class="hljs-number">10</span><br>        <span class="hljs-keyword">return</span> numList<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>     s = Solution()<br>     print(s.translateNum(<span class="hljs-number">18822</span>))<br></code></pre></td></tr></table></figure><h1 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45. 把数组排成最小的数"></a>45. 把数组排成最小的数</h1><p><strong>描述:</strong><br>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [10,2]</span><br><span class="hljs-section">输出: &quot;102&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">3,30,34,5</span>,<span class="hljs-number">9</span>]<br>输出: &quot;<span class="hljs-number">3033459</span>&quot;<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</a></p><p><strong>提示:</strong></p><ul><li><code>0 &lt; nums.length &lt;= 100</code></li></ul><p><strong>说明:</strong></p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li></ul><p><strong>解:</strong><br>自定义排序类型的问题。该种类型解题模板：</p><ol><li>定义元素比较规则，确定比较函数</li><li>将比较函数套入现有排序算法中(快速排序)</li><li>将排序后的元素按要求整理后输出</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumber</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(nums[<span class="hljs-number">0</span>])<br>        self.quickSort(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>)<br>        output = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            output += <span class="hljs-built_in">str</span>(i)<br>        <span class="hljs-keyword">return</span> output<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">self, arr, left, right</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span><br>        l = left<br>        r = right<br>        t = arr[l]<br>        <span class="hljs-keyword">while</span> l &lt; r:<br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> self.compare(arr[r], t) == <span class="hljs-number">1</span>:<br>                r -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[l] = arr[r]<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> self.compare(arr[l], t) == -<span class="hljs-number">1</span>:<br>                l += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> l &lt; r:<br>                arr[r] = arr[l]<br>                r -= <span class="hljs-number">1</span><br>            arr[l] = t<br>        self.quickSort(arr,left,l-<span class="hljs-number">1</span>)<br>        self.quickSort(arr,l+<span class="hljs-number">1</span>,right)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compare</span>(<span class="hljs-params">self, strA ,strB</span>):</span><br>        a = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(strA)+<span class="hljs-built_in">str</span>(strB))<br>        b = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(strB)+<span class="hljs-built_in">str</span>(strA))<br>        <span class="hljs-keyword">if</span> a == b:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> a &gt; b:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h1 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44. 数字序列中某一位的数字"></a>44. 数字序列中某一位的数字</h1><p><strong>描述:</strong><br>数字以0123456789101112131415…的格式序列化到一个字符序列中。<br>在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">11</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</a></p><p><strong>限制：</strong></p><ul><li><code>0 &lt;= n &lt; 2^31</code></li></ul><p><strong>解:</strong><br>这是个纯粹的找规律数学问题<br><img src="/images/%E5%89%91%E6%8C%87offer/image-20210925212710412.png" srcset="/img/loading.gif" alt="image-20210925212710412"></p><p>根据以上分析，可将求解分为三步：</p><ol><li>确定 n 所在 数字 的 位数 ，记为 digit ；</li><li>确定 n 所在的 数字 ，记为 num ；</li><li>确定 n 是num 中的哪一数位，并返回结果。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNthDigit</span>(<span class="hljs-params">self, n</span>):</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        digit = <span class="hljs-number">1</span><br>        start = <span class="hljs-number">1</span><br>        count = <span class="hljs-number">9</span><br>        <span class="hljs-keyword">while</span> n &gt; count:<br>            n -= count<br>            digit += <span class="hljs-number">1</span><br>            start *= <span class="hljs-number">10</span><br>            count = digit * start * <span class="hljs-number">9</span><br>        <br>        num = start + (n-<span class="hljs-number">1</span>) // digit<br>        index = (n-<span class="hljs-number">1</span>) % digit<br>        output = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(num)[index])<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h1 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a>47. 礼物的最大价值</h1><p><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/</a></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。<br>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。<br>给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,5,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[4,2,1]</span></span><br><span class="hljs-comment">]</span><br>输出: 12<br>解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><p><strong>解：</strong></p><p>简单的二维动态规划，注意python中二维数组的初始化问题<br><a href="https://blog.csdn.net/weixin_30023527/article/details/113507419">https://blog.csdn.net/weixin_30023527/article/details/113507419</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxValue</span>(<span class="hljs-params">self, grid</span>):</span><br>        xLen = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        yLen = <span class="hljs-built_in">len</span>(grid)<br>        <span class="hljs-keyword">if</span> xLen == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> yLen == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        dp = [[<span class="hljs-number">0</span>]* xLen <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(yLen)]<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,xLen):<br>            dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i-<span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][i]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,yLen):<br>            dp[i][<span class="hljs-number">0</span>] = dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,yLen):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,xLen):<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    grid = [ [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]<br>    print(s.maxValue(grid))<br></code></pre></td></tr></table></figure><h1 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48. 最长不含重复字符的子字符串"></a>48. 最长不含重复字符的子字符串</h1><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>s.length &lt;= 40000</code></li></ul><p><strong>解：</strong></p><p>方法一：<br>使用双指针与字典(快些)或集合(慢些)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        longestLen = <span class="hljs-number">1</span><br>        p = <span class="hljs-number">0</span><br>        q = <span class="hljs-number">0</span><br>        charDict = <span class="hljs-built_in">dict</span>()<br>        long = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> q &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> s[q] <span class="hljs-keyword">in</span> charDict:<br>                longestLen = <span class="hljs-built_in">max</span>(q-p, longestLen) <br>                p = charDict[s[q]] + <span class="hljs-number">1</span><br>                charDict[s[q]] = q<br>                q += <span class="hljs-number">1</span><br>                long = q - p<br>                <span class="hljs-keyword">for</span> key,values <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(charDict.items()):<br>                    <span class="hljs-keyword">if</span> values &lt; p:<br>                        charDict.pop(key)   <br>            <span class="hljs-keyword">else</span>:<br>                charDict[s[q]] = q<br>                q += <span class="hljs-number">1</span><br>                long += <span class="hljs-number">1</span><br>        longestLen = <span class="hljs-built_in">max</span>(long, longestLen)<br>        <span class="hljs-keyword">return</span> longestLen<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.lengthOfLongestSubstring(<span class="hljs-string">&quot;aab&quot;</span>))<br></code></pre></td></tr></table></figure><h1 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a>49. 丑数</h1><p><strong>描述:</strong><br>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。<br>求按从小到大的顺序的第 n 个丑数。</p><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">https://leetcode-cn.com/problems/chou-shu-lcof/</a></p><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: n = 10</span><br><span class="hljs-section">输出: 12</span><br><span class="hljs-section">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong> </p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nthUglyNumber</span>(<span class="hljs-params">self, n</span>):</span><br>        a=b=c=<span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>]*n<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            n2,n3,n5 = dp[a]*<span class="hljs-number">2</span>,dp[b]*<span class="hljs-number">3</span>,dp[c]*<span class="hljs-number">5</span><br>            dp[i] = <span class="hljs-built_in">min</span>(n2,n3,n5)<br>            <span class="hljs-keyword">if</span> dp[i] == n2:<br>                a += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dp[i] == n3:<br>                b += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> dp[i] == n5:<br>                c += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50.第一个只出现一次的字符"></a>50.第一个只出现一次的字符</h1><p>在字符串 s 中找出第一个只出现一次的字符。<br>如果没有，返回一个单空格。<br> s 只包含小写字母。</p><p><strong>示例 1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;abaccdeff&quot;</span><br>输出：&#x27;b&#x27;<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;&quot;</span> <br>输出：&#x27; &#x27;<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= s 的长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a></p><p><strong>解：</strong></p><p>使用字典(HashMap)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstUniqChar</span>(<span class="hljs-params">self, s</span>):</span><br>        charDict = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> charDict:<br>                charDict[c] = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                charDict[c] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> charDict.items():<br>            <span class="hljs-keyword">if</span> v: <span class="hljs-keyword">return</span> k<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span><br></code></pre></td></tr></table></figure><h1 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h1><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,5,6,4]</span><br><span class="hljs-section">输出: 5</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 数组长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure><p><strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p><p><strong>解:</strong><br>归并排序变形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reversePairs</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        self.arr = nums<br>        self.output = <span class="hljs-number">0</span><br>        print(self.mergeSort(<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> self.output<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">self,left,right</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">return</span> [self.arr[left]]<br>        mid = (left+right) // <span class="hljs-number">2</span><br>        leftArr = self.mergeSort(left,mid)<br>        rightArr = self.mergeSort(mid+<span class="hljs-number">1</span>,right)<br>        mergeArr = <span class="hljs-built_in">list</span>()<br>        p = <span class="hljs-number">0</span><br>        q = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> p &lt; <span class="hljs-built_in">len</span>(leftArr) <span class="hljs-keyword">and</span> q &lt; <span class="hljs-built_in">len</span>(rightArr):<br>            <span class="hljs-keyword">if</span> rightArr[q] &lt; leftArr[p]:<br>                self.output += <span class="hljs-built_in">len</span>(leftArr) - p<br>                mergeArr.append(rightArr[q])<br>                q += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                mergeArr.append(leftArr[p])<br>                p += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> q &lt; <span class="hljs-built_in">len</span>(rightArr):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(q,<span class="hljs-built_in">len</span>(rightArr)):<br>                mergeArr.append(rightArr[i])<br>        <span class="hljs-keyword">if</span> p &lt; <span class="hljs-built_in">len</span>(leftArr):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p,<span class="hljs-built_in">len</span>(leftArr)):<br>                mergeArr.append(leftArr[i])<br>        <span class="hljs-keyword">return</span> mergeArr<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.reversePairs([<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]))<br></code></pre></td></tr></table></figure><h1 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a>52. 两个链表的第一个公共节点</h1><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="/images/%E5%89%91%E6%8C%87offer/160_statement.png" srcset="/img/loading.gif" alt="img"></a></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="/images/%E5%89%91%E6%8C%87offer/160_example_1.png" srcset="/img/loading.gif" alt="img"></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<br><span class="hljs-attr">intersectVal</span> = <span class="hljs-number">8</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">3</span><br>输出：<br>Reference of the node <span class="hljs-keyword">with</span> <span class="hljs-attr">value</span> = <span class="hljs-number">8</span><br>输入解释：<br>相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个列表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 A 为 [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。在 A 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="/images/%E5%89%91%E6%8C%87offer/160_example_3.png" srcset="/img/loading.gif" alt="img"></a></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<br><span class="hljs-attr">intersectVal</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">listA</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">listB</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">skipA</span> = <span class="hljs-number">3</span>, <span class="hljs-attr">skipB</span> = <span class="hljs-number">2</span><br>输出：<br><span class="hljs-literal">null</span><br>输入解释：<br>从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 intersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>解释：<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span>。<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li></ul><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p><p><strong>解：</strong></p><p>双指针交叉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getIntersectionNode</span>(<span class="hljs-params">self, headA, headB</span>):</span><br>        <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> headB == <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        p = headA<br>        q = headB<br>        <span class="hljs-keyword">while</span> p != q:<br>            p = p.<span class="hljs-built_in">next</span><br>            q = q.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> p == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> q == <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">if</span> p == <span class="hljs-literal">None</span>:<br>                p = headB<br>            <br>            <span class="hljs-keyword">if</span> q == <span class="hljs-literal">None</span>:<br>                q = headA<br>        <span class="hljs-keyword">return</span> p<br></code></pre></td></tr></table></figure><h1 id="53-在排序数组中查找数字-I"><a href="#53-在排序数组中查找数字-I" class="headerlink" title="53. 在排序数组中查找数字 I"></a>53. 在排序数组中查找数字 I</h1><p><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/</a></p><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><p><strong>解：</strong></p><p>二分法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, nums, target</span>):</span><br>        <span class="hljs-keyword">if</span> nums == <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> self.dichotomous(nums,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>,target)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dichotomous</span>(<span class="hljs-params">self, arr, left, right, target</span>):</span><br>        <span class="hljs-keyword">if</span> left &gt;= right:<br>            <span class="hljs-keyword">if</span> arr[left] == target:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        mid = left + (right - left) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> self.dichotomous(arr,left,mid,target) + self.dichotomous(arr,mid+<span class="hljs-number">1</span>,right,target)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.search([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h1 id="53-在排序数组中查找数字-II"><a href="#53-在排序数组中查找数字-II" class="headerlink" title="53. 在排序数组中查找数字 II"></a>53. 在排序数组中查找数字 II</h1><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。<br>在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong><br>输入: [0,1,3]<br>输出: 2</p><p><strong>示例 2:</strong><br>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p><p><strong>限制：</strong><br>1 &lt;= 数组长度 &lt;= 10000</p><p>链接：<br><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a></p><p><strong>解：</strong></p><p>二分法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">missingNumber</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">if</span> nums[l - <span class="hljs-number">1</span>] == l-<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> l<br><br>        left = <span class="hljs-number">0</span><br>        right = l-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            mid = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> mid == nums[mid]:<br>                left = mid + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                right = mid - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">return</span> left<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.missingNumber([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]))<br></code></pre></td></tr></table></figure><h1 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点"></a>54. 二叉搜索树的第k大节点</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  /<br> <span class="hljs-number">1</span><br>输出: <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a></p><p><strong>解：</strong><br>二叉树反向的中序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kthLargest</span>(<span class="hljs-params">self, root, k</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        self.rMidOrderList = <span class="hljs-built_in">list</span>()<br>        self.k = k<br>        self.reverseMidTraversal(root)<br>        <span class="hljs-keyword">return</span> self.rMidOrderList[k-<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseMidTraversal</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(self.rMidOrderList) == self.k:<br>            <span class="hljs-keyword">return</span><br>        self.reverseMidTraversal(root.right)<br>        self.rMidOrderList.append(root.val)<br>        self.reverseMidTraversal(root.left)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    head = TreeNode(<span class="hljs-number">3</span>)<br>    head.left = TreeNode(<span class="hljs-number">1</span>)<br>    head.right = TreeNode(<span class="hljs-number">4</span>)<br>    head.left.right = TreeNode(<span class="hljs-number">2</span>)<br>    s.kthLargest(head,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h1 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55. 二叉树的深度"></a>55. 二叉树的深度</h1><p>输入一棵二叉树的根节点，求该树的深度。<br>从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>例如：</strong><br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回它的最大深度 3 。</p><p><strong>提示：</strong><br>节点总数 &lt;= 10000</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof</a></p><p><strong>解：</strong></p><p>二叉树的深度优先搜索或广度优先搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        self.deep = <span class="hljs-number">0</span><br>        self.dfs(root,<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> self.deep<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, root, d</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        d += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> d &gt; self.deep:<br>            self.deep = d<br>        self.dfs(root.left, d)<br>        self.dfs(root.right, d)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">self, root</span>):</span><br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        deep = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            tq = <span class="hljs-built_in">list</span>()<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> node.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    tq.append(node.left)<br>                <span class="hljs-keyword">if</span> node.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    tq.append(node.right)<br>            queue = tq<br>            deep += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> deep<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    head = TreeNode(<span class="hljs-number">3</span>)<br>    head.left = TreeNode(<span class="hljs-number">1</span>)<br>    head.right = TreeNode(<span class="hljs-number">4</span>)<br>    head.left.right = TreeNode(<span class="hljs-number">2</span>)<br>    print(s.maxDepth(head))<br></code></pre></td></tr></table></figure><h1 id="55-II-平衡二叉树"><a href="#55-II-平衡二叉树" class="headerlink" title="55. II 平衡二叉树"></a>55. II 平衡二叉树</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。<br>如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>示例 1:</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回 <code>true</code> 。</p><p><strong>示例 2:</strong><br>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      <span class="hljs-number">1</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>返回 <code>false</code> 。</p><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 树的结点个数 &lt;= 10000</code></li></ul><p><strong>解：</strong><br>先后序遍历再嵌套第55题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.val = x<br>        self.left = <span class="hljs-literal">None</span><br>        self.right = <span class="hljs-literal">None</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBalanced</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">return</span> self.postOrderTraversal(root)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">postOrderTraversal</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        ld = self.getDeepByBFS(root.left)<br>        rd = self.getDeepByBFS(root.right)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(ld - rd) &gt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.postOrderTraversal(root.left) <span class="hljs-keyword">and</span> self.postOrderTraversal(root.right)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getDeepByBFS</span>(<span class="hljs-params">self, root</span>):</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        queue = <span class="hljs-built_in">list</span>()<br>        queue.append(root)<br>        deep = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>            t = <span class="hljs-built_in">list</span>()<br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> queue:<br>                <span class="hljs-keyword">if</span> p.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    t.append(p.left)<br>                <span class="hljs-keyword">if</span> p.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    t.append(p.right)<br>            deep += <span class="hljs-number">1</span><br>            queue = t<br>        <span class="hljs-keyword">return</span> deep<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    head = TreeNode(<span class="hljs-number">3</span>)<br>    head.left = TreeNode(<span class="hljs-number">1</span>)<br>    head.right = TreeNode(<span class="hljs-number">4</span>)<br>    head.left.right = TreeNode(<span class="hljs-number">2</span>)<br>    print(s.isBalanced(head))<br></code></pre></td></tr></table></figure><h1 id="56-I-数组中数字出现的次数"><a href="#56-I-数组中数字出现的次数" class="headerlink" title="56. I 数组中数字出现的次数"></a>56. I 数组中数字出现的次数</h1><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,1,4,6]</span><br>输出：<span class="hljs-comment">[1,6]</span> 或 <span class="hljs-comment">[6,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,10,4,1,4,3,3]</span><br>输出：<span class="hljs-comment">[2,10]</span> 或 <span class="hljs-comment">[10,2]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10000</code></li></ul><p><strong>解：</strong></p><p>异或的骚操作，不看题解真想不到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumbers</span>(<span class="hljs-params">self, nums</span>):</span><br>        ox = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            ox ^= i<br>        m = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> ox &amp; m == <span class="hljs-number">0</span>:<br>            ox &lt;&lt;= <span class="hljs-number">1</span><br>        x, y = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> i &amp; m == <span class="hljs-number">0</span>:<br>                x ^= i<br>            <span class="hljs-keyword">else</span>:<br>                y ^= i<br>        <span class="hljs-keyword">return</span> x,y<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.singleNumbers([<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]))<br></code></pre></td></tr></table></figure><h1 id="56-II-数组中数字出现的次数"><a href="#56-II-数组中数字出现的次数" class="headerlink" title="56.  II 数组中数字出现的次数"></a>56.  II 数组中数字出现的次数</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</a></p><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。<br>请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">3,4,3,3</span>]<br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[9,1,7,9,7,9,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10000</code></li><li><code>1 &lt;= nums[i] &lt; 2^31</code></li></ul><p><strong>解：</strong><br>用集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span>(<span class="hljs-params">self, nums</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        oneTimeNumList = <span class="hljs-built_in">list</span>()<br>        numSet = <span class="hljs-built_in">set</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums:<br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> numSet:<br>                numSet.add(i)<br>                oneTimeNumList.append(i)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> oneTimeNumList:<br>                    oneTimeNumList.remove(i)<br>        <span class="hljs-keyword">return</span> oneTimeNumList.pop()<br></code></pre></td></tr></table></figure><h1 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57. 和为s的两个数字"></a>57. 和为s的两个数字</h1><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。<br>如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[2,7]</span> 或者 <span class="hljs-comment">[7,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[10,26,30,31,47,60]</span>, target = 40<br>输出：<span class="hljs-comment">[10,30]</span> 或者 <span class="hljs-comment">[30,10]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li></ul><p><strong>解：</strong><br>先折半查找确定位置，后双指针对撞</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums, target</span>):</span><br>        <span class="hljs-keyword">if</span> nums <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>] &gt; target:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        left = <span class="hljs-number">0</span><br>        right = self.dichotomous(nums,target)<br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            t = nums[left] + nums[right]<br>            <span class="hljs-keyword">if</span> t == target:<br>                <span class="hljs-keyword">return</span> [nums[left], nums[right]]<br>            <span class="hljs-keyword">elif</span> t &lt; target:<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                right -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dichotomous</span>(<span class="hljs-params">self, arr, target</span>):</span><br>        <span class="hljs-keyword">if</span> arr[<span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span>] &lt; target:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(arr)-<span class="hljs-number">1</span><br>        left = <span class="hljs-number">0</span><br>        right = <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span>(left &lt; right):<br>            mid = (left + right)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> arr[mid] &gt; target:<br>                right = mid - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> arr[mid] &lt; target:<br>                left = mid + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> arr[mid] == target:<br>                <span class="hljs-keyword">return</span> mid -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> left<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    nums = [<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>]<br>    print(s.twoSum(nums,<span class="hljs-number">12</span>))<br></code></pre></td></tr></table></figure><h1 id="57-II和为s的连续正数序列"><a href="#57-II和为s的连续正数序列" class="headerlink" title="57 . II和为s的连续正数序列"></a>57 . II和为s的连续正数序列</h1><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：target = <span class="hljs-number">9</span><br>输出：<span class="hljs-string">[[2,3,4],[4,5]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：target = <span class="hljs-number">15</span><br>输出：<span class="hljs-string">[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^5</code></li></ul><p><strong>解:</strong></p><p>滑动窗口双指针，用求和公式降低时间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">self, target</span>):</span><br>        left = <span class="hljs-number">1</span><br>        right = <span class="hljs-built_in">int</span>((<span class="hljs-built_in">pow</span>((<span class="hljs-number">0.25</span> + <span class="hljs-number">2</span>*target),<span class="hljs-number">0.5</span>) - <span class="hljs-number">0.5</span>))<br>        output = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">while</span> left != right:<br>            <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left,right+<span class="hljs-number">1</span>):<br>                <span class="hljs-built_in">sum</span> += i<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &gt; target:<br>                right -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &lt; target:<br>                left += <span class="hljs-number">1</span><br>                right += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                output.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(left,right+<span class="hljs-number">1</span>)))<br>                left += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    output = s.findContinuousSequence(<span class="hljs-number">9</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> output:<br>        print(i)<br></code></pre></td></tr></table></figure><h1 id="58-I-翻转单词顺序"><a href="#58-I-翻转单词顺序" class="headerlink" title="58. I 翻转单词顺序"></a>58. I 翻转单词顺序</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。<br>为简单起见，标点符号和普通字母一样处理。<br>例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例 1：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入: <span class="hljs-comment">&quot;the sky is blue&quot;</span><br>输出: <span class="hljs-comment">&quot;blue is sky the&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;  hello world!  &quot;</span><br><span class="hljs-section">输出: &quot;world! hello&quot;</span><br><span class="hljs-section">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入: <span class="hljs-comment">&quot;a good   example&quot;</span><br>输出: <span class="hljs-comment">&quot;example good a&quot;</span><br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><p><strong>解：</strong></p><p>用栈，python3特性，双指针都可以解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWordsByStack</span>(<span class="hljs-params">self, s</span>):</span><br>        stack = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s.split():<br>            stack.insert(<span class="hljs-number">0</span>,c)<br>        s = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(stack)):<br>            s += <span class="hljs-string">&quot; &quot;</span> + stack.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> s[<span class="hljs-number">1</span>:]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWordsByPy3</span>(<span class="hljs-params">self, s</span>):</span><br>        strList = s.split()[::-<span class="hljs-number">1</span>]<br>        s = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> strList:<br>            s += <span class="hljs-string">&quot; &quot;</span> + i<br>        <span class="hljs-keyword">return</span> s[<span class="hljs-number">1</span>:]<br></code></pre></td></tr></table></figure><h1 id="59-I-滑动窗口的最大值"><a href="#59-I-滑动窗口的最大值" class="headerlink" title="59. I 滑动窗口的最大值"></a>59. I 滑动窗口的最大值</h1><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7] <br>解释: <br><br>  滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</a></p><p><strong>提示：</strong></p><p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-comment"># 滑动窗口暴力破解</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSlidingWindowByBP</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        q = k - <span class="hljs-number">1</span><br>        maxList = <span class="hljs-built_in">list</span>()<br>        maxNum = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; maxNum:<br>                maxNum = nums[i]<br>        maxList.append(maxNum)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(nums)):<br>            q += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> q &gt;= <span class="hljs-built_in">len</span>(nums):<br>                <span class="hljs-keyword">break</span><br>            maxNum = nums[i]<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,q+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[j] &gt;  maxNum:<br>                    maxNum = nums[j]<br>            maxList.append(maxNum)<br>        <span class="hljs-keyword">return</span> maxList<br>    <span class="hljs-comment"># 单调队列优化解法</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">monoQueuePush</span>(<span class="hljs-params">self, monoQueue, element</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoQueue) == <span class="hljs-number">0</span>:<br>            monoQueue.append(element)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> element &lt;= monoQueue[-<span class="hljs-number">1</span>]:<br>            monoQueue.append(element)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(monoQueue) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> element &gt; monoQueue[-<span class="hljs-number">1</span>]:<br>                monoQueue.pop()<br>            monoQueue.append(element)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSlidingWindowByMonoQueues</span>(<span class="hljs-params">self, nums, k</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums<br>        maxList = <span class="hljs-built_in">list</span>()<br>        monoQueue = <span class="hljs-built_in">list</span>()<br><br>        monoQueue.append(nums[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,k):<br>            self.monoQueuePush(monoQueue, nums[i])<br>        maxList.append(monoQueue[<span class="hljs-number">0</span>])<br><br>        p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k,<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> monoQueue[<span class="hljs-number">0</span>] == nums[p]:<br>                monoQueue.pop(<span class="hljs-number">0</span>)<br>            p += <span class="hljs-number">1</span><br>            self.monoQueuePush(monoQueue, nums[i])<br>            maxList.append(monoQueue[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> maxList<br></code></pre></td></tr></table></figure><h1 id="59-II-队列的最大值"><a href="#59-II-队列的最大值" class="headerlink" title="59. II 队列的最大值"></a>59. II 队列的最大值</h1><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p><strong>示例 1：</strong><br>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出:<br>[null,null,null,2,1,2]</p><p><strong>示例 2：</strong><br>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出:<br>[null,-1,-1]</p><p><strong>限制：</strong><br>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p><p><strong>链接：</strong><br><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a></p><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.queue = <span class="hljs-built_in">list</span>()<br>        self.maxQueue = <span class="hljs-built_in">list</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_value</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.maxQueue) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.maxQueue[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_back</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>):</span><br>        self.queue.append(value)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(self.maxQueue) !=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> self.maxQueue[-<span class="hljs-number">1</span>] &lt; value:<br>            self.maxQueue.pop()<br>        self.maxQueue.append(value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop_front</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.queue) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        x = self.queue.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> x == self.maxQueue[<span class="hljs-number">0</span>]:<br>            self.maxQueue.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><h1 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60. n个骰子的点数"></a>60. n个骰子的点数</h1><p><strong>描述:</strong><br>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。<br>输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/</a></p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: <span class="hljs-number">1</span><br>输出: [<span class="hljs-number">0.16667,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">16667</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: <span class="hljs-number">2</span><br>输出: [<span class="hljs-number">0.02778,0</span>.<span class="hljs-number">05556,0</span>.<span class="hljs-number">08333,0</span>.<span class="hljs-number">11111,0</span>.<span class="hljs-number">13889,0</span>.<span class="hljs-number">16667,0</span>.<span class="hljs-number">13889,0</span>.<span class="hljs-number">11111,0</span>.<span class="hljs-number">08333,0</span>.<span class="hljs-number">05556,0</span>.<span class="hljs-number">02778</span>]<br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= n &lt;= <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p><strong>解:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dicesProbability</span>(<span class="hljs-params">self, n</span>):</span><br>        dp = [<span class="hljs-number">0</span>]*n<br>        dp[<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>]*<span class="hljs-number">6</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            dp[i] = [<span class="hljs-number">0</span>]*((i+<span class="hljs-number">1</span>)*<span class="hljs-number">6</span>-i)<br>            p = <span class="hljs-number">0</span><br>            q = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dp[i])):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">6</span>:<br>                    print(<span class="hljs-string">&quot;good6&quot;</span>)<br>                <span class="hljs-keyword">if</span> q == <span class="hljs-built_in">len</span>(dp[i-<span class="hljs-number">1</span>])-<span class="hljs-number">1</span>:<br>                    p += <span class="hljs-number">1</span>                  <br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> q - p == <span class="hljs-number">5</span>:<br>                        p += <span class="hljs-number">1</span><br>                        q += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        q += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(p,q+<span class="hljs-number">1</span>):<br>                    dp[i][j] += dp[i-<span class="hljs-number">1</span>][k]<br>        total = <span class="hljs-built_in">pow</span>(<span class="hljs-number">6</span>,n)<br>        output = dp[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(output)):<br>            output[i] = <span class="hljs-built_in">float</span>(output[i] / total)<br>        <span class="hljs-keyword">return</span> output<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    s = Solution()<br>    print(s.dicesProbability(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h1 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a>63. 股票的最大利润</h1><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/</a></p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,1,5,3,6,4]</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 数组长度 &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">0</span>]*<span class="hljs-built_in">len</span>(prices)<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        minPrice = prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(prices)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>],prices[i]-minPrice)<br>            <span class="hljs-keyword">if</span> prices[i] &lt; minPrice:<br>                minPrice = prices[i]<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a>66. 构建乘积数组</h1><p><strong>描述:</strong><br>给定一个数组 <code>A[0,1,…,n-1]</code>，请构建一个数组 <code>B[0,1,…,n-1]</code>，其中 <code>B[i]</code> 的值是数组 <code>A</code> 中除了下标 <code>i</code> 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p><p> <strong>链接:</strong><br><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/</a></p><p><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: <span class="hljs-string">[1,2,3,4,5]</span><br>输出: <span class="hljs-string">[120,60,40,30,24]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有元素乘积之和不会溢出 32 位整数</li><li><code>a.length &lt;= 100000</code></li></ul><p><strong>解:</strong></p><p><img src="/images/%E5%89%91%E6%8C%87offer/image-20210925225643388.png" srcset="/img/loading.gif" alt="image-20210925225643388"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">constructArr</span>(<span class="hljs-params">self, a</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> a<br>        b = [<span class="hljs-number">1</span>]*<span class="hljs-built_in">len</span>(a)<br>        t = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(a)):<br>            b[i] = b[i-<span class="hljs-number">1</span>] * a[i-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            t *= a[j+<span class="hljs-number">1</span>]<br>            b[j] *= t<br>        <span class="hljs-keyword">return</span> b<br></code></pre></td></tr></table></figure><h1 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67. 把字符串转换成整数"></a>67. 把字符串转换成整数</h1><p><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</a></p><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><blockquote><p>注意：<br>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p></blockquote><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;42&quot;</span><br><span class="hljs-section">输出: 42</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;   -42&quot;</span><br><span class="hljs-section">输出: -42</span><br><span class="hljs-section">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;4193 with words&quot;</span><br><span class="hljs-section">输出: 4193</span><br><span class="hljs-section">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;words and 987&quot;</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br>     因此无法执行有效的转换。<br></code></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: &quot;-<span class="hljs-number">91283472332</span>&quot;<br>输出: -<span class="hljs-number">2147483648</span><br>解释: 数字 &quot;-<span class="hljs-number">91283472332</span>&quot; 超过 <span class="hljs-number">32</span> 位有符号整数范围。 <br>     因此返回 INT_MIN (−<span class="hljs-number">231</span>) 。<br></code></pre></td></tr></table></figure><p>解：</p><p>愣做，多考虑特殊情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strToInt</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span></span>):</span><br>        <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>.strip()                      <span class="hljs-comment"># 删除首尾空格</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">str</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                   <span class="hljs-comment"># 字符串为空则直接返回</span><br>        res, i, sign = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>        int_max, int_min, bndry = <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> - <span class="hljs-number">1</span>, -<span class="hljs-number">2</span> ** <span class="hljs-number">31</span>, <span class="hljs-number">2</span> ** <span class="hljs-number">31</span> // <span class="hljs-number">10</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>: sign = -<span class="hljs-number">1</span>            <span class="hljs-comment"># 保存负号</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">str</span>[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span>: i = <span class="hljs-number">0</span>              <span class="hljs-comment"># 若无符号位，则需从 i = 0 开始数字拼接</span><br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>[i:]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &lt;= <span class="hljs-string">&#x27;9&#x27;</span> : <span class="hljs-keyword">break</span>     <span class="hljs-comment"># 遇到非数字的字符则跳出</span><br>            <span class="hljs-keyword">if</span> res &gt; bndry <span class="hljs-keyword">or</span> res == bndry <span class="hljs-keyword">and</span> c &gt; <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-keyword">return</span> int_max <span class="hljs-keyword">if</span> sign == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> int_min <span class="hljs-comment"># 数字越界处理</span><br>            res = <span class="hljs-number">10</span> * res + <span class="hljs-built_in">ord</span>(c) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment"># 数字拼接</span><br>        <span class="hljs-keyword">return</span> sign * res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>New2048开发文档</title>
    <link href="/2021/07/01/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/2021/07/01/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="New2048开发日志"><a href="#New2048开发日志" class="headerlink" title="New2048开发日志"></a>New2048开发日志</h1><p><strong>项目信息：</strong><br>项目负责人：买烤麸烤饼<br>主程序：买烤麸烤饼<br>美工：买烤麸烤饼<br>音效：洛一<br>配音：小鸠<br>项目开发周期：2021.6.25-2021.7.4</p><p><strong>版本信息：</strong></p><ul><li>v1.0 完成2048的基础玩法</li><li>v2.0 增加球球新玩法</li></ul><h1 id="1-玩法分析"><a href="#1-玩法分析" class="headerlink" title="1. 玩法分析"></a>1. 玩法分析</h1><h2 id="1-1-经典模式"><a href="#1-1-经典模式" class="headerlink" title="1.1 经典模式"></a>1.1 经典模式</h2><p><strong>游戏原型：</strong>2048</p><p><strong>游戏目标：</strong><br>合成更多数字块以得到更高的分数</p><p><strong>得分计算：</strong><br>当两个相同数字块合并时，得分+=新数字块的数字</p><p><strong>玩家操作：</strong></p><ul><li>向上滑动<br>上方向键</li><li>向下滑动<br>下方向键</li><li>向左滑动<br>左方向键</li><li>向右滑动<br>右方向键</li></ul><p><strong>失败判定：</strong><br>棋盘被数字填满，无法进行有效移动，判负，游戏结束。</p><p><strong>流程简述：</strong><br>开始时棋盘内随机出现两个数字<br>出现的数字仅可能为2或4。</p><p>玩家可以选择上下左右四个方向<br>若棋盘内的数字出现位移或合并，视为有效移动。</p><p>玩家选择的方向上若有相同的数字则合并<br>每次有效移动可以同时合并，但不可以连续合并。</p><p>合并所得的所有新生成数字想加即为该步的有效得分。</p><p>玩家选择的方向行或列前方有空格则出现位移。</p><p>每有效移动一步，棋盘的空位(无数字处)随机出现一个数字(依然可能为2或4)。</p><p>棋盘被数字填满，无法进行有效移动，判负，游戏结束。</p><p>棋盘上出现2048，判胜，游戏结束。<br>也可以继续游戏，攒出更大的数字</p><h2 id="1-1-球球模式"><a href="#1-1-球球模式" class="headerlink" title="1.1 球球模式"></a>1.1 球球模式</h2><p><strong>游戏原型：</strong>合成大西瓜</p><p><strong>游戏目标：</strong><br>合成更多数字球以得到更高的分数</p><p><strong>得分计算：</strong><br>当两个相同数字球合并时，得分+=新数字块的数字</p><p><strong>玩家操作：</strong></p><ul><li>触摸控制球球生成位置<br>鼠标控制球球生成位置</li><li>长按抖动水池<br>按空格抖动水池</li></ul><p><strong>失败判断：</strong><br>当水池被球球填满时游戏结束</p><p><strong>流程简述：</strong><br>随机生成2，4，8的球，掉落至水池中<br>遇到相同数字的球则合并</p><p>玩家可以在水池上方控制潜水艇的左右位置决定新生成球的位置</p><p>当水池被填满时游戏结束</p><h1 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h1><h2 id="2-1-游戏实体分析"><a href="#2-1-游戏实体分析" class="headerlink" title="2.1 游戏实体分析"></a>2.1 游戏实体分析</h2><h3 id="2-1-1-经典模式"><a href="#2-1-1-经典模式" class="headerlink" title="2.1.1 经典模式"></a>2.1.1 经典模式</h3><ul><li>数字块<br>有数字2,4,8,16,32…<br>不同数字使用不同的精灵图片<br>但是是同一个预制体</li><li>棋盘<br>能放下4*4=16个数字块的棋盘</li></ul><h3 id="2-1-2-球球模式"><a href="#2-1-2-球球模式" class="headerlink" title="2.1.2 球球模式"></a>2.1.2 球球模式</h3><ul><li>数字球<br>有数字2,4,8,16,32…<br>不同数字使用不同的精灵图片，有不同的大小<br>但是是同一个预制体</li><li>水池<br>左，右，下三个方向有碰撞体积<br>上方有触发器<br>可以晃动</li><li>潜水艇<br>通过潜水艇来释放数字球<br>潜水艇在水池上方固定高度移动</li></ul><h2 id="2-2-UI需求分析"><a href="#2-2-UI需求分析" class="headerlink" title="2.2 UI需求分析"></a>2.2 UI需求分析</h2><h2 id="2-3-音效需求分析"><a href="#2-3-音效需求分析" class="headerlink" title="2.3 音效需求分析"></a>2.3 音效需求分析</h2><p><strong>配音内容：</strong></p><table><thead><tr><th>用于</th><th>内容</th><th>描述</th></tr></thead><tbody><tr><td>游戏开始</td><td>Game Start！</td><td>日式大佐英语，元气语气</td></tr><tr><td>游戏开始</td><td>游戏开始了哦！</td><td>中文，认真系美少女语气</td></tr><tr><td>游戏结束</td><td>Game Over…</td><td>日式大佐英语，惋惜语气</td></tr><tr><td>游戏结束</td><td>失敗しました(失败啦…)</td><td>日语，无口少女棒读</td></tr><tr><td>新纪录</td><td>New Score！</td><td>日式大佐英语，元气语气</td></tr></tbody></table><p>配音员：小鸠</p><ul><li>BGM 一条</li><li>人声配音5条</li></ul><h1 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h1><h2 id="3-1-工程类图"><a href="#3-1-工程类图" class="headerlink" title="3.1 工程类图"></a>3.1 工程类图</h2><h3 id="3-1-1-主场景-HomePageScene"><a href="#3-1-1-主场景-HomePageScene" class="headerlink" title="3.1.1 主场景(HomePageScene)"></a>3.1.1 主场景(HomePageScene)</h3><p><strong>实体类图设计</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210704201328215.png" srcset="/img/loading.gif" alt="主场景(HomePageScene)实体类图设计"></p><p><strong>活动图</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210704203522669.png" srcset="/img/loading.gif" alt="主场景活动图"></p><p><strong>View视图类：</strong></p><p>该场景为游戏开始时的主场景，用于玩家选择模式，加载游戏，查看游戏介绍等功能的实现。<br>在该场景下有一个主画布，该主画布下有3个功能面板，详细情况如下：</p><ul><li>HomePanel<br>主面板<br>是游戏的入口界面</li><li>AboutPanel<br>关于面板<br>是游戏的介绍界面</li><li>ModeChosePanel<br>模式选择面板<br>用于选择开始与加载的游戏模式</li></ul><p>该场景的所有视图对象(UI)由<strong>HomePageUIManager</strong>类控制，它作为组件挂载在主画布<strong>Canvas</strong>上，其中包含了各个面板的全部按键响应函数。</p><p><strong>Controller控制类：</strong></p><p><strong>PlayerSetting</strong>类是该场景的唯一控制类，该类用于记录用户两种游戏设置：</p><ul><li>bool Mute<br>游戏是否静音</li><li>bool IsLoad<br>是否加载之前保存的游戏进度</li></ul><p>该类的脚本挂载至一个名叫<strong>PlayerSetting</strong>的空物体上，并设置为<strong>DontDestroyOnLoad</strong>(切换场景时不销毁该GO)。它会传递到下一个场景，即游戏场景，来决定是否加载之前保存的游戏进度。</p><h3 id="3-1-2-经典模式场景-GameScene1"><a href="#3-1-2-经典模式场景-GameScene1" class="headerlink" title="3.1.2 经典模式场景(GameScene1)"></a>3.1.2 经典模式场景(GameScene1)</h3><p><strong>实体类图设计:</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="经典模式实体类图"></p><p><strong>场景活动图:</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2048-%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%BC%8F%E5%9C%BA%E6%99%AF%E6%B4%BB%E5%8A%A8%E5%9B%BE.png" srcset="/img/loading.gif"></p><p><strong>View视图类:</strong></p><p>该场景为经典模式游戏的场景，用于玩家游玩经典模式的2048小游戏。<br>在该场景下有三个画布，详细情况如下：</p><ul><li>GameCanvas<br>游戏画布<br>是进行游戏的界面</li><li>PauseCanvas<br>暂停画布<br>是游戏暂停时的功能性画布</li><li>GGCanvas<br>游戏失败画布<br>是游戏失败后弹出的画布</li></ul><p>该场景的所有视图对象(UI)由<strong>GamePageUIManager</strong>类控制，它作为组件挂载在EventSystem上，其中包含了各个画布的全部按键响应函数。</p><p>值得注意的是，因为UI与游戏物体高度融合，Map应当显示在UI背景的前方。因此画布应当设置为<strong>Screen Space-Camera渲染模式</strong>。相关知识详见<a href="https://mycroftcooper.github.io/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/">UGUI详解-画布</a></p><h3 id="3-1-3-球球模式场景-GameScene2"><a href="#3-1-3-球球模式场景-GameScene2" class="headerlink" title="3.1.3 球球模式场景(GameScene2)"></a>3.1.3 球球模式场景(GameScene2)</h3><p><strong>实体类图设计:</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/2048-%E7%90%83%E7%90%83%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE.png" srcset="/img/loading.gif" alt="2048-球球模式设计类图"></p><h2 id="3-2-UI实现"><a href="#3-2-UI实现" class="headerlink" title="3.2 UI实现"></a>3.2 UI实现</h2><p><strong>开始界面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629220904860.png" srcset="/img/loading.gif" alt="开始界面"></p><p><strong>模式选择页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221015700.png" srcset="/img/loading.gif" alt="模式选择页面"></p><p><strong>经典模式页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221144410.png" srcset="/img/loading.gif" alt="经典模式页面"></p><p><strong>球球模式页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221506826.png" srcset="/img/loading.gif" alt="球球模式页面"></p><p><strong>暂停页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221318433.png" srcset="/img/loading.gif" alt="暂停页面"></p><p><strong>失败页面</strong></p><p><img src="/images/2048%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/image-20210629221350145.png" srcset="/img/loading.gif" alt="失败页面"></p><h2 id="3-3-技术实现亮点与难点"><a href="#3-3-技术实现亮点与难点" class="headerlink" title="3.3 技术实现亮点与难点"></a>3.3 技术实现亮点与难点</h2><h3 id="3-3-1-2048经典模式核心玩法算法"><a href="#3-3-1-2048经典模式核心玩法算法" class="headerlink" title="3.3.1 2048经典模式核心玩法算法"></a>3.3.1 2048经典模式核心玩法算法</h3><h4 id="数字块的抽象"><a href="#数字块的抽象" class="headerlink" title="数字块的抽象"></a>数字块的抽象</h4><p>将每个数字抽象为一个数字块类，放入棋盘的格子中。</p><p>是用Block类的二维数组存储数字块</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">static</span> GameController_Mode1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Map</span>:<span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> sideLength;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> blockCounter;<br>    <span class="hljs-keyword">private</span> Block [][] blocks;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Score &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> BestScore &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitMap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> sideLength</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.sideLength = sideLength;<br>        blocks = <span class="hljs-keyword">new</span> Block[sideLength][];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength; i++)<br>        &#123;<br>            blocks[i] = <span class="hljs-keyword">new</span> Block[sideLength];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; sideLength; j++)<br>            &#123;<br>                blocks[i][j] = <span class="hljs-keyword">new</span> Block(<span class="hljs-keyword">new</span> Vector2Int(i, j), screenPosition[i, j]);<br>            &#125;<br>        &#125;<br>        blockCounter = <span class="hljs-number">0</span>;<br>        transform.position = originalPosition;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DestroyMap</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Block[] i <span class="hljs-keyword">in</span> blocks)<br>        &#123;<br>            <span class="hljs-keyword">foreach</span>(Block j <span class="hljs-keyword">in</span> i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!j.isEmpty())<br>                &#123;<br>                    GameObject.Destroy(j.Entity.gameObject);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//剩下的代码在下面</span><br></code></pre></td></tr></table></figure><h4 id="数字块的生成与合并"><a href="#数字块的生成与合并" class="headerlink" title="数字块的生成与合并"></a>数字块的生成与合并</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 生成数字块</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNewNumber</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//在哪里生成</span><br><span class="hljs-built_in">int</span> putWhere = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">15</span> - blockCounter);<br><span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; sideLength; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!blocks[i][j].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (counter == putWhere)<br>            &#123;<br>                blocks[i][j].Entity = EntityControllerMode1.createNewEntity(blocks[i][j]);<br>                blockCounter++;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> counter++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//合并数字块</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeNumber</span>(<span class="hljs-params">Block blockA,Block blockB</span>)</span><br><span class="hljs-function"></span>&#123;<br>    blockA.Entity.isChanged = <span class="hljs-literal">true</span>;<br>    Score += blockB.Entity.Num;<br>    GameObject.Destroy(blockB.Entity.gameObject);<br>    blockCounter--;<br>    blockB.Entity = blockA.Entity;<br>    blockA.Entity = <span class="hljs-literal">null</span>;<br>    blockB.Entity.doEntityMove(blockB);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数字块的移动"><a href="#数字块的移动" class="headerlink" title="数字块的移动"></a>数字块的移动</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveNumber</span>(<span class="hljs-params">Block blockA, Block blockB</span>)<span class="hljs-comment">//AtoB</span></span><br><span class="hljs-function"></span>&#123;<br>    blockB.Entity = blockA.Entity;<br>    blockA.Entity = <span class="hljs-literal">null</span>;<br>    blockB.Entity.doEntityMove(blockB);<br>&#125;<br><br><span class="hljs-comment">//判断是否有数字块正在移动(其实可以用回调函数)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">isNowMoving</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (transform.localPosition != originalPosition)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sideLength;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;sideLength;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!blocks[i][j].isEmpty() &amp;&amp;<br>                !blocks[i][j].Entity.isOnPosition( blocks[i][j].ScreenPosition))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//向四个方向移动的算法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveUp</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">1</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextRow = row - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[nextRow][col].isEmpty() &amp;&amp; nextRow != <span class="hljs-number">0</span>)<br>                nextRow--;<br>            <span class="hljs-keyword">if</span> (!blocks[nextRow][col].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[nextRow][col].Entity.Num &amp;&amp; !blocks[nextRow][col].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[nextRow][col]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>; <br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextRow == (row - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextRow++;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[nextRow][col]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveDown</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = sideLength<span class="hljs-number">-2</span>; row &gt;=<span class="hljs-number">0</span>; row--)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">0</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextRow = row + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[nextRow][col].isEmpty() &amp;&amp; nextRow != sideLength<span class="hljs-number">-1</span>)<br>                nextRow++;<br>            <span class="hljs-keyword">if</span> (!blocks[nextRow][col].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[nextRow][col].Entity.Num &amp;&amp; !blocks[nextRow][col].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[nextRow][col]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextRow == (row + <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextRow--;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[nextRow][col]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveLeft</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = <span class="hljs-number">1</span>; col &lt; sideLength; col++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextCol = col - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[row][nextCol].isEmpty() &amp;&amp; nextCol != <span class="hljs-number">0</span>)<br>                nextCol--;<br>            <span class="hljs-keyword">if</span> (!blocks[row][nextCol].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[row][nextCol].Entity.Num &amp;&amp; !blocks[row][nextCol].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[row][nextCol]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextCol == (col - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextCol++;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[row][nextCol]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">moveRight</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">bool</span> isMoved = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> row = <span class="hljs-number">0</span>; row &lt; sideLength; row++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> col = sideLength - <span class="hljs-number">2</span>; col &gt;=<span class="hljs-number">0</span>; col--)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[row][col].isEmpty()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">int</span> nextCol = col + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (blocks[row][nextCol].isEmpty() &amp;&amp; nextCol != sideLength - <span class="hljs-number">1</span>)<br>                nextCol++;<br>            <span class="hljs-keyword">if</span> (!blocks[row][nextCol].isEmpty())<br>            &#123;<br>                <span class="hljs-keyword">if</span> (blocks[row][col].Entity.Num == blocks[row][nextCol].Entity.Num &amp;&amp; !blocks[row][nextCol].Entity.isChanged)<br>                &#123;<br>                    mergeNumber(blocks[row][col], blocks[row][nextCol]);<br>                    isMoved = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (nextCol == (col + <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>                    nextCol--;<br>                &#125;<br>            &#125;<br>            moveNumber(blocks[row][col], blocks[row][nextCol]);<br>            isMoved = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> isMoved;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是逻辑层面移动数字块，实际上每个数字块的移动是用协程实现的。<br>协程是用法可见：<br><a href="https://mycroftcooper.github.io/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/">https://mycroftcooper.github.io/2021/06/19/Unity-%E5%8D%8F%E7%A8%8B/</a></p><h4 id="判断游戏结束"><a href="#判断游戏结束" class="headerlink" title="判断游戏结束"></a>判断游戏结束</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">isLose</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (blockCounter != (<span class="hljs-built_in">int</span>)Mathf.Pow((<span class="hljs-built_in">float</span>)sideLength, <span class="hljs-number">2f</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;sideLength;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;sideLength<span class="hljs-number">-1</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (blocks[i][j].Entity.Num == blocks[i][j + <span class="hljs-number">1</span>].Entity.Num) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(blocks[j][i].Entity.Num == blocks[j+<span class="hljs-number">1</span>][i].Entity.Num) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-球球模式的潜水艇控制"><a href="#3-3-3-球球模式的潜水艇控制" class="headerlink" title="3.3.3 球球模式的潜水艇控制"></a>3.3.3 球球模式的潜水艇控制</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//用户输入检测</span><br><span class="hljs-keyword">private</span> Touch touch;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PhoneInput</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!GC.IsPause() &amp;&amp; !GC.isShaking)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Input.touchCount != <span class="hljs-number">1</span> &amp;&amp; Input.touchCount != <span class="hljs-number">2</span>) <br>            <span class="hljs-keyword">return</span>;<br>        touch = Input.GetTouch(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (Input.touchCount == <span class="hljs-number">2</span>)<br>        &#123;<br>            GC.dropTheEntity();<br>            GC.shakePool();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Input.GetTouch(<span class="hljs-number">0</span>).phase == TouchPhase.Moved)<br>            GC.moveSubmarine(Camera.main.ScreenToWorldPoint(touch.position));<br>        <span class="hljs-keyword">if</span> (!GC.hasNewEntity() <br>            &amp;&amp; touch.phase==TouchPhase.Began &amp;&amp; Input.touchCount ==<span class="hljs-number">1</span>)<br>            GC.createNewEntity();<br>        <span class="hljs-keyword">if</span> (touch.phase == TouchPhase.Ended)<br>            GC.dropTheEntity();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//潜水艇移动响应函数</span><br><span class="hljs-keyword">private</span> Vector3 LeftLimiter = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-2f</span>, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br><span class="hljs-keyword">private</span> Vector3 RightLimiter = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">2f</span>, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move_EventHandle</span>(<span class="hljs-params">Vector3 targetPosition</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (targetPosition.x &lt; LeftLimiter.x)<br>        transform.position = LeftLimiter;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetPosition.x &gt; RightLimiter.x)<br>        transform.position = RightLimiter;<br>    <span class="hljs-keyword">else</span><br>        transform.position = <span class="hljs-keyword">new</span> Vector3(targetPosition.x, <span class="hljs-number">2.65f</span>, <span class="hljs-number">0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目开发文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目开发文档</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader 标准光照模型(一)理论基础</title>
    <link href="/2021/06/22/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/06/22/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>虽然光照模型有很多种类，但在早期的游戏引擎中往往只使用一个光照模型，这个模型被称为标准光照模型。</p><p>在1975年，著名学者<strong>裴祥风(Bui Tuong Phong)</strong> 提出了标准光照模型背后的基本理念。</p><p>标准光照模型只关心**直接光照(directlight)**，也就是那些直接从光源发射出来照射到物体表面后,经过物体表面的一次反射直接进入摄像机的光线。</p><p>它的基本方法是，把进入到摄像机内的光线分为4个部分，每个部分使用一种方法来计算它的贡献度。</p><p>这4个部分是：</p><ul><li><p><strong>自发光 (emissive)</strong><br>这个部分用于描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量。<br>需要注意的是：<br>如果没有使用<strong>全局光照(globalillumination)技术</strong>，这些自发光的表面并不会真的照亮周围的物体，而是它本身看起来更亮了而已。</p></li><li><p><strong>高光反射(specular)</strong><br>这个部分用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。</p></li><li><p><strong>漫反射(diffuse)</strong><br>这个部分用于描述，当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量。</p></li><li><p><strong>环境光 (ambient)</strong><br>它用于描述其他所有的间接光照。</p></li></ul><p>标准光照模型仅仅是一个经验模型，它并不完全符合真实世界中的光照现象。<br>但由于它的易用性、计算速度和得到的效果都比较好，因此仍然被广泛使用。</p><p>但这种模型有很多局限性。</p><ul><li>有很多重要的物理现象无法用<strong>Blinn-Phong模型</strong>表现出来，<br>例如**菲涅耳反射(Fresnel reflection)**。</li><li><strong>Blinn-Phong 模型</strong>是<strong>各项同性(isotropic)</strong> 的<br>当我们固定视角和光源方向旋转这个表面时，反射不会发生任何改变。<br>但有些表面是具有**各向异性(anisotropic)**反射性质的例如拉丝金属、毛发等。<br>所以它看起来不够真实</li></ul><h1 id="2-理论基础"><a href="#2-理论基础" class="headerlink" title="2. 理论基础"></a>2. 理论基础</h1><h2 id="2-1-环境光"><a href="#2-1-环境光" class="headerlink" title="2.1 环境光"></a>2.1 环境光</h2><p>虽然标准光照模型的重点在于描述直接光照，但在真实的世界中，物体也可以被间接光照(indirect light)所照亮。</p><p>间接光照指：光线通常会在多个物体之间反射，最后进入摄像机。<br>也就是说，在光线进入摄像机之前，经过了不止一次的物体反射。<br>例如：<br>在红地毯上放置一个浅灰色的沙发，那么沙发底部也会有红色，这些红色是由红地毯反射了一部分光线，再反弹到沙发上的。</p><p>在标准光照模型中，我们使用了一种被称为环境光的部分来近似模拟间接光照。<br>环境光的计算非常简单，它通常是一个 全局变量，即场景中的所有物体都使用这个环境光。</p><p><strong>环境光计算公式：</strong><br>$c_{ambient}=g_{ambient}$<br><strong>物体环境光=全局环境光</strong></p><h2 id="2-2-自发光"><a href="#2-2-自发光" class="headerlink" title="2.2 自发光"></a>2.2 自发光</h2><p>光线也可以直接由光源发射进入摄像机，而不需要经过任何物体的反射。</p><p>标准光照模型使用自发光来计算这个部分的贡献度。<br>它的计算也很简单，就是直接使用了该材质的自发光颜色:</p><p><strong>自发光计算公式：</strong><br>$c_{emissive}=m_{emissive}$<br><strong>物体自发光=该物体材质自发光</strong></p><blockquote><p>通常在实时渲染中，自发光的表面往往并不会照亮周围的表面<br>也就是说，这个物体并不会被当成一个光源。<br>Unity5引入的全新的全局光照系统则可以模拟这类自发光物体对周围物体的影响</p></blockquote><h2 id="2-3-漫反射"><a href="#2-3-漫反射" class="headerlink" title="2.3 漫反射"></a>2.3 漫反射</h2><p>漫反射光照是用于对那些被物体表面随机散射到各个方向的辐射度进行建模的。</p><p>在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为在任何反射方向上的分布都是一样的。但是，入射光线的角度很重要。</p><p>漫反射光照符合<strong>兰伯特定律(Lambert’s law)</strong>:<br>反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比。</p><p><strong>漫反射计算公式：</strong><br>$c_{diffuse}=(c_{light}·m_{diffuse})max(0,n·I)$<br><strong>物体漫反射光=(光源颜色·物体材质漫反射颜色)·取大值(0,法线方向矢量·光源方向矢量)</strong><br>其中：</p><ul><li><p>n是表面法线</p></li><li><p>I是指向光源的单位矢量</p></li><li><p>$m_{diffuse}$是材质的漫反射颜色</p></li><li><p>$c_{light}$ 是光源颜色。</p></li></ul><blockquote><p>需要注意的是:<br>我们需要防止法线和光源方向点乘的结果为负值，<br>为此，我们使用取最大值的函数来将其截取到0，<br>这可以防止物体被从后面来的光源照亮。</p></blockquote><h2 id="2-4-高光反射"><a href="#2-4-高光反射" class="headerlink" title="2.4 高光反射"></a>2.4 高光反射</h2><h3 id="2-4-1-Phong模型"><a href="#2-4-1-Phong模型" class="headerlink" title="2.4.1 Phong模型"></a>2.4.1 Phong模型</h3><p>这里的高光反射是一种经验模型， 也就是说，它并不完全符合真实世界中的高光反射现象。</p><p>它可用于计算那些沿着完全镜面反射方向被反射的光线，这可以让物体看起来是有光泽的，例如金属材质。</p><p>计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向等。<br>我们假设这些矢量都是单位矢量。如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622112428355.png" srcset="/img/loading.gif" alt="image-20210622112428355"></p><p>在这四个矢量中，我们实际上只需要知道其中3个矢量即可，而反射方向可以通过其他信息计算得到：<br>$\hat r=2(\hat n·I)\hat n-I$</p><p>这样，我们就可以利用Phong 模型来计算高光反射的部分:<br><strong>高光反射计算公式(Phong模型)：</strong><br>$c_{spscular}=(c_{light}·m_{specular})max(0,\hat v·\hat r)^{m_{gloss}} $<br><strong>物体高光反射=(光源颜色·物体材质高光反射颜色)·取大值(0,视角向量方向·反射向量方向)物体光泽度次幕</strong><br>其中:</p><ul><li><p>$m_{specular}$是材质的光泽度(gloss)， 也被称为反光度(shininess)。<br>它用于控制高光区域的亮点”有多宽，mgloss越大，亮点就越小。</p></li><li><p>$m_{specular}$是材质的高光反射颜色，<br>它用于控制该材质对于高光反射的强度和颜色。</p></li><li><p>$c_{light}$ 则是光源的颜色和强度。</p></li></ul><p>同样，这里也需要防止$\hat v·\hat r$的结果为负数。</p><h3 id="2-4-2-Blinn模型"><a href="#2-4-2-Blinn模型" class="headerlink" title="2.4.2 Blinn模型"></a>2.4.2 Blinn模型</h3><p>和上述的Phong 模型相比，Blinn 提出了一个简单的修改方法来得到类似的效果。<br>它的基本思想是，避免计算反射方向$\hat r$。<br>为此，Blin 模型引入了一个新的矢量$\hat h$，它是通过对$\hat v$和$\hat I$的取平均后再归一化得到的。</p><p>即:<br>$\hat h=\frac {\hat v+I}{|\hat v+I|}$<br>然后，使用$\hat h$和$\hat n$之间的夹角进行计算，而非$\hat v$和$\hat r$之间的夹角如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622114447454.png" srcset="/img/loading.gif" alt="image-20210622114447454"><br><strong>高光反射计算公式(Blinn模型)：</strong><br>$c_{spscular}=(c_{light}·m_{specular})max(0,\hat n·\hat h)^{m_{gloss}} $<br><strong>物体高光反射=(光源颜色·物体材质高光反射颜色)·取大值(0,法线方向·向量h方向)物体光泽度次幕</strong></p><p>$\hat h=\frac {\hat v+I}{|\hat v+I|}$<br><strong>$向量h方向=\frac {视角方向向量+光源方向向量}{|视角方向向量+光源方向向量|}$</strong></p><p>在硬件实现时:</p><ul><li>若摄像机和光源距离模型足够远<br>Blinn 模型会快于Phong模型<br>因为此时可以认为$\hat v$和$\hat I$都是定值，因此$\hat h$将是一个常量。</li><li>当$\hat v$和$\hat I$不是定值时，Phong 模型可能反而更快一些。</li></ul><blockquote><p>注意:<br>这两种光照模型都是经验模型<br>也就是说，我们不应该认为Blinn 模型是对“正确的”Phong模型的近似。<br>实际上，在一些情况下，Blinn 模型更符合实验结果。</p></blockquote><h2 id="2-5-标准光照模型的两种着色"><a href="#2-5-标准光照模型的两种着色" class="headerlink" title="2.5 标准光照模型的两种着色"></a>2.5 标准光照模型的两种着色</h2><p>计算光照模型通有两种选择:</p><ul><li><p><strong>在片元着色器中计算——逐像素光照(per-pixel lighting)</strong><br>也被称为<strong>Phong着色(Phong shading)**或</strong>Phong插值<strong>或</strong>法线插值**着色技术<br>在逐像素光照中，我们会以每个像素为基础，得到它的法线<br>(可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的)，然后进行光照模型的计算。</p><blockquote><p>这不同于我们之前讲到的Phong光照模型。</p></blockquote></li><li><p><strong>在顶点着色器中计算——逐顶点光照(per-vertex lighting)</strong><br>也被称为**高洛德着色(Gouraud shading)**。<br>我们在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。<br>由于顶点数目往往远小于像素数目，因此逐顶点光照的计算量往往要小于逐像素光照。</p><blockquote><p>注意：<br>由于逐顶点光照依赖于线性插值来得到像素光照<br>因此，当光照模型中有非线性的计算( 例如计算高光反射时)时，逐顶点光照就会出问题。<br>而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，<br>这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。</p></blockquote></li></ul><h1 id="3-动手实践"><a href="#3-动手实践" class="headerlink" title="3.动手实践"></a>3.动手实践</h1><h2 id="3-1-在Unity中实现环境光与自发光"><a href="#3-1-在Unity中实现环境光与自发光" class="headerlink" title="3.1 在Unity中实现环境光与自发光"></a>3.1 在Unity中实现环境光与自发光</h2><p>在标准光照模型中，环境光和自发光的计算是最简单的。<br>在Unity中,场景中的环境光可以在：<br>Window-&gt;Lighting -&gt; Ambient Source/Ambient Color/Ambient Intensity(英文)<br>窗口-&gt;渲染-&gt;光照-&gt;场景-&gt;环境中控制，</p><p>如下图所示：<br><img src="/images/UnityShader%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/image-20210622131750865.png" srcset="/img/loading.gif" alt="image-20210622131750865"></p><p>在Shader中，我们只需要通过Unity的内置变量UNITY_ LIGHTMODEL AMBIENT就可以得到环境光的颜色和强度信息。</p><p>而大多数物体是没有自发光特性的。<br>如果要计算自发光也非常简单，我们只需要在片元着色器输出最后的颜色之前，把材质的自发光颜色添加到输出颜色上即可。</p><h2 id="3-2-在UnityShader中实现漫反射光照模型"><a href="#3-2-在UnityShader中实现漫反射光照模型" class="headerlink" title="3.2 在UnityShader中实现漫反射光照模型"></a>3.2 在UnityShader中实现漫反射光照模型</h2><p>从公式可以看出，要计算漫反射需要知道4个参数:入射光线的颜色和强度Cight, 材质的漫<br>反射系数mdij<br>lifuse<br>表面法线介 以及光源方向I。2<br>为了防止点积结果为负值，我们需要使用max操作，而CG提供了这样的函数。在本例中，<br>使用CG的另一个函数可以达到同样的目的，即saturate函数。<br>函数: saturate(x)<br>参数: x:为用于操作的标量或矢量，可以是float、 float2、 float3 等类型。<br>描述:把x截取在[0, 1]范围内，如果x是一一个矢量，那么会对它的每一一个分量进行这样的操作。</p><h3 id="3-2-1-逐项点光照"><a href="#3-2-1-逐项点光照" class="headerlink" title="3.2.1 逐项点光照"></a>3.2.1 逐项点光照</h3><p>我们首先来看如何实现-一个逐顶点的漫反射光照效果。在学习完本节后，我们会得到类似<br>图6.6中的效果。<br>为此，我们进行如下准备工作。<br>(1)在Unity中新建一一个场景。在本书资源中，该场景名为Scene_ 6 _4。 在Unity 5.2中，默<br>认情况下场景将包含一个摄像机和一个平行光，并且使用了内置的天空盒子。在Window -&gt;</p><p>Lighting -&gt; Skybox中去掉场景中的天空盒子。<br>(2) 新建一个材质。在本书资源中，该材质名为DiffuseVertexLevelMato<br>(3)新建一一个 Unity Shader.在本书资源中，该Shader<br>名为Chapter6-DiffuseVertexLevel。 把新的Shader 赋给<br>第2步中创建的材质。<br>(4)在场景中创建一个胶囊体，并把第2步中的材<br>质赋给该胶囊体。<br>(5)保存场景。<br>下面，我们需要编写自己的Shader来实现–个逐顶<br>点的漫反射效果。打开第3步中创建的Unity Shader,<br>删除所有已有代码，并进行如下修改。<br>(1)首先，我们需要为这个Shader起一 一个名字:<br>Shader “Unity Shaders Book/Chapter 6/Dlffuse Vertex-Level” {<br>(2)为了得到并且控制材质的漫反射颜色，我们首先在Shader的Properties语义块中声明了<br>个Color类型的属性，并把它的初始值设为白色:<br>Properties {.<br>Diffuse (“Diffuse”, Color) = (1, 1, 1, 1)<br>(3)然后，我们在SsubShader语义块中定义了一个Pass 语义块。这是因为顶点/片元着色器的<br>代码需要写在Pass 语义块，而非SubShader语义块中。而且，我们在Pass的第一行指明 了该Pass<br>的光照模式:<br>SubShader {<br>Pass<br>Tags { “LightMode “= “ForwardBase” }<br>LightMode标签是Pass标签中的一种，它用于定义该Pass在Unity的光照流水线中的角色，<br>在第9章中我们会更加详细地解释它。在这里，我们只需要知道，只有定义了正确的LightMode,<br>我们才能得到一些Unity的内置光照变量，例如下面要讲到的_ LightColor0。<br>(4)然后，我们使用CGPROGRAM和ENDCG米包围CG代码片，以定义最重要的顶点着色<br>器和片元着色器代码。首先，我们使用#pragma指令来告诉Unity,我们定义的顶点着色器和片元<br>着色器叫什么名字。在本例中，它们的名字分别是vert和frag:<br>CGPROGRAM<br>#pragma vertex vert<br>#pragma fragment frag<br>(5)为了使用Unity内置的一些变量， 如后面要讲到的<em>LightColor0， 还需要包含进Unity的<br>内置文件Lighting.cginc:<br>#include “Lighting. cginc”<br>(6) 为了在Shader中使用Properties语义块中声明的属性，我们需要定义一个和该属性类型<br>相匹配的变量:<br>fixed4</em> Diffuse;<br>通过这样的方式，我们就可以得到漫反射公式中需要的参数之一一一材 质的漫反射属性。由<br>于颜色属性的范围在0到1之间，因此我们可以使用fixed精度的变量来存储它。</p><p>(7)然后，我们定义了顶点着色器的输入和输出结构体(输出结构体同时也是片元着色器的<br>输入结构体):<br>struct a2v {<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>struct v2f (<br>float4 pos : SV_ POSITION;<br>fixed3 color : COLOR;<br>;<br>为了访问顶点的法线，我们需要在a2v中定义-个normal变量，并通过使用NORMAL语义<br>来告诉Unity要把模型项点的法线信息存储到normal变量中。为了把在项点着色器中计算得到的<br>光照颜色传递给片元着色器，我们需要在v2f中定义-一个color变量，且并不是必须使用COLOR<br>语义，一些资料中会使用TEXCOORDO语义。<br>(8)接下来是关键的顶点着色器。由于本小节关注如何实现一一个逐顶点的漫反射光照，因此<br>漫反射部分的计算都将在顶点着色器中进行:<br>v2f vert(a2v v) {<br>v2f o;<br>// Transform the vertex from object. space, to projection space<br>o.pos = mul (UNITY_ MATRIX MVP，v.vertex);<br>/ Get ambient term<br>fixed3 ambient = UNITY_ LIGHTMODEL_ AMBIENT 。xyz;<br>// Transform the normal fram object space to world space<br>fixed3 worldNormal = normalize (mul (v.normal, (f1oat3x3)_ Wor1d20bject));<br>// Get the 1ight direction in world space<br>fixed3 worldLight . normalize(_ WorldSpaceLightPos0.xyz);<br>// Compute diffuse term<br>fixed3 diffuse = LightColor0.rgb * Diffuse.rgb * saturate (dot (worldNormal,<br>worldLight));<br>o.color = ambient + diffuse;<br>return o;<br>在第一行，我们首先定义了返回值0。我们已经重复过很多次，顶点着色器最基本的任务就<br>是把顶点位置从模型空间转换到裁剪空间中，因此我们需要使用Unity内置的模型<em>世界</em>投影矩<br>阵UNITY MATRIX MVP来完成这样的坐标变换。接下来，我们通过Unity 的内置变量<br>UNITY LIGHTMODEL_ AMBIENT得到了环境光部分。<br>然后，就是真正计算漫反射光照的部分。回忆一下，为了计算漫反射光照我们需要知道4个<br>参数。在前面的步骤中，我们已经知道了材质的漫反射颜色<em>Diffuse 以及顶点法线v.normal。我们<br>还需要知道光源的颜色和强度信息以及光源方向。Unity 提供给我们一“个内置变量LightColor0 来<br>访问该Pass 处理的光源的颜色和强度信息(注意，想要得到正确的值需要定义合适的LightMode<br>标签)，而光源方向可以由</em> WorldSpaceLightPos0 来得到。需要注意的是，这里对光源方向的计算<br>并不具有通用性。在本节中，我们假设场景中只有一个光源且该光源的类型是平行光。但如果场<br>景中有多个光源并且类型可能是点光源等其他类型，直接使用_ WorldSpaceLightPos0就不能得到<br>正确的结果。我们将在6.6节中学习如何使用内置函数来处理更复杂的光源类型。<br>在计算法线和光源方向之间的点积时，我们需要选择它们所在的坐标系，只有两者处于同一<br>坐标空间下，它们的点积才有意义。在这里，我们选择了世界坐标空间。而由a2v得到的顶点法<br>线是位于模型空间下的，因此我们首先需要把法线转换到世界空间中。在4.7节中，我们已经知</p><h3 id="3-2-2-逐像素光照"><a href="#3-2-2-逐像素光照" class="headerlink" title="3.2.2 逐像素光照"></a>3.2.2 逐像素光照</h3>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity协程</title>
    <link href="/2021/06/19/Unity%E5%8D%8F%E7%A8%8B/"/>
    <url>/2021/06/19/Unity%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>unity的<strong>协程（Coroutine）</strong>只是在c#的基础上做了一层封装，其实yield是C#的关键字。</p><p>unity协程是一个能够暂停协程执行，暂停后立即返回主函数，执行主函数剩余的部分，直到中断指令完成后，从中断指令的下一行继续执行协程剩余的函数。<br>函数体全部执行完成，协程结束。<br>由于中断指令的出现，使得可以将一个函数分割到多个帧里去执行。</p><p>协程不是进程，也不是线程，它就是一个特殊的函数——可以在某个地方挂起，并且可以重新在挂起处继续运行。</p><p><strong>协程方法与普通方法的区别：</strong></p><ul><li>普通方法<br>被调用时，原来执行的部分保留现场，停止执行，然后去执行要调用的方法，并且，被调用的方法执行完之后才能返回到调用前的状态接着往下执行。</li><li>协同方法<br>执行不用等协同方法执行完再执行调用之前原来方法的代码，而是两者异步执行。</li></ul><p>协程不是多线程，它与主线程同时运行，它在主线程运行的同时开启另一段逻辑处理。<br>类似一个子线程单独出来处理一些问题，性能开销较小。<br>Unity的协程会在每帧结束之后去检测yield的条件是否满足，满足则执行yield return之后的代码。</p><p>在一个MonoBehaviour提供的主线程里只能有一个处于运行状态的协程，而其他协程处于休眠状态。<br>协程实际上是在一个线程中，只不过每个协程对CUP进行分时，协程可以访问和使用unity的所有方法和component。</p><p><strong>性能：</strong><br>在性能上相比于一般函数没有更多的开销</p><p><strong>协程的好处：</strong><br>让原来要使用异步 + 回调方式写的非人类代码, 可以用看似同步的方式写出来。<br>能够分步做一个比较耗时的事情，如果需要大量的计算，将计算放到一个随时间进行的协程来处理，能分散计算压力</p><p><strong>协程的坏处：</strong><br>协程本质是迭代器，且是基于unity生命周期的，大量开启协程会引起gc<br>如果同时激活的协程较多，就可能会出现多个高开销的协程挤在同一帧执行导致的卡帧</p><p><strong>协程书写时的性能优化：</strong><br>常见的问题是直接new 一个中断指令，带来不必要的 GC 负担，可以复用一个全局的中断指令对象，优化掉开销；在 Yielders.cs 这个文件里，已经集中地创建了上面这些类型的静态对象<br>这个链接分析了一下<a href="https://link.zhihu.com/?target=https://blog.csdn.net/liujunjie612/article/details/70623943">https://blog.csdn.net/liujunjie612/article/details/70623943</a></p><p><strong>协程是在什么地方执行？</strong><br>协程不是线程，不是异步执行；协程和monobehaviour的update函数一样也是在主线程中执行<br>unity在每一帧都会处理对象上的协程，也就是说，协程跟update一样都是unity每帧会去处理的函数<br>经过测试，协程至少是每帧的lateUpdate后运行的。<br>参照unity的生命周期图</p><p><strong>前驱知识：</strong></p><ul><li>设计模式——迭代器模式</li><li>C#中的IEnumerator、IEnumerable接口</li></ul><h1 id="2-协程的实现"><a href="#2-协程的实现" class="headerlink" title="2. 协程的实现"></a>2. 协程的实现</h1><p>协程的实现需要在Unity中继承MonoBehaviour并使用C#的迭代器IEnumrator，格式如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEnumrator 函数名(形参表)  <span class="hljs-comment">//最多只能有一个形参 </span><br>&#123;   <br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> xxx; <span class="hljs-comment">//恢复执行条件</span><br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在IEnumerator类型的方法中写入需要执行的操作，遇到yield后会暂时挂起，等到yield return后的条件满足才继续执行yield语句后面的内容。</p><h1 id="3-协程的开启与中止"><a href="#3-协程的开启与中止" class="headerlink" title="3. 协程的开启与中止"></a>3. 协程的开启与中止</h1><p>相关测试：<a href="https://blog.csdn.net/qq_37421018/article/details/88560239?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">Unity 协程的一些基本用法及测试</a></p><h2 id="3-1-协程的开启"><a href="#3-1-协程的开启" class="headerlink" title="3.1 协程的开启"></a>3.1 协程的开启</h2><p>开启协程需要使用StartCoroutine()方法：</p><ul><li><p>开启无参数的协程：<br><code>StartCoroutine(协程名());</code>或<code>StartCoroutine(&quot;协程名&quot;);</code></p></li><li><p>开启单参数的协程：<br><code>StartCoroutine(协程名(参数));</code>或<code>StartCoroutine(&quot;协程名&quot;,参数);</code></p></li><li><p>开启多参数的协程：<br><code>StartCoroutine(协程名(参数1,......));</code><br>或</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//开启协程的函数</span></span><br><span class="hljs-function"></span>&#123;<br>    IEnumerator coroutine = Test(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>    StartCoroutine(coroutine);<br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)<span class="hljs-comment">//协程</span></span><br><span class="hljs-function"></span> &#123;<br>     <span class="hljs-comment">//等待帧画面渲染结束</span><br>     <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForEndOfFrame</span>(<span class="hljs-params"></span>)</span>;<br>     a=<span class="hljs-number">2</span>;<br>     b=<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>用“协程名”启动的方式不允许传入 一个以上的参数</p></blockquote></li></ul><h2 id="3-2-协程的结束"><a href="#3-2-协程的结束" class="headerlink" title="3.2 协程的结束"></a>3.2 协程的结束</h2><p>结束协程有两种情况：</p><ul><li><p>当协程的方法体执行完毕将会自动结束</p></li><li><p>调用StopCoroutine();方法中止协程执行</p></li></ul><p>中止协程的几种情况：</p><ul><li><p>中止所有协程：<br><code>StopAllCoroutines();</code></p></li><li><p>使用对象实例中止指定协程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#">Coroutine c;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    c = StartCoroutine(CountSeconds());        <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.J))<br>    &#123;<br>        StopCoroutine(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用字符串中止指定协程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">StartCoroutine(<span class="hljs-string">&quot;协程名&quot;</span>);<br>StopCoroutine(<span class="hljs-string">&quot;协程名&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>只有以协程名字符串启动的协程可以用此方法中止<br>既：<strong>StartCoroutine(“协程名”);**或</strong>StartCoroutine(“协程名”,参数);**</p><p>允许使用**StopCoroutine(“协程名”);**中止协程</p></blockquote><blockquote><p>不允许使用直接调用协程方法的方式中止指定协程<br>既：**StopCoroutine(协程名([参数]));**不被允许</p></blockquote></li></ul><h1 id="4-yield-协程回复条件语句"><a href="#4-yield-协程回复条件语句" class="headerlink" title="4. yield 协程回复条件语句"></a>4. yield 协程回复条件语句</h1><p><strong>快查表：</strong></p><table><thead><tr><th>yield语句</th><th>功能</th></tr></thead><tbody><tr><td>yield return null;</td><td>下一帧再执行后续代码</td></tr><tr><td>yield return 0;</td><td>下一帧再执行后续代码</td></tr><tr><td>yield return 6;(任意数字)</td><td>下一帧再执行后续代码</td></tr><tr><td>yield break;</td><td>直接结束该协程的后续操作</td></tr><tr><td>yield return asyncOperation;</td><td>等异步操作结束后再执行后续代码</td></tr><tr><td>yield return StartCoroution(其它协程);</td><td>调用执行其它协程后再执行后续代码</td></tr><tr><td>yield return WWW();</td><td>等待WWW操作完成后再执行后续代码</td></tr><tr><td>yield return new WaitForEndOfFrame();</td><td>等待帧结束,等待直到所有的摄像机和GUI被渲染完成后，在该帧显示在屏幕之前执行</td></tr><tr><td>yield return new WaitForSeconds(0.3f);</td><td>等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间会受到Time.timeScale的影响）;</td></tr><tr><td>yield return new WaitForSecondsRealtime(0.3f);</td><td>等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间不受到Time.timeScale的影响）;</td></tr><tr><td>yield return WaitForFixedUpdate();</td><td>等待下一次FixedUpdate开始时再执行后续代码</td></tr><tr><td>yield return new WaitUntil()</td><td>将协同执行直到当输入的参数（或者委托）为true的时候</td></tr><tr><td>yield return new WaitWhile()</td><td>将协同执行直到 当输入的参数（或者委托）为false的时候</td></tr></tbody></table><p><strong>生命周期图：</strong><br><img src="/images/Unity%E5%8D%8F%E7%A8%8B/image-20210619124505977.png" srcset="/img/loading.gif"></p><h2 id="4-1-yield-return-null"><a href="#4-1-yield-return-null" class="headerlink" title="4.1 yield return null;"></a>4.1 yield return null;</h2><p>从生命周期图中可以看到，在GameLogic部分对协程中挂起的条件进行了判断。</p><p>也就是说，协程顺序为：<br>（当前帧为第1帧）<br>第1帧在start中开启协程，执行协程（自上而下），遇到yield return null 将后面的内容挂起。<br>这时继续执行第1帧剩下的东西直到第1帧Update执行结束，这时对挂起的协程进行判断 是否满足return条件，<br>满足则在第2帧Update之后，在LateUpdate前执行协程中yield return 以后的代码；<br>不满足条件则继续执行第1帧的LateUpdate。<br>第2帧同第1帧相同。</p><p><strong>测试如下：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CorTest2</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">//update中判断次数的变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;start 1&quot;</span>);<br>        <span class="hljs-comment">//开启协程1</span><br>        StartCoroutine(Test());<br>        Debug.Log(<span class="hljs-string">&quot;start 2&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;第&quot;</span> + ++i + <span class="hljs-string">&quot;帧开始&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;帧结束&quot;</span>);<br>    &#125;<br>    <span class="hljs-function">IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            Debug.Log(<span class="hljs-string">&quot;协程1第一次&quot;</span>);<br>            <span class="hljs-comment">//挂起时机</span><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            Debug.Log(<span class="hljs-string">&quot;协程1第二次&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果如下：</strong></p><p><img src="/images/Unity%E5%8D%8F%E7%A8%8B/image-20210619124653298.png" srcset="/img/loading.gif"></p><p>可以看到，协程运行到一半在第一帧被挂起，第二帧Update执行完后满足条件继续执行。</p><h2 id="4-2-yield-return-StartCoroutine"><a href="#4-2-yield-return-StartCoroutine" class="headerlink" title="4.2 yield return StartCoroutine();"></a>4.2 yield return StartCoroutine();</h2><p><strong>测试如下：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">Test</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>   &#123;<br>       <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>       &#123;<br>           Debug.Log(<span class="hljs-string">&quot;协程1第一次&quot;</span>);<br>           <span class="hljs-comment">//挂起时机</span><br>           <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">Test2(</span>))</span>;<br>           Debug.Log(<span class="hljs-string">&quot;协程1第二次&quot;</span>);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-function">IEnumerator <span class="hljs-title">Test2</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>   &#123;<br>       Debug.Log(<span class="hljs-string">&quot;协程2第一次&quot;</span>);<br>       <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       Debug.Log(<span class="hljs-string">&quot;协程2第二次&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>结果如下：</strong><br><img src="/images/Unity%E5%8D%8F%E7%A8%8B/image-20210619125001267.png" srcset="/img/loading.gif"></p><p>原理都是一样的，执行完yield return 后挂起（注意不是遇到就挂起，而是执行），在每一帧的update与lateupdate之间对挂起的内容进行判断，满足则继续执行被挂起的协程的剩余部分。</p><h2 id="4-3-yield-return-new-WaitUntil"><a href="#4-3-yield-return-new-WaitUntil" class="headerlink" title="4.3 yield return new WaitUntil();"></a>4.3 yield return new WaitUntil();</h2><p><strong>案例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter;<br><span class="hljs-function">IEnumerator <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    counter=<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitUntil</span>(<span class="hljs-params">TestWait</span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;Start执行完毕&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TestWait</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当方法TestWait的返回值为true的时候<br>Start会一次性执行完。</li><li>当方法TestWait的返回值为false的时候<br>Start会一直等待着，只要返回值为false，那么Start的最后一句打印就不会执行。</li></ul><blockquote><p>可以使用lambda表达式</p></blockquote><h2 id="4-4-yield-return-new-WaitWhile"><a href="#4-4-yield-return-new-WaitWhile" class="headerlink" title="4.4 yield return new WaitWhile()"></a>4.4 yield return new WaitWhile()</h2><p><strong>案例：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> counter;<br><span class="hljs-function">IEnumerator <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    counter=<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitWhile</span>(<span class="hljs-params">TestWait</span>)</span>;<br>    Debug.Log(<span class="hljs-string">&quot;Start执行完毕&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">TestWait</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当方法TestWait的返回值为true的时候<br>Start会一直等待着，只要返回值为true，那么Start的最后一句打印就不会执行。</li><li>当方法TestWait的返回值为false的时候<br>Start会一次性执行完。</li></ul><blockquote><p>可以使用lambda表达式</p></blockquote><h1 id="5-协程的嵌套"><a href="#5-协程的嵌套" class="headerlink" title="5. 协程的嵌套"></a>5. 协程的嵌套</h1><p>利用<code>yield return StartCoroution(其它协程);</code>可以实现多个协程的嵌套使用。<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">SaySomeThings</span>(<span class="hljs-params"></span>)   </span><br><span class="hljs-function"></span>&#123;       <br>    Debug.Log(<span class="hljs-string">&quot;The routine has started&quot;</span>);       <br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">RepeatMessage(<span class="hljs-number">1</span>, <span class="hljs-number">1f</span>, <span class="hljs-string">&quot;Hello&quot;</span></span>))</span>;       <br>    Debug.Log(<span class="hljs-string">&quot;1 second has passed since the last message&quot;</span>);       <br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">RepeatMessage(<span class="hljs-number">1</span>, <span class="hljs-number">2.5f</span>, <span class="hljs-string">&quot;Hello&quot;</span></span>))</span>;       <br>    Debug.Log(<span class="hljs-string">&quot;2.5 seconds have passed since the last message&quot;</span>);   <br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/Unity%E5%8D%8F%E7%A8%8B/image-20210619123813192.png" srcset="/img/loading.gif"></p><h1 id="6-注意"><a href="#6-注意" class="headerlink" title="6. 注意"></a>6. 注意</h1><ul><li>IEnumerator 类型的方法不能带 ref 或者 out 型的参数，但可以带被传递的引用</li><li>在函数 Update 和 FixedUpdate 中不能使用 yield 语句，否则会报错， 但是可以启动协程</li><li>在一个协程中，StartCoroutine()和 yield return StartCoroutine()是不一样的。<br>前者仅仅是开始一个新的Coroutine，这个新的Coroutine和现有Coroutine并行执行。<br>后者是返回一个新的Coroutine，是一个中断指令，当这个新的Coroutine执行完毕后，才继承执行现有Coroutine。</li></ul><h1 id="7-使用案例"><a href="#7-使用案例" class="headerlink" title="7. 使用案例"></a>7. 使用案例</h1><h2 id="7-1-运动到某一位置"><a href="#7-1-运动到某一位置" class="headerlink" title="7.1 运动到某一位置"></a>7.1 运动到某一位置</h2><p>在Inspector面板中设置目标位置和运动速度，在游戏开始时将一个物体移动到目标位置</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Vector3 targetPosition;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> moveSpeed=<span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    c = StartCoroutine(MoveToPosition(targetPosition));<br>&#125;<br><span class="hljs-function">IEnumerator <span class="hljs-title">MoveToPosition</span>(<span class="hljs-params">Vector3 target</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (transform.position != target)<br>    &#123;<br>        transform.position = Vector3.MoveTowards(transform.position,target,moveSpeed*Time.deltaTime);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-按指定路径前进"><a href="#7-2-按指定路径前进" class="headerlink" title="7.2 按指定路径前进"></a>7.2 按指定路径前进</h2><p>我们可以让运动到某一位置的程序做更多，不仅仅是一个指定位置，我们还可以通过数组来给它赋值更多的位置，通过MoveToPosition() ，我们可以让它在这些点之间持续运动。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> List&lt;Vector3&gt; path;    <br><span class="hljs-function">IEnumerator <span class="hljs-title">MoveOnPath</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> loop</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> point <span class="hljs-keyword">in</span> path)<br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-title">StartCoroutine</span>(<span class="hljs-params">MoveToPosition(point</span>))</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (loop);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-倒计时"><a href="#7-3-倒计时" class="headerlink" title="7.3 倒计时"></a>7.3 倒计时</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">CountDown</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> time</span>)</span><br><span class="hljs-function"></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> t = time;t &gt;= <span class="hljs-number">0</span>;t -= <span class="hljs-number">1</span>)<br>        &#123;<br>            print(time);<br>            time -= <span class="hljs-number">1</span>; <br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSecondsRealtime</span>(<span class="hljs-params"><span class="hljs-number">1f</span></span>)</span>; <span class="hljs-comment">//WaitForSecondsRealtime不受时间缩放影响</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>底层机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>yield</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity 资源处理</title>
    <link href="/2021/06/17/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/"/>
    <url>/2021/06/17/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>实际的游戏开发中，其实有相当一部分静态数据是可以放在客户端的。<br>所以势必会产生要动态读取这些文件的需求，比如csv（其实就是文本文件），xml等等。</p><p>做unity3d开发时，都一定要先在editor中去实现基本的功能，再具体到各个移动平台上去调试。<br>所以作为要读取外部文件的第一步，显然我们要先在editor也就是pc上实现这个功能。</p><p>既然是用Unity3D来开发游戏，那么自然要使用Unity3D规定的操作方式，而不是我们在PC上很原始的那种操作方式来操作。</p><p>否则就会写出移动端无法使用的很傻的代码来。</p><h1 id="2-资源处理分类"><a href="#2-资源处理分类" class="headerlink" title="2. 资源处理分类"></a>2. 资源处理分类</h1><p>Unity中的资源资源的处理种类大致分为：Resources、StreamingAssets、AssetBundle、PersistentDataPath 四类。</p><h2 id="2-1-Resources"><a href="#2-1-Resources" class="headerlink" title="2.1 Resources"></a>2.1 Resources</h2><p>是作为一个Unity的保留文件夹出现的，也就是如果你新建的文件夹的名字叫Resources，那么里面的内容在打包时都会被无条件的打到发布包中。</p><h3 id="2-1-1-特点"><a href="#2-1-1-特点" class="headerlink" title="2.1.1 特点"></a>2.1.1 特点</h3><ul><li>只读，即不能动态修改。所以想要动态更新的资源不要放在这里。</li><li>会将文件夹内的资源打包集成到.asset文件里面。因此建议可以放一些Prefab，因为Prefab在打包时会自动过滤掉不需要的资源，有利于减小资源包的大小。</li><li>资源读取使用Resources.Load()。</li></ul><h3 id="2-1-2-使用方法"><a href="#2-1-2-使用方法" class="headerlink" title="2.1.2 使用方法"></a>2.1.2 使用方法</h3><h4 id="2-1-2-1-加载"><a href="#2-1-2-1-加载" class="headerlink" title="2.1.2.1 加载"></a>2.1.2.1 加载</h4><ul><li>Resources.Load<br>加载Resources目录的一个asset</li><li>Resources.LoadAsync<br>Resources.Load的异步方法</li><li>Resources.LoadAll<br>类似Resources.Load，但是用于加载某目录下所有asset</li><li>Resources.LoadAssetAtPath<br>加载Asset/目录下的资源，只能用于编辑器模式，写打包工具时可能用到</li></ul><p>Resources类只能加载Resources文件夹下的资源，若出现嵌套，都会加载</p><p>Resources加载资源时应使用相对路径，且不包含扩展名。<br>如 Resources.Load&lt;Texture2D&gt;(“images/texture1”); </p><blockquote><p>建议在Assets下放一个Resource文件夹就好；</p></blockquote><h4 id="2-1-2-2-卸载资源："><a href="#2-1-2-2-卸载资源：" class="headerlink" title="2.1.2.2 卸载资源："></a>2.1.2.2 卸载资源：</h4><ul><li>Resources.UnloadAsset(Object assetToUnload)<br>卸载指定的asset，只能用于从磁盘加载的；<br>如果场景中有此asset的引用，Unity会自动重新加载它，CPU开销小。</li><li>Resources.UnloadUnusedAssets<br>卸载所有未被引用的asset，可以在画面切换时调用，或定时调用释放全局未使用资源。<br>被脚本的静态变量引用的资源不会被卸载。<br>尽量避免在游戏进行中调用，因为该接口开销较大，容易引起卡顿<br>可尝试用Resources.Unload(obj)逐个卸载，保证游戏的流畅度。</li></ul><h3 id="2-1-3-案例"><a href="#2-1-3-案例" class="headerlink" title="2.1.3 案例"></a>2.1.3 案例</h3><p>需要新建一个Resources目录，并且并将资源放在这目录中。<br>使用Resources.Load(Path)静态方法加载该目录路径下的资源。</p><p>示例：</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617174912162.png" srcset="/img/loading.gif" alt="image-20210617174912162"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br><span class="hljs-keyword">public</span> Image image; <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;  <br><span class="hljs-built_in">string</span> str = Resources.Load (<span class="hljs-string">&quot;Text&quot;</span>).ToString(); <br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-2-StreamingAssets"><a href="#2-2-StreamingAssets" class="headerlink" title="2.2 StreamingAssets"></a>2.2 StreamingAssets</h2><p>StreamingAssets和Resources很像。<br>同样作为一个只读的Unity3D的保留文件夹出现。</p><p>不过两者也有很大的区别。<br>那就是Resources文件夹中的内容在打包时会被压缩和加密。<br>而StreamingAsset文件夹中的内容则会原封不动的打入包中，因此StreamingAssets主要用来存放一些二进制文件。</p><h3 id="2-2-1-特点"><a href="#2-2-1-特点" class="headerlink" title="2.2.1 特点"></a>2.2.1 特点</h3><ul><li>只读不可写。</li><li>主要用来存放二进制文件。</li><li>只能用过WWW类来读取。</li></ul><h3 id="2-2-2-使用方法"><a href="#2-2-2-使用方法" class="headerlink" title="2.2.2 使用方法"></a>2.2.2 使用方法</h3><p>首先我们新建一个StreamingAssets目录，并且并将资源放在这目录中。</p><blockquote><p>StreamingAssets文件夹内的东西并不会被压缩和加密，放进去什么就是什么<br>所以一般是要放二进制文件的<br>在实际操作中切记不要直接把数据文件放到这个目录中打包</p></blockquote><p>示例：</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617175047000.png" srcset="/img/loading.gif" alt="image-20210617175047000"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br>    <span class="hljs-built_in">string</span> _result;  <br>    Start () <br>    &#123;  <br>        StartCoroutine(LoadXML());  <br>    &#125;  <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-built_in">string</span> sPath= Application.streamingAssetsPath + <span class="hljs-string">&quot;/Test.xml&quot;</span>; <br>        WWW www = <span class="hljs-keyword">new</span> WWW(sPath); <br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> www; <br>        _result = www.text; <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="2-3-AssetBundle"><a href="#2-3-AssetBundle" class="headerlink" title="2.3 AssetBundle"></a>2.3 AssetBundle</h2><p>AssetBundle就是把prefab或者二进制文件封装成AssetBundle文件。</p><h3 id="2-3-1-生存周期"><a href="#2-3-1-生存周期" class="headerlink" title="2.3.1 生存周期"></a>2.3.1 生存周期</h3><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617180330593.png" srcset="/img/loading.gif" alt="image-20210617180330593"></p><p>1.Unity 在使用 WWW 方法时会分配一系列的内存空间来存放 WWW 实例对象、 WebStream 数据。该数据包括原始的 AssetBundle 数据、解压后的 AssetBundle 数据以及一个用于解压的 Decompression Buffer 。（一般情况下， Decompression Buffer 会在原始的 AssetBundle 解压完成后自动销毁，但需要注意的是， Unity 会自动保留一个 Decompression Buffer ，不被系统回收，这样做的好处是不用过于频繁的开辟和销毁解压 Buffer ，从而在一定程度上降低 CPU 的消耗。）</p><p>2.当把AssetBundle 解压到内存后，可以使用WWW .assetBundle属性来获取AssetBundle 对象，从而可以得到各种Asset，进而对这些Assets进行加载或者实例化操作。加载过程中，Unity 会将AssetBundle 中的数据流转变为引擎可以识别的信息类型(纹理、材质、对象等)。加载完成后，开发者可以对其进行进一步的操作，比如对象的实例化、纹理和材质的复制和替换等。</p><p>更新：</p><p>游戏一开始运行时，通过文件里面记录的版本号，和服务器上文件中的版本号比对。如果本地版本号低，下载对应的AB包到可读写目录，并对本地资源进行替换，这样进入游戏中加载的就是新下载的AB包资源。</p><p>更新流程如下：</p><pre><code>   1.  将更新包资源(安装包中的资源)复制到可读写目录下   2.  复制完成开始比对哈希文件,开始更新资源   3.  下载添加资源,替换旧资源,删除原来可读写目录下的无用资源   4.  初始化assetbundle依赖关系   5.  完成整个流程</code></pre><p>更新注意：</p><pre><code>   1.  要有下载失败重试几次机制；   2.  要进行超时检测；   3.  要记录更新日志，例如哪几个资源时整个更新流程失败。</code></pre><h3 id="2-3-1-特点"><a href="#2-3-1-特点" class="headerlink" title="2.3.1 特点"></a>2.3.1 特点</h3><ul><li>是Unity3D定义的一种二进制类型。</li><li>使用WWW类来下载。</li></ul><h3 id="2-3-2-使用方法"><a href="#2-3-2-使用方法" class="headerlink" title="2.3.2 使用方法"></a>2.3.2 使用方法</h3><p>这里就和上面两个不一样了。</p><p>首先我们要把我们的文件Test.xml打成AssetBundle文件，由于本案例AssetBundle的平台选择为Andorid。</p><p>如图，我们创建了一个AssetBundle文件，并命名为TextXML。<br>并且按照二进制文件放入StreamingAssets文件夹中的惯例，将这个AssetBundle文件放入StreamingAssets文件夹。</p><p><img src="/images/Unity%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/image-20210617175300313.png" srcset="/img/loading.gif" alt="image-20210617175300313"></p><p>下面是从AssetBudle中读取Test.xml的代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> EggToolkit;<br><span class="hljs-keyword">using</span> System.Xml.Linq;<br><span class="hljs-keyword">using</span> System.Xml;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _result;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123;<br>LoadXML();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>AssetBundle AssetBundleCsv = <span class="hljs-keyword">new</span> AssetBundle();<br><span class="hljs-comment">//读取放入StreamingAssets文件夹中的bundle文件</span><br><span class="hljs-built_in">string</span> str = Application.streamingAssetsPath + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-string">&quot;TestXML.bundle&quot;</span>;<br>WWW www = <span class="hljs-keyword">new</span> WWW(str);<br>www = WWW.LoadFromCacheOrDownload(str, <span class="hljs-number">0</span>);<br>AssetBundleCsv = www.assetBundle;<br><span class="hljs-built_in">string</span> path = <span class="hljs-string">&quot;Test&quot;</span>;<br>TextAsset test = AssetBundleCsv.Load(path, <span class="hljs-keyword">typeof</span>(TextAsset)) <span class="hljs-keyword">as</span> TextAsset;<br>_result = test.ToString();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-PersistentDataPath"><a href="#2-4-PersistentDataPath" class="headerlink" title="2.4 PersistentDataPath"></a>2.4 PersistentDataPath</h2><p>这个路径下是可读写。<br>而且在IOS上就是应用程序的沙盒，但是在Android可以是程序的沙盒，也可以是sdcard。<br>并且在Android打包的时候，ProjectSetting页面有一个选项Write Access，可以设置它的路径是沙盒还是sdcard。</p><h3 id="2-4-1-特点"><a href="#2-4-1-特点" class="headerlink" title="2.4.1 特点"></a>2.4.1 特点</h3><ul><li>内容可读写，不过只能运行时才能写入或者读取。 <strong>提前将数据存入这个路径是不可行的</strong>。</li><li>无内容限制。你可以从 StreamingAsset 中读取二进制文件或者从 AssetBundle 读取文件来写入 PersistentDataPath 中。</li><li>写下的文件，可以在电脑上查看。同样也可以清掉。</li><li>需要使用WWW类来读取。</li></ul><h3 id="2-4-2-使用方法"><a href="#2-4-2-使用方法" class="headerlink" title="2.4.2 使用方法"></a>2.4.2 使用方法</h3><p>之前我们说过，内容可读写，不过只能运行时才能写入或者读取。 <strong>提前将数据存入这个路径是不可行的</strong>。也就是说，PersistentDataPath是在运行时生成的，例如通过网络下载资源存在放PersistentDataPath中。</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine; <br><span class="hljs-keyword">using</span> System.Collections; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadResources</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123; <br>    <span class="hljs-built_in">string</span> _result; <br>    Start () <br>    &#123;  <br>        StartCoroutine(LoadXML());  <br>    &#125;  <br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadXML</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-built_in">string</span> sPath= Application.persistentDataPath + <span class="hljs-string">&quot;/test.xml&quot;</span>; <br>        sPath = <span class="hljs-string">&quot;file://&quot;</span> + sPath; WWW www = <span class="hljs-keyword">new</span> WWW(sPath); <br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> www; <br>        _result = www.text; <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>这加载方式看起来与StreamingAssets很相识，但是注意这里多了行<code>sPath = &quot;file://&quot; + sPath;</code><br>这很重要！！</p><p>想要通过WWW类加载PersistentDataPath必须使用**file://**协议实现加载。</p><h1 id="3-各平台下的资源路径"><a href="#3-各平台下的资源路径" class="headerlink" title="3. 各平台下的资源路径"></a>3. 各平台下的资源路径</h1><p>想读取文件就必须找到文件所在的目录，我们先来了解一下Unity下各个资源路径的特点和在各平台下资源路径的存放位置吧。</p><h2 id="3-1-Unity3D中的资源路径"><a href="#3-1-Unity3D中的资源路径" class="headerlink" title="3.1 Unity3D中的资源路径"></a>3.1 Unity3D中的资源路径</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径说明</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">此属性用于返回程序的数据文件所在文件夹的路径。例如在Editor中就是Assets了。</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">此属性用于返回流数据的缓存目录，返回路径为相对路径，适合设置一些外部数据文件的路径。放在Unity工程StreamingAssets文件夹中的资源发布后都可以通过这个路径读取出来。</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">此属性用于返回一个持久化数据存储目录的路径，可以在此路径下存储一些持久化的数据文件。</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">此属性用于返回一个临时数据的缓存目录。</td></tr></tbody></table><h2 id="3-2-android平台"><a href="#3-2-android平台" class="headerlink" title="3.2 android平台"></a>3.2 android平台</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">/data/app/xxx.xxx.xxx.apk</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">jar:file:///data/app/xxx.xxx.xxx.apk/!/assets</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">/data/data/xxx.xxx.xxx/files</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">/data/data/xxx.xxx.xxx/cache</td></tr></tbody></table><h2 id="3-3-ios平台"><a href="#3-3-ios平台" class="headerlink" title="3.3 ios平台"></a>3.3 ios平台</h2><table><thead><tr><th align="left">路径属性</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">Application.dataPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data</td></tr><tr><td align="left">Application.streamingAssetsPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/Raw</td></tr><tr><td align="left">Application.persistentDataPath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Documents</td></tr><tr><td align="left">Application.temporaryCachePath</td><td align="left">Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches</td></tr></tbody></table><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1><p>本文90%的内容都是参考：<br><a href="http://www.tuicool.com/articles/qMNnmm6">http://www.tuicool.com/articles/qMNnmm6</a></p><p><a href="https://blog.csdn.net/jfy307596479/article/details/84975736">https://blog.csdn.net/jfy307596479/article/details/84975736</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>总结</tag>
      
      <tag>资源处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UGUI详解-画布</title>
    <link href="/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/"/>
    <url>/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h1><ul><li><p>UI组件</p><ul><li><p><a href="https://mycroftcooper.github.io/2021/06/15/Unity-UGUI-%E7%94%BB%E5%B8%83/">画布</a></p></li><li><p><a href="">图片</a></p></li><li><p>文本</p></li><li><p>按钮</p></li><li><p>单选框</p></li><li><p>滑动条</p></li><li><p>滚动条</p></li><li><p>下拉菜单</p></li><li><p>输入框</p></li><li><p>视频播放</p></li></ul></li><li><p>控制组件</p><ul><li>矩形变换组件</li><li>布局元素组件</li><li>布局控制组件</li></ul></li><li><p>UI事件</p></li><li><p>图集</p></li><li><p>渲染顺序</p></li></ul><h1 id="1-画布"><a href="#1-画布" class="headerlink" title="1. 画布"></a>1. 画布</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>画布组件是UI渲染最主要的组件。</p><p>我们可以将画布组件理解成一个容器，其他UI元素都必须填充到该容器中，最终形成我们看到的一个UI界面。</p><p>如果场景中没有画布，那么我们创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下。</p><p>因此可以游戏中用到画布组件的地方均可以作为一个独立的游戏界面。</p><blockquote><p>当容器的渲染属性发生改变时，所有子物体均会受到影响。</p></blockquote><h2 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><ul><li>只有放在画布组件下的子物体才会参与UI的渲染。</li><li>形状大小取决于屏幕分辨率， 创建出来的画布组件是一个矩形，我们可以修改Game窗口的分辨率选项来修改矩形的大小。<blockquote><p>窗口分辨率默认设置为Free Aspect我们可以把它切换成90像素x1080像素这样具体数值的分辨率，这样我们的界面就不容易易出现变形。</p></blockquote></li><li>子物体的渲染层级取决于UI元素在层次结构中出现的顺序<br>两个UI元素在位置上重叠，层级结构下方的UI元素会遮挡上方的UI元素</li></ul><h2 id="1-3-渲染模式"><a href="#1-3-渲染模式" class="headerlink" title="1.3 渲染模式"></a>1.3 渲染模式</h2><p>三种渲染模式的区别：</p><table><thead><tr><th>渲染模式</th><th>画布对应屏幕</th><th>摄像机</th><th>像素对应</th><th>适合类型</th></tr></thead><tbody><tr><td>Screen Space-Overlay</td><td>是</td><td>不需要</td><td>可选</td><td>2D UI</td></tr><tr><td>Screen Space-Camera</td><td>是</td><td>需要</td><td>可选</td><td>2D UI</td></tr><tr><td>World Space</td><td>否</td><td>需要</td><td>不可选</td><td>3D UI</td></tr></tbody></table><h3 id="1-3-1-覆盖渲染模式"><a href="#1-3-1-覆盖渲染模式" class="headerlink" title="1.3.1 覆盖渲染模式"></a>1.3.1 覆盖渲染模式</h3><p><strong>Screen Space-Overlay</strong>（屏幕控件-覆盖模式）的画布会填满整个屏幕空间，并将画布下面的所有的UI元素置于屏幕的最上层，或者说画布的画面永远“覆盖”其他普通的3D画面，如果屏幕尺寸被改变，画布将自动改变尺寸来匹配屏幕，如下图效果：</p><p><img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615154529500.png" srcset="/img/loading.gif" alt="image-20210615154529500"></p><blockquote><p>在此模式下，虽然在Canvas前放置了3D人物，但是在Game窗口中并不能观察到3D人物</p></blockquote><p><strong>Screen Space-Overlay</strong>模式的画布有三个参数：</p><ul><li><strong>Pixel Perfect</strong> 抗锯齿渲染<br>只有RenderMode为Screen类型时才有的选项。<br>使UI元素像素对应，效果就是边缘清晰不模糊。</li><li><strong>Sort Layer</strong> 渲染排序<br>是UGUI专用的设置，用来指示画布的深度。</li><li><strong>TargetDisplay</strong> 显示目标<br>与多屏幕显示相关</li></ul><h3 id="1-3-2-摄像机渲染模式"><a href="#1-3-2-摄像机渲染模式" class="headerlink" title="1.3.2 摄像机渲染模式"></a>1.3.2 摄像机渲染模式</h3><p><strong>Screen Space-Camera</strong>（屏幕空间-摄影机模式）和<strong>Screen Space-Overlay</strong>模式类似，画布也是填满整个屏幕空间，如果屏幕尺寸改变，画布也会自动改变尺寸来匹配屏幕。</p><p>所不同的是，在该模式下，画布会被放置到摄影机前方。<br>在这种渲染模式下，画布看起来 绘制在一个与摄影机固定距离的平面上。<br>所有的UI元素都由该摄影机渲染，因此摄影机的设置会影响到UI画面。<br>在此模式下，UI元素是由<strong>perspective</strong>也就是视角设定的，视角广度由Filed of View设置。</p><p>这种模式可以用来实现在UI上显示3D模型的需求，比如:<br>很多MMO游戏中的查看人物装备的界面，可能屏幕的左侧有一个运动的3D人物，左侧是一些UI元素。<br>通过设置<strong>Screen Space-Camera</strong>模式就可以实现上述的需求，效果如下图所示：<img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615155308173.png" srcset="/img/loading.gif" alt="image-20210615155308173"></p><p>它比<strong>Screen Space-Overlay</strong>模式的画布多了下面几个参数：</p><ul><li><strong>Render Camera</strong><br>渲染摄像机</li><li><strong>Plane Distance</strong><br>画布距离摄像机的距离</li><li><strong>Sorting Layer</strong><br>是UGUI专用的设置，用来指示画布的深度。<br>可以通过点击该栏的选项，在下拉菜单中点击“Add Sorting Layer”按钮进入标签和层的设置界面，或者点击导航菜单-&gt;edit-&gt;Project Settings-&gt;Tags and Layers进入该页面。<br>可以点击“+”添加Layer，或者点击“-”删除Layer。<br>画布所使用的Sorting Layer越排在下面，显示的优先级也就越高。</li><li><strong>Order in Layer</strong><br>在相同的Sort Layer下的画布显示先后顺序。<br>数字越高，显示的优先级也就越高。</li></ul><h3 id="1-3-3-世界空间渲染"><a href="#1-3-3-世界空间渲染" class="headerlink" title="1.3.3 世界空间渲染"></a>1.3.3 世界空间渲染</h3><p>World Space即世界控件模式。<br>在此模式下，画布被视为与场景中其他普通游戏对象性质相同的类似于一张面片（Plane）的游戏物体。</p><p>画布的尺寸可以通过RectTransform设置，所有的UI元素可能位于普通3D物体的前面或者后面显示。</p><p>当UI为场景的一部分时，可以使用这个模式。</p><p>它有一个单独的参数:</p><ul><li><strong>Event Camera</strong><br>用来指定接受事件的摄像机，可以通过画布上的GraphicRaycaster组件发射射线产生事件。</li></ul><p>这种模式可以用来实现跟随人物移动的血条或者名称，如下图所示：</p><p><img src="/images/Unity-UGUI-%E7%94%BB%E5%B8%83/image-20210615155346268.png" srcset="/img/loading.gif" alt="image-20210615155346268"></p><h2 id="1-4-Canvas-Scale画布缩放组件"><a href="#1-4-Canvas-Scale画布缩放组件" class="headerlink" title="1.4 Canvas Scale画布缩放组件"></a>1.4 Canvas Scale画布缩放组件</h2><h3 id="1-4-1-作用"><a href="#1-4-1-作用" class="headerlink" title="1.4.1 作用"></a>1.4.1 作用</h3><p><strong>Canvas Scalerde</strong>的作用：</p><ul><li>控制整体界面UI元素的大小</li><li>UI界面比例自适应</li></ul><p>Canvas Scale画布缩放组件用于控制整体界面的缩放和画布上UI元素的像素密度。<br>这种缩放影响画布中的所有内容，包括文字大小和图像边框。</p><p>由于游戏会存在不同的分辨率模式，UI需要能在不同的分辨率下保持一个恰当的显示效果。<br>因此，我们需要让UI有一个可以适应的区域范围，比如屏幕由长方形变成正方形时，UI界面不会发生太严重的变形。</p><p>这个时候就需要设置画布缩放组件，以调节我们的UI界面始终保持和屏幕对齐。</p><h3 id="1-4-2-完美像素"><a href="#1-4-2-完美像素" class="headerlink" title="1.4.2 完美像素"></a>1.4.2 完美像素</h3><p><strong>Pixelperfect</strong><br>指一个UI素材本身的像素对应屏幕上一个像素的情况。<br>这种情况下UI素材映射到屏幕上时没有任何拉伸和压缩，这种情况下UI显示效果非常清晰完美。</p><h3 id="1-4-3-缩放组件的渲染模式"><a href="#1-4-3-缩放组件的渲染模式" class="headerlink" title="1.4.3 缩放组件的渲染模式"></a>1.4.3 缩放组件的渲染模式</h3><p>有三种UI缩放渲染模式，每种模式都有其相关参数：</p><ul><li><strong>Constant Pixel Size</strong><br>固定像素尺寸大小<br>不管屏幕尺寸如何变化, UI元素保持相同的像素大小</li><li><strong>Scale With Screen Size</strong><br>随屏幕缩放尺寸<br>使UI随着屏幕大小变化</li><li><strong>Constant Physical Size</strong><br>恒定物理尺寸<br>不管屏幕大小和分辨率如何变化, UI元素保持相同的物理尺寸</li></ul><h3 id="1-4-4-固定像素尺寸大小模式"><a href="#1-4-4-固定像素尺寸大小模式" class="headerlink" title="1.4.4 固定像素尺寸大小模式"></a>1.4.4 固定像素尺寸大小模式</h3><h4 id="1-4-4-1-缩放系数参数"><a href="#1-4-4-1-缩放系数参数" class="headerlink" title="1.4.4.1 缩放系数参数"></a>1.4.4.1 缩放系数参数</h4><p><strong>Scale Factor参数</strong><br>Canvas整体的缩放比例</p><ul><li>在<strong>Screen Space – Overlay</strong> 的情况下默认为1</li><li>在<strong>Screen Space – Camera</strong> 的情况下则不一定为1，会受到渲染UI的摄像机参数影响<blockquote><p>如果为Perspective 相机，会受到 Field Of View影响<br>如果是 Orthographic相机，会受到 Size影响</p></blockquote></li></ul><blockquote><p>默认推荐为1，表示正常大小</p></blockquote><h4 id="1-4-4-2-每单元参考像素大小参数"><a href="#1-4-4-2-每单元参考像素大小参数" class="headerlink" title="1.4.4.2 每单元参考像素大小参数"></a>1.4.4.2 每单元参考像素大小参数</h4><p><strong>ReferencePixelsPerUnit参数</strong></p><p>一般用这个是来缩放图片的，用这个Factor（因子）值我可以一张图实现很多的大小还不失真。<br>这种模式保证了恒定像素的来缩放的。<br>这个对美术来说是个好组建，不用每个大小的都做一张，只要调好Factor因子值就好了。</p><h3 id="1-4-5-随屏幕缩放尺寸模式"><a href="#1-4-5-随屏幕缩放尺寸模式" class="headerlink" title="1.4.5 随屏幕缩放尺寸模式"></a>1.4.5 随屏幕缩放尺寸模式</h3><h4 id="1-4-5-1-参考分辨率"><a href="#1-4-5-1-参考分辨率" class="headerlink" title="1.4.5.1 参考分辨率"></a>1.4.5.1 参考分辨率</h4><p><strong>Reference Resolution参数</strong><br>参照当前UI布局所依据的分辨率，随屏幕分辨率的变化而变化。</p><blockquote><p>游戏运行的最理想分辨率，就是你做游戏时采用的分辨率</p></blockquote><h4 id="1-4-5-2-屏幕匹配模式参数"><a href="#1-4-5-2-屏幕匹配模式参数" class="headerlink" title="1.4.5.2 屏幕匹配模式参数"></a>1.4.5.2 屏幕匹配模式参数</h4><p><strong>Screen Match Mode参数</strong><br>一共有以下三种屏幕匹配模式：</p><h5 id="1-4-5-2-1-匹配宽高模式"><a href="#1-4-5-2-1-匹配宽高模式" class="headerlink" title="1.4.5.2.1 匹配宽高模式"></a>1.4.5.2.1 匹配宽高模式</h5><p><strong>Match Width Or Height模式</strong><br>参考宽，或者高，或者两者来布局画布<br>一个滑条，拉在最左时是Width ，最右时是Height，中间则是按比例混合。</p><ul><li>当处于最左边时，屏幕高度对于UI大小完全没有任何影响，只有宽度会对UI大小产生影响。<br>假设宽度为Reference Resolution宽度的x倍，则UI整体缩放为Reference Resolution状态下的x倍。<br>也就是说只有宽度等于Reference Resolution宽度时，才能做到pixel perfect，否则像素就会有拉伸</li><li>当处于最右边时，与上述情况正好相反，决定整体缩放值的是高度，而宽度则没有任何影响</li><li>处于中间某处时，对上述两者的影响进行权重加成</li></ul><blockquote><p>一般来说：</p><ul><li><p>手机适配用高度适配</p></li><li><p>PC适配用宽度适配</p></li></ul><p>自适应并不是一定要适应全屏，它只会找一个最合适的匹配模式来显示。</p></blockquote><h5 id="1-4-5-2-2-扩展模式"><a href="#1-4-5-2-2-扩展模式" class="headerlink" title="1.4.5.2.2 扩展模式"></a>1.4.5.2.2 扩展模式</h5><p><strong>Expand模式</strong><br>当屏幕分辨率大于参考分辨率时，选择变化较小的一个方向（横向还是纵向），作为放大Canvas Scale的标准，另一方向上的变化则是在整体缩放以后再进行补偿性的变化。<br>此举旨在减少扩大分辨率时由于非等比扩大而对UI整体布局造成影响。<br>适合制作较小标准尺寸，扩充到较大屏幕。</p><p>例如：<br>假设Reference Resolution为800*600，Canvas Scale为(1,1,1)。<br>如果实际分辨率为800*800,那么Canvas Scale还保持为(1,1,1)因为宽度没有发生变化，只是单纯的高度增加了200。<br>所以势必对布局造成一定得影响。</p><p>1000*600的情况也是一样，Canvas Scale没有变化，只是单纯宽度增加了200。</p><p>但如果实际分辨率变为1000*800,那么Canvas Scale就变成(1.25,1.25,1.25)。<br>因为宽度是参考分辨率宽度的1.25倍，高度是1.33倍，那么取较小的1.25。 </p><p>这个1.25倍的意义是：<br>整体Canvas渲染放大1.25倍，横向或纵向的变化超过了1.25倍，则靠拉伸Canvas来变化，此时因为这部分变化，可能会对布局产生一些相对较小的影响，例如相对位置、某些元素的长宽比。</p><h5 id="1-4-5-2-3-收缩模式"><a href="#1-4-5-2-3-收缩模式" class="headerlink" title="1.4.5.2.3 收缩模式"></a>1.4.5.2.3 收缩模式</h5><p><strong>Shrink模式</strong><br>和Expand类似，但是更适合于缩小的情形。<br>它会在屏幕尺寸缩小时，通过缩小CanvasScale尽量减少由于非等比缩小对布局产生的影响。<br>按照影响较小的一个方向缩小的比例去缩小CanvasScale，然后再通过变形调整另外一个方向。</p><h3 id="1-4-6-恒定物理尺寸模式"><a href="#1-4-6-恒定物理尺寸模式" class="headerlink" title="1.4.6 恒定物理尺寸模式"></a>1.4.6 恒定物理尺寸模式</h3><p><strong>Contant Physical Size 恒定物理尺寸模式</strong>和Constant Pixel Size类似，但是只能通过RectTransform来改变大小。</p><p>很少用到，就略述了。</p><p><strong>参数表</strong></p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>物理单位</td><td>指定位置和大小的物理单位</td></tr><tr><td>Fallback Screen DPI</td><td>屏幕DPI未知时采用的DPI</td></tr><tr><td>默认屏幕DPI</td><td>每英寸像素数，用于具有“每单位像素数”属性的sprites ,该属性与“每单位参考像素数”匹配</td></tr><tr><td>每单位像素数</td><td>如果一个sprite具有“每单位像素数”属性,它的DPI会匹配”默认的spriteDPI”设置</td></tr></tbody></table><h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1><p><a href="https://www.cnblogs.com/crazytomato/p/7832838.html">https://www.cnblogs.com/crazytomato/p/7832838.html</a></p><p><a href="https://www.cnblogs.com/morning-lee/p/7135782.html">https://www.cnblogs.com/morning-lee/p/7135782.html</a></p><p><a href="https://www.cnblogs.com/msxh/p/6337338.html">https://www.cnblogs.com/msxh/p/6337338.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>UGUI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>UGUI</tag>
      
      <tag>画布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程基本知识</title>
    <link href="/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1进程-线程"><a href="#1-1进程-线程" class="headerlink" title="1.1进程/线程"></a>1.1进程/线程</h2><h3 id="1-1-1-进程"><a href="#1-1-1-进程" class="headerlink" title="1.1.1 进程"></a>1.1.1 进程</h3><p>进程指一个应用程序所运行的操作系统单元，它是操作系统环境中的基本成分、是系统进行资源分配的基本单位。</p><p>进程是执行程序的实例。<br>当运行一个应用程序后，就生成了一个进程，这个进程拥有自己的独立内存空间。<br>每一个进程对应一个活动的程序，当进程激活时，操作系统就将系统的资源包括内存、I/O和CPU等分配给它，使它执行。</p><ul><li><p>进程在运行时创建的资源随着进程的终止而死亡。</p></li><li><p>进程间获得专用数据或内存的唯一途径就是通过协议来共享内存块，这是一种协作策略。</p></li><li><p>一个进程可以创建多个线程及子进程（启动外部程序）。</p></li><li><p>一个进程内部的线程可以共享该进程所分配的资源。</p></li></ul><p>由于进程之间的切换非常消耗资源和时间，为了提高操作系统的并发性，提高CPU的利用率，在进程下面又加入了线程的概念。<br>线程的创建与撤销、线程之间的切换所占用的资源比进程少很多。</p><h3 id="1-1-2-线程"><a href="#1-1-2-线程" class="headerlink" title="1.1.2 线程"></a>1.1.2 线程</h3><p>进程可以分为若干个独立执行流（路径），这些执行流被称为线程。</p><p>线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>线程是进程的一个实体，是CPU调度和分配时间的基本单位。</p><p>线程基本不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同一进程的其它线程共享进程所拥有的全部资源。<br>所以线程间共享内存空间很容易做到，多线程协作也很容易和便捷。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程间可以并发执行。</p><p>线程提供了多任务处理的能力。</p><h3 id="1-1-3-线程与进程的异同"><a href="#1-1-3-线程与进程的异同" class="headerlink" title="1.1.3  线程与进程的异同"></a>1.1.3  线程与进程的异同</h3><ul><li><p>地址空间：</p><ul><li><p>进程拥有自己独立的内存地址空间；</p></li><li><p>线程共享进程的地址空间；</p><blockquote><p>换句话说就是进程间彼此是完全隔绝的，同一进程的所有线程共享(堆heap)内存；</p></blockquote></li></ul></li><li><p>资源拥有：</p><ul><li>进程是资源分配和拥有的单位</li><li>同一进程内的线程共享进程的资源；</li></ul></li><li><p>系统粒度：</p><ul><li>进程是分配资源的基本单位</li><li>线程则是系统（处理器）调度的基本单位；</li></ul></li><li><p>执行过程：</p><ul><li>每个独立的进程都有一个程序运行的入口、顺序执行序列和程序的出口；</li><li>线程不能独立执行，必须依存于进程中；</li></ul></li><li><p>系统开销：</p><p>创建或撤销进程时，系统都要为之分配或回收资源（如内存空间、IO设备）<br>进程间的切换也要消耗远大于线程切换的开销。</p></li></ul><p>二者均可并发执行。</p><p>一个程序至少有一个进程，一个进程至少有一个线程（主线程）。<br>主线程以函数地址的形式，如Main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止。<br>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</p><h2 id="1-2-并发-并行"><a href="#1-2-并发-并行" class="headerlink" title="1.2 并发/并行"></a>1.2 并发/并行</h2><p>在单CPU系统中，系统调度在某一刻只能让一个线程运行，虽然这种调度机制有多种形式（时分/频分），但无论如何，要通过不断切换需要运行的线程，这种运行模式称为并发（Concurrent）。</p><p>而在多CPU系统中，可以让两个以上的线程同时运行，这种运行模式称为并行（Parallel）。</p><h2 id="1-3-同步-异步操作"><a href="#1-3-同步-异步操作" class="headerlink" title="1.3 同步/异步操作"></a>1.3 同步/异步操作</h2><h3 id="1-3-1-同步与异步的定义"><a href="#1-3-1-同步与异步的定义" class="headerlink" title="1.3.1 同步与异步的定义"></a>1.3.1 同步与异步的定义</h3><p>同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)</p><ul><li><p>同步，就是调用某个东西是，调用方得等待这个调用返回结果才能继续往后执行。</p></li><li><p>异步，和同步相反 调用方不会立即得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状态来通知调用者，或者通过回掉函数来处理这个调用。</p></li></ul><p>所有的程序最终都会由计算机硬件来执行，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。<br>这些无须消耗CPU时间的I/O操作是异步操作的硬件基础。<br>硬盘、光驱、网卡、声卡、显卡都具有DMA功能。</p><p>DMA（DirectMemory Access）是直接内存访问的意思，它是不经过CPU而直接进行内存数据存储的数据交换模式。</p><p>I/O操作包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.Net Remoting等跨进程的调用。</p><p>异步操作可达到避免调用线程堵塞的目的，从而提高软件的可响应性。</p><h3 id="1-3-2-同步与异步的对比"><a href="#1-3-2-同步与异步的对比" class="headerlink" title="1.3.2 同步与异步的对比"></a>1.3.2 同步与异步的对比</h3><p>线程不是一个计算机的硬件功能，而是操作系统提供的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度。</p><p>异步模式无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必共享变量，减少了死锁的可能。</p><p>不过，编写异步操作的复杂程度比较高，程序主要使用回调方式进行处理，与人的思维方式有出入，而且难以调试。</p><p>计算密集型工作使用多线程（如图形处理、算法）；IO密集型工作使用异步机制。</p><h2 id="1-4-任务管理器"><a href="#1-4-任务管理器" class="headerlink" title="1.4 任务管理器"></a>1.4 任务管理器</h2><p>映射名称列：<br>进程并不拥有独立于其所属实例的映射名称；</p><blockquote><p>如果运行5个Notepad拷贝，你会看到5个称为Notepad.exe的进程；</p></blockquote><p>它们是根据进程ID进行区分的，该进程ID是由系统维护，并可以循环使用。</p><p>CPU列：<br>它是进程中线程所占用的CPU时间百分比</p><p>每个任务管理器中的进程，其实内部都包含若干个线程，每个时间点都是某个程序进程中的某个线程在运行。</p><h2 id="1-5-线程是如何工作的"><a href="#1-5-线程是如何工作的" class="headerlink" title="1.5 线程是如何工作的"></a>1.5 线程是如何工作的</h2><p>线程被一个线程协调程序管理着——一个CLR委托给操作系统的函数。<br>线程协调程序确保将所有活动的线程被分配适当的执行时间；<br>并且那些等待或阻止的线程——比如说在排它锁中、或在用户输入——都是不消耗CPU时间的。</p><p>在单核处理器的电脑中，线程协调程序完成一个时间片之后迅速地在活动的线程之间进行切换执行。<br>这就导致“波涛汹涌”的行为，例如在第一个例子，每次重复的X 或 Y 块相当于分给线程的时间片。<br>在Windows XP中时间片通常在10毫秒内选择要比CPU开销在处理线程切换的时候的消耗大的多。(即通常在几微秒区间)</p><p>在多核的电脑中，多线程被实现成混合时间片和真实的并发——不同的线程在不同的CPU上运行。<br>但这仍然会出现一些时间切片,因为操作系统的服务线程、以及一些其他的应用程序都会争夺对CPU的使用权。</p><p>线程由于外部因素（比如时间片）被中断被称为被抢占，在大多数情况下,一个线程在被抢占的那一刻就失去了对它的控制权。</p><h2 id="1-6-线程安全"><a href="#1-6-线程安全" class="headerlink" title="1.6 线程安全"></a>1.6 线程安全</h2><p>当使用线程（Thread）时，程序员必须注意同步处理的问题</p><p>理论上每个Thread都是独立运行的个体，由CLR来主导排程，视Thread的优先权的设置，每个Thread会分到特定的运行时间，当某个Thread的运行时间用完时，CLR就会强制将运行权由该Thread取回，转交给下个Thread<br>这也就意味着Thread本身无法得知自己何时会丧失运行权，所以会发生所谓的race condition（竞速状态）。</p><p>当两个线程争夺一个锁的时候（在这个例子里是locker），一个线程等待，或者说被阻止到那个锁变的可用。<br>在这种情况下，就确保了在同一时刻只有一个线程能进入临界区，所以”Done”只被打印了1次。代码以如此方式在不确定的多线程环境中被叫做线程安全。</p><p>临时暂停，或阻止是多线程的协同工作，同步活动的本质特征。<br>等待一个排它锁被释放是一个线程被阻止的原因，另一个原因是线程想要暂停或Sleep一段时间：</p><p>Thread.Sleep (TimeSpan.FromSeconds (30));  // 阻止30秒</p><p>一个线程也可以使用它的Join方法来等待另一个线程结束：</p><p>Threadt = new Thread(Go);  // 假设Go是某个静态方法</p><p>t.Start();</p><p>t.Join();  // 等待（阻止）直到线程t结束</p><h1 id="2-使用多线程的情况分析"><a href="#2-使用多线程的情况分析" class="headerlink" title="2. 使用多线程的情况分析"></a>2. 使用多线程的情况分析</h1><h2 id="2-1-为什么要使用多线程"><a href="#2-1-为什么要使用多线程" class="headerlink" title="2.1 为什么要使用多线程"></a>2.1 为什么要使用多线程</h2><ul><li>并发需要<br>在C/S或B/S模式下的服务端需要处理来自不同终端的并发请求，使用单线程是不可思议的。</li><li>提高应用程序的响应速度<br>当一个耗时的操作进行时，当前程序都会等待这个操作结束<br>此时程序不会响应键盘、鼠标、菜单等操作，程序处于假死状态；<br>使用多线程可将耗时长的操作（Time Consuming）置于一个新的线程，此时程序仍能响应用户的其它操作</li><li>提高CPU利用率<br>在多CPU体系中，操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li><li>改善程序结构<br>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分<br>这样的程序会利于理解和修改。</li><li>花销小、切换快<br>线程间的切换时间很小，可以忽略不计</li><li>方便的通信机制<br>线程间共享内存，互相间交换数据很简单。</li></ul><p>多线程的意义在于<br>一个应用程序中，有多个执行部分可以同时执行：<br>一个线程可以在后台读取数据，而另一个线程可以在前台展现已读取的数据。</p><p>C#支持通过多线程并行地执行代码，一个线程有它独立的执行路径，能够与其它的线程同时地运行。<br>一个C#程序开始于一个单线程，这个单线程是被CLR和操作系统（也称为“主线程”）自动创建的，并具有多线程创建额外的线程。</p><h2 id="2-2-何时使用多线程"><a href="#2-2-何时使用多线程" class="headerlink" title="2.2 何时使用多线程"></a>2.2 何时使用多线程</h2><p>多线程程序一般被用来在后台执行耗时的任务：主线程保持运行，而工作线程执行后台工作。</p><ul><li><p>对于Windows Forms程序来说，如果主线程执行了一个冗长的操作，键盘和鼠标的操作会变的迟钝，程序也会失去响应，进入假死的状态，可能导致用户强制结束程序进程而出现错误。<br>有鉴于此，应该在主线程运行一个耗时任务时另外添加一个工作线程，同时在主线程上有一个友好的提示“处理中…”，允许继续接收事件（比如响应鼠标、键盘操作）。<br>同时程序还应该实现“取消”功能，允许取消/结束当前工作线程。<br>BackgroundWorker类就提供这一功能。</p></li><li><p>在没有用户界面的程序里，比如说WindowsService中使用多线程特别的有意义。<br>当一个任务有潜在的耗时（在等待被请求方的响应——比如应用服务器，数据库服务器），用工作线程完成任务意味着主线程可以在发送请求后立即做其它的事情。</p></li><li><p>另一个多线程的用途是在需要完成一个复杂的计算工作时,它会在多核的电脑上运行得更快，如果工作量被多个线程分开的话（C#中可使用Environment.ProcessorCount属性来侦测处理芯片的数量）。</p></li></ul><p>远程服务器，或WebServices或ASP.NET程序将别无选择，必须使用多线程；<br>一个单线程的ASP.NET Web Service是不可想象的；<br>幸运的是，应用服务器中多线程是相当普遍的；<br>唯一值得关心的是提供适当锁机制的静态变量问题。</p><h2 id="2-3-何时不用多线程"><a href="#2-3-何时不用多线程" class="headerlink" title="2.3 何时不用多线程"></a>2.3 何时不用多线程</h2><p>多线程也同样会带来缺点，最大的问题是它使程序变的过于复杂<br>拥有多线程本身并不复杂，复杂是的线程的交互作用<br>无论交互是否是有意的，都会带来较长的开发周期，以及带来间歇性和非重复性的Bugs。<br>因此，要么多线程的交互设计简单一些，要么就根本不使用多线程，除非你有强烈的重写和调试欲望。</p><p>当用户频繁地分配和切换线程时，多线程会带来增加资源和CPU的开销。<br>在某些情况下，太多的I/O操作是非常棘手的，当只有一个或两个工作线程要比有众多的线程在相同时间执行任务快的多。</p><h1 id="3-C-中的线程"><a href="#3-C-中的线程" class="headerlink" title="3. C#中的线程"></a>3. C#中的线程</h1><h2 id="3-1-程序域"><a href="#3-1-程序域" class="headerlink" title="3.1 程序域"></a>3.1 程序域</h2><p>在.Net中Process由AppDomain对象所取代。</p><p>虽然AppDomain在CLR中被视为Process的替代品，但实际上AppDomain跟Process是属于主从关系的，AppDomain被放置在一个Process中，<br>每个Process可以拥有多个AppDomain，<br>每个AppDomain又可拥有多个Thread对象。</p><p>Process、AppDomain、Thread的关系如下图所示：</p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/image-20210528201620106.png" srcset="/img/loading.gif" alt="进程、域、线程关系图"></p><p>AppDomain定义了一些事件供程序员使用。</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>AssemblyLoad</td><td>触发于AppDomain载入一个Assembly时</td></tr><tr><td>DomainUnLoad</td><td>触发于AppDomain卸载时，也就是Unload函数被调用或是该AppDomain被消灭前</td></tr><tr><td>ProcessExit</td><td>当默认的AppDomain被卸载时触发，多半是应用程序退出时</td></tr></tbody></table><p>各AppDomain间互不影响。</p><h2 id="3-2-C-中实现线程的方法"><a href="#3-2-C-中实现线程的方法" class="headerlink" title="3.2 C#中实现线程的方法"></a>3.2 C#中实现线程的方法</h2><p>一个C#程序成为多线程可以通过2种方式来实现：</p><ul><li><p>明确地创建和运行多线程</p></li><li><p>使用.NET Framework中封装了多线程的类<br>比如:</p><ul><li><p>BackgroundWorker类</p></li><li><p>线程池</p></li><li><p>Threading Timer</p></li></ul></li></ul><p>更多C#中实现线程的方法请看<br><a href="https://mycroftcooper.github.io/2021/05/28/C%E4%BA%95%E5%A4%9A%E7%BA%BF%E7%A8%8B/">C#中实现线程的方法</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>计算机基本知识</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp-多线程</title>
    <link href="/2021/05/28/CSharp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/05/28/CSharp-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>在学习本篇文章前你需要学习的相关知识：<br><a href="https://mycroftcooper.github.io/2021/05/28/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">线程基本知识</a></p><p>此篇文章简单总结了C#中主要的多线程实现方法，包括：</p><ul><li>Thread<br>线程</li><li>ThreadPool<br>线程池</li><li>Parallel</li><li>Task<br>任务</li><li>BackgroundWorker组件</li></ul><h1 id="2-Thread类"><a href="#2-Thread类" class="headerlink" title="2. Thread类"></a>2. Thread类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul><li><p>使用Thread类通过ThreadStart（无参数）或ParameterizedThreadStart（一个输入参数）类型的委托创建一个Thread对象，开启一个新线程，执行该委托传递的任务，此时线程尚未处于运行状态。</p></li><li><p>调用Start()函数启动线程，当前线程继续执行。</p></li><li><p>调用Join()函数可以阻塞当前线程，直到调用Join()的线程终止。</p></li><li><p>调用Abort()方法，如需中止线程，在调用该方法的线程上抛出ThreadAbortException异常，以结束该线程</p></li><li><p>可以通过Thread.ResetAbort()方法阻止线程的中止。</p></li></ul><h2 id="2-1-属性表"><a href="#2-1-属性表" class="headerlink" title="2.1 属性表"></a>2.1 属性表</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Name</td><td>属性，获取或设置线程的名称</td></tr><tr><td>Priority</td><td>属性，获取或设置线程的优先级</td></tr><tr><td>ThreadState</td><td>属性，获取线程当前的状态</td></tr><tr><td>IsAlive</td><td>属性，获取当前线程是否处于启动状态</td></tr><tr><td>IsBackground</td><td>属性，获取或设置值，表示该线程是否为后台线程</td></tr><tr><td>CurrentThread</td><td>属性，获取当前正在运行的线程</td></tr></tbody></table><h2 id="2-2-方法表"><a href="#2-2-方法表" class="headerlink" title="2.2 方法表"></a>2.2 方法表</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Start()</td><td>方法，启动线程</td></tr><tr><td>Sleep(int millisecondsTimout)</td><td>方法，将当前线程暂停指定的毫秒数</td></tr><tr><td>Suspend()</td><td>方法，挂起当前线程（已经被弃用）</td></tr><tr><td>Join()</td><td>方法，阻塞调用线程，直到某个线程终止为止</td></tr><tr><td>Interrupt()</td><td>方法，中断当前线程</td></tr><tr><td>Resume()</td><td>方法，继续已经挂起的线程（已经被弃用）</td></tr><tr><td>Abort()</td><td>方法，终止线程（已经被弃用）</td></tr></tbody></table><h2 id="2-3-开启线程"><a href="#2-3-开启线程" class="headerlink" title="2.3 开启线程"></a>2.3 开启线程</h2><p>首先用new申请Thread对象，然后对象调用Start()方法启用线程。</p><p>代码如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Thread.CurrentThread.ManagedThreadId获取当前线程的ID，便于管理。</p></blockquote><p>用Lambda表达式代替函数调用，也能达到相同的效果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>        &#125;);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-传递参数"><a href="#2-4-传递参数" class="headerlink" title="2.4 传递参数"></a>2.4 传递参数</h2><p>有两种为线程传递参数的方法：</p><ul><li><p>Start()函数传参法</p></li><li><p>对象成员方法传参法</p></li><li><p>匿名方法传参法</p><h3 id="2-4-1-Start-函数传参"><a href="#2-4-1-Start-函数传参" class="headerlink" title="2.4.1 Start()函数传参"></a>2.4.1 Start()函数传参</h3></li></ul><p>为某方法创建新线程后，在使用Start()方法启动线程时传递该方法需要的参数。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> name</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + name);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start(<span class="hljs-string">&quot;April&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-1-对象传递"><a href="#2-4-1-对象传递" class="headerlink" title="2.4.1 对象传递"></a>2.4.1 对象传递</h3><p>初始化一个对象，然后用对象的方法初始化Thread，这样该线程就可以使用这个对象的所有成员。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Download</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Id;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> Name;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Download</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id, <span class="hljs-built_in">string</span> name</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Id = id;<br>            Name = name;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownloadFile</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + <span class="hljs-string">&quot;ID: &quot;</span> + Id + <span class="hljs-string">&quot; Name: &quot;</span> + Name);<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);              <br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Download download = <span class="hljs-keyword">new</span> Download(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;人民日报&quot;</span>);<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(download.DownloadFile);<br>        thread.Start();<br>        Console.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-5-匿名方法"><a href="#2-4-5-匿名方法" class="headerlink" title="2.4.5 匿名方法"></a>2.4.5 匿名方法</h3><p>需要接收多个参数的解决方案是使用一个匿名方法调用，方法如下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (<span class="hljs-string">&quot;Hello&quot;</span>); &#125;);<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure><p>它的优点是目标方法（这里是WriteText），可以接收任意数量的参数，并且没有装箱操作。</p><p>不过这需要将一个外部变量放入到匿名方法中，如下示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">voidMain</span>(<span class="hljs-params"></span>)</span> &#123;<br>stringtext = <span class="hljs-string">&quot;Before&quot;</span>;<br><br>Threadt = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>() &#123; WriteText (text); &#125;);<br><br>text = <span class="hljs-string">&quot;After&quot;</span>;<br><br>t.Start();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteText</span> (<span class="hljs-params">stringtext</span>)</span> &#123; Console.WriteLine (text); &#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是:<br>当外部变量的值被修改，匿名方法可能进行无意的互动，导致一些古怪的现象。<br>一旦线程开始运行，外部变量最好被处理成只读的——除非有人愿意使用适当的锁。</p></blockquote><h2 id="2-5-线程命名"><a href="#2-5-线程命名" class="headerlink" title="2.5 线程命名"></a>2.5 线程命名</h2><p>线程可以通过它的Name属性进行命名，这非常有利于调试：<br>可以用Console.WriteLine打印出线程的名字<br>Microsoft Visual Studio可以将线程的名字显示在调试工具栏的位置上。</p><p>线程的名字可以在被任何时间设置——但只能设置一次，重命名会引发异常。</p><p>程序的主线程也可以被命名，下面例子里主线程通过CurrentThread命名：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#">Class ThreadNaming &#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span> &#123;<br>Thread.CurrentThread.Name= <span class="hljs-string">&quot;main&quot;</span>;<br><br>Thread worker = <span class="hljs-keyword">new</span> Thread(Go);<br><br>worker.Name= <span class="hljs-string">&quot;worker&quot;</span>;<br><br>worker.Start();<br><br>Go();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Go</span>(<span class="hljs-params"></span>)</span> &#123;<br>Console.WriteLine (<span class="hljs-string">&quot;Hello from &quot;</span>+ Thread.CurrentThread.Name);<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p>Hellofrom main</p><p>Hellofrom worker</p><h2 id="2-6-前台线程和后台线程"><a href="#2-6-前台线程和后台线程" class="headerlink" title="2.6 前台线程和后台线程"></a>2.6 前台线程和后台线程</h2><ul><li>前台线程(用户界面线程)<br>只要存在有一个前台线程在运行，应用程序就在运行<br>通常用来处理用户的输入并响应各种事件和消息</li><li>后台线程(工作线程)<br>应用程序关闭时，如果后台线程没有执行完，会被强制性的关闭<br>用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等</li></ul><p>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DownLoad</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad Begin &quot;</span> + Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;DownLoad End&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-built_in">string</span>[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//创建Thread对象</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(DownLoad);<br>        <span class="hljs-comment">//设为后台线程</span><br>        thread.IsBackground = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//启动线程</span><br>        thread.Start();<br>        <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;Main&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，thread被设置为后台线程。<br>Main执行完后，没有前台线程了，应用程序就结束，虽然后台线程thread此时尚未执行完，也被终止。</p><blockquote><p>改变线程从前台到后台不会以任何方式改变它在CPU协调程序中的优先级和状态。</p></blockquote><p>拥有一个后台工作线程是有益的，<br>最直接的理由是当提到结束程序它总是可能有最后的发言权。<br>交织以不会消亡的前台线程，保证程序的正常退出。</p><p>抛弃一个前台工作线程是尤为险恶的，尤其对Windows Forms程序，<br>因为程序直到主线程结束时才退出（至少对用户来说），但是它的进程仍然运行着。<br>在Windows任务管理器它将从应用程序栏消失不见，但却可以在进程栏找到它。<br>除非用户找到并结束它，它将继续消耗资源，并可能阻止一个新的实例的运行从开始或影响它的特性。</p><p>对于程序失败退出的普遍原因就是存在“被忘记”的前台线程。</p><table><thead><tr><th>线程类型</th><th>动作</th><th>结束</th><th>后续处理</th></tr></thead><tbody><tr><td>前台线程</td><td>主程序关闭</td><td>否</td><td>显示关闭线程/杀掉当前进程</td></tr><tr><td>后台线程</td><td>主程序关闭</td><td>是</td><td>无</td></tr></tbody></table><h2 id="2-7-注意事项"><a href="#2-7-注意事项" class="headerlink" title="2.7 注意事项"></a>2.7 注意事项</h2><ul><li><p>Thread类创建的线程默认为前台线程，可以通过IsBackground属性设置其为前台或后台线程。</p><blockquote><p>用Thread类创建的线程是前台线程，线程池中的线程总是后台线程</p></blockquote></li><li><p>可以通过Priority属性设置线程的优先级。</p></li><li><p>线程内部可以通过try catch捕获该异常，在catch模块中进行一些必要的处理<br>如释放持有的锁和文件资源等</p></li><li><p>慎重使用Abort()方法<br>如果在当前线程中抛出该异常，其结果是可预测的<br>但是对于其他线程，它会中断任何正在执行的代码，有可能中断静态对象的生成，造成不可预测的结果。</p></li></ul><h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>ThreadPool类维护一个线程的列表，提供给用户以执行不同的小任务，减少频繁创建线程的开销。<br>该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</p><p>线程池其实就是一个存放线程对象的“池子(pool)”，他提供了一些基本方法，如：设置pool中最小/最大线程数量、把要执行的方法排入队列等等。ThreadPool是一个静态类，因此可以直接使用，不用创建对象。</p><h2 id="3-2-线程池的优点"><a href="#3-2-线程池的优点" class="headerlink" title="3.2 线程池的优点"></a>3.2 线程池的优点</h2><p>每新建一个线程都需要占用内存空间和其他资源<br>而新建了那么多线程，有很多在休眠，或者在等待资源释放；<br>又有许多线程只是周期性的做一些小工作，如刷新数据等等，太浪费了，划不来。<br>实际编程中大量线程突发，然后在短时间内结束的情况很少见。</p><p>于是，就提出了线程池的概念。</p><p>线程池中的线程执行完指定的方法后并不会自动消除，而是以挂起状态返回线程池，如果应用程序再次向线程池发出请求，那么处以挂起状态的线程就会被激活并执行任务，而不会创建新线程，这就节约了很多开销。<br>只有当线程数达到最大线程数量，系统才会自动销毁线程。</p><p>因此，使用线程池可以避免大量的创建和销毁的开支，具有更好的性能和稳定性，其次，开发人员把线程交给系统管理，可以集中精力处理其他任务。</p><h2 id="3-3-线程池的使用"><a href="#3-3-线程池的使用" class="headerlink" title="3.3 线程池的使用"></a>3.3 线程池的使用</h2><ul><li><p>设置线程池最大最小：<br><strong>ThreadPool.SetMaxThreads (int workerThreads,int completionPortThreads)</strong><br>设置可以同时处于活动状态的线程池的请求数目。<br>所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。<br>还可以设置最小线程数。</p></li><li><p>将任务添加进线程池:<br><strong>ThreadPool.QueueUserWorkItem(new WaitCallback(方法名));**或<br>**ThreadPool.QueueUserWorkItem(new WaitCallback(方法名), 参数);</strong></p></li></ul><p>但是线程池的使用也有一些限制：</p><ul><li>线程池中的线程均为后台线程，并且不能修改为前台线程</li><li>不能给入池的线程设置优先级或名称</li><li>对于COM对象，入池的所有线程都是多线程单元（MTA）线程，许多COM对象都需要单线程单元（STA）  线程</li><li>入池的线程只适合时间较短的任务，如果线程需要长时间运行，应使用Thread类创建线程或使用Task的LongRunning选项</li><li>.Net下线程池最小默认允许4个工作线程，最大允许2048个工作线程。<br>并发线程启动后，瞬间会启动4个线程。<br>而剩下的会依据环境每0.5秒或者1秒启动一个。<br>如果同时运行的线程达到Max工作线程，那么剩下的就会挂起<br>直到线程池中的线程有空闲得了，才会去执行。</li></ul><h1 id="4-Parallel类"><a href="#4-Parallel类" class="headerlink" title="4.  Parallel类"></a>4.  Parallel类</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>整理自<a href="https://blog.csdn.net/honantic/article/details/46876871">https://blog.csdn.net/honantic/article/details/46876871</a></p><p>Parallel和Task类都位于System.Threading.Task命名空间中，是对Thread和ThreadPool类更高级的抽象。</p><p>Parrallel类有For()、ForEach()、Invoke()三个方法</p><ul><li><p>Invoke()<br>实现任务并行性<br>允许同时调用不同的方法，</p></li><li><p>Parallel.For()和 Parallel.ForEach()<br>实现数据并行性<br>在每次迭代中调用相同的代码</p></li></ul><h2 id="4-2-常用方法"><a href="#4-2-常用方法" class="headerlink" title="4.2 常用方法"></a>4.2 常用方法</h2><h3 id="4-2-1-Parallel-For"><a href="#4-2-1-Parallel-For" class="headerlink" title="4.2.1 Parallel.For()"></a>4.2.1 Parallel.For()</h3><p>Parallel.For()方法类似于 C#的 for循环语旬,也是多次执行一个任务。<br>使用Parallel.For()方法,可以并行运行迭代。 </p><p>迭代的顺序没有定义，不能保证。</p><p>在For()方法中：</p><ul><li>前两个参数定义了循环的开头和结束。示例从0迭代到 9。</li><li>第 3个参数是一个Action<int>委托<br>是要并行运行迭代的方法</li><li>整数参数是循环的迭代次数,该参数被传递给Action<int>委托引用的方法。</li><li>Parallel.For()方法的返回类型是ParalleLoopResult结构,它提供了循环是否结束的信息。</li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    ParallelLoopResult result = Parallel.For(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, i =&gt;<br>    &#123;<br>        Console.WriteLine<br>        (<span class="hljs-string">&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;</span>, i, Thread.CurrentThread.ManagedThreadId);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Console.WriteLine(<span class="hljs-string">&quot;Is completed: &#123;0&#125;&quot;</span>, result.IsCompleted);<br><br>    <span class="hljs-comment">//i: 0, thread id: 9</span><br>    <span class="hljs-comment">//i: 2, thread id: 10</span><br>    <span class="hljs-comment">//i: 1, thread id: 9</span><br>    <span class="hljs-comment">//i: 3, thread id: 10</span><br>    <span class="hljs-comment">//i: 4, thread id: 9</span><br>    <span class="hljs-comment">//i: 6, thread id: 11</span><br>    <span class="hljs-comment">//i: 7, thread id: 10</span><br>    <span class="hljs-comment">//i: 5, thread id: 9</span><br>    <span class="hljs-comment">//i: 8, thread id: 12</span><br>    <span class="hljs-comment">//i: 9, thread id: 11</span><br>    <span class="hljs-comment">//Is completed: True</span><br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><p>同For()循环类似，Parallel.For()方法也可以中断循环的执行。</p><p>Parallel.For()方法的一个重载版本接受第3个Action&lt;int, ParallelLoopState&gt;类型的参数。<br>使用这些参数定义一个方法,就可以调用ParalleLoopState的Break()或Stop()方法,以影响循环的结果。</p><blockquote><p>注意,迭代的顺序没有定义</p></blockquote><p>案例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tsx">public static void Main()<br>&#123;<br>    ParallelLoopResult result &#x3D; Parallel.For(0, 100, (i, state) &#x3D;&gt;<br>    &#123;<br>        Console.WriteLine(&quot;i:&#123;0&#125;, thread id: &#123;1&#125;&quot;, i, Thread.CurrentThread.ManagedThreadId);<br><br>        if (i &gt; 10)<br>            state.Break();<br><br>        Thread.Sleep(10);<br>    &#125;);<br><br>    Console.WriteLine(&quot;Is completed: &#123;0&#125;&quot;, result.IsCompleted);<br>    Console.WriteLine(&quot;Lowest break iteration: &#123;0&#125;&quot;, result.LowestBreakIteration);<br><br>    &#x2F;&#x2F;i: 0, thread id: 10<br>    &#x2F;&#x2F;i: 25, thread id: 6<br>    &#x2F;&#x2F;i: 1, thread id: 10<br>    &#x2F;&#x2F;i: 2, thread id: 10<br>    &#x2F;&#x2F;i: 3, thread id: 10<br>    &#x2F;&#x2F;i: 4, thread id: 10<br>    &#x2F;&#x2F;i: 5, thread id: 10<br>    &#x2F;&#x2F;i: 6, thread id: 10<br>    &#x2F;&#x2F;i: 7, thread id: 10<br>    &#x2F;&#x2F;i: 8, thread id: 10<br>    &#x2F;&#x2F;i: 9, thread id: 10<br>    &#x2F;&#x2F;i: 10, thread id: 10<br>    &#x2F;&#x2F;i: 11, thread id: 10<br>    &#x2F;&#x2F;Is completed: False<br>    &#x2F;&#x2F;Lowest break iteration: 11<br><br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-2-Parallel-For-lt-TLocal-gt"><a href="#4-2-2-Parallel-For-lt-TLocal-gt" class="headerlink" title="4.2.2 Parallel.For &lt; TLocal &gt;"></a>4.2.2 Parallel.For &lt; TLocal &gt;</h3><p>Parallel.For()方法可能使用几个线程来执行循环 。</p><p>如果需要对每个线程进行初始化,就可以使用Parallel.For<TLocal>方法。<br>除了from和to对应的值之外,For()方法的泛型版本还接受3个委托参数:</p><ul><li><p>第一个参数的类型是Func&lt; TLocal &gt;<br>因为这里的例子对于TLocal使用字符串,所以该方法需要定义为Func&lt; string &gt;,即返回string的方法。<br>这个方法仅对于用于执行迭代的每个线程调用一次</p></li><li><p>第二个委托参数为循环体定义了委托<br>在示例中,该参数的类型是Func&lt;int, ParallelLoopState, string, string&gt;。<br>其中第一个参数是循环迭代,第二个参数 ParallelLoopstate允许停止循环,如前所述 。<br>循环体方法通过第3个参数接收从init方法返回的值,循环体方法还需要返回一个值,其类型是用泛型for参数定义的。</p></li><li><p>For()方法的最后一个参数指定一个委托Action&lt; TLocal &gt;;在该示例中,接收一个字符串。<br>这个方法仅对于每个线程调用一次,这是一个线程退出方法。</p></li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">Parallel.For&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>,() =&gt;<br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;init thread &#123;0&#125;,\t task &#123;1&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;t&#123;0&#125;&quot;</span>, Thread.CurrentThread.ManagedThreadId);<br>                &#125;,<br>            (i, pls, str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;body i &#123;0&#125; \t str &#123;1&#125; \t thread &#123;2&#125; \t task &#123;3&#125;&quot;</span>, i, str, Thread.CurrentThread.ManagedThreadId, Task.CurrentId);<br>                Thread.Sleep(<span class="hljs-number">10</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;i \t&#123;0&#125;&quot;</span>, i);<br>            &#125;,<br>            (str) =&gt;<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;finally\t &#123;0&#125;&quot;</span>, str);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><p><strong>Parallel.For<TLocal> 方法 (Int32, Int32, Func<TLocal>, Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;, Action<TLocal>)</strong></p><p>参数表：</p><table><thead><tr><th>参数名</th><th>数据类型</th><th>作用</th></tr></thead><tbody><tr><td></td><td>TLoca</td><td>线程本地数据的类型</td></tr><tr><td>fromInclusive</td><td>System.Int32</td><td>开始索引（含）</td></tr><tr><td>toExclusive</td><td>System.Int32</td><td>结束索引（不含）</td></tr><tr><td>localInit</td><td>System.Func<TLocal></td><td>用于返回每个任务的本地数据的初始状态的函数委托</td></tr><tr><td>body</td><td>System.Func&lt;Int32, ParallelLoopState, TLocal, TLocal&gt;</td><td>将为每个迭代调用一次的委托</td></tr><tr><td>localFinally</td><td>System.Action<TLocal></td><td>用于对每个任务的本地状态执行一个最终操作的委托</td></tr><tr><td>返回值</td><td>System.Threading.Tasks.ParallelLoopResult</td><td></td></tr></tbody></table><p>在迭代范围 (fromInclusive，toExclusive) ，为每个值调用一次body 委托。<br>为它提供以下参数：</p><ul><li>迭代次数 (Int32)</li><li>可用来提前退出循环的ParallelLoopState实例</li><li>可以在同一线程上执行的迭代之间共享的某些本地状态。</li></ul><p>对于参与循环执行的每个任务调用 localInit 委托一次，并返回每个任务的初始本地状态。<br>这些初始状态传递给第一个在该任务上 调用的 body。<br>然后，每个后续正文调用返回可能修改过的状态值，传递到下一个正文调用。<br>最后，每个任务上的最后正文调用返回传递给 localFinally 委托的状态值。<br>每个任务调用 localFinally 委托一次，以对每个任务的本地状态执行最终操作。<br>此委托可以被多个任务同步调用；<br>因此您必须同步对任何共享变量的访问。</p><p>Parallel.For方法比在它执行生存期的线程可能使用更多任务，作为现有的任务完成并被新任务替换。<br>这使基础 TaskScheduler 对象有机会添加、更改或移除服务循环的线程。</p><p>如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。</p><h3 id="4-2-3-Parallel-ForEach"><a href="#4-2-3-Parallel-ForEach" class="headerlink" title="4.2.3 Parallel.ForEach()"></a>4.2.3 Parallel.ForEach()</h3><p>Parallel.ForEach()方法遍历实现了IEnumerable的集合,其方式类似于foreach语句,但以异步方式遍历。<br>这里也没有确定遍历顺序。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s) =&gt;<br>            &#123;<br>                Console.WriteLine(s);<br>            &#125;);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><p>中断循环<br>如果需要中断循环,就可以使用ForEach()方法的重载版本和ParallelLoopState参数。其方式与前面的For()方法相同。<br>ForEach()方法的一个重载版本也可以用于访问索引器,从而获得迭代次数<br>如下所示:　</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span>[] data = &#123; <span class="hljs-string">&quot;zero&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;eight&quot;</span>, <span class="hljs-string">&quot;nine&quot;</span>, <span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;eleven&quot;</span>, <span class="hljs-string">&quot;twelve&quot;</span> &#125;;<br>            ParallelLoopResult result = Parallel.ForEach&lt;<span class="hljs-built_in">string</span>&gt;(data, (s, pls, l) =&gt;<br>             &#123;<br>                 Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;\t&#123;1&#125;&quot;</span>, s, l);<br>                 <span class="hljs-keyword">if</span> (l &gt; <span class="hljs-number">10</span>)<br>                 &#123;<br>                     pls.Break();<br>                 &#125;<br>             &#125;);<br>            Console.WriteLine(<span class="hljs-string">&quot;Lowest break iteration: &#123;0&#125;&quot;</span>, result.LowestBreakIteration);<br>            Console.ReadKey();<br></code></pre></td></tr></table></figure><h3 id="4-2-4-Parallel-Invoke"><a href="#4-2-4-Parallel-Invoke" class="headerlink" title="4.2.4 Parallel.Invoke()"></a>4.2.4 Parallel.Invoke()</h3><p>如果多个任务应并行运行,就可以使用Parallel.Invoke()方法。<br>Parallel.Invoke()方法允许传递一个Action委托数组,在其中可以指定应运行的方法。<br>示例代码传递了要并行调用的Foo()和Bar()方法:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Foo, Bar);<br>    Console.ReadKey();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Foo&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Bar&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如需同时执行多个不同的任务，可以使用Parallel.Invoke()方法，它允许传递一个Action委托数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Parallel.Invoke(Func1, Func2, Func3);<br>    Console.ReadKey();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Task类"><a href="#5-Task类" class="headerlink" title="5. Task类"></a>5. Task类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>相比于Thread类，Task类为控制线程提供了更大的灵活性。</p><ul><li><p>Task类可以获取线程的返回值</p></li><li><p>可以定义连续的任务：在一个任务结束结束后开启下一个任务</p></li><li><p>可以在层次结构中安排任务，在父任务中可以创建子任务<br>这样就创建了一种依赖关系，如果父任务被取消，子任务也随之取消</p></li></ul><blockquote><p>注意：<br>Task类默认使用线程池中的线程，如果该任务需长期运行，应使用TaskCreationOptions.LongRunning属性告诉任务管理器创建一个新的线程，而不是使用线程池中的线程。</p></blockquote><h2 id="5-2-任务Task和线程Thread的区别："><a href="#5-2-任务Task和线程Thread的区别：" class="headerlink" title="5.2 任务Task和线程Thread的区别："></a>5.2 任务Task和线程Thread的区别：</h2><ul><li>任务是架构在线程之上的<br>也就是说任务最终还是要<strong>抛给线程</strong>去执行。</li><li><strong>任务跟线程不是一对一的关系</strong><br>比如开10个任务并不是说会开10个线程，这一点任务有点类似线程池，但是任务相比线程池有很小的开销和精确的控制。</li><li>Task和Thread一样，位于System.Threading命名空间下!</li></ul><h2 id="5-3-Task的生存周期与状态"><a href="#5-3-Task的生存周期与状态" class="headerlink" title="5.3 Task的生存周期与状态"></a>5.3 Task的生存周期与状态</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Created</td><td>表示默认初始化任务，但是“工厂创建的”实例直接跳过。</td></tr><tr><td>WaitingToRun</td><td>这种状态表示等待任务调度器分配线程给任务执行。</td></tr><tr><td>RanToCompletion</td><td>任务执行完毕。</td></tr></tbody></table><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//查看Task中的状态</span><br>   <span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>         &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Begin&quot;</span>);<br>            System.Threading.Thread.Sleep(<span class="hljs-number">2000</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;Finish&quot;</span>);<br>         &#125;);<br>         Console.WriteLine(<span class="hljs-string">&quot;Before start:&quot;</span> + task1.Status);<br>         task1.Start();<br>         Console.WriteLine(<span class="hljs-string">&quot;After start:&quot;</span> + task1.Status);<br>         task1.Wait();<br>         Console.WriteLine(<span class="hljs-string">&quot;After Finish:&quot;</span> + task1.Status);<br></code></pre></td></tr></table></figure><h2 id="5-4-Task的使用方法"><a href="#5-4-Task的使用方法" class="headerlink" title="5.4 Task的使用方法"></a>5.4 Task的使用方法</h2><h3 id="5-4-1-启动任务"><a href="#5-4-1-启动任务" class="headerlink" title="5.4.1 启动任务"></a>5.4.1 启动任务</h3><p>以下程序演示了几种通过Task类启动任务的方式：</p><ul><li><p>实例化后手动start()</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> task1 = <span class="hljs-keyword">new</span> Task(() =&gt;<br>    &#123;<br>       <span class="hljs-comment">//TODO you code</span><br>    &#125;);<br>   task1.Start();<br></code></pre></td></tr></table></figure></li><li><p>使用Task工厂对象创建新任务并执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>工厂创建，直接执行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p>案例如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ThreadExample</span><br> &#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>     &#123;<br>         TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>         Task t1 = tf.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task factory&quot;</span>);<br><br>         Task t2 = Task.Factory.StartNew(TaskMethod.DoTask, <span class="hljs-string">&quot;factory via a task&quot;</span>);<br><br>         Task t3 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using a task constructor and start&quot;</span>);<br>         t3.Start();<br><br>         <span class="hljs-comment">//需要.NetFramework 4.5以上</span><br>         <span class="hljs-keyword">var</span> t4 = Task.Run(() =&gt; TaskMethod.DoTask(<span class="hljs-string">&quot;using Run method&quot;</span>));<br><br>         Console.ReadKey();<br>     &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">TaskMethod</span><br> &#123;<br>     <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> taskLock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoTask</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> msg</span>)</span><br><span class="hljs-function"></span>     &#123;<br>         <span class="hljs-keyword">lock</span> (taskLock)<br>         &#123;<br>             Console.WriteLine(msg);<br>             Console.WriteLine(<span class="hljs-string">&quot;Task id:&#123;0&#125;, Thread id :&#123;1&#125;&quot;</span>,<br>                            Task.CurrentId == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;no task&quot;</span> : Task.CurrentId.ToString(),<br>                            Thread.CurrentThread.ManagedThreadId);<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-2-任务控制"><a href="#5-4-2-任务控制" class="headerlink" title="5.4.2 任务控制"></a>5.4.2 任务控制</h3><h4 id="5-4-2-1-Task-Wait"><a href="#5-4-2-1-Task-Wait" class="headerlink" title="5.4.2.1 Task.Wait()"></a>5.4.2.1 Task.Wait()</h4><p>就是等待任务执行（task1）完成，task1的状态变为Completed。</p><h4 id="5-4-2-2-Task-WaitAll"><a href="#5-4-2-2-Task-WaitAll" class="headerlink" title="5.4.2.2 Task.WaitAll()"></a>5.4.2.2 Task.WaitAll()</h4><p>等待所有的任务都执行完成：<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAll(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;All task finished!&quot;</span>);<br></code></pre></td></tr></table></figure><p>即当task,task2,task3…N全部任务都执行完成之后才会往下执行代码（打印出：“All task finished!”）</p><h4 id="5-4-2-3-Task-WaitAny"><a href="#5-4-2-3-Task-WaitAny" class="headerlink" title="5.4.2.3 Task.WaitAny()"></a>5.4.2.3 Task.WaitAny()</h4><p>同Task.WaitAll，等待任何一个任务完成就继续向下执行，将上面的代码WaitAll替换为WaitAny</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">Task.WaitAny(task,task2,task3...N)<br>Console.WriteLine(<span class="hljs-string">&quot;Any task finished!&quot;</span>);<br></code></pre></td></tr></table></figure><p> 即当task,task2,task3…N任意一个任务都执行完成之后就会往下执行代码（打印出：” Any task finished!”）</p><h4 id="5-4-2-4-Task-ContinueWith"><a href="#5-4-2-4-Task-ContinueWith" class="headerlink" title="5.4.2.4 Task.ContinueWith()"></a>5.4.2.4 Task.ContinueWith()</h4><p>在第一个Task完成后自动启动下一个Task，实现Task的延续，编写如下代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskFactory tf = <span class="hljs-keyword">new</span> TaskFactory();<br>    Task t1 = tf.StartNew(()=&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务1\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t2 = t1.ContinueWith((t) =&gt;<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务2\r\n&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;);<br><br>    Task t3 = t2.ContinueWith(<span class="hljs-built_in">delegate</span>(Task t) <br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Last Task id = &#123;0&#125;&quot;</span>, t.Id);<br>        Console.WriteLine(<span class="hljs-string">&quot;Current Task id = &#123;0&#125;&quot;</span>, Task.CurrentId);<br>        Console.WriteLine(<span class="hljs-string">&quot;执行任务3\r\n&quot;</span>);<br>    &#125;, TaskContinuationOptions.OnlyOnRanToCompletion);<br><br>    Console.ReadKey(); <br>&#125;<br>    <span class="hljs-comment">//执行结果</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//Current Task id = 1</span><br>    <span class="hljs-comment">//执行任务1</span><br><br>    <span class="hljs-comment">//Last Task id = 1</span><br>    <span class="hljs-comment">//Current Task id = 2</span><br>    <span class="hljs-comment">//执行任务2</span><br><br>    <span class="hljs-comment">//Last Task id = 2</span><br>    <span class="hljs-comment">//Current Task id = 3</span><br>    <span class="hljs-comment">//执行任务3</span><br></code></pre></td></tr></table></figure><p>从执行结果可以看出，任务1，2，3被顺序执行，同时通过 TaskContinuationOptions 还可以指定何种情况下继续执行该任务，常用的值包括OnlyOnFaulted, OnlyOnCanceled, NotOnFaulted, NotOnCanceled等。如将上例中的OnlyOnRanToCompletion改为OnlyOnFaulted，任务2结束之后，任务3将不被执行。</p><p>对于ContinueWith()的使用，MSDN演示了更加优雅的“流式”调用方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)  </span><br><span class="hljs-function"></span>&#123;  <br>   <span class="hljs-keyword">var</span> backgroundScheduler = TaskScheduler.Default;  <br>   <span class="hljs-keyword">var</span> uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  <br>   Task.Factory.StartNew(<span class="hljs-built_in">delegate</span> &#123; DoBackgroundComputation(); &#125;,  <br>                         backgroundScheduler).  <br>   ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUI(); &#125;, uiScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; DoAnotherBackgroundComputation(); &#125;,  <br>                             backgroundScheduler).  <br>                ContinueWith(<span class="hljs-built_in">delegate</span> &#123; UpdateUIAgain(); &#125;, uiScheduler);  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="5-4-2-5-RunSynchronously"><a href="#5-4-2-5-RunSynchronously" class="headerlink" title="5.4.2.5 RunSynchronously()"></a>5.4.2.5 RunSynchronously()</h4><p>用于实现同步调用，直接在当前线程上调用该任务。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    TaskMethod.DoTask(<span class="hljs-string">&quot;Just Main thread&quot;</span>);<br>    Task t1 = <span class="hljs-keyword">new</span> Task(TaskMethod.DoTask, <span class="hljs-string">&quot;using Run Sync&quot;</span>);<br>    t1.RunSynchronously();<br>    <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-comment">//Just Main thread</span><br>    <span class="hljs-comment">//Task id: no task, Thread id: 9</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//using Run Sync</span><br>    <span class="hljs-comment">//Task id:1, Thread id :9</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-3-任务取消"><a href="#5-4-3-任务取消" class="headerlink" title="5.4.3 任务取消"></a>5.4.3 任务取消</h3><p>当我们启动了一个task,出现异常或者用户点击取消等等，我们可以取消这个任务。</p><p>我们通过cancellation的tokens来取消一个Task。<br>在很多Task的Body里面包含循环，我们可以在轮询的时候判断IsCancellationRequested属性是否为True<br>如果是True的话就return或者抛出异常，抛出异常后面再说，因为还没有说异常处理的东西。</p><p>下面在代码中看下如何实现任务的取消，代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#">　　　　<span class="hljs-keyword">var</span> tokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><span class="hljs-keyword">var</span> token = tokenSource.Token;<br><span class="hljs-keyword">var</span> task = Task.Factory.StartNew(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>    &#123;<br>        System.Threading.Thread.Sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Abort mission success!&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;, token);<br>token.Register(() =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>&#125;);<br>Console.WriteLine(<span class="hljs-string">&quot;Press enter to cancel task...&quot;</span>);<br>Console.ReadKey();<br>tokenSource.Cancel();<span class="hljs-number">123456789101112131415161718192021</span><br></code></pre></td></tr></table></figure><p>这里开启了一个Task,并给token注册了一个方法，输出一条信息，然后执行ReadKey开始等待用户输入，用户点击回车后，执行tokenSource.Cancel方法，取消任务。</p><blockquote><p>注意：<br>因为任务通常运行以异步方式在线程池线程上，创建并启动任务的线程将继续执行，一旦该任务已实例化。<br>在某些情况下，当调用线程的主应用程序线程，该应用程序可能会终止之前任何任务实际开始执行。<br>其他情况下，应用程序的逻辑可能需要调用线程继续执行，仅当一个或多个任务执行完毕。<br>您可以同步调用线程的执行，以及异步任务它启动通过调用 Wait 方法来等待要完成的一个或多个任务。<br>若要等待完成一项任务，可以调用其 Task.Wait 方法。<br>调用 Wait 方法将一直阻塞调用线程直到单一类实例都已完成执行。</p></blockquote><h3 id="5-4-4-接收任务的返回值"><a href="#5-4-4-接收任务的返回值" class="headerlink" title="5.4.4 接收任务的返回值"></a>5.4.4 接收任务的返回值</h3><p>对于任务有返回值的情况，可使用Task<TResult>泛型类，TResult定义了返回值的类型，以下代码演示了调用返回int值的任务的方法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">var</span> t5 = <span class="hljs-keyword">new</span> Task&lt;<span class="hljs-built_in">int</span>&gt;(TaskWithResult, Tuple.Create&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    t5.Start();<br>    t5.Wait();<br>    Console.WriteLine(<span class="hljs-string">&quot;adder results: &#123;0&#125;&quot;</span>, t5.Result);<br><br>    Console.ReadKey(); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">TaskWithResult</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> o</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; adder = (Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;)o;<br>    <span class="hljs-keyword">return</span> adder.Item1 + adder.Item2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-任务的层次结构"><a href="#5-5-任务的层次结构" class="headerlink" title="5.5 任务的层次结构"></a>5.5 任务的层次结构</h2><p>如果在一个Task内部创建了另一个任务，这两者间就存在父/子的层次结构，当父任务被取消时，子任务也会被取消。</p><p>如果不希望使用该层次结构，可在创建子任务时选择TaskCreationOptions.DetachedFromParent。</p><h1 id="6-BackgroundWorker控件"><a href="#6-BackgroundWorker控件" class="headerlink" title="6. BackgroundWorker控件"></a>6. BackgroundWorker控件</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><p>C#提供了BackgroundWorker控件帮助用户更简单、安全地实现多线程运算。</p><p>该控件提供了DoWork, ProgressChanged 和 RunWorkerCompleted事件<br>为DoWork添加事件处理函数，再调用RunWorkerAsync()方法，即可创建一个新的线程执行DoWork任务</p><p>ProgressChanged和RunWorkerCompleted事件均在UI线程中执行，添加相应的处理函数，即可完成任务线程与UI线程间的交互，可用于显示任务的执行状态（完成百分比）、执行结果等。</p><p>同时，该控件还提供了CancleAsync()方法，以中断线程的执行<br>需注意的是，调用该方法后，只是将控件的CancellationPending属性置True，用户需在程序执行过程中查询该属性以判定是否应中断线程。</p><p>具体用法可参考MSDN：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.componentmodel.backgroundworker?view=netframework-4.7.2">BackgroundWorker用法范例</a><br>可以看的出来，BackgroundWorker组件提供了一种执行异步操作（后台线程）的同时，并且还能妥妥的显示操作进度的解决方案。</p><h2 id="6-2-属性表"><a href="#6-2-属性表" class="headerlink" title="6.2 属性表"></a>6.2 属性表</h2><h3 id="6-2-1-WorkerReportsProgress"><a href="#6-2-1-WorkerReportsProgress" class="headerlink" title="6.2.1 WorkerReportsProgress"></a>6.2.1 WorkerReportsProgress</h3><p>bool类型，指示BackgroundWorker是否可以报告进度更新。</p><ul><li>True时，可以成功调用ReportProgress方法</li><li>否则将引发InvalidOperationException异常</li></ul><p>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> BackgroundWorker bgWorker = <span class="hljs-keyword">new</span> BackgroundWorker();<br>bgWorker.WorkerReportsProgress = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-2-WorkerSupportsCancellation"><a href="#6-2-2-WorkerSupportsCancellation" class="headerlink" title="6.2.2 WorkerSupportsCancellation"></a>6.2.2 WorkerSupportsCancellation</h3><p>bool类型，指示BackgroundWorker是否支持异步取消操作</p><ul><li><p>True时，将可以成功调用CancelAsync方法</p></li><li><p>否则将引发InvalidOperationException异<br>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">bgWorker.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="6-2-3-CancellationPending"><a href="#6-2-3-CancellationPending" class="headerlink" title="6.2.3 CancellationPending"></a>6.2.3 CancellationPending</h3><p>bool类型，指示应用程序是否已请求取消后台操作。<br>此属性通常放在用户执行的异步操作内部，用来判断用户是否取消执行异步操作。<br>当执行BackgroundWorker.CancelAsync()方法时，该属性值将变为True。<br>用法：</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在DoWork中键入如下代码</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (bgWorker.CancellationPending)<br>      &#123;<br>          e.Cancel = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>          bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>          System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>      &#125;<br>  &#125;   <br></code></pre></td></tr></table></figure><h3 id="6-2-4-IsBusy"><a href="#6-2-4-IsBusy" class="headerlink" title="6.2.4 IsBusy"></a>6.2.4 IsBusy</h3><p>bool类型，指示BackgroundWorker是否正在执行一个异步操作。<br>此属性通常放在BackgroundWorker.RunWorkerAsync()方法之前，避免多次调用RunWorkerAsync()方法引发异常。<br>当执行BackgroundWorker.RunWorkerAsync()方法是，该属性值将变为True。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//防止重复执行异步操作引发错误</span><br> <span class="hljs-keyword">if</span> (bgWorker.IsBusy)<br>     <span class="hljs-keyword">return</span>;<br> bgWorker.RunWorkerAsync();<br></code></pre></td></tr></table></figure><h2 id="6-3-方法表"><a href="#6-3-方法表" class="headerlink" title="6.3 方法表"></a>6.3 方法表</h2><h3 id="6-3-1-RunWorkerAsync"><a href="#6-3-1-RunWorkerAsync" class="headerlink" title="6.3.1 RunWorkerAsync()"></a>6.3.1 RunWorkerAsync()</h3><p>开始执行一个后台操作。</p><p>调用该方法后，将触发BackgroundWorker.DoWork事件，并以异步的方式执行DoWork事件中的代码。<br>该方法还有一个带参数的重载方法：RunWorkerAsync(Object)。<br>该方法允许传递一个Object类型的参数到后台操作中，并且可以通过DoWork事件的DoWorkEventArgs.Argument属性将该参数提取出来。</p><blockquote><p>注：当BackgroundWorker的IsBusy属性为True时，调用该方法将引发InvalidOperationException异常。</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在启动异步操作的地方键入代码</span><br>bgWorker.RunWorkerAsync(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="6-3-2-ReportProgress-Int-percentProgress"><a href="#6-3-2-ReportProgress-Int-percentProgress" class="headerlink" title="6.3.2 ReportProgress(Int percentProgress)"></a>6.3.2 ReportProgress(Int percentProgress)</h3><p>报告操作进度。</p><p>调用该方法后，将触发BackgroundWorker. ProgressChanged事件。<br>另外，该方法包含了一个int类型的参数percentProgress，用来表示当前异步操作所执行的进度百分比。</p><p>该方法还有一个重载方法：ReportProgress(Int percentProgress, Object userState)。<br>允许传递一个Object类型的状态对象到 ProgressChanged事件中<br>并且可以通过ProgressChanged事件的ProgressChangedEventArgs.UserState属性取得参数值。</p><blockquote><p>注：调用该方法之前需确保WorkerReportsProgress属性值为True，否则将引发InvalidOperationException异常。</p></blockquote><p>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>&#123;c<br>    <span class="hljs-comment">//向ProgressChanged报告进度</span><br>    bgWorker.ReportProgress(i,<span class="hljs-string">&quot;Working&quot;</span>);<br>    System.Threading.Thread.Sleep(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-3-CancelAsync"><a href="#6-3-3-CancelAsync" class="headerlink" title="6.3.3 CancelAsync()"></a>6.3.3 CancelAsync()</h3><p>请求取消当前正在执行的异步操作。</p><p>调用该方法将使BackgroundWorker.CancellationPending属性设置为True。<br>但需要注意的是，并非每次调用CancelAsync()都能确保异步操作，CancelAsync()通常不适用于取消一个紧密执行的操作，更适用于在循环体中执行。<br>用法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//在需要执行取消操作的地方键入以下代码</span><br>bgWorker.CancelAsync();<br></code></pre></td></tr></table></figure><h2 id="6-4-事件表"><a href="#6-4-事件表" class="headerlink" title="6.4 事件表"></a>6.4 事件表</h2><h3 id="6-4-1-DoWork"><a href="#6-4-1-DoWork" class="headerlink" title="6.4.1 DoWork"></a>6.4.1 DoWork</h3><p>用于承载异步操作。当调用BackgroundWorker.RunWorkerAsync()时触发。</p><p>需要注意的是：<br>由于DoWork事件内部的代码运行在非UI线程之上，所以在DoWork事件内部应避免于用户界面交互，<br>而于用户界面交互的操作应放置在ProgressChanged和RunWorkerCompleted事件中。</p><h3 id="6-4-2-ProgressChanged"><a href="#6-4-2-ProgressChanged" class="headerlink" title="6.4.2 ProgressChanged"></a>6.4.2 ProgressChanged</h3><p>当调用BackgroundWorker.ReportProgress(int percentProgress)方式时触发该事件。<br>该事件的ProgressChangedEventArgs.ProgressPercentage属性可以接收来自ReportProgress方法传递的percentProgress参数值,ProgressChangedEventArgs.UserState属性可以接收来自ReportProgress方法传递的userState参数。</p><h3 id="6-4-3-RunWorkerCompleted"><a href="#6-4-3-RunWorkerCompleted" class="headerlink" title="6.4.3 RunWorkerCompleted"></a>6.4.3 RunWorkerCompleted</h3><p>异步操作完成或取消时执行的操作，当调用DoWork事件执行完成时触发。</p><p>该事件的RunWorkerCompletedEventArgs参数包含三个常用的属性Error,Cancelled,Result。其中，Error表示在执行异步操作期间发生的错误；Cancelled用于判断用户是否取消了异步操作；Result属性接收来自DoWork事件的DoWorkEventArgs参数的Result属性值，可用于传递异步操作的执行结果。</p><h2 id="6-3-案例"><a href="#6-3-案例" class="headerlink" title="6.3 案例"></a>6.3 案例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br> <br><span class="hljs-keyword">namespace</span> <span class="hljs-title">bcworker</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-comment">//后台工作</span><br>        <span class="hljs-keyword">private</span> BackgroundWorker bw = <span class="hljs-keyword">new</span> BackgroundWorker();<br> <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>            <span class="hljs-comment">//后台工作初始化</span><br>            bw.WorkerReportsProgress = <span class="hljs-literal">true</span>;<span class="hljs-comment">//报告进度</span><br>            bw.WorkerSupportsCancellation = <span class="hljs-literal">true</span>;<span class="hljs-comment">//支持取消</span><br>            bw.DoWork += <span class="hljs-keyword">new</span> DoWorkEventHandler(bgWorker_DoWork);<span class="hljs-comment">//开始工作</span><br>            bw.ProgressChanged += <span class="hljs-keyword">new</span> ProgressChangedEventHandler(bgWorker_ProgessChanged);<span class="hljs-comment">//进度改变事件</span><br>            bw.RunWorkerCompleted += <span class="hljs-keyword">new</span> RunWorkerCompletedEventHandler(bgWorker_WorkerCompleted);<span class="hljs-comment">//进度完成事件</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnStart_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//后台工作运行中，避免重入</span><br>            <span class="hljs-keyword">if</span> (bw.IsBusy) <span class="hljs-keyword">return</span>;<br>            bw.RunWorkerAsync(<span class="hljs-string">&quot;参数&quot;</span>);<span class="hljs-comment">//触发DoWork事件并异步执行，IsBusy置为True</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作将异步执行</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_DoWork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, DoWorkEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.Argument == &quot;参数&quot;;</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)<br>            &#123;<br> <br>                <span class="hljs-keyword">if</span> (bw.CancellationPending)<br>                &#123;<span class="hljs-comment">//用户取消了工作</span><br>                    e.Cancel = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    bw.ReportProgress(i, <span class="hljs-string">&quot;Working&quot;</span>);<span class="hljs-comment">//报告进度，触发ProgressChanged事件</span><br>                    Thread.Sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//模拟工作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进度改变事件</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_ProgessChanged</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, ProgressChangedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//(string)e.UserState==&quot;Working&quot;</span><br>            progressBar1.Value = e.ProgressPercentage;<span class="hljs-comment">//取得进度更新控件，不用Invoke了</span><br>        &#125;<br>        <span class="hljs-comment">//后台工作执行完毕,IsBusy置为False</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bgWorker_WorkerCompleted</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//e.Error == null 是否发生错误</span><br>            <span class="hljs-comment">//e.Cancelled 完成是由于取消还是正常完成</span><br>        &#125;<br> <br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span> (bw.IsBusy) bw.CancelAsync();<span class="hljs-comment">//设置CancellationPending属性为True</span><br>        &#125;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp-序列化</title>
    <link href="/2021/05/23/CSharp-%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2021/05/23/CSharp-%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是序列化"><a href="#1-1-什么是序列化" class="headerlink" title="1.1 什么是序列化"></a>1.1 什么是序列化</h2><p>序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。<br>在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p><h2 id="1-2-序列化的目的"><a href="#1-2-序列化的目的" class="headerlink" title="1.2 序列化的目的"></a>1.2 序列化的目的</h2><p>1、方便对象长久存储</p><p>2、方便对象传输</p><p>3、使程序更具维护性</p><h2 id="1-3-序列化操作"><a href="#1-3-序列化操作" class="headerlink" title="1.3 序列化操作"></a>1.3 序列化操作</h2><ul><li><p>序列化<br>将对象转换为字符串或二进制数据，以便存储或传输</p></li><li><p>反序列化<br>将字符串或二进制数据还原成对象</p></li><li><p>无序列化<br>标明对象的属性中哪些属性不需要序列化<br><img src="/images/CSharp-%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523182615355.png" srcset="/img/loading.gif"></p></li></ul><h2 id="1-4-常用的序列化格式"><a href="#1-4-常用的序列化格式" class="headerlink" title="1.4 常用的序列化格式"></a>1.4 常用的序列化格式</h2><ul><li><p>Binary(二进制)</p><ul><li>protocol buffer</li></ul></li><li><p>XML</p></li><li><p>JSON(最先进，最推荐)</p><blockquote><p><a href="https://www.bejson.com/">在线JSON格式化校验</a></p></blockquote></li></ul><p>性能指标：Binary&gt;JSON&gt;XML</p><h1 id="2-Binary序列化"><a href="#2-Binary序列化" class="headerlink" title="2. Binary序列化"></a>2. Binary序列化</h1><p>略，求求你，用json吧！</p><p><strong>protocol buffer</strong>是Google的一种<strong>独立和轻量级</strong>的数据交换格式。以<strong>二进制结构</strong>进行存储。</p><h1 id="3-XML序列化"><a href="#3-XML序列化" class="headerlink" title="3. XML序列化"></a>3. XML序列化</h1><p>略，求求你，用json吧！</p><p><strong>XML</strong> 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）。是一种<strong>通用和重量级</strong>的数据交换格式。以<strong>文本结构</strong>存储。</p><p>格式很像HTML</p><h1 id="4-JSON序列化"><a href="#4-JSON序列化" class="headerlink" title="4. JSON序列化"></a>4. JSON序列化</h1><h2 id="4-1-JSON简介"><a href="#4-1-JSON简介" class="headerlink" title="4.1 JSON简介"></a>4.1 JSON简介</h2><p><strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JSON">JSON</a></strong>(<strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">J</a></strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">ava</a><strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">S</a></strong><a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/JavaScript">cript</a> <strong>O</strong>bject <strong>N</strong>otation, JS 对象简谱) 是一种<strong>通用和轻量级</strong>的数据交换格式。以<strong>文本结构</strong>存储，它是完全独立于语言的。</p><h3 id="4-1-1-支持的数据结构"><a href="#4-1-1-支持的数据结构" class="headerlink" title="4.1.1 支持的数据结构"></a>4.1.1 支持的数据结构</h3><p>Json支持下面两种数据结构：</p><ul><li>键值对的集合–各种不同的编程语言，都支持这种数据结构；</li><li>有序的列表类型值的集合–这其中包含数组，集合，矢量，或者序列，等等。</li></ul><h3 id="4-1-2-表现形式"><a href="#4-1-2-表现形式" class="headerlink" title="4.1.2 表现形式"></a>4.1.2 表现形式</h3><h4 id="4-1-2-1-对象"><a href="#4-1-2-1-对象" class="headerlink" title="4.1.2.1 对象"></a>4.1.2.1 对象</h4><p>一个没有顺序的“键/值”,一个对象以花括号“{”开始，并以花括号”}”结束，在每一个“键”的后面，有一个冒号，并且使用逗号来分隔多个键值对。</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var user =  &#123;``&quot;name&quot;``:``&quot;Manas&quot;``,``&quot;gender&quot;``:``&quot;Male&quot;``,``&quot;birthday&quot;``:``&quot;1987-8-8&quot;``&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-数组"><a href="#4-1-1-2-数组" class="headerlink" title="4.1.1.2 数组"></a>4.1.1.2 数组</h4><p>设置值的顺序，一个数组以中括号”[“开始,并以中括号”]”结束，并且所有的值使用逗号分隔</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var userlist = [&#123;``&quot;user&quot;``:&#123;``&quot;name&quot;``:``&quot;Manas&quot;``,``&quot;gender&quot;``:``&quot;Male&quot;``,``&quot;birthday&quot;``:``&quot;1987-8-8&quot;``&#125;&#125;, ``&#123;``&quot;user&quot;``:&#123;``&quot;name&quot;``:``&quot;Mohapatra&quot;``,``&quot;Male&quot;``:``&quot;Female&quot;``,``&quot;birthday&quot;``:``&quot;1987-7-7&quot;``&#125;&#125;]<br></code></pre></td></tr></table></figure><h4 id="4-1-1-3-字符串"><a href="#4-1-1-3-字符串" class="headerlink" title="4.1.1.3 字符串"></a>4.1.1.3 字符串</h4><p>任意数量的Unicode字符，使用引号做标记，并使用反斜杠来分隔。</p><p>例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">var userlist = ``&quot;&#123;\&quot;ID\&quot;:1,\&quot;Name\&quot;:\&quot;Manas\&quot;,\&quot;Address\&quot;:\&quot;India\&quot;&#125;&quot;<br></code></pre></td></tr></table></figure><h2 id="4-2-C-使用JSON序列化"><a href="#4-2-C-使用JSON序列化" class="headerlink" title="4.2 C#使用JSON序列化"></a>4.2 C#使用JSON序列化</h2><p><strong>序列化和反序列化有三种方式：</strong></p><ol><li><p>使用<code>JavaScriptSerializer</code>类</p></li><li><p>使用<code>DataContractJsonSerializer</code>类</p></li><li><p>使用JSON.NET类库</p></li></ol><blockquote><p>第三种最好，求求你直接看第三种吧</p></blockquote><h3 id="4-2-1-使用JavaScriptSerializer类"><a href="#4-2-1-使用JavaScriptSerializer类" class="headerlink" title="4.2.1 使用JavaScriptSerializer类"></a>4.2.1 使用JavaScriptSerializer类</h3><p><code>DataContractJsonSerializer</code>类帮助我们序列化和反序列化Json，他在程序集<code> System.Runtime.Serialization.dll</code>下的<code>System.Runtime.Serialization.Json</code>命名空间里。</p><p><strong>首先，这里，我新建一个控制台的程序，新建一个类Student</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">JsonSerializerAndDeSerializer</span><br>&#123;<br> [<span class="hljs-meta">DataContract</span>]<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br> &#123;<br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>  [<span class="hljs-meta">DataMember</span>]<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Sex &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>上面的Student实体中的契约 [DataMember]，[DataContract]，是使用<code>DataContractJsonSerializer</code>序列化和反序列化必须要加的，对于其他两种方式不必加，也可以的。</p><p><strong>我们程序的代码：</strong></p><p>要先引用程序集，在引入这个命名空间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//使用DataContractJsonSerializer方式需要引入的命名空间，在System.Runtime.Serialization.dll.中</span><br><span class="hljs-keyword">using</span> System.Runtime.Serialization.Json;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 1.DataContractJsonSerializer方式序列化和反序列化</span><br>   Student stu = <span class="hljs-keyword">new</span> Student()<br>    &#123;<br>     ID = <span class="hljs-number">1</span>,<br>     Name = <span class="hljs-string">&quot;曹操&quot;</span>,<br>     Sex = <span class="hljs-string">&quot;男&quot;</span>,<br>     Age = <span class="hljs-number">1000</span><br>    &#125;;<br>   <span class="hljs-comment">//序列化</span><br>   DataContractJsonSerializer js = <span class="hljs-keyword">new</span> DataContractJsonSerializer(<span class="hljs-keyword">typeof</span>(Student));<br>   MemoryStream msObj = <span class="hljs-keyword">new</span> MemoryStream();<br>   <span class="hljs-comment">//将序列化之后的Json格式数据写入流中</span><br>   js.WriteObject(msObj, stu);<br>   msObj.Position = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">//从0这个位置开始读取流中的数据</span><br>   StreamReader sr = <span class="hljs-keyword">new</span> StreamReader(msObj, Encoding.UTF8);<br>   <span class="hljs-built_in">string</span> json = sr.ReadToEnd();<br>   sr.Close();<br>   msObj.Close();<br>   Console.WriteLine(json);<br><br>   <span class="hljs-comment">//反序列化</span><br>   <span class="hljs-built_in">string</span> toDes = json;<br>   <span class="hljs-comment">//string to = &quot;&#123;\&quot;ID\&quot;:\&quot;1\&quot;,\&quot;Name\&quot;:\&quot;曹操\&quot;,\&quot;Sex\&quot;:\&quot;男\&quot;,\&quot;Age\&quot;:\&quot;1230\&quot;&#125;&quot;;</span><br>   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> ms = <span class="hljs-keyword">new</span> MemoryStream(Encoding.Unicode.GetBytes(toDes)))<br>   &#123;<br>    DataContractJsonSerializer deseralizer = <span class="hljs-keyword">new</span> DataContractJsonSerializer(<span class="hljs-keyword">typeof</span>(Student));<br>    Student model = (Student)deseralizer.ReadObject(ms);<span class="hljs-comment">// //反序列化ReadObject</span><br>    Console.WriteLine(<span class="hljs-string">&quot;ID=&quot;</span> + model.ID);<br>    Console.WriteLine(<span class="hljs-string">&quot;Name=&quot;</span> + model.Name);<br>    Console.WriteLine(<span class="hljs-string">&quot;Age=&quot;</span> + model.Age);<br>    Console.WriteLine(<span class="hljs-string">&quot;Sex=&quot;</span> + model.Sex);<br>   &#125;<br>   Console.ReadKey(); <br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p>运行之后结果是：</p><p><img src="/images/CSharp-%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181440077.png" srcset="/img/loading.gif"></p><h3 id="4-2-2-使用JavaScriptJsonSerializer类"><a href="#4-2-2-使用JavaScriptJsonSerializer类" class="headerlink" title="4.2.2 使用JavaScriptJsonSerializer类"></a>4.2.2 使用JavaScriptJsonSerializer类</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-comment">//使用JavaScriptSerializer方式需要引入的命名空间，这个在程序集System.Web.Extensions.dll.中</span><br><span class="hljs-keyword">using</span> System.Web.Script.Serialization;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 2.JavaScriptSerializer方式实现序列化和反序列化</span><br>   Student stu = <span class="hljs-keyword">new</span> Student()<br>    &#123;<br>     ID = <span class="hljs-number">1</span>,<br>     Name = <span class="hljs-string">&quot;关羽&quot;</span>,<br>     Age = <span class="hljs-number">2000</span>,<br>     Sex = <span class="hljs-string">&quot;男&quot;</span><br>    &#125;;<br><br>   JavaScriptSerializer js = <span class="hljs-keyword">new</span> JavaScriptSerializer();<br>   <span class="hljs-built_in">string</span> jsonData = js.Serialize(stu);<span class="hljs-comment">//序列化</span><br>   Console.WriteLine(jsonData);<br><br><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span>/反序列化方式一：</span><br>   <span class="hljs-built_in">string</span> desJson = jsonData;<br>   <span class="hljs-comment">//Student model = js.Deserialize&lt;Student&gt;(desJson);// //反序列化</span><br>   <span class="hljs-comment">//string message = string.Format(&quot;ID=&#123;0&#125;,Name=&#123;1&#125;,Age=&#123;2&#125;,Sex=&#123;3&#125;&quot;, model.ID, model.Name, model.Age, model.Sex);</span><br>   <span class="hljs-comment">//Console.WriteLine(message);</span><br>   <span class="hljs-comment">//Console.ReadKey(); </span><br><br><br>   <span class="hljs-comment"><span class="hljs-doctag">///</span>/反序列化方式2</span><br>   <span class="hljs-built_in">dynamic</span> modelDy = js.Deserialize&lt;<span class="hljs-built_in">dynamic</span>&gt;(desJson); <span class="hljs-comment">//反序列化</span><br>   <span class="hljs-built_in">string</span> messageDy = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;动态的反序列化,ID=&#123;0&#125;,Name=&#123;1&#125;,Age=&#123;2&#125;,Sex=&#123;3&#125;&quot;</span>,<br>    modelDy[<span class="hljs-string">&quot;ID&quot;</span>], modelDy[<span class="hljs-string">&quot;Name&quot;</span>], modelDy[<span class="hljs-string">&quot;Age&quot;</span>], modelDy[<span class="hljs-string">&quot;Sex&quot;</span>]);<span class="hljs-comment">//这里要使用索引取值，不能使用对象.属性</span><br>   Console.WriteLine(messageDy);<br>   Console.ReadKey(); <br><span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span> </span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/CSharp-%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181633952.png" srcset="/img/loading.gif"></p><h3 id="4-2-3-使用JSON-NET类库-推荐"><a href="#4-2-3-使用JSON-NET类库-推荐" class="headerlink" title="4.2.3 使用JSON.NET类库(推荐)"></a>4.2.3 使用JSON.NET类库(推荐)</h3><p>首先在NuGet上下载Json.NET类库。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//使用Json.NET类库需要引入的命名空间</span><br><span class="hljs-keyword">using</span> Newtonsoft.Json;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">region</span> 3.Json.NET序列化</span><br>   List&lt;Student&gt; lstStuModel = <span class="hljs-keyword">new</span> List&lt;Student&gt;() <br>   &#123;<br>   <br>   <span class="hljs-keyword">new</span> Student()&#123;ID=<span class="hljs-number">1</span>,Name=<span class="hljs-string">&quot;张飞&quot;</span>,Age=<span class="hljs-number">250</span>,Sex=<span class="hljs-string">&quot;男&quot;</span>&#125;,<br>   <span class="hljs-keyword">new</span> Student()&#123;ID=<span class="hljs-number">2</span>,Name=<span class="hljs-string">&quot;潘金莲&quot;</span>,Age=<span class="hljs-number">300</span>,Sex=<span class="hljs-string">&quot;女&quot;</span>&#125;<br>   &#125;;<br><br>   <span class="hljs-comment">//Json.NET序列化</span><br>   <span class="hljs-built_in">string</span> jsonData = JsonConvert.SerializeObject(lstStuModel);<br><br>   Console.WriteLine(jsonData);<br>   Console.ReadKey();<br><br><br>   <span class="hljs-comment">//Json.NET反序列化</span><br>   <span class="hljs-built_in">string</span> json = <span class="hljs-string">@&quot;&#123; &#x27;Name&#x27;:&#x27;C#&#x27;,&#x27;Age&#x27;:&#x27;3000&#x27;,&#x27;ID&#x27;:&#x27;1&#x27;,&#x27;Sex&#x27;:&#x27;女&#x27;&#125;&quot;</span>;<br>   Student descJsonStu = JsonConvert.DeserializeObject&lt;Student&gt;(json);<span class="hljs-comment">//反序列化</span><br>   Console.WriteLine(<span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;反序列化： ID=&#123;0&#125;,Name=&#123;1&#125;,Sex=&#123;2&#125;,Sex=&#123;3&#125;&quot;</span>, descJsonStu.ID, descJsonStu.Name, descJsonStu.Age, descJsonStu.Sex));<br>   Console.ReadKey(); <br>   <span class="hljs-meta">#<span class="hljs-meta-keyword">endregion</span></span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/images/CSharp-%E5%BA%8F%E5%88%97%E5%8C%96/image-20210523181908106.png" srcset="/img/loading.gif"></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader的形式</title>
    <link href="/2021/05/23/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/"/>
    <url>/2021/05/23/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>UnityShader最重要的任务是：指定各种着色器所需的代码</p><p>而代码的编写形式有以下三种</p><h1 id="2-长子：顶点-片元着色器"><a href="#2-长子：顶点-片元着色器" class="headerlink" title="2. 长子：顶点/片元着色器"></a>2. 长子：顶点/片元着色器</h1><p>在Unity中我们可以使用<strong>CG/HLSL语言</strong>来编写**顶点/片元着色器(Vertex/Fragment Shader)**。<br>它更复杂也更灵活。</p><p>它写在Pass语句块内，格式如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">Shader <span class="hljs-string">&quot;Unlit/MyFirstShader&quot;</span><br>&#123;<br>Properties<br>&#123;<br>_Color(<span class="hljs-string">&quot;Color&quot;</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>&#125;<br><br>SubShader<br>&#123;<br>Pass<br>&#123;<br><span class="hljs-built_in">CGPROGRAM</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span><br><br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>#pragma是Unity内置的编绎指令用的命令<br>在Pass中我们就利用此命令来声明所需要的顶点着色器与片元着色器。</p><ul><li><p>#pragma vertexName<br>定义顶点着色器为*name,*通常情况下会起名为vert。</p></li><li><p>#pragma fragmentName<br>定义片元着色器为*name,*通常情况下会起名为frag。</p></li></ul><h2 id="2-1-顶点着色器"><a href="#2-1-顶点着色器" class="headerlink" title="2.1 顶点着色器"></a>2.1 顶点着色器</h2><p>顶点着色器就是处理顶点的着色器，每个顶点都会执行一次顶点着色器。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">float4 <span class="hljs-title">vert</span><span class="hljs-params">(float4 vertex:POSITION)</span>:SV_POSITION</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> UnityObjectToClipPos(vertex);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/image-20210523163930947.png" srcset="/img/loading.gif" alt="image-20210523163930947"></p><p>首先呢，我们先来解释下顶点这个函数的结构。</p><ol><li>顶点着色器函数的名称，在上面我们已经指定了顶点着色器的名称就是vert，所以这里我们必须要用vert作为名称。</li><li>其中float4 vertex是我们自己定义的一个四维向量，名字叫vertex（名字我们可以随便起），仅仅定义一个四维向量并不能使它拥有我们模型的顶点信息，所以这里我们需要为它指定一个语义——POSITION，POSITION就是代表着模型的顶点位置信息。此时变量vertex就表示着我们模型的顶点位置。</li><li>在顶色着色器中最主要的事情就是将顶点从模型坐标转换到裁剪坐标（将模型显示在二维显示器上时需要做的一些矩阵转换）。<br>不会矩阵转换怎么办，没关系，Unity已经为我们准备好现成的命令了，只需调用UnityObjectToClipPos即可，后面括号中加上我们的顶点位置变量就可以了。</li><li>在后面片断着色器中我们需要顶点着色器中的输出结果，所以3中需要加上return来将转换后的顶点返回，float4就是用来定义我们返回的是四维向量。</li><li>经过变换后返回的顶点位置，我们也需要利用语义来标记一下，以便片元着色器可以知道哪个是从顶点着色器输出过来的顶点位置信息。所以我们在函数的后面加上: SV_POSITION。</li></ol><blockquote><p>简单地说：<br>POSITION语义是用于顶点着色器，用来指定模型的顶点位置，是在变换前的顶点的本地空间坐标。<br>SV_POSITION语义则用于像素着色器，用来标识经过顶点着色器变换之后的顶点坐标。</p><p>在顶点着色器中处理顶点时，我们首先需要获取到模型的顶点数据（比如顶点位置、法线信息、顶点颜色等等），那么这些数据都是直接存储在模型中的，我们在Shader中只需要通过标识语义就可以自动获得。</p></blockquote><p>此时我们的Shader还不能正常编译，因为了除了顶点着色器外，还们需要一个片断着色器。</p><h2 id="2-2-片元着色器"><a href="#2-2-片元着色器" class="headerlink" title="2.2 片元着色器"></a>2.2 片元着色器</h2><p>片元着色器也被称作像素着色器，主要是处理最终显示在屏幕上的像素结果。</p><p>经过顶点着色器的处理，我们已经得到了最终显示在屏幕上的顶点矩阵，内部会自动进行插值计算，以获得当前模型的所有片元像素，然后每个像素都会执行一次片元着色器，得到最终每个像素的颜色值。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">fixed4 _Color;<br><span class="hljs-function">fixed4 <span class="hljs-title">frag</span> <span class="hljs-params">()</span> : SV_Target</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _Color;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/UnityShader%E7%9A%84%E5%BD%A2%E5%BC%8F/image-20210523164629339.png" srcset="/img/loading.gif" alt="image-20210523164629339"></p><ol><li><p>片断着色器的函数名，其中()中是空的，因为在这个简单的示例中我们并不需要额外的数据传过来，所以暂时为空。</p></li><li><p>在Cg/HLSL中使用Properties中的变量前还需要在Cg/HLSL中再重新声明一次，名称要求一致。<br>这是死规则，我们只能按照要求来执行。<br>float、half、fixed，这三都是浮点数的表示，只是分别对应的精度不一样，主要用此可以进行更进一步的优化。</p></li><li><p>直接返回_Color,也就是直接返回我们在材质面板中定义的颜色，这也是我们这个小例子想要的效果。</p></li><li><p>返回的值是个四维向量，我们用float4来表示，如果想优化的话就用fixed4来表示，精度问题，这里不是重点。</p></li><li><p>SV_TARGET是系统值，表示该函数返回的是用于下一个阶段输出的颜色值，也就是我们最终输出到显示器上的值。</p></li></ol><h2 id="2-3-最终代码"><a href="#2-3-最终代码" class="headerlink" title="2.3 最终代码"></a>2.3 最终代码</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs text">Shader &quot;Unlit/MyFirstShader&quot;<br>&#123;<br>Properties<br>&#123;<br>_Color(&quot;Color&quot;, Color) = (1,1,1,1)<br>&#125;<br><br>SubShader<br>&#123;<br>Pass<br>&#123;<br>CGPROGRAM<br>#pragma vertex vert<br>#pragma fragment frag<br><br>fixed4 _Color;<br><br>float4 vert ( float4 vertex : POSITION ) : SV_POSITION<br>&#123;<br>return UnityObjectToClipPos(vertex);<br>&#125;<br><br>fixed4 frag () : SV_Target<br>&#123;<br>return _Color;<br>&#125;<br>ENDCG<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们已经可以正常编译并实时更换颜色得到反馈了。</p><h2 id="2-4-注意"><a href="#2-4-注意" class="headerlink" title="2.4 注意"></a>2.4 注意</h2><p>顶点着色器与片断着色器的执行并不是1:1的</p><p>例如:<br>一个三角面片，只有三个顶点，顶点着色器只需执行3次，而片断着色器由最终的像素数来决定，执行几百上千都是很正常的。</p><p>所以从性能的角度来考虑，我们要尽量把计算放在顶点着色器中去执行。<br>其次在片断着色器中也要尽量的简化算法，节省开支。</p><h1 id="3-宠儿：表面着色器"><a href="#3-宠儿：表面着色器" class="headerlink" title="3. 宠儿：表面着色器"></a>3. 宠儿：表面着色器</h1><p>表面着色器(Surface Shader)是Unity自己创造的一种着色器代码类型。</p><p>特点是：</p><ul><li><p>代码量少，使用方便简单</p></li><li><p>渲染代价大</p></li></ul><p>实际上，表面着色器在运行时会被Unity编译成对应的顶点/片元着色器。<br>我们可以理解为表面着色器是Unity对顶点/片元着色器的封装抽象。</p><p>一个非常简单的表面着色器示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">Shader <span class="hljs-string">&quot;Custom/simple surface Shader&quot;</span> <br>&#123;<br>SubShader<br>&#123;<br>Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span> = <span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>CGPROGRAM<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> surface surf Lambert</span><br>struct Input <br>&#123;<br>float4 color : COLOR;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> </span><br><span class="hljs-function"></span>&#123;<br>o.Albedo = <span class="hljs-number">1</span>;<br>&#125;<br>ENDCG<br>&#125;<br>Fallback <span class="hljs-string">&quot;Di ffuse&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>从上述程序中可以看出，表面着色器被定义在SubShader语义块(而非Pass语义块)中的CGPROGRAM和ENDCG之间。<br>因为表面着色器不需要开发者关心使用多少个Pass每个如何渲染等问题，Unity 会在背后为我们做好这些事情。</p><blockquote><p>注意：<br>这里的Cg/HLSL是Unity经封装后提供的，它的语法和标准的CgHLSL语法几乎一样， 但还是有细微的不同<br>例如有些原生的函数和用法Unity并没有提供支持。</p></blockquote><h1 id="4-孤儿：固定函数着色器"><a href="#4-孤儿：固定函数着色器" class="headerlink" title="4. 孤儿：固定函数着色器"></a>4. 孤儿：固定函数着色器</h1><p>上述两种UnityShader形式都使用了可编程管线，而对于一些不支持可编程管线的旧设备，就需要用**固定函数着色器(Fixed Function Shader)**。</p><p>这种着色器往往只能完成非常简单的效果。</p><p>固定函数着色器的代码被定义在Pass语句块中，且只是用ShaderLab的语法，不支持Cg/HLSL。</p><p>因为时代变了，现在大多数GPU都支持可编程管线，所以固定函数着色器成了孤儿。<br>实际上，固定函数着色器在运行时会被Unity编译成对应的顶点/片元着色器，因此真正的固定函数着色器已经不存在了。</p><blockquote><p>所以就略过吧，别学，没用的。</p></blockquote><h1 id="5-着色器的选择"><a href="#5-着色器的选择" class="headerlink" title="5. 着色器的选择"></a>5. 着色器的选择</h1><ul><li>除非你有非常明确的需求必须要使用固定函数着色器<br>例如需要在非常旧的设备上运行你的游戏(这些设备非常少见)<br>否则<strong>不要使用固定函数着色器</strong></li><li>如果你想和<strong>各种光源</strong>打交道<br>使用表面着色器<br>但需要小心它在<strong>移动平台的性能表现</strong></li><li>如果你使用的<strong>光照数目非常少</strong><br>使用顶点/片元着色器</li><li>如果你有<strong>很多自定义的渲染效果</strong><br>请选择顶点/片元着色器</li></ul><blockquote><p>其它两种着色器在编译时都会编译成顶点/片选着色器<br>因此从本质上来讲，Unity中只存在顶点/片选着色器</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unityshader的结构</title>
    <link href="/2021/05/23/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <url>/2021/05/23/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-什么是shader"><a href="#1-1-什么是shader" class="headerlink" title="1.1 什么是shader"></a>1.1 什么是shader</h2><p>Shader的中文翻译是着色器，是一类面对GPU编程语言的总称。<br>Shader其实就是一段代码，这段代码的作用是告诉GPU具体怎样去绘制模型的每一个顶点的颜色以及最终每一个像素点的颜色。</p><p>更具体的讲：</p><ul><li>GPU流水线上–些可高度编程的阶段,而由着色器编译出来的最终代码是会在GPU.上运行的(对于固定管线的渲染来说，着色器有时等同于–些特定的渲染设置);</li><li>有一些特定类型的着色器，如顶点着色器、片元着色器等;</li><li>依靠着色器我们可以控制流水线中的渲染细节,例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</li></ul><h2 id="1-2-shader语言有哪些"><a href="#1-2-shader语言有哪些" class="headerlink" title="1.2 shader语言有哪些"></a>1.2 shader语言有哪些</h2><p>既然Shader是一段代码，那必然要用一种语言来书写它，目前主流的有三种语言：</p><ul><li>基于OpenGL<br>OpenGL Shading Language，简称GLSL。</li><li>基于DirectX<br>High Level Shading Language,简称HLSL。</li><li>基于NVIDIA<br>C for Graphic，简称Cg语言。</li></ul><p>GLSL与HLSL分别是基于OpenGL和Direct3D的接口，两者不能混用。</p><p>而Cg语言是用于图形的C语言。<br>这其实说明了当时设计人员的一个初衷，就是<strong>让基于图形硬件的编程变得和C语言编程一样方便，自由</strong>。<br>正如C++和 Java的语法是基于C的，Cg语言本身也是基于C语言的。<br>如果您使用过C、C++、Java其中任意一个，那么Cg的语法也是比较容易掌握的。<br>Cg语言极力保留了C语言的大部分语义，力图让开发人员从硬件细节中解脱出来，Cg同时拥有高级语言的好处，如代码的易重用性，可读性高等。</p><blockquote><p>Cg语言是Microsoft和NVIDIA相互协作在标准硬件光照语言的语法和语义上达成了一致。<br>所以，HLSL和Cg其实是同一种语言。</p></blockquote><h2 id="1-3-什么是UnityShader"><a href="#1-3-什么是UnityShader" class="headerlink" title="1.3 什么是UnityShader"></a>1.3 什么是UnityShader</h2><p>Unity Shader严格来说并不是传统上的Shader,而是Unity自身封装后的一种便于书写的Shader，又称为ShaderLab。</p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/image-20210523140053736.png" srcset="/img/loading.gif" alt="UnityShader是封装"></p><p>其实在Unity中反而一切变的简单起来了，我们只需关心如何去这实现我们想要的效果就好了，其余的事情全部交给Unity来自动处理。<br>因为我们在Unity中编写的Shader最终会根据不同的平台来编绎成不同的着色器语言。</p><p>官方建议使用Cg/HLSL来编写ShaderLab，因为Cg/HLSL有更好的跨平台性。</p><h1 id="2-UnityShader的结构"><a href="#2-UnityShader的结构" class="headerlink" title="2. UnityShader的结构"></a>2. UnityShader的结构</h1><p>一段完整UnityShader代码的结构应该如下面的例子所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Shader">Shader &quot;Path&#x2F;ShaderName&quot;<br>&#123;<br>Properties<br>&#123;<br><br>&#125;<br>SubShader<br>&#123;<br>Pass<br>&#123;<br><br>&#125;<br>&#125;<br>FallBack &quot;Diffuse&quot;<br>CustomEditor &quot;EditorName&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>从整体来看的话，大致是这样的一个框架结构：</p><p><strong>Shader “name” { [Properties] SubShaders [FallBack] [CustomEditor] }</strong></p><blockquote><p>[]方括号表示可选</p></blockquote><p>可以拆分成以下几个大部分：</p><ul><li>Shader “name”</li><li>Properties</li><li>SubShaders</li><li>FallBack</li><li>CustomEditor</li></ul><h2 id="2-1-Shader-“name”-路径名称"><a href="#2-1-Shader-“name”-路径名称" class="headerlink" title="2.1 Shader “name”-路径名称"></a>2.1 Shader “name”-路径名称</h2><p>每个Unity Shader文件的第一行都需要通过Shader语句来指定该Unity Shader 的名字。<br>当为材质选择使用的UnityShader时,这些名称就会出现在材质面板的下拉列表里。</p><p>通过在字符串中添加斜杠(“/”)， 可以控制UnityShader在材质面板中出现的位置<br>例如:<code>Shader &quot;Custom/ MyShader&quot; &#123;...&#125;</code><br>那么这个UnityShader在材质面板中的位置就是:Shader -&gt; Custom -&gt; MyShader</p><blockquote><p>如果我们把路径名称放在Hidden下面的话<br>比如：<code>Shader &quot;Hidden/TA/MyFirstShader&quot;</code><br>则表示在材质面板中隐藏此Shader,你将无法通过材质下拉列表中找到它。<br>这在做一些不需暴露的Shader时很有用处，可以使Shader下拉列表更精简整洁。</p></blockquote><blockquote><p>而Shader文件的名称，也就是我们在Project面板中的资源文件的名称，是可以与Shader内部的路径名称不一样的，这点与C#是不同的。<br>在定义内部路径名称时，建议统一规划下，不要Shader过多后导致很混乱，不便于美术去使用。</p></blockquote><h2 id="2-2-Properties-属性"><a href="#2-2-Properties-属性" class="headerlink" title="2.2 Properties-属性"></a>2.2 Properties-属性</h2><p>Properties是UnityShader与材质的桥梁，语句块中的属性会出现在材质面板。</p><p>格式如下：<br><code>[Attribute]_Name (&quot;Display Name&quot;,Type) = Default Value</code></p><h3 id="2-2-1-Attribute"><a href="#2-2-1-Attribute" class="headerlink" title="2.2.1 Attribute"></a>2.2.1 Attribute</h3><p>属性标记，说白了就是Unity内置的几个属性标记关键字，用于对当前这条属性进行一些特殊的处理，在下面会进行详细介绍。</p><blockquote><p>此标记不是必选项，可以不添加，同时一条属性上也可以有多条属性标记。</p></blockquote><h3 id="2-2-2-Name"><a href="#2-2-2-Name" class="headerlink" title="2.2.2 _Name"></a>2.2.2 _Name</h3><p>属性的名称，也就是变量名。<br>在Shader的CG代码中就是通过这个名称来调用此属性内容的，在外部利用脚本调用时也是这个名称，所以一定要用英文。</p><p><strong>在名称前一定要加上下划线，否则会出现编绎错误！</strong></p><blockquote><p>关于此变量名，有一点很重要！<br>如果此Shader有FallBack的话，一定要将此Shader中的变量名与FallBack中的变量名保持一致，否则会出现FallBack后原有的属性值获取不到的情况<br>切记！</p></blockquote><h3 id="2-2-3-Display-Name"><a href="#2-2-3-Display-Name" class="headerlink" title="2.2.3 Display Name"></a>2.2.3 Display Name</h3><p>显示在材质面板上的名称，主要起到说明解释的作用，可用中文</p><blockquote><p>（正式项目中建议最好还是用英文）</p></blockquote><h3 id="2-2-4-Type"><a href="#2-2-4-Type" class="headerlink" title="2.2.4 Type"></a>2.2.4 Type</h3><p>属性的类型，常用的有以下几种：</p><table><thead><tr><th>属性类型</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>Int</td><td>整数</td><td>_Int(“我是Int”, Int) = 1</td></tr><tr><td>Float</td><td>浮点数(小数)</td><td>_Float(“我是Float”, Float) = 0.5</td></tr><tr><td>Range</td><td>有范围的浮点数(使用滑块)</td><td>_Float(“我是Float”, Range( 0 , 1)) = 0.5</td></tr><tr><td>PowerSlider</td><td>有曲度变化的Range(非线性滑块)</td><td>[PowerSlider(3)]_Float(“我是Float”, Range( 0 , 1)) = 0.5</td></tr><tr><td>IntRange</td><td>向下取整(使用滑块)</td><td>[IntRange]_Float(“我是Float”, Range( 0 , 1)) = 1</td></tr><tr><td>Toggle</td><td>一个checkbook，选中为1，不选为0</td><td>[Toggle]_Float(“我是Float”, Range( 0 , 1)) = 1</td></tr><tr><td>Enum</td><td>枚举(下拉列表)</td><td>[Enum(UnityEngine.Rendering.CullMode)]_Float(“我是Float”, Float) = 1</td></tr><tr><td>Color</td><td>RGBA颜色</td><td>_Color(“我是Color”, Color) = (1,1,1,1)</td></tr><tr><td>HDR</td><td>带亮度的颜色</td><td>[HDR]_Color(“Color”, Color) = (1,1,0,1)</td></tr><tr><td>Vector</td><td>四维向量</td><td>_Vector(“我是Vector”, Vector) = (0,0,0,0)</td></tr><tr><td>2D</td><td>2D纹理</td><td>_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>NoScaleOffset</td><td>没有Tiling (贴图重复度)与Offset (贴图偏移值)的2D纹理</td><td>[NoScaleOffset]_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>Normal</td><td>法线贴图</td><td>[Normal]_MainTex(“我是2D纹理”, 2D) = “white” {}</td></tr><tr><td>3D</td><td>3D纹理</td><td>_MainTex(“我是3D纹理”, 3d) = “” {}</td></tr><tr><td>Cube</td><td>立方体纹理</td><td>_MainTex(“我是Cube纹理”, CUBE) = “” {}</td></tr></tbody></table><blockquote><p>其他属性类型</p><p><strong>[Header]</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">Properties<br>&#123;<br>[Header(This is Header )]_Int(&quot;我是Int&quot;, Int) = 1<br>_Float(&quot;我是Float&quot;, Range( 0 , 1)) = 1<br>&#125;<br></code></pre></td></tr></table></figure><p>在材质面板上进行标注，通常用作分类组别用，注意只支持英文、数字、空格以及下划线。</p><p><strong>[HideInInspector]</strong><br>在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏。</p></blockquote><h3 id="2-2-5-Default-Value"><a href="#2-2-5-Default-Value" class="headerlink" title="2.2.5 Default Value"></a>2.2.5 Default Value</h3><p>默认值。<br>当第一次指定此Shader时，或者在材质面板上执行Reset时，属性的值会自动恢复到默认值。</p><ul><li><p>Int、 Float、 Range<br>其默认值就是一个单独的数字;</p></li><li><p>Color和Vector<br>默认值是用圆括号包围的一个四维向量;</p></li><li><p>2D、Cube、 3D这3种纹理类型<br>默认值的定义稍微复杂，它们的默认值是通过一个字符串 后跟一个花括号来指定的。</p><ul><li>字符串要么是空的，要么是内置的纹理名称<br>如“white”“black” “gray”或者“bump”。 </li></ul></li></ul><blockquote><p>花括号的用处原本是用于指定一些纹理属性的。<br>例如在Unity 5.0以前的版本中，我们可以通过TexGenCubeReflect、TexGen CubeNormal等选项来控制固定管线的纹理坐标的生成。<br>但在Unity 5.0以后的版本中，这些选项被移除了，如果我们需要类似的功能，就需要自己在顶点着色器中编写计算相应纹理坐标的代码。</p></blockquote><h3 id="2-2-6-案例"><a href="#2-2-6-案例" class="headerlink" title="2.2.6 案例"></a>2.2.6 案例</h3><p>下面的代码给出了一个展示所有属性类型的例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php">Properties<br>&#123;<br><span class="hljs-comment">//Numbers and Sliders</span><br>_Int (<span class="hljs-string">&quot;Int&quot;</span>， <span class="hljs-keyword">Int</span>) = <span class="hljs-number">2</span><br><span class="hljs-keyword">Float</span> (<span class="hljs-string">&quot;Float&quot;</span>, <span class="hljs-keyword">Float</span>) = <span class="hljs-number">1.5</span><br>_Range (<span class="hljs-string">&quot;Range&quot;</span> ,Range(<span class="hljs-number">0.0</span>, <span class="hljs-number">5.0</span>)) = <span class="hljs-number">3.0</span><br><br>   <span class="hljs-comment">// Colors and Vectors .</span><br>Color (<span class="hljs-string">&quot;Color&quot;</span>, color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>_Vector (<span class="hljs-string">&quot;Vector&quot;</span>, Vector) = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// Textures</span><br><span class="hljs-number">2</span>D (<span class="hljs-string">&quot;2D&quot;</span>， <span class="hljs-number">2</span>D) =”<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">Cube (&quot;</span>Cube<span class="hljs-string">&quot;, Cube) = &quot;</span>white<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">_3D (&quot;</span><span class="hljs-number">3</span>D<span class="hljs-string">&quot;, 3D) = &quot;</span>black<span class="hljs-string">&quot; &#123;&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>下图是该案例在属性面板中的显示：</p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/03B62754D758D194E8F6A1E8F9704AD1.jpg" srcset="/img/loading.gif" alt="属性面板"></p><h2 id="2-3-SubShaders-子着色器"><a href="#2-3-SubShaders-子着色器" class="headerlink" title="2.3 SubShaders-子着色器"></a>2.3 SubShaders-子着色器</h2><p>每个Shader中都可以包含多个SubShader，不可以没有，必须至少有一个。</p><p>Shader的核心算法实现就是在SubShader中来实现的。</p><p>在加载Shader时，Unity将遍历所有SubShader列表，并最终选择用户机器支持的第一个。</p><p>作用：<br>我们都知道不同的硬件性能是不一样的，游戏内通常把机器配置分为高中低三种，假如我们做了一个效果很好的Shader，但只能在高配机上有较好的性能表现，中低端就显的太费性能，SubShader在这时就可以派上用场了，我们可以在这个Shader内做三个SubShader，分别对应于高中低不同的配置。</p><p>SubShaders语句块中包含的定义通常如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">SubShader<br>&#123;<br>[Tags]<span class="hljs-regexp">//</span>可选的<br>[RenderSetup]<span class="hljs-regexp">//</span>可选的<br>Pass<br>&#123;<br>...<br>&#125;<br><span class="hljs-regexp">//</span>可有多个Pass<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可见，SubShader语句块由以下三个部分组成</p><ul><li><p>Tags 标签</p></li><li><p>RenderSetup状态</p></li><li><p>Pass</p></li></ul><h3 id="2-3-1-Tags-标签"><a href="#2-3-1-Tags-标签" class="headerlink" title="2.3.1 Tags 标签"></a>2.3.1 Tags 标签</h3><p>标签(Tags) 是一个键值对(Key/Value Pair),它的键和值都是字符串类型。<br>这些键值对是SubShader和渲染引擎之间的沟通桥梁。<br>它们用来告诉Unity的渲染引擎:我希望怎样以及何时渲染这个对象。</p><p>标签的结构如下:<br><code>Tags &#123;&quot;TagNamo1&quot;=&quot;Value1&quot; &quot;TagNamo2&quot;=&quot;Value2&quot;&#125;</code></p><p><img src="/images/UnityShader%E7%9A%84%E7%BB%93%E6%9E%84/image-20210523155428768.png" srcset="/img/loading.gif"></p><blockquote><p>注意:<br>上述标签仅可以在SubShader中声明，而不可以在Pass块中声明。<br>Pass块虽然也可以定义标签，但这些标签是不同于SubShader的标签类型。这是我们下面将要讲到的。</p></blockquote><h3 id="2-3-2-RenderSetup-状态"><a href="#2-3-2-RenderSetup-状态" class="headerlink" title="2.3.2 RenderSetup 状态"></a>2.3.2 RenderSetup 状态</h3><p>ShaderLab提供了一系列渲染状态的设置指令， 这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等。</p><p>下表给出了ShaderLab中常见的渲染状态设置选项。</p><table><thead><tr><th>状态名称</th><th>设置指令</th><th>解释</th></tr></thead><tbody><tr><td>Cull</td><td>Cull Back |Front |Off</td><td>设置剔除模式:剔除背面/正面/关闭剔除</td></tr><tr><td>ZTest</td><td>ZTest Less Greater |LEqual |GEqual I Equal |NotEqual |Always</td><td>设置深度测试时使用的函数</td></tr><tr><td>ZWrite</td><td>ZWrite On |Off</td><td>开启/关闭深度写入</td></tr><tr><td>Blend</td><td>Blend SrcFactor DstFactor</td><td>开启并设置混合模式</td></tr></tbody></table><p>当在SubShader块中设置了上述渲染状态时，将会应用到所有的Pass。<br>如果我们不想这样，可以在Pass语义块中单独进行上面的设置。</p><h3 id="2-3-3-Pass语句块"><a href="#2-3-3-Pass语句块" class="headerlink" title="2.3.3 Pass语句块"></a>2.3.3 Pass语句块</h3><h4 id="2-3-3-1-Pass的结构"><a href="#2-3-3-1-Pass的结构" class="headerlink" title="2.3.3.1 Pass的结构"></a>2.3.3.1 Pass的结构</h4><p>Pass语句块的格式如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Pass<br>&#123;<br><span class="hljs-string">[Name]</span><br><span class="hljs-string">[Tags]</span><br><span class="hljs-string">[RenderSetup]</span><br><br><span class="hljs-comment">//code</span><br>CGPROGRAM<br>...<br>ENDCG<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>[Name]<br>规定该Pass的名称，如<code>Name &quot;MyPassName&quot;</code><br>通过名称可以使用UsePass直接调用其它UnityShader中的Pass，如：<code>UsePase &quot;MyShader/MYPASSNAME&quot;</code></p><blockquote><p>使用UsePage指令时必须使用大写形式的名字</p></blockquote></li><li><p>[Tags]标签</p><p>用于告诉渲染引擎如何渲染物体<br>暂略，没看懂</p></li><li><p>[RenderSetup] 状态<br>与SubShader中的相同</p></li><li><p>CGPROGRAM-ENDCG<br>CG代码段</p></li></ul><h4 id="2-3-3-2-Pass的分类"><a href="#2-3-3-2-Pass的分类" class="headerlink" title="2.3.3.2 Pass的分类"></a>2.3.3.2 Pass的分类</h4><ul><li>Pass<br>普通的Pass</li><li>UsePass<br>复用其它UnityShader中的Pass</li><li>GrabPass<br>抓取屏幕，将结果存在一张纹理中以便后续的Pass处理</li></ul><h2 id="2-4-FallBack指令"><a href="#2-4-FallBack指令" class="headerlink" title="2.4 FallBack指令"></a>2.4 FallBack指令</h2><p>当我们写的Shader在一些机器上不支持时（最终显示成粉红色），只要添加了FallBack，并在双引号内写上了其它Shader的有效路径名称，那么在碰到不支持的硬件时这个Shader就会自动切换成FallBack内的Shader。</p><p>如果FallBack内的Shader也不支持呢，那就继续从FallBack内的Shader中再找FallBack……</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">FallBack <span class="hljs-string">&quot;name&quot;</span><br><span class="hljs-regexp">//</span>或者<br>FallBack Off<span class="hljs-regexp">//</span>关闭fallback功能<br></code></pre></td></tr></table></figure><blockquote><p>FallBack会影响阴影的投射<br>在渲染阴影纹理时，Unity 会在每个Unity Shader中寻找一个阴影投射的Pass。<br>通常情况下，我们不需要自己专门实现一个Pass。<br>这是因为Fallback使用的内置Shader中包含了这样一个通用的Pass。<br>因此，为每个Unity Shader正确设置Fallback是非常重要的。</p></blockquote><h2 id="2-5-CustomEditor-自定义面板编辑器"><a href="#2-5-CustomEditor-自定义面板编辑器" class="headerlink" title="2.5 CustomEditor-自定义面板编辑器"></a>2.5 CustomEditor-自定义面板编辑器</h2><p>自定义界面，也就是说我们可以通过这个功能来自由定义材质面板的显示结果，它可以改写Properties中定义的显示方式。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>UnityShader</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp-is与as</title>
    <link href="/2021/05/16/CSharp-is%E4%B8%8Eas/"/>
    <url>/2021/05/16/CSharp-is%E4%B8%8Eas/</url>
    
    <content type="html"><![CDATA[<h1 id="1-C-类型的转换"><a href="#1-C-类型的转换" class="headerlink" title="1. C#类型的转换"></a>1. C#类型的转换</h1><p>在c#中类型的转换分两种：显式和隐式，基本的规则如下：</p><ul><li>基类对象转化为子类对象，必须显式转换，规则：(类型名) 对象。</li><li>值类型和引用类型的转换采用装箱(boxing)或拆箱(unboxing).</li><li>子类转化为基类对象。</li><li>基本类型互相之间转化可以用Covent类来实现。</li><li>字符串类型转换为对应的基本类型用Parse方法，除了String类型外其他的类型都可以用Parse方法。</li><li>用GetType可以取得对象的精确类型。</li><li>子类转化为基类，采用隐式转换。</li></ul><h1 id="2-C-中的is"><a href="#2-C-中的is" class="headerlink" title="2. C#中的is"></a>2. C#中的is</h1><p>检查一个对象是否兼容于其他指定的类型,并返回一个Bool值,如果一个对象是某个类型或是其父类型的话就返回为true，否则的话就会返回为false。永远不会抛出异常<br>如果对象引用为null，那么is操作符总是返回为false，因为没有对象可以检查其类型。</p><p>　　代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>　　<span class="hljs-keyword">if</span> (o <span class="hljs-keyword">is</span> Label)<br>　　&#123;<br>  　 Label lb = (Label)o;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换成功&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">else</span><br>　　&#123;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换失败&quot;</span>);  <br>　　&#125;<br></code></pre></td></tr></table></figure><h1 id="3-C-中as的转换规则"><a href="#3-C-中as的转换规则" class="headerlink" title="3. C#中as的转换规则"></a>3. C#中as的转换规则</h1><ul><li>检查对象类型的兼容性，并返回转换结果，如果不兼容则返回null；</li><li>不会抛出异常；</li><li>如果结果判断为空，则强制执行类型转换将抛出NullReferenceException异常；</li><li>用as来进行类型转换的时候，所要转换的对象类型必须是目标类型或者转换目标类型的派生类型</li></ul><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();  <br>　　Label lb = o <span class="hljs-keyword">as</span> Label;  <br>　　<span class="hljs-keyword">if</span> (lb == <span class="hljs-literal">null</span>)<br>　　&#123;<br>  　　Response.Write(<span class="hljs-string">&quot;类型转换失败&quot;</span>);<br>　　&#125;<br>　　<span class="hljs-keyword">else</span><br>　　&#123;   <br>  　 Response.Write(<span class="hljs-string">&quot;类型转换成功&quot;</span>); <br>　　&#125;<br></code></pre></td></tr></table></figure><p>使用as操作符有如下几点限制</p><p>第一个就是，不用在类型之间进行类型转化，即如下编写就会出现编译错误。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">NewType newValue = <span class="hljs-keyword">new</span> NewType();<br>NewType1 newValue = newValue <span class="hljs-keyword">as</span> NewType1;<br></code></pre></td></tr></table></figure><p>第二个就是，不能应用在值类型数据，即不能如下写（也会出现编译错误）。</p><p>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">object</span> objTest = <span class="hljs-number">11</span>;<br><span class="hljs-built_in">int</span> nValue = objTest <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>;<br></code></pre></td></tr></table></figure><h1 id="4-as与is的区别"><a href="#4-as与is的区别" class="headerlink" title="4. as与is的区别"></a>4. as与is的区别</h1><ul><li><p>AS在转换的同事兼判断兼容性<br>如果无法进行转换，则 as 返回 null（没有产生新的对象）而不是引发异常。<br>有了AS我想以后就不要再用try-catch来做类型转换的判断了。<br>因此as转换成功要判断是否为null。</p></li><li><p>AS是引用类型类型的转换或者装箱转换，不能用与值类型的转换<br>如果是值类型只能结合is来强制转换</p></li><li><p>IS只是做类型兼容判断，并不执行真正的类型转换<br>返回true或false，不会返回null，对象为null也会返回false。</p></li><li><p>AS模式的效率要比IS模式的高<br>因为借助IS进行类型转换的化，需要执行两次类型兼容检查。<br>而AS只需要做一次类型兼容，一次null检查，null检查要比类型兼容检查快。</p></li></ul><h1 id="5-int-，Int32-Parse-，Convert-ToInt32-的区别"><a href="#5-int-，Int32-Parse-，Convert-ToInt32-的区别" class="headerlink" title="5. (int)，Int32.Parse()，Convert.ToInt32()的区别"></a>5. (int)，Int32.Parse()，Convert.ToInt32()的区别</h1><ul><li>(int)转换：<br>用在数值范围大的类型转换成数值范围小的类型时使用<br>但是如果被转换的数值大于或者小于数值范围，则得到一个错误的结果<br>利用这种转换方式不能将string转换成int，会报错。</li><li>Int32.Parse()转换：<br>在符合数字格式的string到int类型转换过程中使用，并可以对错误的string数字格式的抛出相应的异常。</li><li>Convert.ToInt32()转换：<br>使用这种转换，所提供的字符串必须是数值的有效表达方式，该数还必须不是溢出的数。否则抛出异常。</li></ul><h1 id="6-常用类型转换"><a href="#6-常用类型转换" class="headerlink" title="6. 常用类型转换"></a>6. 常用类型转换</h1><ul><li><p>Object =&gt; 已知引用类型<br>使用as操作符来完成</p></li><li><p>Object =&gt; 已知值类型<br>先使用is操作符来进行判断，再用类型强转方式进行转换</p></li><li><p>已知引用类型之间转换<br>首先需要相应类型提供转换函数，再用类型强转方式进行转换</p></li><li><p>已知值类型之间转换<br>最好使用系统提供的Convert类所涉及的静态方法</p></li></ul><p>希望本文所述对大家的C#程序设计有所帮助。</p><p>转载自：<a href="http://www.jb51.net/article/56657.htm%E3%80%82">http://www.jb51.net/article/56657.htm。</a></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-资源与样式</title>
    <link href="/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/"/>
    <url>/2021/04/27/WPF-%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-资源"><a href="#1-资源" class="headerlink" title="1.资源"></a>1.资源</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>WPF资源系统是一种保管一系列有用对象（如常用的画刷、样式和模板）的简单方法，从而使您可以更容易地重用这些对象。<br>每个元素都有Resources属性，该属性存储了一个资源字典集合（它是ResourceDictionary类的实例）。<br>资源集合可包含任意类型的对象，根据字符串编写索引。</p><h2 id="1-2-写法"><a href="#1-2-写法" class="headerlink" title="1.2 写法"></a>1.2 写法</h2><ul><li><p>Window的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Window&gt;</span><br>   <span class="hljs-section">&lt;Window.Resources&gt;</span><br>   <span class="hljs-section">&lt;/Window.Resources&gt;</span><br><span class="hljs-section">&lt;/Window&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Control的写法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;Control&gt;</span><br>      <span class="hljs-section">&lt;Control.Resources&gt;</span><br>       <span class="hljs-section">&lt;/Control.Resources&gt;</span><br><span class="hljs-section">&lt;/Control&gt;</span><br></code></pre></td></tr></table></figure><h1 id="2-样式"><a href="#2-样式" class="headerlink" title="2. 样式"></a>2. 样式</h1></li></ul><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>样式是修改View（窗体、控件）样式的主要手段，主要作用更改控件的外观以及增强用户体验。</p><h2 id="2-2-样式的属性"><a href="#2-2-样式的属性" class="headerlink" title="2.2 样式的属性"></a>2.2 样式的属性</h2><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>Setterts</td><td>设置属性值以及自动关联事件处理程序的Setter对象或EventSetter对象的集合是Style类中最重要的属性，但并非唯一属性。</td></tr><tr><td>Triggers</td><td>继承自TriggerBase类能自动改变样式设置的对象集合。例如，当另一个属性改变时，或者当发生某个时间时，可以修改样式。</td></tr><tr><td>Resources</td><td>希望用于样式的资源集合。</td></tr><tr><td>BasedOn</td><td>通过该属性可创建继承自其它样式设置的更具体的样式</td></tr><tr><td>TargetType</td><td>该属性标识应用样式的元素类型。通过该属性可创建只影响特定类型元素的设置器，还可以创建能够为恰当的元素类型自动起作用的设置器</td></tr></tbody></table><h2 id="2-3-如何关联样式"><a href="#2-3-如何关联样式" class="headerlink" title="2.3 如何关联样式"></a>2.3 如何关联样式</h2><ul><li>DynamicResource（动态资源）<br><code> &lt;Button Style=&quot;&#123;StaticResource BtnStyle&#125;&quot; /&gt;</code></li><li>StaticResource（静态资源）<br><code>&lt;Button Style=&quot;&#123;DynamicResource BtnStyle&#125;&quot; /&gt;</code></li></ul><blockquote><p>二者区别<br>静态资源在第一次编译后即确定其对象或值，之后不能对其进行修改。<br>动态资源在运行时决定，当运行过程中真正需要时，才到资源目标中查找其值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DataResult与DataTable类</title>
    <link href="/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/"/>
    <url>/2021/04/26/DataResult%E4%B8%8EDataTable%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>DataTable和DataSet可以看做是数据容器，比如你查询数据库后得到一些结果，可以放到这种容器里。</p><p>那你可能要问：我不用这种容器，自己读到变量或数组里也一样可以存起来啊，为什么用容器？</p><p>原因是，这种容器的功能比较强大，除了可以存数据，还可以有更大用途。</p><p>举例：<br>在一个c/s结构的桌面数据库系统里，你可以把前面存放查询结果的容器里的数据显示到你客户端界面上，用户在界面上对数据进行添加、删除、修改，你可以把用户的操作更新到容器。<br>等用户操作完毕了，要求更新，然后你才把容器整个的数据变化更新到中心数据库。</p><blockquote><p>这样做的好处是什么？<br>就是减少了数据库操作，客户端速度提高了，数据库压力减小了。</p></blockquote><p> DataSet可以比作一个内存中的数据库，DataTable是一个内存中的数据表，DataSet里可以存储多个DataTable。</p><h1 id="2-DataTable"><a href="#2-DataTable" class="headerlink" title="2. DataTable"></a>2. DataTable</h1><h2 id="2-1-类成员"><a href="#2-1-类成员" class="headerlink" title="2.1 类成员"></a>2.1 类成员</h2><h3 id="2-1-1-构造函数"><a href="#2-1-1-构造函数" class="headerlink" title="2.1.1 构造函数"></a>2.1.1 构造函数</h3><table><thead><tr><th>函数名</th><th>含义</th></tr></thead><tbody><tr><td>DataTable()</td><td>不带参数初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName)</td><td>用指定的表名初始化DataTable 类的新实例</td></tr><tr><td>DataTable(string tableName, string tableNamespace)</td><td>用指定的表名和命名空间初始化DataTable类的新实例</td></tr></tbody></table><h3 id="2-1-2-常用属性"><a href="#2-1-2-常用属性" class="headerlink" title="2.1.2 常用属性"></a>2.1.2 常用属性</h3><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>CaseSensitive</td><td>指示表中的字符串比较是否区分大小写</td></tr><tr><td>ChildRelations</td><td>获取此DataTable 的子关系的集合</td></tr><tr><td>Columns</td><td>获取属于该表的列的集合</td></tr><tr><td>Constraints</td><td>获取由该表维护的约束的集合</td></tr><tr><td>DataSet</td><td>获取此表所属的DataSet</td></tr><tr><td>DefaultView</td><td>获取可能包括筛选视图或游标位置的表的自定义视图</td></tr><tr><td>HasErrors</td><td>获取一个值，该值指示该表所属的DataSet 的任何表的任何行中是否有错误</td></tr><tr><td>MinimumCapacity</td><td>获取或设置该表最初的起始大小。该表中行的最初起始大小。默认值为 50</td></tr><tr><td>Rows</td><td>获取属于该表的行的集合</td></tr><tr><td>TableName</td><td>获取或设置DataTable 的名称</td></tr></tbody></table><h3 id="2-1-3-常用方法"><a href="#2-1-3-常用方法" class="headerlink" title="2.1.3 常用方法"></a>2.1.3 常用方法</h3><table><thead><tr><th>方法名</th><th>含义</th></tr></thead><tbody><tr><td>AcceptChanges()</td><td>提交自上次调用AcceptChanges() 以来对该表进行的所有更改</td></tr><tr><td>BeginInit()</td><td>开始初始化在窗体上使用或由另一个组件使用的DataTable。初始化发生在运行时</td></tr><tr><td>Clear()</td><td>清除所有数据的DataTable</td></tr><tr><td>Clone()</td><td>克隆DataTable 的结构，包括所有DataTable 架构和约束</td></tr><tr><td>EndInit()</td><td>结束在窗体上使用或由另一个组件使用的DataTable 的初始化。初始化发生在运行时</td></tr><tr><td>ImportRow(DataRow row)</td><td>将DataRow 复制到DataTable 中，保留任何属性设置以及初始值和当前值</td></tr><tr><td>Merge(DataTable table)</td><td>将指定的DataTable 与当前的DataTable 合并</td></tr><tr><td>NewRow()</td><td>创建与该表具有相同架构的新DataRow</td></tr></tbody></table><h2 id="2-2-使用技巧"><a href="#2-2-使用技巧" class="headerlink" title="2.2 使用技巧"></a>2.2 使用技巧</h2><h3 id="2-2-1-创建表"><a href="#2-2-1-创建表" class="headerlink" title="2.2.1 创建表"></a>2.2.1 创建表</h3><p><code>DataTable dt = new DataTable(&quot;Table_AX&quot;); </code></p><h3 id="2-2-2-添加列属性"><a href="#2-2-2-添加列属性" class="headerlink" title="2.2.2 添加列属性"></a>2.2.2 添加列属性</h3><p>方法1：<br><code>dt.Columns.Add(&quot;column0&quot;, System.Type.GetType(&quot;System.String&quot;));</code><br>方法2：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataColumn dc = <span class="hljs-keyword">new</span> DataColumn(<span class="hljs-string">&quot;column1&quot;</span>, System.Type.GetType(<span class="hljs-string">&quot;System.Boolean&quot;</span>));<br>dt.Columns.Add(dc); <br></code></pre></td></tr></table></figure><h3 id="2-2-3-添加数据行"><a href="#2-2-3-添加数据行" class="headerlink" title="2.2.3 添加数据行"></a>2.2.3 添加数据行</h3><p>初始化行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr = dt.NewRow();<br>dr[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AX&quot;</span>;<br>dr[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">true</span>;<br>dt.Rows.Add(dr);<br></code></pre></td></tr></table></figure><p>空行:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow dr1 = dt.NewRow();<br>dt.Rows.Add(dr1);    <br></code></pre></td></tr></table></figure><h3 id="2-2-4-选择数据行"><a href="#2-2-4-选择数据行" class="headerlink" title="2.2.4 选择数据行"></a>2.2.4 选择数据行</h3><p>选择表中所有第0列属性为’AX’的数据行<br><code>DataRow[] drss = dt.Select(&quot;column0 = &#39;AX&#39;&quot;);</code></p><blockquote><p>空属性时用<strong>is null</strong><br>例：<code> DataRow[] drs = dt.Select(&quot;column1 is null&quot;);</code></p></blockquote><h3 id="2-2-5-复制表-包括数据"><a href="#2-2-5-复制表-包括数据" class="headerlink" title="2.2.5 复制表(包括数据)"></a>2.2.5 复制表(包括数据)</h3><p><code>DataTable dtNew = dt.Copy();</code></p><h3 id="2-2-6-复制表-仅结构"><a href="#2-2-6-复制表-仅结构" class="headerlink" title="2.2.6 复制表(仅结构)"></a>2.2.6 复制表(仅结构)</h3><p><code>DataTable dtOnlyScheme = dt.Clone(); </code></p><h3 id="2-2-7-数据行操作"><a href="#2-2-7-数据行操作" class="headerlink" title="2.2.7 数据行操作"></a>2.2.7 数据行操作</h3><ul><li><p>方法一</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataRow drOperate = dt.Rows[<span class="hljs-number">0</span>];<br>drOperate[<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">drOperate[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>drOperate[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法三</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column0&quot;</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;column1&quot;</span>] = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li><li><p>方法四</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;AXzhz&quot;</span>;<br>dt.Rows[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>; <br></code></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>  <span class="hljs-keyword">foreach</span> (DataColumn column <span class="hljs-keyword">in</span> dt.Columns) <br>  &#123; <br> Console.WriteLine(row[column]); <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>row[column] 中的column是检索出来的表个列名。</p><p>如果想把某列的值拼接字符串，那就去掉内层循环就行了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">StringBuilder mailList = <span class="hljs-keyword">new</span> StringBuilder(); <br><span class="hljs-keyword">foreach</span> (DataRow row <span class="hljs-keyword">in</span> dt.Rows) <br>&#123; <br>   mailList.Append(row[<span class="hljs-string">&quot;Email&quot;</span>]); <br>   mailList.Append(<span class="hljs-string">&quot;;&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-8-复制数据行到当前数据表"><a href="#2-2-8-复制数据行到当前数据表" class="headerlink" title="2.2.8 复制数据行到当前数据表"></a>2.2.8 复制数据行到当前数据表</h3></li></ul><p><code>dtOnlyScheme.Rows.Add(dt.Rows[0].ItemArray); </code></p><h3 id="2-2-9-转换为字符串"><a href="#2-2-9-转换为字符串" class="headerlink" title="2.2.9 转换为字符串"></a>2.2.9 转换为字符串</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">System.IO.StringWriter sw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>System.Xml.XmlTextWriter xw = <span class="hljs-keyword">new</span> System.Xml.XmlTextWriter(sw);<br>dt.WriteXml(xw);<br><span class="hljs-built_in">string</span> s = sw.ToString();<br></code></pre></td></tr></table></figure><h3 id="2-2-10-筛选数据表"><a href="#2-2-10-筛选数据表" class="headerlink" title="2.2.10 筛选数据表"></a>2.2.10 筛选数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 &lt;&gt; true&quot;</span>;<br>dt.DefaultView.RowFilter = <span class="hljs-string">&quot;column1 = true&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-11-行排序"><a href="#2-2-11-行排序" class="headerlink" title="2.2.11 行排序"></a>2.2.11 行排序</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">dt.DefaultView.Sort = <span class="hljs-string">&quot;ID ,Name ASC&quot;</span>;<br>dt=dt.DefaultView.ToTable();   <br></code></pre></td></tr></table></figure><h3 id="2-2-12-绑定数据表"><a href="#2-2-12-绑定数据表" class="headerlink" title="2.2.12 绑定数据表"></a>2.2.12 绑定数据表</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">gvTestDataTable.DataSource = dt;<br>gvTestDataTable.DataBind();<br></code></pre></td></tr></table></figure><blockquote><p>绑定的其实是DefaultView</p></blockquote><h3 id="2-2-13-判断一个字符串是否为数据表的列名"><a href="#2-2-13-判断一个字符串是否为数据表的列名" class="headerlink" title="2.2.13 判断一个字符串是否为数据表的列名"></a>2.2.13 判断一个字符串是否为数据表的列名</h3><p><code>dtInfo.Columns.Contains(&quot;AX&quot;);</code></p><h3 id="2-2-14-序列化"><a href="#2-2-14-序列化" class="headerlink" title="2.2.14 序列化"></a>2.2.14 序列化</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#">DataTable convert to XML <span class="hljs-keyword">and</span> XML convert to DataTable<br>     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Page_Load</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br><span class="hljs-function"></span>     &#123;<br>       DataTable dt_AX = <span class="hljs-keyword">new</span> DataTable();<br>       <span class="hljs-comment">//dt_AX.Columns.Add(&quot;Sex&quot;, typeof(System.Boolean));</span><br>       <span class="hljs-comment">//DataRow dr = dt_AX.NewRow();</span><br>       <span class="hljs-comment">//dr[&quot;Sex&quot;] = true;</span><br>       <span class="hljs-comment">//dt_AX.Rows.Add(dr);</span><br>       <span class="hljs-built_in">string</span> xml=ConvertBetweenDataTableAndXML_AX(dt_AX);<br>       DataTable dt = ConvertBetweenDataTableAndXML_AX(xml);<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params">DataTable dtNeedCoveret</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextWriter tw = <span class="hljs-keyword">new</span> System.IO.StringWriter();<br>       <span class="hljs-comment">//if TableName is empty, WriteXml() will throw Exception.         </span><br><br>dtNeedCoveret.TableName=dtNeedCoveret.TableName.Length==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;Table_AX&quot;</span>:dtNeedCoveret.TableName;<br>       dtNeedCoveret.WriteXml(tw);<br>       dtNeedCoveret.WriteXmlSchema(tw);<br>       <span class="hljs-keyword">return</span> tw.ToString();<br>    &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> DataTable <span class="hljs-title">ConvertBetweenDataTableAndXML_AX</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> xml</span>)</span><br><span class="hljs-function"></span>    &#123;<br>       System.IO.TextReader trDataTable = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(<span class="hljs-number">0</span>, xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       System.IO.TextReader trSchema = <span class="hljs-keyword">new</span> System.IO.StringReader(xml.Substring(xml.IndexOf(<span class="hljs-string">&quot;&lt;?xml&quot;</span>)));<br>       DataTable dtReturn = <span class="hljs-keyword">new</span> DataTable();<br>       dtReturn.ReadXmlSchema(trSchema);<br>       dtReturn.ReadXml(trDataTable);<br>       <span class="hljs-keyword">return</span> dtReturn;<br>    &#125;<br> dt.Compute(<span class="hljs-string">&quot;sum(SaleNum)&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>) ; <br><span class="hljs-comment">// 对列SaleNum 汇总支持所以sql 聚合函数 如：sum(),count(),avg()等等。。。  </span><br><br>linq<br><br><span class="hljs-keyword">var</span> productNames = <span class="hljs-keyword">from</span> products <span class="hljs-keyword">in</span> dt.AsEnumerable() <span class="hljs-keyword">select</span> products.Field&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;ProductName&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-MVVC</title>
    <link href="/2021/04/24/WPF-MVVC/"/>
    <url>/2021/04/24/WPF-MVVC/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>MVVM是一种开发模式，是一种开发标准。<br>在WPF中应用到MVVM是非常常见的，MVVM全称为Model、View、ViewModel。</p><p>开发模式有</p><ul><li><p>MVC<br>模型-视图-控制器</p></li><li><p>MVP<br>模型-视图-演示者</p></li><li><p>MVVM<br>模型-视图-视图模型</p></li></ul><p>MVP, MVVM都是由MVC衍生出。<br>所有这些设计模式大体上都有助于开发松散组合、易于测试和维护的应用程序。</p><p><a href="https://www.php.cn/faq/417265.html">开发模式</a></p><p><img src="/images/WPF-MVVC/image-20210424155250844.png" srcset="/img/loading.gif" alt="image-20210424155250844"></p><h1 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h1><ul><li>View<br>代表窗体、控件等可视化资源</li><li>ViewModel<br>代表View的业务处理类，<br>将获取到的数据处理好与View进行关联绑定</li><li>Model<br>通常代表数据模型，它将支持ViewModel中所使用的到的<br>还有一种用法就是在Model里完成业务逻辑的编写ViewModel只需要写出关联逻辑代码，具体的使用方式视情况而定。</li></ul><p><img src="/images/WPF-MVVC/image-20210424154619430.png" srcset="/img/loading.gif" alt="image-20210424154619430"></p><h1 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h1><ul><li>优点<br>前后端逻辑分离，解耦，代码配置灵活，易维护，为数据驱动奠定基础。</li><li>缺点<br>开发耗时较长，对于新手掌握起来略微有难度。<br>基于MVVM再实现绑定难度会有一个小幅度的提升。<br>需多实践积累经验即可。</li></ul><h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4. 文件管理"></a>4. 文件管理</h1><p><img src="/images/WPF-MVVC/image-20210424154830937.png" srcset="/img/loading.gif" alt="image-20210424154830937"></p><p>如图所示</p><ul><li><p>请将与页面可视化相关的xaml文件放于Views文件夹下</p></li><li><p>请将页面逻辑交互相关的cs文件放于ViewModels文件夹下</p></li><li><p>请将数据处理，事务实现相关的cs文件放于Models文件夹下</p></li></ul><blockquote><p>.MainWindow稍微特殊点<br>因为它是主窗体作为整个程序的起始点，它可以单独放在外面</p></blockquote><blockquote><p>App.xaml是程序启动配置文件<br>如果需要更换起始运行窗体则需要修改StartupUri=“xxxView.xaml”即可</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
      <tag>MVVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-命令</title>
    <link href="/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>命令有许多可变的部分组成，但它们都具有以下4个重要元素：</p><ul><li>命令<br>命令表示应用程序任务，并且跟踪任务是否能够被执行。<br>然而，命令实际上不包含执行应用程序任务的代码。</li><li>命令绑定<br>每个命令绑定针对用户界面的具体元素，将命令连接到相关的应用程序逻辑。<br>这种分解的设计是非常重要的，因为单个命令可用于应用程序中的多个地方，并且在每个地方具有不同的意义。<br>为处理这一问题，需要将同一命令与不同的命令绑定。</li><li>命令源<br>命令源触发命令。<br>例如，button就是命令源。<br>单击它们都会执行绑定命令。</li><li>命令目标<br>命令目标是在其中执行命令的元素。</li></ul><p><img src="/images/WPF-%E5%91%BD%E4%BB%A4/image-20210424153346796.png" srcset="/img/loading.gif" alt="image-20210424153346796"></p><h1 id="2-如何实现一个命令"><a href="#2-如何实现一个命令" class="headerlink" title="2.如何实现一个命令"></a>2.如何实现一个命令</h1><p>WPF命令的核心是System.Windows.Input.ICommand接口，该接口定义了命令的工作原理。<br>该接口包含两个方法和一个事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ICommand</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">CanExecute</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> parameter</span>)</span>;<br>    <span class="hljs-keyword">event</span> EventHandler CanExecuteChanged;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>Execute</td><td>将包含引用程序任务逻辑</td></tr><tr><td>CanExecute</td><td>返回命令的状态。可用为true，不可用为false；</td></tr><tr><td>CanExecuteChanged</td><td>当命令状态改变是引发该事件。对于使用命令的任何控件，这是指示信号，表示他们应当调用</td></tr></tbody></table><blockquote><p>Execute和CanExecute方法都接受一个附加的对象参数，可使用该对象传递所需的任何附加信息。</p></blockquote><blockquote><p>CanExecute方法检查命令的状态。<br>通过使用该事件，当命令可用时，命令源（如button）可自动启用自身；<br>当命令不可用时，禁用自身。</p></blockquote><h1 id="3-如何让控件支持命令"><a href="#3-如何让控件支持命令" class="headerlink" title="3. 如何让控件支持命令"></a>3. 如何让控件支持命令</h1><p>支持命令的实现是在“命令源”这个环节实现ICommandSource。</p><p>ICommandSource接口定义了三个属性:</p><table><thead><tr><th>属性名</th><th>作用</th></tr></thead><tbody><tr><td>Command</td><td>指向连接的命令，这是唯一必须的细节</td></tr><tr><td>CommandParameter</td><td>提供其他希望随命令发送的数据</td></tr><tr><td>CommandTarget</td><td>确定将在其中执行命令的元素</td></tr></tbody></table><blockquote><p>不是每个控件都直接支持command绑定的<br>需要将他们关联到实现了ICommandSource接口的控件<br>其中包括继承自ButtonBase类的控件（button和Checkbox等）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-依赖属性</title>
    <link href="/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>依赖属性就是一种自己可以没有值，并且可以通过绑定从其他数据源获取值。<br>依赖属性可支持WPF中的样式设置、数据绑定、继承、动画及默认值。</p><p>将所有的属性都设置为依赖属性并不总是正确的解决方案，具体取决于其应用场景。<br>有时，使用私有字段实现属性的典型方法便能满足要求。</p><p>MSDN中给出了下面几种应用依赖属性的场景：</p><ol><li><p>希望可在样式中设置属性。</p></li><li><p>希望属性支持数据绑定。</p></li><li><p>希望可使用动态资源引用设置属性。</p></li><li><p>希望从元素树中的父元素自动继承属性值。</p></li><li><p>希望属性可进行动画处理。</p></li><li><p>希望属性系统在属性系统、环境或用户执行的操作或者读取并使用样式更改了属性以前的值时报告。</p></li><li><p>希望使用已建立的、WPF 进程也使用的元数据约定，例如报告更改属性值时是否要求布局系统重新编写元素的可视化对象。</p><blockquote><p>总结自<a href="https://www.cnblogs.com/dotnet261010/p/6286475.html">https://www.cnblogs.com/dotnet261010/p/6286475.html</a></p></blockquote></li></ol><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><h2 id="2-1-属性变更通知"><a href="#2-1-属性变更通知" class="headerlink" title="2.1 属性变更通知"></a>2.1 属性变更通知</h2><p>无论什么时候，只要依赖属性的值发生改变，wpf就会自动根据属性的元数据触发一系列的动作，这些动作可以重新呈现UI元素，也可以更新当前的布局，刷新数据绑定等等。<br>这种变更的通知最有趣的特点之一就是属性触发器，它可以在属性值改变的时候，执行一系列自定义的动作，而不需要更改任何其他的代码来实现。通过下面的示例来演示属性变更通知</p><p>示例：当鼠标移动到Button按钮上面时，文字的前景色变为红色，离开时变为默认颜色黑色，采用传统方式和依赖属性两种方式实现：</p><h3 id="2-1-1-使用传统方式实现"><a href="#2-1-1-使用传统方式实现" class="headerlink" title="2.1.1 使用传统方式实现"></a>2.1.1 使用传统方式实现</h3><p>在Button按钮上定义MouseEnter和MouseLeave两个事件，分别处理鼠标移动到按钮上面和离开，</p><p>XAML界面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span>              <br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">MouseEnter</span>=<span class="hljs-string">&quot;Button_MouseEnter&quot;</span> <span class="hljs-attr">MouseLeave</span>=<span class="hljs-string">&quot;Button_MouseLeave&quot;</span> &gt;</span>鼠标移动到上面，前景色变为红色<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>        <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>C#后台代码实现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Collections.Generic;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Linq;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Text;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Threading.Tasks;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Controls;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Data;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Documents;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.<span class="hljs-keyword">Input</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Navigation;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">System</span>.Windows.Shapes;<br> <br>namespace WpfDemo<br>&#123;<br>     // MainWindow.xaml 的交互逻辑<br>     <span class="hljs-built_in">public</span> partial <span class="hljs-keyword">class</span> MainWindow : <span class="hljs-keyword">Window</span><br>     &#123;<br>        <span class="hljs-built_in">public</span> MainWindow()<br>         &#123;<br>             InitializeComponent();<br>         &#125;<br>          // 鼠标移动到按钮上面<br>          // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>          // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseEnter(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Red;<br>             &#125;<br>        &#125;<br>         // 鼠标离开按钮<br>        // &lt;param <span class="hljs-type">name</span>=&quot;sender&quot;&gt;&lt;/param&gt;<br>         // &lt;param <span class="hljs-type">name</span>=&quot;e&quot;&gt;&lt;/param&gt;<br>         private <span class="hljs-type">void</span> Button_MouseLeave(<span class="hljs-keyword">object</span> sender, MouseEventArgs e)<br>         &#123;<br>             Button btn = sender <span class="hljs-keyword">as</span> Button;<br>             <span class="hljs-keyword">if</span> (btn != <span class="hljs-keyword">null</span>)<br>             &#123;<br>                 btn.Foreground = Brushes.Black;<br>             &#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-2-使用依赖属性实现"><a href="#2-1-2-使用依赖属性实现" class="headerlink" title="2.1.2 使用依赖属性实现"></a>2.1.2 使用依赖属性实现</h3><p>XAML界面代码：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">&lt;</span><span class="hljs-variable">Window</span> <span class="hljs-variable">x</span><span class="hljs-operator">:</span><span class="hljs-variable">Class</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br>        <span class="hljs-variable">xmlns</span><span class="hljs-operator">:</span><span class="hljs-variable">x</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br>        <span class="hljs-variable">Title</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Grid面板&quot;</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;237&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;525&quot;</span> <span class="hljs-variable">WindowStartupLocation</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;CenterScreen&quot;</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Grid</span> <span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span> <span class="hljs-variable">Height</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;30&quot;</span> <span class="hljs-variable">Width</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span><span class="hljs-operator">&gt;</span>鼠标移动到上面，前景色变为红色<br>            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span> <span class="hljs-variable">TargetType</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Button&quot;</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Trigger</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;IsMouseOver&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span><span class="hljs-operator">&gt;</span><br>                            <span class="hljs-operator">&lt;</span><span class="hljs-built_in">Setter</span> <span class="hljs-built_in">Property</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Foreground&quot;</span> <span class="hljs-built_in">Value</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Red&quot;</span><span class="hljs-operator">&gt;&lt;/</span><span class="hljs-built_in">Setter</span><span class="hljs-operator">&gt;</span><br>                        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Trigger</span><span class="hljs-operator">&gt;</span><br>                    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">.</span><span class="hljs-variable">Triggers</span><span class="hljs-operator">&gt;</span><br>                <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>           <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">.</span><span class="hljs-built_in">Style</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Button</span><span class="hljs-operator">&gt;</span><br>    <span class="hljs-operator">&lt;/</span><span class="hljs-built_in">Grid</span><span class="hljs-operator">&gt;</span><br><span class="hljs-operator">&lt;/</span><span class="hljs-variable">Window</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>使用上面的两种方式都可以实现Button按钮的前景色改变，效果如下：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230351681-1555534511.png" srcset="/img/loading.gif" alt="img"></p><p>在判断属性IsMouseOver的值为false的时候，自动将Foreground的值改为之前的值，因此就不需要写IsMouseOver的值为false的时候，将Foreground的值改为Black。</p><h2 id="2-2-属性值继承"><a href="#2-2-属性值继承" class="headerlink" title="2.2 属性值继承"></a>2.2 属性值继承</h2><p>是指属性值自顶向下沿着元素树进行传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">Title</span>=<span class="hljs-string">&quot;依赖属性&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;237&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;525&quot;</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">WindowStartupLocation</span>=<span class="hljs-string">&quot;CenterScreen&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我使用的是继承的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">FontSize</span>=<span class="hljs-string">&quot;11&quot;</span>&gt;</span>我使用的是自己的fontsize<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>界面运行效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170114230206494-1555380756.png" srcset="/img/loading.gif" alt="img"></p><h2 id="2-3-节省内存空间"><a href="#2-3-节省内存空间" class="headerlink" title="2.3 节省内存空间"></a>2.3 节省内存空间</h2><p>依赖属性和CLR属性在内存的使用上是截然不同的，每个CLR属性都包含一个非static的字段。<br>因此当我们实例化一个类型的时候，就会创建该类型所拥有的所有CLR属性。<br>也就是说一个对象所占用的内存在调用new操作进行实例化的时候就已经决定了。</p><p>而wpf允许对象在创建的时候并不包含用于存储数据的空间，只保留在需要用到数据的时候能够获得该默认值，即用其他对象数据或者实时分配空间的能力。</p><h1 id="３-如何自定义依赖属性"><a href="#３-如何自定义依赖属性" class="headerlink" title="３. 如何自定义依赖属性"></a>３. 如何自定义依赖属性</h1><h2 id="3-1-声明依赖属性变量"><a href="#3-1-声明依赖属性变量" class="headerlink" title="3.1 声明依赖属性变量"></a>3.1 声明依赖属性变量</h2><p>依赖属性的声明都是通过public static来公开一个静态变量，变量的类型必须是DependencyProperty</p><h2 id="3-2-在属性系统中进行注册"><a href="#3-2-在属性系统中进行注册" class="headerlink" title="3.2 在属性系统中进行注册"></a>3.2 在属性系统中进行注册</h2><p>使用DependencyProperty.Register方法来注册依赖属性，或者是使用DependencyProperty.RegisterReadOnly方法来注册</p><h2 id="3-3-使用-NET属性包装依赖属性"><a href="#3-3-使用-NET属性包装依赖属性" class="headerlink" title="3.3 使用.NET属性包装依赖属性"></a>3.3 使用.NET属性包装依赖属性</h2><p>在类上实现属性时，只要该类派生自 DependencyObject，便可以选择使用 DependencyProperty 标识符来标示属性，从而将其设置为依赖属性。</p><p>其语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DependencyProperty TextProperty;<br>        TextProperty =<br>        DependencyProperty.Register(<span class="hljs-string">&quot;Text&quot;</span>, <span class="hljs-comment">//属性名称</span><br>        <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-comment">//属性类型</span><br>        <span class="hljs-keyword">typeof</span>(TestDependencyPropertyWindow), <span class="hljs-comment">//该属性所有者，即将该属性注册到那个类上</span><br>        <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">//属性默认值</span><br>         <br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Text<br> &#123;<br>    <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(TextProperty); &#125;<br>    <span class="hljs-keyword">set</span> &#123; SetValue(TextProperty, <span class="hljs-keyword">value</span>); &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p> 示例：自定义一个依赖属性，界面包括一个TextBox和TextBlock，TextBlock上面字体的前景色随TextBox里面输入的颜色而改变，如果TextBox里面输入的值可以转换成颜色，TextBlock字体的前景色会显示输入的颜色值，如果不能转换，显示默认的前景色。</p><ul><li>1、在当前项目里面添加一个WPF版的用户控件，命名为“MyDependencyProperty”，在MyDependencyProperty.xaml.cs文件里面自定义一个依赖属性：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Windows;<br><span class="hljs-keyword">using</span> System.Windows.Controls;<br><span class="hljs-keyword">using</span> System.Windows.Data;<br><span class="hljs-keyword">using</span> System.Windows.Documents;<br><span class="hljs-keyword">using</span> System.Windows.Input;<br><span class="hljs-keyword">using</span> System.Windows.Media;<br><span class="hljs-keyword">using</span> System.Windows.Media.Imaging;<br><span class="hljs-keyword">using</span> System.Windows.Navigation;<br><span class="hljs-keyword">using</span> System.Windows.Shapes;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">WpfDemo</span><br>&#123;<br>    <span class="hljs-comment">// MyDependencyProperty.xaml 的交互逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDependencyProperty</span> : <span class="hljs-title">UserControl</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            InitializeComponent();<br>        &#125;<br><br>        <span class="hljs-comment">//1、声明依赖属性变量</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyColorProperty;<br><br>        <span class="hljs-comment">//2、在属性系统中进行注册</span><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">MyDependencyProperty</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            MyColorProperty = DependencyProperty.Register(<span class="hljs-string">&quot;MyColor&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span>(MyDependencyProperty),<br>                <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-string">&quot;Red&quot;</span>, (s, e) =&gt; <br>                &#123;<br>                    <span class="hljs-keyword">var</span> mdp = s <span class="hljs-keyword">as</span> MyDependencyProperty;<br>                    <span class="hljs-keyword">if</span> (mdp != <span class="hljs-literal">null</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">try</span><br>                        &#123;<br>                           <span class="hljs-keyword">var</span> color = (Color)ColorConverter.ConvertFromString(e.NewValue.ToString());<br>                            mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(color);<br>                        &#125;<br>                        catch<br>                        &#123;<br>                           mdp.Foreground = <span class="hljs-keyword">new</span> SolidColorBrush(Colors.Black);<br>                        &#125;<br>                    &#125;<br>                <br>                &#125;));<br>        &#125;<br><br>        <span class="hljs-comment">//3、使用.NET属性包装依赖属性:属性名称与注册时候的名称必须一致，</span><br>       <span class="hljs-comment">//即属性名MyColor对应注册时的MyColor</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> MyColor <br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>               <span class="hljs-keyword">return</span> (<span class="hljs-built_in">string</span>)GetValue(MyColorProperty);<br>          &#125;<br>           <span class="hljs-keyword">set</span><br>            &#123;<br>               SetValue(MyColorProperty, <span class="hljs-keyword">value</span>);<br>            &#125;<br>        &#125;                    <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>快速定义依赖属性的快捷方式：</p><p>输入propdp，连续按两下Tab健，自动生成定义依赖属性的语法。</p><p>和输入cw连续按两下Tab健，自动生成Console.Write()一样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty<br>        &#123;<br>            <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)GetValue(MyPropertyProperty); &#125;<br>            <span class="hljs-keyword">set</span> &#123; SetValue(MyPropertyProperty, <span class="hljs-keyword">value</span>); &#125;<br>        &#125;<br><br>       <span class="hljs-comment">// Using a DependencyProperty as the backing store for MyProperty.  This enables animation, styling, binding, etc...</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DependencyProperty MyPropertyProperty =<br>           DependencyProperty.Register(<span class="hljs-string">&quot;MyProperty&quot;</span>, <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), <span class="hljs-keyword">typeof</span>(ownerclass), <span class="hljs-keyword">new</span> PropertyMetadata(<span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure><ul><li>2、在MyDependencyProperty.xaml里面添加一个TextBlock</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MyDependencyProperty&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:mc</span>=<span class="hljs-string">&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:d</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">mc:Ignorable</span>=<span class="hljs-string">&quot;d&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">d:DesignHeight</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">d:DesignWidth</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>我是自定义的依赖属性<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>3、在MainWindow.xaml里面引用新创建的用户控件，并添加一个TextBox，用于输入颜色值，并将自定义的依赖属性MyColor绑定到TextBox</li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;WpfDemo.MainWindow&quot;</span></span></span><br><span class="xml">         xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="xml">         xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;       </span><br><span class="xml">        xmlns:p=&quot;clr-namespace:WpfDemo&quot;</span><br><span class="xml">         Title=&quot;依赖属性&quot; Height=&quot;237&quot; Width=&quot;525&quot; WindowStartupLocation=&quot;CenterScreen&quot;&gt;</span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Grid</span> &gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr">Name</span>=<span class="hljs-string">&quot;tbColor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextBox</span>&gt;</span></span><br><span class="xml">             <span class="hljs-tag">&lt;<span class="hljs-name">p:MyDependencyProperty</span> <span class="hljs-attr">MyColor</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;Binding Path=Text,ElementName=tbColor&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p:MyDependencyProperty</span>&gt;</span></span><br><span class="xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span>        </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在设计界面显示的效果：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115122217947-1972572422.png" srcset="/img/loading.gif" alt="img"></p><p>4、程序运行效果：</p><p>在TextBox里面输入正确的颜色值，前景色会显示为当前输入的颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121945931-691430131.png" srcset="/img/loading.gif" alt="img"></p><p>在TextBox里面输入错误的颜色值，前景色会显示为默认颜色：</p><p><img src="/images/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/1033738-20170115121956713-612253816.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-布局</title>
    <link href="/2021/04/24/WPF-%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/24/WPF-%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>又称容器，面板。<br>在WPF中是最基础也是最重要的一环，它直接决定你界面的样子。掌握熟练度决定它的美观度和可交互性。</p><p>WPF与JavaSwing的布局(容器)有相似之处但又不完全相同。</p><p>WPF的面板主要有6个：</p><ul><li><p>Grid（网格面板）</p></li><li><p>StackPanel(栈面板)</p></li><li><p>Canvas（画布）</p></li><li><p>WrapPanel（环绕面板）</p></li><li><p>DockPanel（停靠面板）</p></li><li><p>UniformGrid(均布网格)</p></li></ul><p>其中前三个最为常用。</p><h1 id="2-Gird-布局"><a href="#2-Gird-布局" class="headerlink" title="2. Gird 布局"></a>2. Gird 布局</h1><p>可以理解为一个表格，类似于HTML中的Table标签。</p><p>它是由行和列组成。</p><h2 id="2-1-标签"><a href="#2-1-标签" class="headerlink" title="2.1 标签"></a>2.1 标签</h2><ul><li><p><code>&lt;Grid&gt;&lt;/Grid&gt;</code><br>该标签对内写入表格内容</p></li><li><p><code>&lt;Grid.RowDefinitions&gt;</code><br>该标签内写入<code>&lt;RowDefinition&gt;&lt;/RowDefinition&gt;</code>标签对<br>用于定义Gird布局中有几行</p></li><li><p><code>&lt;Grid.ColumnDefinitions&gt;</code><br>该标签内写入<code>&lt;ColumnDefinition&gt;&lt;/ColumnDefinition&gt;</code>标签对<br>用于定义Gird布局中有几列</p></li></ul><h2 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h2><ul><li><p>Grid.Column<br>当前元素在Gird布局中的第几列</p></li><li><p>Grid.Row<br>当前元素在Gird布局中的第几行</p><blockquote><p>都从0开始数，且该属性写在元素标签内</p></blockquote></li></ul><h2 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Grid</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">RowDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">RowDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.RowDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ColumnDefinition</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ColumnDefinition</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grid.ColumnDefinitions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Grid.Row</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Grid.Column</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;25&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Grid</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码的效果是：</p><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424125742746.png" srcset="/img/loading.gif" alt="Grid布局"></p><h1 id="3-StackPanel-布局"><a href="#3-StackPanel-布局" class="headerlink" title="3 StackPanel 布局"></a>3 StackPanel 布局</h1><p>是一个可以将自身内容横向或纵向排列的容器。</p><h2 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h2><ul><li><code>&lt;StackPanel&gt;&lt;/StackPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="3-2-属性"><a href="#3-2-属性" class="headerlink" title="3.2 属性"></a>3.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p><ul><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul></li></ul><blockquote><p>默认情况下：<br>水平排列时，每个元素都与面板一样高；<br>垂直排列时，每个元素都与面板一样宽。<br>如果包含的元素超过了面板空间，它只会截断多出的内容。<br>元素的Margin属性用于使元素之间产生一定得间隔，当元素空间大于其内容的空间时，剩余空间将由HorizontalAlignment和 VerticalAlignment属性来决定如何分配。</p></blockquote><h2 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h2><p>垂直排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Vertical&quot;</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131943534.png" srcset="/img/loading.gif" alt="竖直排列"></p><p>水平排列：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;stackpanel&quot;</span> <span class="hljs-attr">Margin</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">Orientation</span>=<span class="hljs-string">&quot;Horizontal&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第一个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第二个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第三个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;第四个&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/images/WPF-%E5%B8%83%E5%B1%80/image-20210424131833665.png" srcset="/img/loading.gif" alt="水平排列"></p><h1 id="4-WrapPanel-布局"><a href="#4-WrapPanel-布局" class="headerlink" title="4. WrapPanel 布局"></a>4. WrapPanel 布局</h1><p>WrapPanel面板以一行或者一列的形式来布置控件，当一行（列）放满之后自动转到下一行（列）。</p><blockquote><p>除了自动换行外，基本与StackPanel相同</p></blockquote><h2 id="4-1-标签"><a href="#4-1-标签" class="headerlink" title="4.1 标签"></a>4.1 标签</h2><ul><li><code>&lt;WrapPanel&gt;&lt;/WrapPanel&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="4-2-属性"><a href="#4-2-属性" class="headerlink" title="4.2 属性"></a>4.2 属性</h2><ul><li><p>Orientation<br>指定布局的排列方式：</p></li><li><p>Vertical(垂直)【默认】</p></li><li><p>Horizontal(水平)</p></li></ul><h1 id="5-Canvas-布局"><a href="#5-Canvas-布局" class="headerlink" title="5 Canvas 布局"></a>5 Canvas 布局</h1><p>它比较特殊。它属于“任意布局”的一种概念，就是你拖控件到UI上的时候你把它放在哪里它就在那里了。</p><h2 id="5-1-标签"><a href="#5-1-标签" class="headerlink" title="5.1 标签"></a>5.1 标签</h2><ul><li><code>&lt;Canvas&gt;&lt;/Canvas&gt;</code><br>该标签对内写入容器内容</li></ul><h2 id="5-2-属性"><a href="#5-2-属性" class="headerlink" title="5.2 属性"></a>5.2 属性</h2><ul><li>Canvas.Top<br>设置元素距Canvas顶部的距离</li><li>Canvas.Bottom<br>设置元素距Canvas底部的距离</li><li>Canvas.Left<br>设置元素距Canvas左边界的距离</li><li>Canvas.Right<br>设置元素距Canvas右边界的距离</li></ul><blockquote><p>当同时设置left和right,top和bottom,以left和top为准</p></blockquote><h2 id="5-3-案例"><a href="#5-3-案例" class="headerlink" title="5.3 案例"></a>5.3 案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Canvas</span> <span class="hljs-attr">Background</span>=<span class="hljs-string">&quot;LightBlue&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Top</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Top=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Bottom</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Bottom=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Left</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Left=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Canvas.Right</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span>Canvas.Right=&quot;50&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Canvas</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-控件</title>
    <link href="/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/"/>
    <url>/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li>常用控件表</li></ul><table><thead><tr><th>控件名</th><th>作用</th></tr></thead><tbody><tr><td>Label</td><td>一般用户描述性文字显示</td></tr><tr><td>TextBlock</td><td>只读的文本框，无法进行编辑，比较适合显示文本，该文本内容不允许编辑的情况</td></tr><tr><td>TextBox</td><td>支持编辑的基本控件</td></tr><tr><td>PassWordBox</td><td>一般用于用户输入验证或者注册时使用</td></tr><tr><td>DataGrid</td><td>列表数据显示控件</td></tr><tr><td>ListView</td><td>一般ListView都可以用DataGrid替代</td></tr><tr><td>ListBox</td><td>下拉列表级控件</td></tr><tr><td>GroupBox</td><td>用于组织页面相关元素放到一起，方便用户使用等方面提供帮助。</td></tr><tr><td>RichTextBox</td><td>支持富文本和简单文本等，可以实现出类似Word的那样的效果。</td></tr><tr><td>MediaElement</td><td>对媒体文件的操作和访问</td></tr><tr><td>Menu</td><td>菜单栏方式的多级菜单的管理和操作</td></tr><tr><td>TabControl</td><td>分页标签</td></tr></tbody></table><p><img src="/images/WPF-%E6%8E%A7%E4%BB%B6/image-20210424140413545.png" srcset="/img/loading.gif" alt="image-20210424140413545"></p><ul><li>控件的基础属性<br>宽、高、背景色、字体颜色、字体大小、禁用、启用、显示、隐藏等</li><li>控件显示的值内容<br>Content、Text、Value等</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF快速入门</title>
    <link href="/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/04/24/WPF%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>整理自B站视频教程:<a href="https://www.bilibili.com/video/BV19K411M72o?p=1">https://www.bilibili.com/video/BV19K411M72o?p=1</a></p><h2 id="1-1-什么是WPF"><a href="#1-1-什么是WPF" class="headerlink" title="1.1 什么是WPF"></a>1.1 什么是WPF</h2><p>WPF全称Windows Presentation Foundation，是微软推出的一项基于windows操作系统的.net平台的c/s客户端构建技术。<br>最大的特征就是可以快速构建项目从而达到节约项目成本的目的。<br>在众多中小型企业比较受欢迎。</p><p>该项受欢迎的行业有医疗、工业、金融、硬件、物流、管理系统（ERP）等领域。</p><p>简而言之就是微软基于C#与.NET推出的一个可视化框架。</p><blockquote><p>微软的可视化框架发展路径：<br>MFC-&gt;WinForm-&gt;WPF</p></blockquote><h2 id="1-2-推荐书籍"><a href="#1-2-推荐书籍" class="headerlink" title="1.2 推荐书籍"></a>1.2 推荐书籍</h2><ul><li><p>《WPF编程宝典使用c#2012和.net4.5 第四版》</p></li><li><p>《c#高级编程》</p></li><li><p>《CLR Via C#》</p></li></ul><h2 id="1-3-前置知识体系"><a href="#1-3-前置知识体系" class="headerlink" title="1.3 前置知识体系"></a>1.3 前置知识体系</h2><ul><li><p>C#</p></li><li><p>学习过至少一种可视化框架或web框架</p></li></ul><h1 id="2-学习目录索引"><a href="#2-学习目录索引" class="headerlink" title="2 学习目录索引"></a>2 学习目录索引</h1><ul><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%B8%83%E5%B1%80/">布局(Pannel)</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E6%8E%A7%E4%BB%B6/">控件</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/">依赖属性</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/">绑定</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-%E5%91%BD%E4%BB%A4/">命令</a></p></li><li><p><a href="https://mycroftcooper.github.io/2021/04/24/WPF-MVVC/">MVVM</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPF-绑定</title>
    <link href="/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/"/>
    <url>/2021/04/24/WPF-%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p> 绑定顾名思义，是将我们获取到的数据和UI上的控件绑定起来利用数据的变化来更新界面所看到的内容。</p><p>绑定的五个步骤:</p><ul><li>1.绑定目标 </li><li>2.绑定属性 </li><li>3.绑定模式 </li><li>4.绑定数据源 </li><li>5.关联资源</li></ul><h1 id="2-绑定步骤"><a href="#2-绑定步骤" class="headerlink" title="2. 绑定步骤"></a>2. 绑定步骤</h1><h2 id="2-1-绑定目标"><a href="#2-1-绑定目标" class="headerlink" title="2.1 绑定目标"></a>2.1 绑定目标</h2><p>绑定目标很好理解，其实就是你要操作绑定的控件。例如：Button，TextBox。</p><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot;&gt;&lt;/TextBox&gt;</code></p><p><img src="D:\码田\项目\MyBlog\source\images\WPF-绑定\image-20210424143754327.png" srcset="/img/loading.gif" alt="image-20210424143754327"></p><h2 id="2-2绑定属性（依赖项属性）"><a href="#2-2绑定属性（依赖项属性）" class="headerlink" title="2.2绑定属性（依赖项属性）"></a>2.2绑定属性（依赖项属性）</h2><p>例：</p><p><code>&lt;TextBox Width=&quot;200&quot; Height=&quot;25&quot; Text=&quot;&#123;Bingding Name&#125;&quot;&gt;&lt;/TextBox&gt;</code></p><ul><li>Text绑定属性</li><li>Bingding 绑定关键字</li><li>Name你要绑定的数据源的变量名</li></ul><h2 id="2-3-绑定模式"><a href="#2-3-绑定模式" class="headerlink" title="2.3 绑定模式"></a>2.3 绑定模式</h2><table><thead><tr><th>模式名称</th><th>含义</th></tr></thead><tbody><tr><td>TwoWay</td><td>无论是目标属性还是源属性，只要发生了更改，就会更新目标属性或源属性</td></tr><tr><td>OneWay</td><td>仅当源属性发生更改时更新目标属性</td></tr><tr><td>OneTime</td><td>仅当应用程序启动时或 DataContext 进行更改时更新目标属性</td></tr><tr><td>OneWayToSource</td><td>在目标属性更改时更新源属性</td></tr><tr><td>Default</td><td>模式根据实际情况来定，如果是可编辑的就是TwoWay,只读的就是OneWay</td></tr></tbody></table><h2 id="2-4-绑定数据源"><a href="#2-4-绑定数据源" class="headerlink" title="2.4 绑定数据源"></a>2.4 绑定数据源</h2><p>一般来说可以是单个变量（int , double,string）、也可以是一个数据集（List）。根据需求和场景去定义。</p><h2 id="2-5-关联资源-DataContext"><a href="#2-5-关联资源-DataContext" class="headerlink" title="2.5 关联资源 DataContext"></a>2.5 关联资源 DataContext</h2><p>在每一个窗体中，都有一个DataContext ，它是一个object类型主要用来存储绑定资源。</p><h1 id="3-绑定和窗体xaml-cs操作的区别"><a href="#3-绑定和窗体xaml-cs操作的区别" class="headerlink" title="3. 绑定和窗体xaml.cs操作的区别"></a>3. 绑定和窗体xaml.cs操作的区别</h1><p>区别在于，窗体后台文件直接访问控件的操作是事件驱动，如果没有事件的存在是改变不了界面的。</p><p>绑定操作，是以数据本身的变化来通知界面显示改变的。</p><p>UI代码和逻辑代码实现前后端分离。</p>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>WPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>WPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p><p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。<br>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。<br>这种方式简化了在复杂环境下的配置管理。</p><h1 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h1><ul><li><p>单例类只能有一个实例</p></li><li><p>单例类必须自己创建自己的唯一实例</p></li><li><p>单例类必须给所有其他对象提供这一实例</p></li></ul><h2 id="2-1-优缺点"><a href="#2-1-优缺点" class="headerlink" title="2.1 优缺点"></a>2.1 优缺点</h2><h3 id="2-1-1-优点"><a href="#2-1-1-优点" class="headerlink" title="2.1.1 优点"></a>2.1.1 优点</h3><ul><li><p>在内存中只有一个对象，节省内存空间；</p></li><li><p>避免频繁的创建销毁对象，可以提高性能；</p></li><li><p>避免对共享资源的多重占用，简化访问；</p></li><li><p>为整个系统提供一个全局访问点。</p></li></ul><h3 id="2-1-2-缺点"><a href="#2-1-2-缺点" class="headerlink" title="2.1.2 缺点"></a>2.1.2 缺点</h3><ul><li><p>不适用于变化频繁的对象；</p></li><li><p>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；</p></li><li><p>如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失；</p></li></ul><h2 id="2-2-适用场景"><a href="#2-2-适用场景" class="headerlink" title="2.2 适用场景"></a>2.2 适用场景</h2><ul><li>需要生成唯一序列的环境</li><li>需要频繁实例化然后销毁的对象</li><li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象</li><li>方便资源相互通信的环境</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" alt="单例模式"></p><h1 id="4-实现步骤"><a href="#4-实现步骤" class="headerlink" title="4. 实现步骤"></a>4. 实现步骤</h1><ol><li>将该类的构造方法定义为私有方法：<br>这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</li><li>在该类内提供一个静态方法：<br>当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</li></ol><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将为一个网站设计一个用于连接数据库的数据库连接池，它基于JDBC，并且要求具有以下几个功能：</p><ul><li>连接池内有数量可定的已连接对象随时供取用</li><li>当连接池内的连接对象不够时可生成新的对象取用</li><li>当连接操作完毕后，可将连接对象放回连接池</li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p>使用单例模式实现连接池：</p><ol><li><p>将该类的构造方法定义为私有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在该类内提供一个静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>   &#125;<br></code></pre></td></tr></table></figure><p>使用线性表存储连接对象，实现对连接对象操作的各个方法。</p></li></ol><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> EXP6;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.DriverManager;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionPool</span> </span>&#123;<br>    <span class="hljs-comment">//数据库地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String url;<br>    <span class="hljs-comment">//取得用户</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String user;<br>    <span class="hljs-comment">//登录密码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String password;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Connection&gt; connections;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ConnectionPool connectionPool;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">()</span> </span>&#123;<br>        url=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/j2ee_exp&quot;</span>;<br>        user=<span class="hljs-string">&quot;root&quot;</span>;<br>        password=<span class="hljs-string">&quot;0326&quot;</span>;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConnectionPool</span><span class="hljs-params">(String url,String user,String password)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.url=url;<span class="hljs-keyword">this</span>.user=user;<span class="hljs-keyword">this</span>.password=password;<br>        connections=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        addConnection(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> connectionPool;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConnectionPool <span class="hljs-title">getInstance</span><span class="hljs-params">(String url,String user,String password)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(connectionPool==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConnectionPool(url,user,password);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addConnection</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)<br>            &#123;<br>                connections.add(DriverManager.getConnection(url,user,password));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(connections.size()==<span class="hljs-number">0</span>) addConnection(<span class="hljs-number">1</span>);<br>        Connection t=connections.getFirst();<br>        connections.removeFirst();<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseConnection</span><span class="hljs-params">(Connection c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (c.isClosed()) connections.add(c);<br>                <span class="hljs-keyword">else</span> addConnection(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-进阶写法"><a href="#6-进阶写法" class="headerlink" title="6. 进阶写法"></a>6. 进阶写法</h1><h2 id="6-1-懒汉式-线程不安全"><a href="#6-1-懒汉式-线程不安全" class="headerlink" title="6.1 懒汉式(线程不安全)"></a>6.1 懒汉式(线程不安全)</h2><p>懒汉式其实是一种比较形象的称谓。<br>既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作。<br>因此在装载对象的时候不创建对象实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> (<span class="hljs-params"></span>)</span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>         instance = <span class="hljs-keyword">new</span> Singleton();<br>     &#125;<br>     <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。<br>当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。<br>也就是说在多线程下不能正常工作。</p><h2 id="6-2-懒汉式-线程安全"><a href="#6-2-懒汉式-线程安全" class="headerlink" title="6.2 懒汉式(线程安全)"></a>6.2 懒汉式(线程安全)</h2><p>为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。<br>因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。<br>这就引出了双重检验锁。</p><h2 id="6-3-双重检验锁"><a href="#6-3-双重检验锁" class="headerlink" title="6.3 双重检验锁"></a>6.3 双重检验锁</h2><p>双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。<br>程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。<br>为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <span class="hljs-comment">//Single Checked</span><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                 <span class="hljs-comment">//Double Checked</span><br>                instance = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance ;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很完美，很可惜，它是有问题:<br>主要在于instance = new Singleton()这句，这<strong>并非是一个原子操作</strong>，事实上在 JVM 中这句话大概做了下面 3 件事情:</p><ul><li><p>给 instance 分配内存</p></li><li><p>调用 Singleton 的构造函数来初始化成员变量</p></li><li><p>将instance对象指向分配的内存空间<br>（执行完这步 instance 就为非 null 了）</p></li></ul><p>但是在 JVM 的即时编译器中存在指令重排序的优化。</p><p>也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。<br>如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p><p>我们只需要将 instance 变量声明成 volatile 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance; <span class="hljs-comment">//声明成 volatile</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                         <br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;       <br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。<br>但其实是不对的。</p><p><strong>使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。</strong></p><p>也就是说，<strong>在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前</strong>。<br>比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。</p><p>从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。<br>这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。</p><h2 id="6-4-饿汉式-static-final-field"><a href="#6-4-饿汉式-static-final-field" class="headerlink" title="6.4 饿汉式 static final field"></a>6.4 饿汉式 static final field</h2><p>饿汉式其实是一种比较形象的称谓。<br>既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。</p><p>这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-comment">//类加载时就初始化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>缺点是它不是一种懒加载模式（lazy initialization），<strong>单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。</strong></p><blockquote><p>饿汉式的创建方式在一些场景中将无法使用：<br>譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。</p></blockquote><h2 id="6-5-静态内部类-static-nested-class"><a href="#6-5-静态内部类-static-nested-class" class="headerlink" title="6.5 静态内部类 static nested class"></a>6.5 静态内部类 static nested class</h2><p>这种方法也是《Effective Java》上所推荐的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span> <span class="hljs-params">()</span></span>&#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE; <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法仍然使用JVM本身机制保证了线程安全问题。<br>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，**第一次调用getInstance()时将加载内部类SingletonHolder **，在该内部类中定义了一个static类型的变量INSTANCE ，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><h2 id="6-6-枚举-Enum"><a href="#6-6-枚举-Enum" class="headerlink" title="6.6 枚举 Enum"></a>6.6 枚举 Enum</h2><p>用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EasySingleton</span></span>&#123;<br>    <span class="hljs-type">INSTANCE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>我们可以总结出，要想实现效率高的线程安全的单例，我们必须注意以下两点：</p><ul><li><strong>尽量减少同步块的作用域</strong></li><li><strong>尽量使用细粒度的锁</strong></li></ul><p>一般来说，单例模式有五种写法：<br><strong>懒汉、饿汉、双重检验锁、静态内部类、枚举</strong><br>上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。</p><p>一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。<br>如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。</p><p>参考：<br><a href="https://www.jianshu.com/p/650593e69f59">https://www.jianshu.com/p/650593e69f59</a><br><a href="https://www.cnblogs.com/xuwendong/p/9633985.html">https://www.cnblogs.com/xuwendong/p/9633985.html</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket原理</title>
    <link href="/2021/04/07/Socket%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/07/Socket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Socket"><a href="#1-什么是Socket" class="headerlink" title="1. 什么是Socket"></a>1. 什么是Socket</h1><h2 id="1-1-网络中进程之间如何通信"><a href="#1-1-网络中进程之间如何通信" class="headerlink" title="1.1 网络中进程之间如何通信"></a>1.1 网络中进程之间如何通信</h2><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信。</p><p>首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！<br>在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p><p>其实TCP/IP协议族已经帮我们解决了这个问题：<br>网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p><p>使用TCP/IP协议的应用程序通常采用应用编程接口：<br>UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。</p><p>就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p><h2 id="1-2-什么是TCP-IP、UDP"><a href="#1-2-什么是TCP-IP、UDP" class="headerlink" title="1.2 什么是TCP/IP、UDP"></a>1.2 什么是TCP/IP、UDP</h2><ul><li><p>TCP/IP（Transmission Control Protocol/Internet Protocol）<br>即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p></li><li><p>UDP（User Data Protocol，用户数据报协议）<br>是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p></li></ul><p>这里有一张图，表明了这些协议的关系。</p><p>​          <img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154451958.png" srcset="/img/loading.gif" alt="img">                              </p><h2 id="1-3-什么是Socket"><a href="#1-3-什么是Socket" class="headerlink" title="1.3 什么是Socket"></a>1.3 什么是Socket</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。<br>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p><blockquote><h3 id="socket一词的起源"><a href="#socket一词的起源" class="headerlink" title="socket一词的起源"></a>socket一词的起源</h3><p>在组网领域的首次使用是在1970年2月12日发布的文献<a href="http://datatracker.ietf.org/doc/rfc33/">IETF RFC33</a>中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p></blockquote><h2 id="1-4-Socket在哪里"><a href="#1-4-Socket在哪里" class="headerlink" title="1.4 Socket在哪里"></a>1.4 Socket在哪里</h2><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154523875.png" srcset="/img/loading.gif" alt="img"></p><h1 id="2-Socket的使用"><a href="#2-Socket的使用" class="headerlink" title="2. Socket的使用"></a>2. Socket的使用</h1><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718154556909.png" srcset="/img/loading.gif" alt="img">   </p><ul><li>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</li><li>在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。</li><li>客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</li></ul><h2 id="2-1-socket的基本操作"><a href="#2-1-socket的基本操作" class="headerlink" title="2.1 socket的基本操作"></a>2.1 socket的基本操作</h2><p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。<br>下面以TCP为例，介绍几个基本的socket接口函数。</p><h3 id="2-1-1-socket-函数"><a href="#2-1-1-socket-函数" class="headerlink" title="2.1.1 socket()函数"></a>2.1.1 socket()函数</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> socket(<span class="hljs-type">int</span> <span class="hljs-keyword">domain</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">type</span>, <span class="hljs-type">int</span> protocol);<br></code></pre></td></tr></table></figure><p>socket函数对应于普通文件的打开操作。<br>普通文件的打开操作返回一个文件描述字，而**socket()**用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。<br>这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。<br>创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：<br>即协议域，又称为协议族（family）。<br>常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。<br>协议族决定了socket的地址类型，在通信中必须采用对应的地址。<br>如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：<br>指定socket类型。<br>常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：<br>故名思意，就是指定协议。<br>常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等<br>它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</li></ul><blockquote><p>注意：<br>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。<br>当protocol为0时，会自动选择type类型对应的默认协议。</p></blockquote><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h3 id="2-1-2-bind-函数"><a href="#2-1-2-bind-函数" class="headerlink" title="2.1.2 bind()函数"></a>2.1.2 bind()函数</h3><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。<br>例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ul><li><p>sockfd：<br>即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。<br>bind()函数就是将给这个描述字绑定一个名字。</p></li><li><p>addr：<br>一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。<br>这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-keyword">sa_family_t</span>    sin_family; <br>    <span class="hljs-keyword">in_port_t</span>      sin_port;   <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>    <span class="hljs-keyword">uint32_t</span>       s_addr;     <br>&#125;;<br></code></pre></td></tr></table></figure><p>ipv6对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span>     sin6_family;    <br>    <span class="hljs-keyword">in_port_t</span>       sin6_port;      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_flowinfo;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span>      <br>    <span class="hljs-keyword">uint32_t</span>        sin6_scope_id;  <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> &#123;</span> <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   s6_addr[<span class="hljs-number">16</span>];    <br>&#125;;<br></code></pre></td></tr></table></figure><p>Unix域对应的是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UNIX_PATH_MAX    108</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span> <br>    <span class="hljs-keyword">sa_family_t</span> sun_family;                <br>    <span class="hljs-keyword">char</span>        sun_path[UNIX_PATH_MAX];   <br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>addrlen：对应的是地址的长度。</p></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务。<br>客户就可以通过它来接连服务器；</p><p>而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。</p><p>这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p><blockquote><h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><p><strong>主机字节序</strong>就是我们平常说的大端和小端模式：<br>不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。<br>引用标准的Big-Endian和Little-Endian的定义如下：</p><p>　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p><strong>网络字节序</strong>：<br>4个字节的32 bit值以下面的次序传输：<br>首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。<br>这种传输次序称作大端字节序。<br><strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong><br>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>所以： 在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。<br>由于 这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再 赋给socket。</p></blockquote><h3 id="2-1-3-listen-、connect-函数"><a href="#2-1-3-listen-、connect-函数" class="headerlink" title="2.1.3 listen()、connect()函数"></a>2.1.3 listen()、connect()函数</h3><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。<br>客户端通过调用connect函数来建立与TCP服务器的连接。</p><h3 id="2-1-4-accept-函数"><a href="#2-1-4-accept-函数" class="headerlink" title="2.1.4 accept()函数"></a>2.1.4 accept()函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。<br>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。<br>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。<br>之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><blockquote><p>注意：<br>accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。<br>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。<br>内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p></blockquote><h3 id="2-1-5-read-、write-等函数"><a href="#2-1-5-read-、write-等函数" class="headerlink" title="2.1.5 read()、write()等函数"></a>2.1.5 read()、write()等函数</h3><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。</p><p>可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。</p><p>它们的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">const</span> struct sockaddr *dest_addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> len, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">                 struct sockaddr *src_addr, <span class="hljs-keyword">socklen_t</span> *addrlen)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, struct msghdr *msg, <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>read函数<br>负责从fd中读取内容<br>当读成功时，read返回实际所读的字节数</p><ul><li>返回的值是0表示已经读到文件的结束了</li><li>返回的值小于0表示出现了错误。<ul><li>如果错误为EINTR说明读是由中断引起的</li><li>如果是ECONNREST表示网络连接出了问题。</li></ul></li></ul></li><li><p>write函数<br>将buf中的nbytes字节内容写入文件描述符fd。</p><ul><li><p>成功时返回写的字节数</p></li><li><p>失败时返回-1，并设置errno变量</p></li><li><p>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</p><ul><li><p>1)write的返回值大于0，表示写了部分或者是 全部的数据。</p></li><li><p>2)返回的值小于0，此时出现了错误。</p></li></ul><p>我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。<br>如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p></li></ul></li></ul><p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p><h3 id="2-1-6-close-函数"><a href="#2-1-6-close-函数" class="headerlink" title="2.1.6 close()函数"></a>2.1.6 close()函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。<br>该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><blockquote><p>注意：<br>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p></blockquote><h2 id="2-2-socket中TCP的三次握手建立连接详解"><a href="#2-2-socket中TCP的三次握手建立连接详解" class="headerlink" title="2.2 socket中TCP的三次握手建立连接详解"></a>2.2 socket中TCP的三次握手建立连接详解</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0NzYyODYucG5n" srcset="/img/loading.gif" alt="image"></p><p>图1、socket中发送的TCP三次握手</p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote><h2 id="2-3-socket中TCP的四次握手释放连接详解"><a href="#2-3-socket中TCP的四次握手释放连接详解" class="headerlink" title="2.3 socket中TCP的四次握手释放连接详解"></a>2.3 socket中TCP的四次握手释放连接详解</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0OTQ2OTMucG5n" srcset="/img/loading.gif" alt="image"></p><p>图2、socket中发送的TCP四次握手</p><p>图示过程如下：</p><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p><p>6.下面给出实现的一个实例</p><p>首先，先给出实现的截图</p><p><img src="/images/Socket%E5%8E%9F%E7%90%86/20190718155008892.png" srcset="/img/loading.gif" alt="img"></p><p>服务器端代码如下：</p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET sListen = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>//用来指定套接字使用的地址格式，通常使用AF_INET</li><li>//指定套接字的类型，若是SOCK_DGRAM，则用的是udp不可靠传输</li><li>//配合type参数使用，指定使用的协议类型（当指定套接字类型后，可以设置为0，因为默认为UDP或TCP）</li><li>if(sListen == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 填充sockaddr_in结构 ,是个结构体</li><li>sockaddr_in sin;</li><li>sin.sin_family = AF_INET;</li><li>sin.sin_port = htons(4567); //1024 ~ 49151：普通用户注册的端口号</li><li>sin.sin_addr.S_un.S_addr = INADDR_ANY;</li><li>// 绑定这个套节字到一个本地地址</li><li>if(::bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed bind() \n”);</li><li>return 0;</li><li>}</li><li>// 进入监听模式</li><li>//2指的是，监听队列中允许保持的尚未处理的最大连接数</li><li>if(::listen(sListen, 2) == SOCKET_ERROR)</li><li>{</li><li>printf(“Failed listen() \n”);</li><li>return 0;</li><li>}</li><li>// 循环接受客户的连接请求</li><li>sockaddr_in remoteAddr;</li><li>int nAddrLen = sizeof(remoteAddr);</li><li>SOCKET sClient = 0;</li><li>char szText[] = “ TCP Server Demo! \r\n”;</li><li>while(sClient==0)</li><li>{</li><li>// 接受一个新连接</li><li>//（(SOCKADDR*)&amp;remoteAddr）一个指向sockaddr_in结构的指针，用于获取对方地址</li><li>sClient = ::accept(sListen, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen);</li><li>if(sClient == INVALID_SOCKET)</li><li>{</li><li>printf(“Failed accept()”);</li><li>}</li><li>printf(“接受到一个连接：%s \r\n”, inet_ntoa(remoteAddr.sin_addr));</li><li>continue ;</li><li>}</li><li>while(TRUE)</li><li>{</li><li>// 向客户端发送数据</li><li>gets(szText) ;</li><li>::send(sClient, szText, strlen(szText), 0);</li><li>// 从客户端接收数据</li><li>char buff[256] ;</li><li>int nRecv = ::recv(sClient, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“ 接收到数据：%s\n”, buff);</li><li>}</li><li>}</li><li>// 关闭同客户端的连接</li><li>::closesocket(sClient);</li><li>// 关闭监听套节字</li><li>::closesocket(sListen);</li><li>return 0;</li><li>}</li></ol><p>客户端代码：</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include “InitSock.h”</li><li>#include</li><li>#include</li><li>using namespace std;</li><li>CInitSock initSock; // 初始化Winsock库</li><li>int main()</li><li>{</li><li>// 创建套节字</li><li>SOCKET s = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</li><li>if(s == INVALID_SOCKET)</li><li>{</li><li>printf(“ Failed socket() \n”);</li><li>return 0;</li><li>}</li><li>// 也可以在这里调用bind函数绑定一个本地地址</li><li>// 否则系统将会自动安排</li><li>// 填写远程地址信息</li><li>sockaddr_in servAddr;</li><li>servAddr.sin_family = AF_INET;</li><li>servAddr.sin_port = htons(4567);</li><li>// 注意，这里要填写服务器程序（TCPServer程序）所在机器的IP地址</li><li>// 如果你的计算机没有联网，直接使用127.0.0.1即可</li><li>servAddr.sin_addr.S_un.S_addr = inet_addr(“127.0.0.1”);</li><li>if(::connect(s, (sockaddr*)&amp;servAddr, sizeof(servAddr)) == -1)</li><li>{</li><li>printf(“ Failed connect() \n”);</li><li>return 0;</li><li>}</li><li>char buff[256];</li><li>char szText[256] ;</li><li>while(TRUE)</li><li>{</li><li>//从服务器端接收数据</li><li>int nRecv = ::recv(s, buff, 256, 0);</li><li>if(nRecv &gt; 0)</li><li>{</li><li>buff[nRecv] = ‘\0’;</li><li>printf(“接收到数据：%s\n”, buff);</li><li>}</li><li>// 向服务器端发送数据</li><li>gets(szText) ;</li><li>szText[255] = ‘\0’;</li><li>::send(s, szText, strlen(szText), 0) ;</li><li>}</li><li>// 关闭套节字</li><li>::closesocket(s);</li><li>return 0;</li><li>}</li></ol><p>封装的InitSock.h</p><p><strong>[cpp]</strong> <a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">view plain</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">copy</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">print</a><a href="http://blog.csdn.net/dlutbrucezhang/article/details/8577810">?</a></p><ol><li>#include</li><li>#include</li><li>#include</li><li>#include</li><li>#pragma comment(lib, “WS2_32”) // 链接到WS2_32.lib</li><li>class CInitSock</li><li>{</li><li>public:</li><li>CInitSock(BYTE minorVer = 2, BYTE majorVer = 2)</li><li>{</li><li>// 初始化WS2_32.dll</li><li>WSADATA wsaData;</li><li>WORD sockVersion = MAKEWORD(minorVer, majorVer);</li><li>if(::WSAStartup(sockVersion, &amp;wsaData) != 0)</li><li>{</li><li>exit(0);</li><li>}</li><li>}</li><li>~CInitSock()</li><li>{</li><li>::WSACleanup();</li><li>}</li><li>};</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>Socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-输入操作</title>
    <link href="/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/03/25/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>输入操作是游戏的基础操作之一。</p><p>Unity支持的操作方式：</p><ul><li>鼠标、键盘，小键盘(PC)</li><li>手柄(主机)</li><li>触屏操作、重力传感器、手势（移动平台）</li><li>VR，AR</li><li>麦克风，摄像头</li></ul><h1 id="2-虚拟输入轴-Virtual-axes"><a href="#2-虚拟输入轴-Virtual-axes" class="headerlink" title="2. 虚拟输入轴(Virtual axes)"></a>2. 虚拟输入轴(Virtual axes)</h1><p>虚拟控制轴将不同的输入设备(比如键盘或摇杆的按键)都归纳到一个统一的虚拟控制系统中。<br>(比如键盘的w、S键以及手柄摇杆的上下运动默认都统一映射到竖直(Verica)输入轴上)<br>这样就屏蔽了不同设备之间的差异，让开发者可以用一套非常简单的输入逻辑，同时兼容多种输入设备。</p><p>使用**输入管理器(Input Manager)**可以查看、修改或增删虚拟轴。</p><p>现代的游戏中往往允许玩家在游戏中自定义按键，所以使用Unity的输入管理器就更为重要要了。<br>通过一层虚拟轴间接操作，可以避免在代码中直接写死操作按钮，而且还能通过动态修改虚拟轴的设置来改变键位的功能。</p><p>关于虚拟输入轴，还有一些需要知道的内容：</p><ol><li><p>脚本可以直接通过虚拟轴的名称读取那个轴的输入状态。</p></li><li><p>创建Unity工程时，默认创建了以下虚拟轴:</p><ul><li><p>横向输入和纵向输入被映射在键盘的W、A、S、 D键以及方向键上</p></li><li><p>Fire1、 Fire2、 Fire3这三个按钮映射到了鼠标的左、中、右键以及键盘的Ctrl. AIt等键位上</p></li><li><p>鼠标移动可以模拟摇杆输入(和鼠标光标在屏幕上的位置无关)，且被映射在专门的鼠标偏移轴上</p></li><li><p>其他常用虚拟轴，例如跳跃(Jump) 、确认(Submit) 和取消(Cancel) </p><h2 id="2-1-添加和编辑虚拟输入轴"><a href="#2-1-添加和编辑虚拟输入轴" class="headerlink" title="2.1 添加和编辑虚拟输入轴"></a>2.1 添加和编辑虚拟输入轴</h2></li></ul></li></ol><p>要添加新的虚拟输入轴，只需要单击主菜单的Edit &gt; Projet Setings &gt; Input 选项，单击路街检视窗口中会显示一个输入管理器，在里面就可以修改或添加虚拟轴了。</p><blockquote><p>注意:<br>虚拟轴具有正、负两个方向。英文记作Positive和Negative.。<br>某些相反的动作可以只用一个轴来表示。<br>比如，如果摇杆向上为正，那么向下就是同一个轴的负方向。</p></blockquote><p>每个虚拟轴可以映射两个按键，第二个按键作为备用，功能一样，备用的英文为Alterative。</p><h2 id="2-2-虚拟输入轴属性表"><a href="#2-2-虚拟输入轴属性表" class="headerlink" title="2.2 虚拟输入轴属性表"></a>2.2 虚拟输入轴属性表</h2><p>下表是虚拟输入轴的属性表：</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>Name</td><td>轴的名字。在脚本中用这个名字来访问这个轴</td></tr><tr><td>Descriptive Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(正方向)</td></tr><tr><td>Descriptive Negative Name</td><td>描述性信息，在某些窗口中显示出来以方便查看(负方向)</td></tr><tr><td>Ncgative Button</td><td>该轴的负方向，用于绑定某个按键</td></tr><tr><td>Positive Button</td><td>该轴的正方向，用于绑定某个按键</td></tr><tr><td>Alt Negative Button</td><td>该轴的负方向，用于绑定某个备用按键</td></tr><tr><td>Alt Positive Button</td><td>该轴的正方向，用于绑定某个备用按键</td></tr><tr><td>Gravity</td><td>轴回中的力度</td></tr><tr><td>Dead</td><td>轴的死区</td></tr><tr><td>Sensitivity</td><td>敏感度</td></tr><tr><td>Snap</td><td>保持式按键。比如按住下方向键，则一直保持下的状态，直到再次按上方向键</td></tr><tr><td>Invert</td><td>如果勾选，则交换正负方向</td></tr><tr><td>Type</td><td>控制该虚拟轴的类型， 比如手柄、键盘是两种不同的类型</td></tr><tr><td>Axis</td><td>很多手柄的输入不是按钮式的，这时就不能配置到Button里面，而是要配置到这里。可以理解为实际的操作轴</td></tr><tr><td>Joy Num</td><td>当有多个控制器时，要填写控制器的编号</td></tr></tbody></table><p>上表中的Gravity、Dead 等属性需要解释一下。</p><h3 id="2-2-1-Gravity"><a href="#2-2-1-Gravity" class="headerlink" title="2.2.1 Gravity"></a>2.2.1 Gravity</h3><p>现代游戏的方向输入和早期游戏的方向输入不太一样。<br>早期游戏中，上、中、下都是离散的状态，可以直接用1、0、-1来表示。<br>而现代游戏输入往往具有中间状态，比如0、0.35、 0.5、0.7、1, 是带有多级梯度的。<br>比如轻推摇杆代表走路，推到底就是跑步。<br>所以现代游戏的输入默认都是采用多梯度的模式。</p><p>虽然键盘没有多级输入的功能，但Unity依然会模拟这个功能，也就是说当你按住W键时，这个轴的值会以很快的速度逐渐从0增加到1。</p><p>所以，上表中Gravity和Sensitivity的含义就不难理解了，它们影响着虚拟轴从1到0、从0到1的速度以及敏感度。</p><blockquote><p>具体调试方法这里不再介绍，建议使用默认值</p></blockquote><h3 id="2-2-2-Dead"><a href="#2-2-2-Dead" class="headerlink" title="2.2.2 Dead"></a>2.2.2 Dead</h3><p>还有死区需要单独说明。</p><p>由于实体手柄、摇杆会有一些误差，比如，手柄放着不动时，某些手柄的输出值可能会在0.05 和0.08之间浮动。这个误差有必要在程序中排除。<br>所以Unity设计了死区的功能，在该值范围内的抖动被忽略为0,这样就可以过滤掉输入设备的误差。</p><h2 id="2-3-在脚本中处理输入"><a href="#2-3-在脚本中处理输入" class="headerlink" title="2.3 在脚本中处理输入"></a>2.3 在脚本中处理输入</h2><p>读取输入轴的方法很简单，代码如下:</p><p><code>float value = Input.GetAxis (&quot;Horizontal&quot;);</code></p><p>得到的值的范围为-1~1,默认位置为0。<br>这个读取虚拟轴的方法与具体控制器是键盘还是手柄无关。</p><blockquote><p>如果用鼠标控制虚拟轴，就有可能由于移动过快导致值超出-1~1的范围。</p></blockquote><blockquote><p>注意:<br>可以创建多个相同名字的虚拟轴。<br>Unity 可以同时管理多个同名的轴，最终结果以变化最大的轴为准。<br>这样做的原因是很多游戏可以同时用多种设备进行操作。<br>比如PC游戏可以用键盘、鼠标或手柄进行操作，手机游戏可以用重力感应器或手柄进行操作。<br>这种设计有助于用户在多种操作设备之间切换，且在脚本中不用去关心这一点。</p></blockquote><h2 id="2-4-按键名称"><a href="#2-4-按键名称" class="headerlink" title="2.4 按键名称"></a>2.4 按键名称</h2><p>要映射按键到轴上，需要在正方向输入框或者负方向输入框中输入正确的按键名称。<br>按键名称的规则和例子如下。</p><ul><li><p>常规按键: A、B、……</p></li><li><p>数字键: 1、2、……</p></li><li><p>方向键: Up、 Down、 Left、 Right…..</p></li><li><p>小键盘键: [1]、 [2]、 [3]、 [+]、 [equals]…..</p></li><li><p>修饰键: Right+Shift、 Lef+Shift、Right+Ctrl、Left+Ctrl、Right+Alt、Left+Alt、Right+Cmd、Left+Cmd….</p></li><li><p>鼠标按钮: mouse 0、mouse 1、mouse2 …..</p></li><li><p>手柄按钮(不指定具体的手柄序号) : joystick button 0、joystick button 1…..</p></li><li><p>手柄按钮(指定具体的手柄序号): joystick 1 button 0、joystick 1 button 1……</p></li><li><p>特殊键: Backspace、 Tab、 Retur、 Escape、 Space、 Delete、 Enter、 Insert、 Home、Page Up…..</p></li><li><p>功能键: FI、F2、…..</p><blockquote><p>可以使用<strong>KeyCode枚举类</strong>型来指定案件，与用字符串的效果一致</p></blockquote></li></ul><h1 id="3-在PC端输入"><a href="#3-在PC端输入" class="headerlink" title="3. 在PC端输入"></a>3. 在PC端输入</h1><p>unity为开发者提供了input库，来支持键盘事件，鼠标事件以及触摸事件。</p><h2 id="3-1-键盘事件"><a href="#3-1-键盘事件" class="headerlink" title="3.1 键盘事件"></a>3.1 键盘事件</h2><p>一般的PC键盘有104个不同的按键，在程序中通过监听这些按键事件，从而进一步执行逻辑操作。<br>如：射击游戏中，W表示前进，S表示后退，A表示左移，D表示右移。</p><h3 id="3-1-1-按下事件"><a href="#3-1-1-按下事件" class="headerlink" title="3.1.1 按下事件"></a>3.1.1 按下事件</h3><p>在脚本中，用<strong>input.GetKeyDown( )方法</strong>将按键值作为参数，监听此按键是否被按下。<br>按下返回true，否者返回false。</p><p>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了W键&quot;</span>);  <br>            &#125;  <br><span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;您按下了空格键&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-2-抬起事件"><a href="#3-1-2-抬起事件" class="headerlink" title="3.1.2 抬起事件"></a>3.1.2 抬起事件</h3><p>抬起事件完全依赖于按下事件，因为只有按下才有抬起。</p><p>我们用<strong>Input.GetKeyUp( )方法</strong>监听抬起事件<br>按键抬起后，返回true，否则返回false。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.W))  <br>           &#123;  <br>               Debug.Log(<span class="hljs-string">&quot;您抬起了W键&quot;</span>);  <br>           &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-3-长按事件"><a href="#3-1-3-长按事件" class="headerlink" title="3.1.3 长按事件"></a>3.1.3 长按事件</h3><p>长按事件是监听某一按键是否处于一直按下的状态<br>通过**Input.GetKey( )**来判断键盘中某一按键是否被一直按着。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span> (Input.GetKey (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//记录按下的帧数  </span><br>                keyFrame++;  <br>                Debug.Log(<span class="hljs-string">&quot;A连按:&quot;</span> + keyFrame+<span class="hljs-string">&quot;帧&quot;</span>);  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyUp (KeyCode.A))  <br>            &#123;  <br>                <span class="hljs-comment">//抬起后清空帧数  </span><br>                keyFrame=<span class="hljs-number">0</span>;  <br>                Debug.Log(<span class="hljs-string">&quot;A按键抬起&quot;</span>);  <br>            &#125;     <br></code></pre></td></tr></table></figure><h3 id="3-1-4-任意键事件"><a href="#3-1-4-任意键事件" class="headerlink" title="3.1.4 任意键事件"></a>3.1.4 任意键事件</h3><p>在程序中还可以监听按键中的任意按键是否被按下</p><p>常见于加载完游戏后，按任意键进入。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">if</span>(Input.anyKeyDown)  <br>            &#123;  <br>                Debug.Log(<span class="hljs-string">&quot;任意键被按下&quot;</span>);  <br>            &#125;  <br></code></pre></td></tr></table></figure><h3 id="3-1-4实例——组合按键"><a href="#3-1-4实例——组合按键" class="headerlink" title="3.1.4实例——组合按键"></a>3.1.4实例——组合按键</h3><p>在经典的格斗游戏中，会有组合键发出牛逼的大招，而这个功能的事件思路其实不难：<br>在玩家按下某一键后，便开始时间记数，在某一时间内按出所需要的键便发出大招。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs c#">    <span class="hljs-keyword">using</span> UnityEngine;  <br>    <span class="hljs-keyword">using</span> System.Collections.Generic;  <br>    <span class="hljs-keyword">using</span> System;  <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Script_07_05</span> : <span class="hljs-title">MonoBehaviour</span>   <br>    &#123;  <br>        <span class="hljs-comment">//方向键上的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageUp;  <br>        <span class="hljs-comment">//方向键下的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageDown;  <br>        <span class="hljs-comment">//方向键左的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageLeft;  <br>        <span class="hljs-comment">//方向键右的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageRight;  <br>        <span class="hljs-comment">//按键成功的贴图  </span><br>        <span class="hljs-keyword">public</span> Texture imageSuccess; <br>        <br>        <span class="hljs-comment">//自定义方向键的储存值  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_UP = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_DOWN = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_LEFT = <span class="hljs-number">2</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_RIGHT = <span class="hljs-number">3</span>;  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> KEY_FIRT = <span class="hljs-number">4</span>;  <br>        <br>        <span class="hljs-comment">//连续按键的事件限制  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> FRAME_COUNT = <span class="hljs-number">100</span>;  <br><br>        <span class="hljs-comment">//仓库中储存技能的数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_SIZE = <span class="hljs-number">3</span>;  <br><br>        <span class="hljs-comment">//每组技能的按键数量  </span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> SAMPLE_COUNT = <span class="hljs-number">5</span>;  <br><br>        <span class="hljs-comment">//技能仓库  </span><br>        <span class="hljs-built_in">int</span>[,] Sample =   <br>        &#123;  <br>            <span class="hljs-comment">//下 + 前 + 下 + 前 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_RIGHT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 前 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_RIGHT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>            <span class="hljs-comment">//下 + 后 + 下 + 后 + 拳  </span><br>            &#123;KEY_DOWN,KEY_LEFT,KEY_DOWN,KEY_LEFT,KEY_FIRT&#125;,  <br>        &#125;;  <br>        <span class="hljs-comment">//记录当前按下按键的键值  </span><br>        <span class="hljs-built_in">int</span>  currentkeyCode =<span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//标志是否开启监听按键  </span><br>        <span class="hljs-built_in">bool</span> startFrame = <span class="hljs-literal">false</span>;  <br>        <span class="hljs-comment">//记录当前开启监听到现在的时间  </span><br>        <span class="hljs-built_in">int</span>  currentFrame = <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">//保存一段时间内玩家输入的按键组合  </span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; playerSample;  <br>        <span class="hljs-comment">//标志完成操作  </span><br>        <span class="hljs-built_in">bool</span> isSuccess= <span class="hljs-literal">false</span>;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//初始话按键组合链表  </span><br>            playerSample  = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();  <br>        &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>(<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获得按键组合链表中储存按键的数量  </span><br>            <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>            <span class="hljs-comment">//遍历该按键组合链表  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; size; i++)  <br>            &#123;  <br>                <span class="hljs-comment">//将按下按键对应的图片显示在屏幕中  </span><br>                <span class="hljs-built_in">int</span> key = playerSample[i];  <br>                Texture temp = <span class="hljs-literal">null</span>;  <br>                <span class="hljs-keyword">switch</span>(key)  <br>                &#123;  <br>                    <span class="hljs-keyword">case</span> KEY_UP:  <br>                        temp = imageUp;  <br>                        <span class="hljs-keyword">break</span>;  <br>                    <span class="hljs-keyword">case</span> KEY_DOWN:<br>                        temp = imageDown;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_LEFT:<br>                        temp = imageLeft;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> KEY_RIGHT:<br>                        temp = imageRight;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp != <span class="hljs-literal">null</span>)  <br>                &#123;<br>                    GUILayout.Label(temp);  <br>                &#125;  <br>            &#125;<br>            <span class="hljs-keyword">if</span>(isSuccess)<br>            &#123;<br>                <span class="hljs-comment">//显示成功贴图</span><br>                GUILayout.Label(imageSuccess);<br>            &#125;<br>            <span class="hljs-comment">//默认提示信息</span><br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键1：下、前、下、前、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、前、下、后、拳&quot;</span>);<br>            GUILayout.Label(<span class="hljs-string">&quot;连续组合按键2：下、后、下、后、拳&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-comment">//更新按键</span><br>            UpdateKey();<br>            <span class="hljs-keyword">if</span>(Input.anyKeyDown)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(isSuccess)<br>                &#123;<br>                    <span class="hljs-comment">//按键成功后重置</span><br>                    isSuccess = <span class="hljs-literal">false</span>;<br>                    Reset();<br>                &#125;<br>                <span class="hljs-keyword">if</span>(!startFrame)<br>                &#123;<br>                    <span class="hljs-comment">//启动时间计数器</span><br>                    startFrame = <span class="hljs-literal">true</span>;<br>                &#125;  <br>                <span class="hljs-comment">//将按键值添加如链表中  </span><br>                playerSample.Add(currentkeyCode);  <br>                <span class="hljs-comment">//遍历链表  </span><br>                <span class="hljs-built_in">int</span> size = playerSample.Count;  <br>                <span class="hljs-keyword">if</span>(size == SAMPLE_COUNT)  <br>                &#123;  <br>                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt; SAMPLE_SIZE; i++)  <br>                    &#123;  <br>                        <span class="hljs-built_in">int</span> SuccessCount = <span class="hljs-number">0</span>;  <br>                        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j&lt; SAMPLE_COUNT; j++)  <br>                        &#123;  <br>                            <span class="hljs-built_in">int</span> temp = playerSample[j];  <br>                            <span class="hljs-keyword">if</span>(temp== Sample[i,j])<br>                            &#123;  <br>                                SuccessCount++;  <br>                            &#125;  <br>                        &#125;  <br><span class="hljs-comment">//玩家按下的组合按键与仓库中的按键组合相同表示释放技能成功</span><br>                        <span class="hljs-keyword">if</span>(SuccessCount ==SAMPLE_COUNT)  <br>                        &#123;  <br>                            isSuccess = <span class="hljs-literal">true</span>;  <br>                            <span class="hljs-keyword">break</span>;  <br>                        &#125;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(startFrame)  <br>            &#123;  <br>                <span class="hljs-comment">//计数器++  </span><br>                currentFrame++;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(currentFrame &gt;= FRAME_COUNT)  <br>            &#123; <br>                <span class="hljs-comment">//计数器超时  </span><br>                <span class="hljs-keyword">if</span>(!isSuccess)  <br>                &#123;  <br>                    Reset();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>         <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span> (<span class="hljs-params"></span>)  </span><br><span class="hljs-function"></span>         &#123;  <br>            <span class="hljs-comment">//重置按键相关信息  </span><br>            currentFrame = <span class="hljs-number">0</span>;  <br>            startFrame = <span class="hljs-literal">false</span>;  <br>            playerSample.Clear();  <br>         &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateKey</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>        &#123;  <br>            <span class="hljs-comment">//获取当前键盘的按键信息  </span><br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.W))  <br>            &#123;  <br>                currentkeyCode = KEY_UP;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.S))  <br>            &#123;  <br>                currentkeyCode = KEY_DOWN;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.A))  <br>            &#123;  <br>                currentkeyCode = KEY_LEFT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.D))  <br>            &#123;  <br>                currentkeyCode = KEY_RIGHT;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (Input.GetKeyDown (KeyCode.Space))  <br>            &#123;  <br>               currentkeyCode = KEY_FIRT;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>按s,d,s,d,空格：<img src="./images/Unity-%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/20160426162352358.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="3-2-鼠标事件"><a href="#3-2-鼠标事件" class="headerlink" title="3.2 鼠标事件"></a>3.2 鼠标事件</h2><p>和键盘事件一样，鼠标一般只有3个按键，左键、右键和中键。</p><p>具体如下：</p><h3 id="3-2-1-按下事件"><a href="#3-2-1-按下事件" class="headerlink" title="3.2.1 按下事件"></a>3.2.1 按下事件</h3><p><code>Input.GetMouseButtonDown()</code><br>来判断鼠标哪个按键被按下：</p><ul><li>返回值为0代表鼠标左键被按下</li><li>返回值为1代表鼠标右键被按下</li><li>返回值为2代表鼠标中键被按下</li></ul><h3 id="3-2-2-抬起事件"><a href="#3-2-2-抬起事件" class="headerlink" title="3.2.2 抬起事件"></a>3.2.2 抬起事件</h3><p><code>Input.GetMouseButtonUp()</code><br>方法监听鼠标按键的抬起事件</p><h3 id="3-2-3-长按事件"><a href="#3-2-3-长按事件" class="headerlink" title="3.2.3 长按事件"></a>3.2.3 长按事件</h3><p><code>Input.GetMouseButton()</code></p><p>监听鼠标某个按键是否一直处于按下状态</p><h1 id="4-在移动端输入"><a href="#4-在移动端输入" class="headerlink" title="4. 在移动端输入"></a>4. 在移动端输入</h1><p>对于移动设备来说，Ioput类还提供了触屏、加速度计以及访问地理位置的功能。<br>此外，移动设备上还经常会用到虚拟键盘，即在屏幕上操作的键盘，Uity中也有相应的访问方法。</p><p>本小节专门讨论移动设备特有的输入方式。</p><h2 id="4-1-多点触摸"><a href="#4-1-多点触摸" class="headerlink" title="4.1 多点触摸"></a>4.1 多点触摸</h2><p>iPhone、iPad、安卓等设备提供同时捕捉多个手指触摸操作的功能，通常可以处理最多5根手指同时触摸屏幕的情况。<br>通过访问Input.touches属性，可以以数组的方式处理多个手指当前的位置等信息。</p><p>安卓设备上多点触摸的规范相对灵活，不同的设备能捕捉的多点触摸操作的数量不尽相同。</p><ul><li><p>较老的设备可能只支持1到2个点同时触摸</p></li><li><p>新设备可能会支持5个点同时触摸</p></li></ul><p>每一个手指的触摸信息以Input.Touch结构体来表示。<br><strong>Input.Touch的属性列表：</strong></p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>fingerld</td><td>该触摸的序号</td></tr><tr><td>position</td><td>触摸在屏幕上的位置</td></tr><tr><td>dcllaPosition</td><td>当前触摸位置和前一个触摸位置的差距</td></tr><tr><td>doltaTime</td><td>最近两次改变触摸位置之间的操作时间的间隔</td></tr><tr><td>tapCount</td><td>IPhone/Ipad设备会记录用户短时间内单击屏幕的次数，它表示用户多次单击操作且没有将手拿开的次数。安卓设备没有这个功能，该值保持为1</td></tr><tr><td>phase</td><td>触摸的阶段。可以用它来判断是刚开始触摸、触摸时移动，还是手指刚刚离开屏幕</td></tr></tbody></table><p>phase的取值是个枚举，枚举值如下：</p><ul><li>Began<br>手指刚接触到屏幕</li><li>Moved<br>手指在屏幕上滑动</li><li>Stationary<br>手指接触到屏幕但还未滑动</li><li>Ended<br>手指离开了屏幕。<br>这个状态代表着一次触摸操作的结束</li><li>Cancceled<br>系统取滑了这次触屏操作。<br>例如当用户拿起手机进行通话，或者触损点多于9个的时候，这次触摸操作就会被取消。<br>这个状态也代表这次触摸操作结束</li></ul><h2 id="4-2-模拟鼠标操作"><a href="#4-2-模拟鼠标操作" class="headerlink" title="4.2 模拟鼠标操作"></a>4.2 模拟鼠标操作</h2><p>绝大部分移动设备可以用触屏模拟鼠标操作。<br>比如使用Input.mousePosition属性不仅可以获得鼠标光标的位置，也可以获得移动设备上触摸的位置。<br>这个功能的原理不难理解，毕竟触屏可以支持多点触摸，而鼠标则是单点操作，这个功能属于向下兼容。</p><p>在移动平台的游戏的开发阶段可以暂时用鼠标操作代替触屏操作，但是稍后应当修改为触屏专用的方式，因为操作手感和功能会有很大区别。</p><h2 id="4-3-加速度计"><a href="#4-3-加速度计" class="headerlink" title="4.3 加速度计"></a>4.3 加速度计</h2><p>当移动设备移动时，内置的加速度计会持续报告当前加速度的值，这个值是一个三维向量，因为物体的运动是任意方向的。<br>这个数值和重力加速度的表示方法类似：</p><ul><li><p>在某个轴方向上，1.0代表该轴具有+1.0g的加速度</p></li><li><p>而负值则代表该轴具有相反方向的加速度。</p></li></ul><p>正常竖直持手机(Home键在下方)时：</p><ul><li><p>X轴的正方向朝右</p></li><li><p>Y轴的正方向朝上</p></li><li><p>Z轴的正方向从手机指向用户</p></li></ul><p>通过Input.aceleation属性可以直接访问加速度计当前的数值。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>总结</tag>
      
      <tag>输入操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>观察者模式是一种对象行为模式。<br>在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。</p><p>它定义对象间的一种一对多的依赖关系：<br>当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>主体是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅并接收通知。</p><p>观察者模式（Observer）完美的将观察者和被观察的对象分离开。<br>观察者模式被广泛应用于软件界面元素之间的交互，在业务对象之间的交互、权限管理等方面。</p><blockquote><p>此种模式通常被用来实现事件处理系统</p></blockquote><p>别名：</p><ul><li>发布-订阅(Publish/Subscribe)模式</li><li>模型-视图(Model/View)模式</li><li>源-监听器(Source/Listener)模式</li><li>从属者(Dependents)模式</li></ul><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>交互对象之间尽量采用低耦合设计</li><li>封装代码中经常变化的数据</li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/3985563-8f775c097136a39d.png" srcset="/img/loading.gif" alt="img"></p><p>观察者模式所涉及的角色有：</p><ul><li><p><strong>抽象主题(Subject)角色：</strong><br>抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。<br>抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。</p></li><li><p><strong>具体主题(ConcreteSubject)角色：</strong><br>将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。<br>具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p></li><li><p><strong>抽象观察者(Observer)角色：</strong><br>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p></li><li><p><strong>具体观察者(ConcreteObserver)角色：</strong><br>存储与主题的状态自恰的状态。<br>具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。<br>如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p></li></ul><h1 id="4-推模型与拉模型"><a href="#4-推模型与拉模型" class="headerlink" title="4. 推模型与拉模型"></a>4. 推模型与拉模型</h1><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><h2 id="4-1-推模型"><a href="#4-1-推模型" class="headerlink" title="4.1 推模型"></a>4.1 推模型</h2><p>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</p><h2 id="4-2-拉模型"><a href="#4-2-拉模型" class="headerlink" title="4.2 拉模型"></a>4.2 拉模型</h2><p>主题对象在通知观察者的时候，只传递少量信息。<br>如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。</p><p>一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</p><h2 id="4-3-二者比较"><a href="#4-3-二者比较" class="headerlink" title="4.3 二者比较"></a>4.3 二者比较</h2><ul><li><ul><li><p>推模型是假定主题对象知道观察者需要的数据</p></li><li><p>拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值</p></li></ul></li><li><ul><li><p>推模型可能会使得观察者对象难以复用<br>因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况<br>这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者</p></li><li><p>拉模型就不会造成这样的情况<br>因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。</p></li></ul></li></ul><h1 id="5-模式案例"><a href="#5-模式案例" class="headerlink" title="5. 模式案例"></a>5. 模式案例</h1><h2 id="5-1-案例描述"><a href="#5-1-案例描述" class="headerlink" title="5.1 案例描述"></a>5.1 案例描述</h2><p>你将设计一个气象监测应用，它要求具备以下几个功能：</p><ul><li><p>可以从气象站更新：温度，湿度，气压三项数据</p></li><li><p>可以给用户用多种视图展示数据：<br>初始三种视图：目前状况，天气统计，天气预报<br>可以随时增加新的视图</p></li><li><p>用户视图更新有两种方式：</p><ul><li><p>系统按事件自动更新数据同时更新视图</p></li><li><p>用户主动请求更新数据与视图</p></li></ul><h2 id="5-2-案例分析"><a href="#5-2-案例分析" class="headerlink" title="5.2 案例分析"></a>5.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%A4%A9%E6%B0%94%E7%9B%91%E6%B5%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="天气监测应用设计类图"></p></li></ul><p>从上图可以分析出各个类在观察者模式中他们的角色：</p><ul><li><p>抽象主题(Subject)角色：Subject</p></li><li><p>具体主题(ConcreteSubject)角色：WeatherData</p></li><li><p>抽象观察者(Observer)角色：Observer</p></li><li><p>具体观察者(ConcreteObserver)角色：StatisticsDisplay;ThirdPartDisplay;ForecastDisplay;</p></li></ul><h2 id="5-3-代码编写"><a href="#5-3-代码编写" class="headerlink" title="5.3 代码编写"></a>5.3 代码编写</h2><h3 id="5-3-1-抽象主题编写"><a href="#5-3-1-抽象主题编写" class="headerlink" title="5.3.1 抽象主题编写"></a>5.3.1 抽象主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//添加观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>;<span class="hljs-comment">//移除观察者订阅</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//广播</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-抽象观察者编写"><a href="#5-3-2-抽象观察者编写" class="headerlink" title="5.3.2 抽象观察者编写"></a>5.3.2 抽象观察者编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span>;<span class="hljs-comment">//广播更新的数据(推模型)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-comment">//观察者申请数据更新(拉模型)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-具体主题编写"><a href="#5-3-3-具体主题编写" class="headerlink" title="5.3.3 具体主题编写"></a>5.3.3 具体主题编写</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeatherData</span>:<span class="hljs-title">Subject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Data<br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> temperature;<span class="hljs-comment">//温度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> humidity;<span class="hljs-comment">//湿度</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> pressure;<span class="hljs-comment">//气压</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> Data data;<br>    List&lt;Observer&gt; listeners;<span class="hljs-comment">//订阅的观察者名单</span><br>    <span class="hljs-keyword">public</span> Data Datas &#123; <span class="hljs-keyword">get</span> =&gt; data;&#125;<span class="hljs-comment">//用于实现拉模式的get属性</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherData</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123; <br>        listeners = <span class="hljs-keyword">new</span> List&lt;Observer&gt;();<br>        measurementsChanged();<br>        data = <span class="hljs-keyword">new</span> Data();<br>    &#125;<br>    <span class="hljs-comment">//对Subject接口的实现</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Add(a);<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span>(<span class="hljs-params">Observer a</span>)</span>=&gt; listeners.Remove(a);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">foreach</span>(Observer i <span class="hljs-keyword">in</span> listeners)<br>        &#123;<br>            i.update(data);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//更新天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        getRandomDate();<br>        notifyObserver();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRandomDate</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//随机产生天气数据</span></span><br><span class="hljs-function"></span>    &#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        data.humidity = random.NextDouble();<br>      data.temperature=random.Next(<span class="hljs-number">-40</span>,<span class="hljs-number">40</span>)+random.NextDouble();<br>        data.pressure = random.Next(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)+random.NextDouble();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-4-具体观察者编写"><a href="#5-3-4-具体观察者编写" class="headerlink" title="5.3.4 具体观察者编写"></a>5.3.4 具体观察者编写</h3><p>显示模式的接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">DisplayElement</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>三种显示模式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CurrentConditionsDisplay</span>:<span class="hljs-title">Observer</span>,<span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示当前观测值</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    <span class="hljs-keyword">private</span> Data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CurrentConditionsDisplay</span>(<span class="hljs-params">Subject x</span>) </span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = x; <br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;---当前天气---&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;当前温度:&quot;</span> + d.temperature.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前气压:&quot;</span> <br>        + d.pressure.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t当前湿度:&quot;</span>+d.humidity.ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StatisticsDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示统计最大最小平均值</span><br>&#123;<br>    Subject weatherData;<br>    <span class="hljs-keyword">private</span> Queue&lt;Data&gt; dates;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StatisticsDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>        dates = <span class="hljs-keyword">new</span> Queue&lt;Data&gt;();<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span>(dates.Count== <span class="hljs-number">3</span>)dates.Dequeue();<br>        dates.Enqueue(x);<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span>=&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Double[] average = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">foreach</span> (Data i <span class="hljs-keyword">in</span> dates)<br>        &#123;<br>            average[<span class="hljs-number">0</span>] += i.temperature;<br>            average[<span class="hljs-number">1</span>] += i.pressure;<br>            average[<span class="hljs-number">2</span>] += i.humidity;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;***天气统计***&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;最高温度:&quot;</span> + dates.Max(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低温度:&quot;</span> + dates.Min(x =&gt; x.temperature).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均温度:&quot;</span> +<br>        (average[<span class="hljs-number">0</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高气压:&quot;</span> + dates.Max(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <br>        <span class="hljs-string">&quot;\t最低气压:&quot;</span> + dates.Min(x =&gt; x.pressure).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均气压:&quot;</span> +<br>        (average[<span class="hljs-number">1</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>));<br>        <br>        Console.WriteLine(<span class="hljs-string">&quot;最高湿度:&quot;</span> + dates.Max(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) +<br>        <span class="hljs-string">&quot;\t最低湿度:&quot;</span> + dates.Min(x =&gt; x.humidity).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\t平均湿度:&quot;</span> +<br>        (average[<span class="hljs-number">2</span>] / dates.Count).ToString(<span class="hljs-string">&quot;F2&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ForecastDisplay</span> : <span class="hljs-title">Observer</span>, <span class="hljs-title">DisplayElement</span><span class="hljs-comment">//显示天气预报</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    Data d;<br>    String weather;<br>    <span class="hljs-built_in">double</span> t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForecastDisplay</span>(<span class="hljs-params">Subject x</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        weatherData = x;<br>        weatherData.registerObserver(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-comment">//实现接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data data</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        d = data;<br>        <span class="hljs-keyword">if</span> (d.humidity &gt; <span class="hljs-number">0.5</span> &amp;&amp; d.pressure &gt; <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(d.temperature&lt;<span class="hljs-number">1</span>) weather = <span class="hljs-string">&quot;雪&quot;</span>;<br>                <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;雨&quot;</span>;<br>            &#125;<br>        <span class="hljs-keyword">else</span> weather = <span class="hljs-string">&quot;晴&quot;</span>;<br>        t = d.temperature;<br>        display();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pulldate</span>(<span class="hljs-params"></span>)</span> =&gt; update(((WeatherData)weatherData).Datas);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;===天气预报===&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;今日天气:&quot;</span> + weather + <span class="hljs-string">&quot;\t 温度:&quot;</span> + t.ToString(<span class="hljs-string">&quot;F2&quot;</span>)+<span class="hljs-string">&quot;\n&quot;</span>); ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-5-测试"><a href="#5-3-5-测试" class="headerlink" title="5.3.5 测试"></a>5.3.5 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    WeatherData weatherData = <span class="hljs-keyword">new</span> WeatherData();<br>    CurrentConditionsDisplay s1 = <span class="hljs-keyword">new</span> CurrentConditionsDisplay(weatherData);<br>    StatisticsDisplay s2 = <span class="hljs-keyword">new</span> StatisticsDisplay(weatherData);<br>    ForecastDisplay s3 = <span class="hljs-keyword">new</span> ForecastDisplay(weatherData);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>    &#123;<br>        weatherData.measurementsChanged();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210325114238949.png" srcset="/img/loading.gif" alt="测试结果"></p><h1 id="6-java中的观察者模式类"><a href="#6-java中的观察者模式类" class="headerlink" title="6. java中的观察者模式类"></a>6. java中的观察者模式类</h1><blockquote><p>略 <a href="https://www.jianshu.com/p/fc4554cda68d">https://www.jianshu.com/p/fc4554cda68d</a></p></blockquote><h1 id="8-C-中实现观察者模式的方法"><a href="#8-C-中实现观察者模式的方法" class="headerlink" title="8. C#中实现观察者模式的方法"></a>8. C#中实现观察者模式的方法</h1><p>整理自：<a href="https://www.jb51.net/article/63077.htm">https://www.jb51.net/article/63077.htm</a></p><h2 id="8-1-利用事件"><a href="#8-1-利用事件" class="headerlink" title="8.1 利用事件"></a>8.1 利用事件</h2><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a></p></blockquote><p>我们将上面讲的天气数据监测应用改成用C#事件实现的观察者模式</p><ol><li><p>在WeatherData类中声明委托与事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WeatherdateUpdate</span>(<span class="hljs-params">Data data</span>)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> WeatherdateUpdate updata;<br></code></pre></td></tr></table></figure></li><li><p>在WeatherData类中编写事件触发函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyByEvent</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            <span class="hljs-keyword">if</span>(updata!=<span class="hljs-literal">null</span>)<br>            &#123;<br>                updata(data);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>在三个具体观察者中编写事件处理函数并在构造函数中订阅到事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//写在构造函数里</span><br>WeatherData.updata += update;<span class="hljs-comment">//事件订阅</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span>(<span class="hljs-params">Data x</span>)<span class="hljs-comment">//事件处理</span></span><br><span class="hljs-function"></span>        &#123;<br>            d = x; <br>            display();<br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>触发事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measurementsChanged</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>        &#123;<br>            getRandomDate();<br>            <span class="hljs-comment">//notifyObserver();</span><br>            notifyByEvent();<br>        &#125;<br></code></pre></td></tr></table></figure><p>运行输出结果与用接口实现的效果完全相同。</p></li></ol><h2 id="8-2-利用IObservable和IObserver实现"><a href="#8-2-利用IObservable和IObserver实现" class="headerlink" title="8.2 利用IObservable和IObserver实现"></a>8.2 利用IObservable<out T>和IObserver<in T>实现</h2><p>与java中类似，略</p><h2 id="8-3-利用Action函数式"><a href="#8-3-利用Action函数式" class="headerlink" title="8.3 利用Action函数式"></a>8.3 利用Action函数式</h2><p>略</p><h1 id="7-优缺点"><a href="#7-优缺点" class="headerlink" title="7. 优缺点"></a>7. 优缺点</h1><h2 id="7-1-优点"><a href="#7-1-优点" class="headerlink" title="7.1 优点"></a>7.1 优点</h2><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。</li><li>目标与观察者之间建立了一套触发机制。</li></ul><h2 id="7-2-缺点"><a href="#7-2-缺点" class="headerlink" title="7.2 缺点"></a>7.2 缺点</h2><ul><li><p>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</p></li><li><p>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>策略模式属于对象的行为模式。<br>其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。<br>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><ul><li><h1 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h1><ul><li>找出项目中不稳定的代码（可能需要改动的地方），把它们独立出来，不要把它们和其它稳定的代码混在一起</li><li>针对接口编程而不是针对实现编程</li><li>多用组合少用继承</li></ul></li></ul><h1 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h1><p>策略模式是对算法的包装，是把调用算法的责任（行为）和算法本身（行为实现）分割开来，委派给不同的对象管理。</p><p>策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-b97fa59581b3c88c.png" srcset="/img/loading.gif" alt="img"></p><p>这个模式涉及到三个角色：</p><ul><li>环境(Context)角色：<br>持有一个Strategy的引用，即具有复杂多变行为的对象。</li><li>抽象策略(Strategy)角色：<br>这是一个抽象角色，通常由一个接口或抽象类实现。<br>此角色给出所有的具体策略类所需的接口。</li><li>具体策略(ConcreteStrategy)角色：<br>包装了相关的算法或行为。</li></ul><h1 id="4-模式案例"><a href="#4-模式案例" class="headerlink" title="4. 模式案例"></a>4. 模式案例</h1><h2 id="4-1-案例描述"><a href="#4-1-案例描述" class="headerlink" title="4.1 案例描述"></a>4.1 案例描述</h2><p>你将设计一个ARPG文字冒险小游戏，你需要设计以下内容：</p><ul><li>四个角色：<br>女王Queen；国王King；骑士Knight；巨魔Troll；</li><li>四种武器：<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；</li></ul><p>每个角色一次只能使用一种武器，但是在游戏的过程中可以切换武器。</p><p>让他们相互攻击，直到有人胜出。</p><h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/423180E36C6DA4925016AA187CA09C05-1616508222683.jpg" srcset="/img/loading.gif" alt="423180E36C6DA4925016AA187CA09C05"></p><p>由上图可以看出类的结构为<br>女王Queen；国王King；骑士Knight；巨魔Troll；继承于Character。<br>匕首Knife；弓箭BowAndArrow；斧头Axe；直剑Sword；实现了WeaponBehavior接口。</p><p>由此可以分析出在策略模式中他们的角色：</p><ul><li>环境(Context)角色：Character</li><li>抽象策略(Strategy)角色：WeaponBehavior</li><li>具体策略(ConcreteStrategy)角色：<br>KnifeBehavior，BowAndArrowBehavior，AxeBehavior，SwordBehavior</li></ul><h2 id="4-3-代码编写"><a href="#4-3-代码编写" class="headerlink" title="4.3 代码编写"></a>4.3 代码编写</h2><h3 id="4-3-1-环境角色编写"><a href="#4-3-1-环境角色编写" class="headerlink" title="4.3.1 环境角色编写"></a>4.3.1 环境角色编写</h3><p>编写所有角色的基类Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> hp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> energy;<br>    WeaponBehavior weapon;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span> =&gt; name; <span class="hljs-keyword">set</span> =&gt; name = <span class="hljs-keyword">value</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Hp &#123; <span class="hljs-keyword">get</span> =&gt; hp; <span class="hljs-keyword">set</span> =&gt; hp = <span class="hljs-keyword">value</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Energy &#123; <span class="hljs-keyword">get</span> =&gt; energy; <span class="hljs-keyword">set</span> =&gt; energy = <span class="hljs-keyword">value</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Character</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name,<span class="hljs-built_in">int</span> hp,<span class="hljs-built_in">int</span> energy</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.hp = hp;<br>        <span class="hljs-keyword">this</span>.energy = energy;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeapon</span>(<span class="hljs-params">WeaponBehavior weapon</span>)<span class="hljs-comment">//设置武器</span></span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">this</span>.weapon = weapon;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">fight</span>(<span class="hljs-params">Character A</span>)<span class="hljs-comment">//攻击！</span></span><br><span class="hljs-function"></span>    &#123;<br>        weapon.useWeapon(<span class="hljs-keyword">this</span>,A);<br>        <span class="hljs-keyword">if</span> (A.Hp &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(A.Name + <span class="hljs-string">&quot;被&quot;</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;杀死了&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showState</span>(<span class="hljs-params"></span>)<span class="hljs-comment">//显示状态</span></span><br><span class="hljs-function"></span>    &#123;<br>        Console.WriteLine(Name+<span class="hljs-string">&quot;:血量 &quot;</span>+ hp+<span class="hljs-string">&quot;精力 &quot;</span>+energy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写四种角色类继承Character：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Queen</span>:<span class="hljs-title">Character</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Queen</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">10</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> KnifeBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">King</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">King</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">5</span>, <span class="hljs-number">20</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Knight</span> : <span class="hljs-title">Character</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Knight</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">20</span>, <span class="hljs-number">10</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> SwordBehavior());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Troll</span> : <span class="hljs-title">Character</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Troll</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name, <span class="hljs-number">15</span>, <span class="hljs-number">15</span></span>)</span> =&gt; <span class="hljs-keyword">base</span>.setWeapon(<span class="hljs-keyword">new</span> AexBehavior());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-2-抽象策略角色编写"><a href="#4-3-2-抽象策略角色编写" class="headerlink" title="4.3.2 抽象策略角色编写"></a>4.3.2 抽象策略角色编写</h3><p>编写武器行为接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A,Character B</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-具体策略角色编写"><a href="#4-3-3-具体策略角色编写" class="headerlink" title="4.3.3 具体策略角色编写"></a>4.3.3 具体策略角色编写</h3><p>编写具体的武器行为，实现接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">KnifeBehavior</span>:<span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name+<span class="hljs-string">&quot;对&quot;</span>+B.Name+<span class="hljs-string">&quot;使用了 匕首 刺杀&quot;</span>);<br>        B.Hp--;<br>        A.Energy --;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BowandArrowBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;射了一箭&quot;</span>);<br>        B.Hp--;<br>        A.Energy--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AexBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 斧头 劈砍&quot;</span>);<br>        B.Hp-=<span class="hljs-number">3</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy-=<span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SwordBehavior</span> : <span class="hljs-title">WeaponBehavior</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useWeapon</span>(<span class="hljs-params">Character A, Character B</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">if</span> (A.Energy &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(A.Name + <span class="hljs-string">&quot;对&quot;</span> + B.Name + <span class="hljs-string">&quot;使用了 直剑 挥击&quot;</span>);<br>        B.Hp -= <span class="hljs-number">5</span>;<br>        B.Energy -= <span class="hljs-number">3</span>;<br>        A.Energy -= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-测试"><a href="#4-3-4-测试" class="headerlink" title="4.3.4 测试"></a>4.3.4 测试</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br><span class="hljs-function"></span>&#123;<br>    Random random = <span class="hljs-keyword">new</span> Random();<br>    List&lt;Character&gt; c = <span class="hljs-keyword">new</span> List&lt;Character&gt;(<span class="hljs-number">4</span>);<span class="hljs-comment">//将各种角色类都装箱成Character</span><br>    c.Add(<span class="hljs-keyword">new</span> King(<span class="hljs-string">&quot;大清皇帝&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Troll(<span class="hljs-string">&quot;林登万&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Knight(<span class="hljs-string">&quot;堂吉诃德&quot;</span>));<br>    c.Add(<span class="hljs-keyword">new</span> Queen(<span class="hljs-string">&quot;玛丽&quot;</span>));<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">while</span> (c.Count != <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">int</span> a, b;<br>        a = random.Next(<span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">//随机选取两人PK，直到剩下最后一位角色活着</span><br>        <span class="hljs-keyword">while</span> ((b = random.Next(<span class="hljs-number">0</span>, i)) == a)<br>        &#123;<br>            b = random.Next(<span class="hljs-number">0</span>, i);<br>        &#125;<br>        c[a].showState();<br>        c[b].showState();<br>        <span class="hljs-keyword">if</span> (c[a].fight(c[b]))<br>        &#123;<br>            c.RemoveAt(b);<br>            i--;<br>        &#125;<br>        Console.WriteLine(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//每回合恢复体力</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;c.Count;j++)<br>        &#123;<br>            c[j].Energy++;<br>        &#125;<br>    &#125;<br>    Console.WriteLine(<span class="hljs-string">&quot;胜者是:&quot;</span> + c[<span class="hljs-number">0</span>].Name + <span class="hljs-string">&quot;!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这次中世纪文字吃鸡的结果是：</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95.png" srcset="/img/loading.gif" alt="策略模式测试"></p><h1 id="5-对策略模式的深入认识"><a href="#5-对策略模式的深入认识" class="headerlink" title="5.对策略模式的深入认识"></a>5.对策略模式的深入认识</h1><h2 id="5-1-策略模式对多态的使用"><a href="#5-1-策略模式对多态的使用" class="headerlink" title="5.1 策略模式对多态的使用"></a>5.1 策略模式对多态的使用</h2><p> 　通过让环境类持有一个抽象策略类（超类）的引用，在生成环境类实例对象时，让该引用指向具体的策略子类。再对应的方法调用中，就会通过Java的多态，调用对应策略子类的方法。从而可以相互替换，不需要修改环境类内部的实现。同时，在有新的需求的情况下，也只需要修改策略类即可，降低与环境类之间的耦合度。</p><h2 id="5-2-策略模式的重心"><a href="#5-2-策略模式的重心" class="headerlink" title="5.2 策略模式的重心"></a>5.2 策略模式的重心</h2><p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p><h2 id="5-3算法的平等性"><a href="#5-3算法的平等性" class="headerlink" title="5.3算法的平等性"></a>5.3算法的平等性</h2><p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p><p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p><h2 id="5-4-运行时策略的唯一性"><a href="#5-4-运行时策略的唯一性" class="headerlink" title="5.4 运行时策略的唯一性"></a>5.4 运行时策略的唯一性</h2><p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p><h2 id="5-5-公有的行为"><a href="#5-5-公有的行为" class="headerlink" title="5.5 公有的行为"></a>5.5 公有的行为</h2><p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p><p>这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/3985563-398483227b01f042.png" srcset="/img/loading.gif" alt="img"></p><h1 id="6-策略模式的优缺点"><a href="#6-策略模式的优缺点" class="headerlink" title="6. 策略模式的优缺点"></a>6. 策略模式的优缺点</h1><h2 id="6-1-相较于纯继承的优点"><a href="#6-1-相较于纯继承的优点" class="headerlink" title="6.1 相较于纯继承的优点"></a>6.1 相较于纯继承的优点</h2><ul><li><p>代码复用度高，子类中几乎没有重复</p></li><li><p>很容易知道该类的全部策略（算法）</p></li><li><p>在运行时可以更容易的更改策略</p></li><li><p>改动时不会牵一发而动全身，代码耦合度低</p></li></ul><h2 id="6-2-策略模式的优点"><a href="#6-2-策略模式的优点" class="headerlink" title="6.2 策略模式的优点"></a>6.2 策略模式的优点</h2><ul><li>策略模式提供了管理相关的算法族的办法。<br>策略类的等级结构定义了一个算法或行为族。<br>恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</li><li>使用策略模式可以避免使用多重条件(if-else)语句。<br>多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</li></ul><h2 id="6-3策略模式的缺点"><a href="#6-3策略模式的缺点" class="headerlink" title="6.3策略模式的缺点"></a>6.3策略模式的缺点</h2><ul><li><p>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。<br>这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p></li><li><p>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p></li></ul><p>总结自：</p><ul><li>《设计模式HeadFirst》</li><li><a href="https://www.jianshu.com/p/7fa8ad000a97">https://www.jianshu.com/p/7fa8ad000a97</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的标签 层级 静态物体 预制体</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E6%A0%87%E7%AD%BE%20%E5%B1%82%E7%BA%A7%20%E9%9D%99%E6%80%81%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标签"><a href="#1-标签" class="headerlink" title="1. 标签"></a>1. 标签</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>标签(Tag)是一个可以标记在游戏物体上的记号，它一般是一个简单的单词。<br>比如：你可以为游戏人物添加一个Player标签，并为敌人角色添加一个Encemy 标签，还可以为地图上的道具添加一个Collectable标签。</p><p>在脚本中查找和指定物体时，使用标签是一种非常好的方法。<br>这种方法可以避免总是采用某个公开变量的方式来指定游戏物体，那样还需要通过拖曳的操作才能给变量赋初值。通过标签来查找物体可以简化编辑工作。</p><p>标签还特别适合用在处理碰撞的时候，当游戏人物与其他物体发生碰撞时，你可以通过判断碰到的物体是敌人、道具还是其他东西，来进行下一步处理。</p><h2 id="1-2-Unity预制标签"><a href="#1-2-Unity预制标签" class="headerlink" title="1.2. Unity预制标签"></a>1.2. Unity预制标签</h2><p>Uniy预置了一些常用的标签， 在标签管理器中你不能修改下面这些预置的标签：</p><table><thead><tr><th>标签名</th><th>含义</th></tr></thead><tbody><tr><td>Untagged</td><td>没有标签</td></tr><tr><td>Respawn</td><td>出生</td></tr><tr><td>Finish</td><td>完成</td></tr><tr><td>EditorOnly</td><td>编辑器专用</td></tr><tr><td>MainCamera</td><td>主摄像机</td></tr><tr><td>Player</td><td>玩家</td></tr><tr><td>GameController</td><td>游戏控制器</td></tr></tbody></table><h2 id="1-3-创建新标签"><a href="#1-3-创建新标签" class="headerlink" title="1.3. 创建新标签"></a>1.3. 创建新标签</h2><p>要创建一个新的标签，需要在标签下拉菜单中选择Add Tag,之后检视窗口会切换到标签与层级管理器(Tag and Layer Manager)。</p><blockquote><p>注意:标签一旦创建就不可以再被修改，只能删除并重新创建。</p></blockquote><h2 id="1-4-为物体设置标签"><a href="#1-4-为物体设置标签" class="headerlink" title="1.4. 为物体设置标签"></a>1.4. 为物体设置标签</h2><p>检视窗口的上方显示了标签(Tg)和层级(Layer) 的下拉菜单。</p><p>在标装的下技菜单中单击任意.个标签名称，就可以为物体指定该标签了</p><h2 id="1-5-使用标签查找游戏物体"><a href="#1-5-使用标签查找游戏物体" class="headerlink" title="1.5. 使用标签查找游戏物体"></a>1.5. 使用标签查找游戏物体</h2><blockquote><p>略，详见<a href="https://mycroftcooper.github.io/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/">在脚本中访问其他物体2.3</a></p></blockquote><h2 id="1-6-小提示"><a href="#1-6-小提示" class="headerlink" title="1.6. 小提示"></a>1.6. 小提示</h2><ul><li>一个游戏物体只能被指定一个标签</li><li>可以用任意一个单词作为标签的名称<br>甚至可以用一个很长的词组作为名称<br>但是那样非会不太方便，比如在界面中看不到完整的名字</li></ul><h1 id="2-层级"><a href="#2-层级" class="headerlink" title="2. 层级"></a>2. 层级</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>层级最有用、最常用的地方有：</p><ul><li>用来让摄像机仅渲染场景中的一部分物体</li><li>还可以让灯光只照亮一部分物体。</li><li>用来在进行碰撞检测、射线检测时，从而只让某些物体发生碰撞，让另一些物体不发生碰撞。</li></ul><h2 id="2-2-新建层级"><a href="#2-2-新建层级" class="headerlink" title="2.2 新建层级"></a>2.2 新建层级</h2><p>单击主菜单的Edit &gt; Project Settings &gt; Tagsand Layers选项，会在检视窗口中打开层级和标签窗口。<br>这步操作和之前介绍标签时的操作完全一样， 不同的是，在学习标签时我们展开了标签菜单，这里我们要展开层级菜单。<br>将新的层级User Layer8命名为Player,就建立了一个新的Player层级，序号为8.</p><h2 id="2-3-只渲染场景的一部分"><a href="#2-3-只渲染场景的一部分" class="headerlink" title="2.3 只渲染场景的一部分"></a>2.3 只渲染场景的一部分</h2><p>层级配合摄像机的剔除遮眾Culling Mas)使用，就可以有选择性地显示某些层级的物体，而不渲染另一些层级的物体。</p><p>要做到这一点， 只需要在摄像机中选中需要渲染的层级即可。<br>单击摄像机的剔除遮罩下拉菜单，打钩的层就是要显示的层。</p><blockquote><p>注意: Unity 中有很多类似这样的下拉菜单，菜单的最上面两项是特殊的：<br>单击Noting时，所有选项都会被取消勾选，表示全部不选<br>单击Everyhing 时，则所有选项都会被勾选。<br>使用这两个快捷选项有助于快速选中必要的层。<br>比如说，要仅选中Ul层和Player层，就可以先选择Nothing,然后再单独勾选UI层和Player层即可.</p></blockquote><blockquote><p>UI系统如果采用屏幕空间画布，则不会受摄像机别除遮罩的影响。</p></blockquote><h2 id="2-5-选择性的射线检测"><a href="#2-5-选择性的射线检测" class="headerlink" title="2.5 选择性的射线检测"></a>2.5 选择性的射线检测</h2><p>使用层级可以让射线检测忽略某些碰撞体，这种效果也是用“层级”和“遮罩”这两个概念来设置的。</p><p>例如，有时需要发射条射线， 仅和Player 层的物体发生碰撞， 而忽略其他层的物体。<br>Physics.Racast方法用来发射一条射线， 它可以带有一个叫作layerMask 的参数，layerMask是一个利用位标记作为遮罩的参数。</p><blockquote><p>用位(bit)作为标记是二进制相关的一种方法<br>原理是int型的变量由32个位组成，每个位的值只能是0或1<br>因此可以根据某个位是0还是1来选中或者忽略某一层</p></blockquote><ul><li>如果layerMask所有的位都是1,那么就会和所有的层发生碰撞。</li><li>如果layerMask等于0，那么它就不会和任何层、任何物体发生碰撞。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//将1左移8位</span><br><span class="hljs-built_in">int</span> layerMask =<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br><span class="hljs-comment">//将layerMask设置为只有从右数第8位是1,其他位是0，则只会和Layer 8 Player层发生碰撞</span><br><span class="hljs-keyword">if</span> (Physics .Raycast (transform.position, Vector3. forward, Mathf. Infinity, layerMask))<br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;The ray hit the player&quot;</span>) ;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是玩家的游戏人物射击发出的检测射线，就恰恰相反，需要和除玩家的游戏人物以外的所有物体发生碰撞，代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//将1左移8位</span><br>    <span class="hljs-built_in">int</span> layerMask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">//按位取反，所有值为0的位变为1,值为1的位变为0</span><br>    layerMask = ~ layerMask;<br>    RaycastHit hit;<br>    <span class="hljs-comment">//发射射线，Debug. DrawRay用于画出辅助框线</span><br>    <span class="hljs-keyword">if</span> (Physics.Raycast(transform.position,traform.TransformDirection(Vector3.forward),<br>                        <span class="hljs-keyword">out</span> hit, Mathf.Infinity,layerMask))<br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<br>                      hit.distance,Color.yellow);<br>        Debug. Log(<span class="hljs-string">&quot;Did Hit&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        Debug.DrawRay(transform.position,<br>                      transform.TransformDirection(Vector3.forward)*<span class="hljs-number">1000</span><br>                      Color.white) ;<br>        Debug.Log(<span class="hljs-string">&quot;Did not Hit&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在调用Raycast方法时省略layerMask参数，则默认除了Ignore Raycast这层不会被碰撞，其他层都可能发生碰撞。</p><p>使用lgnore Raycast层可以专门指定某些物体不受射线检测碰撞。</p><blockquote><p>序号为31的最后一层是特别的，编辑器把它作为预览使用，开发者不要使用这一层，会造成冲突</p></blockquote><h1 id="3-静态物体"><a href="#3-静态物体" class="headerlink" title="3. 静态物体"></a>3. 静态物体</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>如果引擎事先知道了某一个物体在游戏进行中是否会移动，那么就可以针对性地应用一系列优化策略。</p><p>如果一个物体是静态的，即不会移动的，那么引擎就可以假定它不会受到任何其他物体或者事件的影响，从而预先计算好物体的信息。<br>比如说，渲染器可以将场景中许多静态物体台并为一个整体，这样就可以通过一次渲染就将它们全部处理完毕，这种做法也被称为批量渲染。</p><p>在检视窗口中，每个游戏物体名称的右侧都有一一个静态(Static) 复选框以及一个菜单，它用来指定物体是否是静态的，且可以进一步指定物体 在某些子系统中是否是静态的，还可以独立地设置游戏物体在每个子系统中是否是静态的，这样就可以对物体进行非常细致的优化。</p><p>下图是静态标记菜单，可以有针对性地设置物体在每个子系统中是否是静态的。</p><h2 id="3-2-子系统的静态特性内容"><a href="#3-2-子系统的静态特性内容" class="headerlink" title="3.2 子系统的静态特性内容"></a>3.2 子系统的静态特性内容</h2><p>静态菜单中的Everyhing和Nothing选项分别用于同时启用或禁用物体在所有子系统中的静态特性以便优化。</p><p>这些子系统包含如下内容：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Lightmap Static</td><td>场景中的高级光照特性</td></tr><tr><td>Occluder Static</td><td>根据物体在特定摄像机下的可见性，进行渲染优化</td></tr><tr><td>Batching Static</td><td>将多个物体合并为一个整体进行渲染</td></tr><tr><td>Navigation Static</td><td>在寻路系统中，将此物体作为静态的障碍物</td></tr><tr><td>Off Mesh Link Generation</td><td>寻路系统中的网格链接</td></tr><tr><td>Reflection Probe Static</td><td>反射探针优化</td></tr></tbody></table><p>某些子系统与内部渲染方式有较大关联，可以在相关文档中阅读它们的细节。</p><h1 id="4-预制体"><a href="#4-预制体" class="headerlink" title="4.预制体"></a>4.预制体</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>在场景中创建物体、添加组件并设置合适参数的操作一开始会令人觉得方便， 但是当场影的用到大量同样的NPC、障碍物或机关时，创建以及设置属性的操作就会带来巨大的麻烦。<br>复制这些物体看似可以解决问题，但是由于这些物体都是独立的，所以还是需要一个一个单独体改它们。</p><p>所以，Unity 提供了预制体这个概念。<br>它允许事先保存一个游戏物体，包括该物体上挂载的组件与设置的参数。<br>这样预制体就可以成为模板，可以用这个模板在场景中创建物体。</p><p>预制体具有以下两个优点</p><ul><li><p>对预制体文件的任何修改可以立即影响所有相关联的物体</p></li><li><p>每个物体还可以重载(override)一些些组件和参数， 以实现与模板有所区别的设置</p></li></ul><blockquote><p>注意:<br>当你拖曳一个资源文件(比如一个模型)到场景中时，Unity 会自动创建一个新的游戏物体，原始资源的修改也会影响到这些相关的游戏物体。<br>这种物体看起来像是预制体，但是和预制体是完全不同的，所以不适用下面介绍的预制体的特性。<br>这种“引用关系”仅仅是与预制体有相似之处。</p></blockquote><h2 id="4-2-使用预制体"><a href="#4-2-使用预制体" class="headerlink" title="4.2 使用预制体"></a>4.2 使用预制体</h2><p>创建预制体有两种常用方法: </p><ul><li>方法一:<br>在工程窗口中的某个文件夹内单击右键，选择Create&gt; Prefab创建一个空白预制体，然后将场景中制作好的某个游戏物体拖曳到空白预制体上。</li><li>方法二:<br>直接将某个游戏物体从场景拖曳到文件夹中。<br>在创建好预制体以后，将另一个游戏物体拖曳到预制体文件上，系统会提示是否替换预制体。</li></ul><blockquote><p>预制体是一个后缀为 .prefab的资源文件。<br>在层级视图中，所有与预制体关联的游戏物体的名称，都会以蓝色显示(普通物体的名称是以黑色显示的)</p></blockquote><blockquote><p>编辑器会用粗体字来显示游戏物体中与预制体不一样的独特属性</p></blockquote><h2 id="4-3-通过游戏物体实例修改预制体"><a href="#4-3-通过游戏物体实例修改预制体" class="headerlink" title="4.3 通过游戏物体实例修改预制体"></a>4.3 通过游戏物体实例修改预制体</h2><p>与预制体关联的游戏物体，会在检视窗口的上方多出三个按钮:</p><ul><li><p>选择( Select)<br>选中与物体相关联的那个预制体，单击后，在工程窗口中会高亮显示该预制体。<br>这有助于迅速找到相关的预制体。</p></li><li><p>回滚(Revert)<br>将游戏物体修改过的组件和属性恢复到和预制体一致。<br>这个功能用于试验性地修改某些参数以后，将物体恢复到原始状态。</p></li><li><p>应用(Apply)<br>将本物体上修改的那些组件和参数写回到原始的预制体中(但是变换组件的位置信息不会写回预制体)。<br>这有助于通过任何一个物体修改预制体，有时会非常方便，特别是在某些预制体只有一个实例的时候。</p></li></ul><h2 id="４-4-预制体实例化"><a href="#４-4-预制体实例化" class="headerlink" title="４.4 预制体实例化"></a>４.4 预制体实例化</h2><p>使用<strong>Instantiate函数</strong></p><p>Instantiate函数实例化是将传入对象的所有子物体和子组件完全复制，成为一个新的对象。<br>这个新的对象拥有与源对象完全一样的东西，包括坐标值等。</p><h3 id="4-4-1-参数"><a href="#4-4-1-参数" class="headerlink" title="4.4.1 参数"></a>4.4.1 参数</h3><table><thead><tr><th>参数名</th><th>作用</th></tr></thead><tbody><tr><td>original</td><td>用来做复制操作的对像物体，源对象</td></tr><tr><td>position</td><td>实例化的对象的位置坐标</td></tr><tr><td>rotation</td><td>实例化的对象的旋转坐标（旋转四元数）</td></tr><tr><td>parent</td><td>实例化对象的父对象，在完成实例化函数处理后，实例化对象将是父对象的子对象</td></tr><tr><td>instantiateWorldSpace</td><td>为TRUE，表示实例化对象相对于世界坐标系的位置（是位置，不是坐标值，比如实例化前在Canvas左上角，实例化后还在左上角）不变，相对于父对象的坐标值变了<br />为false，表示实例化对象相对于父对象的坐标值不变，但在世界坐标系中的位置变了。</td></tr></tbody></table><p><a href="https://blog.csdn.net/qq_29413829/article/details/78934579">https://blog.csdn.net/qq_29413829/article/details/78934579</a></p><h3 id="4-4-2-重载"><a href="#4-4-2-重载" class="headerlink" title="4.4.2 重载"></a>4.4.2 重载</h3><p>![Instantiate函数](./images/Unity中的标签 层级 静态物体/20171229171822891)</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>总结</tag>
      
      <tag>层级</tag>
      
      <tag>标签</tag>
      
      <tag>静态物体</tag>
      
      <tag>预制体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity中的事件</title>
    <link href="/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity在C#Event特性的基础上进行了改良，Event只能用于纯代码编程，而UnityEvent可以和UnityEditor配合使用提高效率。</p><blockquote><p>请先学习<a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E4%BA%8B%E4%BB%B6/">C#事件</a>！</p></blockquote><h1 id="2-Unity事件的改良"><a href="#2-Unity事件的改良" class="headerlink" title="2. Unity事件的改良"></a>2. Unity事件的改良</h1><p>在C#事件中我们举的例子中，可以看出.Net框架下的事件存在以下几个问题：</p><ul><li>订阅的时机受限<br>你必须在事件触发前完成事件的订阅<br>事件处理程序将收不到订阅前的事件动态</li><li>不方便管理<br>想要查看所有订阅事件的对象，我们就得查找项目中所有对事件的引用，然后再把每个对象的文件打开，可以说是非常麻烦了</li></ul><p>为了避免上述的缺点，Unity使用Serializable（序列化）让用户可以在Editor中直接绑定所有对象的调用，即一目了然又不用担心把握不准订阅的时机，这就是<strong>UnityEvent</strong>。</p><h1 id="3-UnityEvent类"><a href="#3-UnityEvent类" class="headerlink" title="3. UnityEvent类"></a>3. UnityEvent类</h1><p><strong>UnityEvent</strong> 可添加到任何 <strong>MonoBehaviour</strong>，并从标准 .net 委托之类的代码中执行。当 <strong>UnityEvent</strong>添加到 <strong>MonoBehaviour</strong>时，它会出现在 <strong>Inspector</strong> 中，并可添加持久回调。</p><h2 id="3-1-方法"><a href="#3-1-方法" class="headerlink" title="3.1 方法"></a>3.1 方法</h2><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>AddListener</td><td>将一个非持久性侦听器添加到UnityEvent</td></tr><tr><td>Invoke</td><td>调用所有已注册的回调（运行时和持久的）</td></tr><tr><td>RemoveListener</td><td>从UnityEvent中删除一个非持久性侦听器</td></tr></tbody></table><h2 id="3-2-继承的成员"><a href="#3-2-继承的成员" class="headerlink" title="3.2 继承的成员"></a>3.2 继承的成员</h2><p>普通方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetPersistentEventCount</td><td>获取已注册的持久性侦听器的数量</td></tr><tr><td>GetPersistentMethodName</td><td>获取索引为index的侦听器的目标方法名称</td></tr><tr><td>GetPersistentTarget</td><td>在索引index处获取侦听器的目标组件</td></tr><tr><td>RemoveAllListeners</td><td>从事件中删除所有侦听器</td></tr><tr><td>SetPersistentListenerState</td><td>修改持久侦听器的执行状态</td></tr></tbody></table><p>静态方法</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>GetValidMethodInfo</td><td>给定对象，函数名称和参数类型列表；找到匹配的方法</td></tr></tbody></table><h2 id="3-3-UnityEvent的使用"><a href="#3-3-UnityEvent的使用" class="headerlink" title="3.3 UnityEvent的使用"></a>3.3 UnityEvent的使用</h2><p>要在 Editor 中配置回调，需执行以下几个步骤：</p><ol><li>确保脚本导入/使用 <code>UnityEngine.Events</code>。</li><li>选择 + 图标为回调添加字段</li><li>选择要接收回调的 UnityEngine.Object（可使用对象选择器进行选择）</li><li>选择要调用的函数</li><li>可为事件添加多个回调</li></ol><p>在 <strong>Inspector</strong> 中配置 <strong>UnityEvent</strong> 时，支持两种类型的函数调用：</p><ul><li>静态。<br>静态调用是预配置的调用，具有在 UI 中设置的预配置值。<br>这意味着，在调用回调时，使用已在 UI 中输入的参数调用目标函数。</li><li>动态。<br>使用从代码发送的参数调用动态调用，并与正在调用的 UnityEvent 类型相关。<br>UI 会过滤回调，仅显示对 UnityEvent 有效的动态调用。</li></ul><h2 id="3-4-UnityEvent的多态（派生自定义事件）"><a href="#3-4-UnityEvent的多态（派生自定义事件）" class="headerlink" title="3.4 UnityEvent的多态（派生自定义事件）"></a>3.4 UnityEvent的多态（派生自定义事件）</h2><p>默认情况下，<strong>Monobehaviour</strong> 中的 UnityEvent 动态绑定到 void 函数。</p><p>但不一定非得如此，<strong>UnityEvent</strong> 的子类支持绑定到最多包含 4 个参数的函数。</p><p>为此，您可以定义一个支持多个参数的自定义 <strong>UnityEvent</strong> 类。</p><p>此定义十分简单：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringEvent</span> : <span class="hljs-title">UnityEvent</span> &lt;<span class="hljs-title">string</span>&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><p>订阅时订阅此派生类的实例而不是基类 <strong>UnityEvent</strong>，即可回调时传递各种参数。</p><p>然后，可通过调用**Invoke()**函数来对其进行调用。</p><blockquote><p>UnityEvent 可在其通用定义中定义最多 4 个参数。</p></blockquote><h2 id="3-5-使用案例："><a href="#3-5-使用案例：" class="headerlink" title="3.5 使用案例："></a>3.5 使用案例：</h2><p>将C#事件中的用例代码改写成Unity引擎内继承于<strong>UnityEvent</strong>的脚本：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.Events;<br><br><span class="hljs-comment">//使用Serializable序列化IdolEvent, 否则无法在Editor中显示</span><br>[<span class="hljs-meta">System.Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IdolEvent</span> : <span class="hljs-title">UnityEvent</span>&lt;<span class="hljs-title">string</span>&gt; &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">//public delegate void IdolBehaviour(string behaviour);</span><br>    <span class="hljs-comment">//public event IdolBehaviour IdolDoSomethingHandler;</span><br>    <span class="hljs-keyword">public</span> IdolEvent idolEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (idolEvent == <span class="hljs-literal">null</span>)<br>        &#123;<br>            idolEvent = <span class="hljs-keyword">new</span> IdolEvent();<br>        &#125;<br>        idolEvent.Invoke(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将三个脚本绑定在三个GameObject上，此时两个粉丝还未实现订阅。和Event不同，UnityEvent在序列化后可以在Editor上显示，并且可以在Editor上设置好需要执行的函数</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315164014120.png" srcset="/img/loading.gif" alt="image-20210315164014120"></p><p>运行</p><p><img src="/images/Unity%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6/image-20210315160434052.png" srcset="/img/loading.gif" alt="image-20210315160434052"></p><p>除此之外，UnityEvent依然提供和C# Event 类似的运行时绑定的功能，不过不同的是，UnityEvent是一个对象，向其绑定函数是通过AddListener()方法实现的。以SubscriberB为例，我们可以在代码中实现同等效果的绑定：</p><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-keyword">public</span> Idol myIdol;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        myIdol.idolEvent.AddListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        myIdol.idolEvent.RemoveListener(HateIdol);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;idolAction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于UnityEvent是一个对象，所以自然可以允许我们通过继承实现自己的Event，实际上Unity中包括Button在内的许多UI组件的点击事件都是通过继承自UnityEvent来复写的。<br>可访问性(public/private)决定了UnityEvent的默认值，当可访问性为public时，默认会为其分配空间(new UnityEvent())；当可访问性为private时，默认UnityEvent为null，需要在Start()中为其分配内存。</p></blockquote><h1 id="4-EventSystem"><a href="#4-EventSystem" class="headerlink" title="4. EventSystem"></a>4. EventSystem</h1><p>EventSystem在Unity中是一个看起来像是专门服务于UGUI系统的组件。<br>每当在场景里创建UGUI对象时，Unity编辑器都会自动产生一个EventSystem对象放在场景中，与之相对应的也有一个Canvas对象，这两个对象就组成了UGUI系统的基础。<br>所有开发人员能看到和能用到的UGUI功能都依附于这两个对象。</p><h2 id="4-1-UGUI中的EventSystem"><a href="#4-1-UGUI中的EventSystem" class="headerlink" title="4.1 UGUI中的EventSystem"></a>4.1 UGUI中的EventSystem</h2><p>使用<strong>UGUI</strong>制作游戏界面时，<strong>EventSystem</strong>的作用就像是一个专为<strong>UGUI</strong>设计好的消息中心，它管理着所有能参与消息处理的<strong>UGUI</strong>组件，包括但不仅限于<strong>Panel</strong>，<strong>Image</strong>，<strong>Button</strong>等。</p><p>如果在<strong>Unity</strong>创建好<strong>EventSystem</strong>之后观察该对象上附带的组件可以看到，至少有两个组件会被自动添加</p><ul><li><p><strong>EventSystem组件</strong>，也就是消息机制的核心；</p></li><li><p><strong>StandaloneInputModule组件</strong>，这个是负责产生输入的组件。<br>StandaloneInputModule本身是个继承自BaseInputModule的实现类，而类似的实现类Unity中还有另外几个，甚至用户也能自定义一个实现类用于事件处理。</p></li></ul><p>看起来这个系统似乎缺少一个部分，就是怎么确定某个事件是发给谁的。<br>因此为了确定操作对象究竟是哪个，一个必不可少的步骤就是检测。</p><p>在GUI之外的游戏场景编辑中，要感知当前鼠标对准的物体是哪个，最常用的方法就是射线检测了：<br>从摄像机对着鼠标指向的方向发出射线，通过碰撞来检测目标。</p><p>这个方案简单实用，可以说在游戏中随处可见，而UGUI所使用的机制也就是这一套射线检测，只不过射线的发射和碰撞处理都被隐藏在了组件之中。</p><p>所以，缺失的部分就是射线检测模块，这个模块不在EventSystem上，而是在Canvas上挂着。<br>这很好理解，Canvas是所有UGUI组件的根对象，所以由他来负责射线处理是相当正常的解决方案，至于射线到底碰到了谁，UGUI组件自然有射线接收反馈来确定。</p><p>Canvas上挂载的组件叫做GraphicRaycaster，它实际上是BaseRaycaster的实现类，专门负责Canvas之下的图形对象的射线检测与计算问题。</p><p>至此，UGUI中的情况就比较清晰了：</p><ul><li><p><strong>EventSystem对象</strong><br>负责管理所有事件相关对象<br>该对象下挂载了EventSystem组件和StandaloneInputModule组件，前者为管理脚本，后者为输入模块</p></li><li><p><strong>Canvas对象</strong><br>下挂载了GraphicRaycaster负责处理射线相关运算<br>用户的操作都会通过射线检测来映射到UGUI组件上，InputModule将用户的操作转化为射线检测，Raycaster则找到目标对象并通知EventSystem，最后EventSystem发送事件让目标对象进行响应</p><p>如下图所示：</p><img src="/images/Unity中的事件/UGUI结构.png" srcset="/img/loading.gif" alt="UGUI结构"  /></li></ul><h3 id="4-1-1-事件响应"><a href="#4-1-1-事件响应" class="headerlink" title="4.1.1 事件响应"></a>4.1.1 事件响应</h3><p>UGUI的事件响应处理有多种方式，这里我们介绍两种常用方法</p><h4 id="4-1-1-1-实现特定接口处理事件响应"><a href="#4-1-1-1-实现特定接口处理事件响应" class="headerlink" title="4.1.1.1 实现特定接口处理事件响应"></a>4.1.1.1 实现特定接口处理事件响应</h4><p>由于Canvas挂载了GraphicRaycaster组件，因此在Canvas对象之下的所有GUI对象都可以通过挂载脚本并且实现一些和事件相关的接口来处理事件，比如常见的IPointerClickHandler接口就是用于处理点击事件的接口。</p><p>可以实现的接口列表大概如下所示：</p><table><thead><tr><th>接口名</th><th>作用</th></tr></thead><tbody><tr><td>IPointerEnterHandler - OnPointerEnter</td><td>当光标进入对象时调用</td></tr><tr><td>IPointerExitHandler - OnPointerExit</td><td>当光标退出对象时调用</td></tr><tr><td>IPointerDownHandler - OnPointerDown</td><td>在对象上按下指针时调用</td></tr><tr><td>IPointerUpHandler - OnPointerUp</td><td>松开鼠标时调用（在指针正在点击的游戏对象上调用）</td></tr><tr><td>IPointerClickHandler - OnPointerClick</td><td>在同一对象上按下再松开指针时调用</td></tr><tr><td>IInitializePotentialDragHandler - OnInitializePotentialDrag</td><td>在找到拖动目标时调用，可用于初始化值</td></tr><tr><td>IBeginDragHandler - OnBeginDrag</td><td>即将开始拖动时在拖动对象上调用</td></tr><tr><td>IDragHandler - OnDrag</td><td>发生拖动时在拖动对象上调用</td></tr><tr><td>IEndDragHandler - OnEndDrag</td><td>拖动完成时在拖动对象上调用</td></tr><tr><td>IDropHandler - OnDrop</td><td>在拖动目标对象上调用</td></tr><tr><td>IScrollHandler - OnScroll</td><td>当鼠标滚轮滚动时调用</td></tr><tr><td>IUpdateSelectedHandler - OnUpdateSelected</td><td>每次勾选时在选定对象上调用</td></tr><tr><td>ISelectHandler - OnSelect</td><td>当对象成为选定对象时调用</td></tr><tr><td>IDeselectHandler - OnDeselect</td><td>取消选择选定对象时调用</td></tr><tr><td>IMoveHandler - OnMove</td><td>发生移动事件（上、下、左、右等）时调用</td></tr><tr><td>ISubmitHandler - OnSubmit</td><td>按下 Submit 按钮时调用</td></tr><tr><td>ICancelHandler - OnCancel</td><td>按下 Cancel 按钮时调用</td></tr></tbody></table><p>只要在挂载的脚本中实现所需要的接口，对应的事件回调也就可以执行了。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventTest</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerClickHandler</span>, <span class="hljs-title">IDragHandler</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span> <br>&#123;<br>    <span class="hljs-comment">// Execute every update when dragging</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-comment">// quick down and up will perform click</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerClick</span>(<span class="hljs-params">PointerEventData eventData</span>)</span> &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer down</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData eventData</span>) <span class="hljs-comment">// pointer up</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Use this for initialization</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">// Update is called once per frame</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-2-利用EventTrigger组件处理事件响应"><a href="#4-1-1-2-利用EventTrigger组件处理事件响应" class="headerlink" title="4.1.1.2  利用EventTrigger组件处理事件响应"></a>4.1.1.2  利用EventTrigger组件处理事件响应</h4><p>EventTrigger组件是一个通用的事件触发器，它可以用来管理单个组件上的所有可能触发的事件。<br>其使用方法有两种：</p><ul><li><p>编辑器设定方法</p><p>指定组件上添加EventTrigger组件，然后为它添加触发事件类型，再为指定类型添加回调方法。</p></li></ul><p>这种做法的操作很简单，而且灵活性也相当高，想要跨脚本调用方法只需要鼠标拖一拖点一点就好。<br>但是这样在编辑器中设定事件回调会在项目变大时造成比较严重的管理障碍，尤其是当绑定了EventTrigger以及回调指向的物体有修改或者删除情况时，所造成的引用缺失需要花费更多的时间进行处理。</p><blockquote><p>略</p></blockquote><ul><li>动态设定方法</li></ul><p>想要更好地管理大量的事件触发和回调处理，可以尝试采用动态设置的方案。<br>所谓动态设置其实就是在代码中设置EventTrigger来处理事件回调，方法也很简单</p><blockquote><p>略</p></blockquote><h2 id="4-2-场景中的EventSystem"><a href="#4-2-场景中的EventSystem" class="headerlink" title="4.2 场景中的EventSystem"></a>4.2 场景中的EventSystem</h2><p>EventSystem也能在一般的场景中使用。<br>如果没有实现自己的事件系统而又需要一些回调处理的方案的话，可以试着直接将EventSystem应用到一般的游戏场景中。<br>要这样使用EventSystem的话，核心在于前文提到过的事件系统三大部分：</p><ul><li>EventSystem</li><li>InputModule</li><li>Raycaster。</li></ul><p>通过考察三者各自的作用可知，EventSystem和InputModule都和EventSystem对象紧密结合，而唯有Raycaster是孤零零地在Canvas对象上处理所有Canvas内部的射线检测。</p><p>那么想要借助EventSystem的能力来处理场景中的事件传递，肯定不能去动EventSystem对象，毕竟这是建立事件系统时自动创建的对象，不用说一定是要用到的。<br>那么就只剩下Raycaster了，这个组件在Canvas上挂载，用于处理射线检测，那么如果想要在场景里进行射线检测，应该把组件挂到哪里呢？</p><p>一般而言，摄像机是一个不错的选择，因为通常来说游戏大部分时候都只有一个摄像机，而且基本上可以操作的界面也只隶属于一个摄像机，因此将Raycaster挂载到游戏的主摄像机上就是个很自然的考虑了。<br>​ 而Unity编辑器提供的Raycaster一共有三种</p><ul><li>GraphicRaycaster 界面射线处理器，用于Canvas</li><li>Physics2DRaycaster 2D场景射线处理器，用于2D场景</li><li>PhysicsRaycaster 3D场景射线处理器，用于3D场景</li></ul><p>因此要用到的就是后两种了，根据当前场景的特点选择相应的Raycaster并挂载到主摄像机上即可，剩下的就和UGUI中很像了。</p><p>不过需要注意的是，在UGUI中想要让组件可以响应事件必须将组件的RaycasterTarget属性勾选上，而场景中则要在需要响应事件的对象上挂载碰撞器，满足需求的任何碰撞器都可以。<br>然后就和前文讲的一样，实现对应接口或者添加EventTrigger组件来实现各种事件回调。</p><p>使用这样的方案实现的回调，其传递的数据PointerEventData中包含的位置参数还是屏幕位置，而且跟像素相关，以屏幕左下角为原点的坐标。<br>如果希望获取触发事件时的世界坐标，则需要用到PointerEventData类中的pointerCurrentRaycast成员，该成员表示了射线检测的结果，因此其中包含碰撞点的世界坐标。</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>底层机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp-委托</title>
    <link href="/2021/03/21/CSharp-%E5%A7%94%E6%89%98/"/>
    <url>/2021/03/21/CSharp-%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>委托(delegate)是一种存储函数引用的类型。<br>委托是C#的一个语言级特性，而在Java语言中没有直接的对应，但是java利用反射即可实现委托。</p><p>委托最重要的用途在事件和事件处理时才能解释清楚，但这里也将介绍有关委托的许多内容。</p><p>委托是一种数据类型，和类是同级别的，我们可以将delegate与class类比：</p><ul><li>class里存放的是一系列方法，属性，字段，事件，索引。</li><li>delegate里存放的是一系列具有相同类型参数和返回回类型的方法的地址的地址。<br>可以看作为储存方法的载体。</li></ul><p>有了引用函数的变量后，就可以执行无法用其他方式完成的操作。<br>例如，可以把委托变量作为参数传递给-一个函数，这样，该函数就可以使用委托调用它引用的任何函数，而且在运行之前不必知道调用的是哪个函数。下面的示例使用委托访问两个函数中的一个。</p><blockquote><p><a href="https://baike.baidu.com/item/c%23%E5%A7%94%E6%89%98/6916387?fr=aladdin">委托百度百科</a>上看的最明白</p></blockquote><h1 id="2-委托的声明"><a href="#2-委托的声明" class="headerlink" title="2. 委托的声明"></a>2. 委托的声明</h1><p><strong>delegate &lt;函数返回类型&gt; 委托名（函数参数）</strong>   </p><p><strong>例：</strong> <code>public delegate void myDelegate(string name);</code></p><h1 id="3-委托的实例化"><a href="#3-委托的实例化" class="headerlink" title="3. 委托的实例化"></a>3. 委托的实例化</h1><ul><li><strong>&lt;委托名&gt;实例化名= new &lt;委托名&gt;（注册函数）</strong></li></ul><p>例 : <code> myDelegate delegateinstance = new myDelegate(method);</code></p><blockquote><p>注意：注册函数不包含参数，或者可以直接将一个注册函数赋值给委托</p></blockquote><ul><li>匿名方法实例化委托</li></ul><p>​        <strong>&lt;委托类型&gt; &lt;实例化名&gt;=delegate(&lt;函数参数&gt;){函数体}</strong></p><ul><li>使用lamda表达式实例化委托</li></ul><p>实例化例子如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>   <br>&#123;     <br>    <span class="hljs-comment">//声明委托     </span><br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)     </span><br><span class="hljs-function"></span>    &#123; <br>        <span class="hljs-comment">//实例化委托 </span><br>        <span class="hljs-comment">//1、使用new关键字       </span><br>        MyDelegate _myDelegate = <span class="hljs-keyword">new</span> MyDelegate(GetSum);<br>        <span class="hljs-comment">//2、使用匿名方法       </span><br>        MyDelegate myDelegate = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y)&#123;<span class="hljs-keyword">return</span> x + y;&#125;;<br>        <span class="hljs-comment">//3、使用Lambda表达式       </span><br>        MyDelegate myDelegateLambda = (<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) =&gt; &#123; <span class="hljs-keyword">return</span> x + y; &#125;;  <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetSum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)     </span><br><span class="hljs-function"></span>    &#123;       <br>        <span class="hljs-keyword">return</span> x + y;     <br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-多播委托"><a href="#4-多播委托" class="headerlink" title="4.多播委托"></a>4.多播委托</h1><p>实例化委托时必须将一个匹配函数注册到委托上来实例化一个委托对象，但是一个实例化委托不仅可以注册一个函数还可以注册多个函数。注册多个函数后，在执行委托的时候会根据注册函数的注册先后顺序依次执行每一个注册函数。</p><ul><li><p>多播委托实际上形成委托链 </p><p>函数注册委托的原型：</p><p>​            <strong>&lt;委托类型&gt; &lt;实例化名&gt;+=或者-=new &lt;委托类型&gt;(&lt;注册函数&gt;)</strong><br>如果在委托注册了多个函数后，如果委托有返回值，那么调用委托时，返回的将是最后一个注册函数的返回值。</p><blockquote><p>注意：委托必须先实例化以后，才能使用+=注册其他方法。如果对注册了函数的委托实例从新使用=号赋值，相当于是重新实例化了委托，之前在上面注册的函数和委托实例之间也不再产生任何关系。</p></blockquote></li></ul><blockquote><p>多播委托不支持返回值，也不支持数据引用，是单向广播</p></blockquote><h1 id="5-泛型委托"><a href="#5-泛型委托" class="headerlink" title="5.泛型委托"></a>5.泛型委托</h1><p>委托也支持泛型的使用<br>泛型委托原型：</p><ul><li><strong>delegate <T1> &lt;委托名&gt;&lt;T1,T2,T3…&gt; (T1 t1,T2 t2,T3 t3…)</strong></li></ul><h2 id="5-1-内置泛型委托"><a href="#5-1-内置泛型委托" class="headerlink" title="5.1 内置泛型委托"></a>5.1 内置泛型委托</h2><p>delegate      void   Action&lt;T1，T2，T3&gt;    泛型委托是可以达到16个参数的无返回值委托<br>delegate  Tresult Fun&lt;T1,T2,Tresult&gt;    Fun是内置泛型委托，具有返回值<br>delegate bool Predicate<T>(T obj)    内置泛型委托，返回bool值</p><h1 id="6-委托的清空"><a href="#6-委托的清空" class="headerlink" title="6. 委托的清空"></a>6. 委托的清空</h1><ol><li>在类中申明清空委托方法，依次循环去除委托引用。方法如下：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>&#123;<br>    <span class="hljs-keyword">public</span> DelegateMethod OnDelegate;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClearDelegate</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.OnDelegate != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.OnDelegate -= <span class="hljs-keyword">this</span>.OnDelegate;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>如果在类中没有申明清空委托的方法，我们可以利用GetInvocationList查询出委托引用，然后进行去除。</p><p>方法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#">TestDelegate test = <span class="hljs-keyword">new</span> TestDelegate();<br><span class="hljs-keyword">if</span> (test.OnDelegate != <span class="hljs-literal">null</span>)<br>&#123;<br>  System.Delegate[] dels = test.OnDelegate.GetInvocationList();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; dels.Length; i++)<br>  &#123;<br>     test.OnDelegate -= dels[i] <span class="hljs-keyword">as</span> DelegateMethod;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-委托的应用"><a href="#7-委托的应用" class="headerlink" title="7.委托的应用"></a>7.委托的应用</h1></li></ol><ul><li>高内聚低耦合</li><li>用于事件系统</li><li>用于设计模式——观察者模式开发</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSharp-事件</title>
    <link href="/2021/03/21/CSharp-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2021/03/21/CSharp-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>C#事件的核心思想是基于windows消息处理机制的，只是封装的更好，让开发者无须知道底层的消息处理机制，就可以开发出强大的基于事件的应用程序来。</p><p>关于事件，比较形象的比喻就是广播者和订阅者。事件执行时会广播给订阅他函数，告诉每个函数该运行了，但不管函数的实现细节。</p><p>事件类似于异常，因为它们都由对象引发(抛出)，并且都可以通过我们提供的代码来处理。<br>但它们也有个重要区别：事件并没有与tny. catch类似的结构来处理事件，你必须订阅(Subseribe)它们。</p><p>订阅一个事件的含义是提供代码，在事件发生时执行这些代码，它们称为事件处理程序。</p><p>单个事件可供多个处理程序订阅，在该事件发生时，这些处理程序都会被调用，事件处理程序可以在引发事件的类中，也可以在其他类中。</p><p>事件处理程序本身都是简单方法。对事件处理方法的唯一限制是它必须匹配事件所要求的返回类型和参数，这个限制是事件定义的一部分，由一个委托指定。</p><blockquote><p>学习事件前请先学习<br><a href="https://mycroftcooper.github.io/2021/03/21/C%E4%BA%95%E5%A7%94%E6%89%98/">委托</a></p></blockquote><h1 id="2-事件与委托的关系与区别"><a href="#2-事件与委托的关系与区别" class="headerlink" title="2. 事件与委托的关系与区别"></a>2. 事件与委托的关系与区别</h1><p><strong>事件Event</strong>是在<strong>多播委托multicast delegate</strong>的基础上演变而来。</p><ul><li>event是升级版delegate，用event实现的功能用delegate同样可以实现。</li><li>event较之delegate具有继承方面的安全性。<br>用event，别的类只能订阅/取消订阅，如果用一个 public delegate成员变量，别的类可以调用或者覆盖我们的delegate变量。</li><li>一般来说，如果你要创建一个包含多个类的动态体系，使用event而不是delegate。</li></ul><h1 id="3-使用事件的优点"><a href="#3-使用事件的优点" class="headerlink" title="3. 使用事件的优点"></a>3. 使用事件的优点</h1><p>在以往我们编程时，往往采用等待机制，为了等待某件事情的发生，需要不断地检测某些判断变量，而引入事件编程后，大大简化了这种过程：</p><ul><li><p>可以很方便地确定程序执行顺序。</p></li><li><p>当事件驱动程序等待事件时，它不占用很多资源。<br>事件驱动程序与过程式程序最大的不同就在于，程序不再不停地检查输入设备，而是呆着不动，等待消息的到来,每个输入的消息会被排进队列，等待程序处理它。<br>如果没有消息在等待，则程序会把控制交回给操作系统，以运行其他程序。</p></li><li><p>简化了编程。<br>操作系统只是简单地将消息传送给对象，由对象的事件驱动程序确定事件的处理方法。<br>操作系统不必知道程序的内部工作机制，只是需要知道如何与对象进行对话，也就是如何传递消息。</p></li><li><p>在事件源和事件接收器之间启用非常小的耦合。<br>这两个组件可能不会由同一个组织编写，甚至可能会通过完全不同的计划进行更新。</p></li><li><p>订阅事件并从同一事件取消订阅应该非常简单。</p></li><li><p>事件源应支持多个事件订阅服务器。<br>它还应支持不附加任何事件订阅服务器。</p></li></ul><h1 id="4-使用事件需要的步骤"><a href="#4-使用事件需要的步骤" class="headerlink" title="4. 使用事件需要的步骤"></a>4. 使用事件需要的步骤</h1><p>我们编写一个偶像搞事事件来描述使用事件的步骤。</p><p>代码与步骤如下：</p><h2 id="4-1-创建一个委托"><a href="#4-1-创建一个委托" class="headerlink" title="4.1 创建一个委托"></a>4.1 创建一个委托</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像行为委托，参数是行为字符串，返回值为空</p></blockquote><h2 id="4-2-将委托与已有或自定义事件关联"><a href="#4-2-将委托与已有或自定义事件关联" class="headerlink" title="4.2 将委托与已有或自定义事件关联"></a>4.2 将委托与已有或自定义事件关联</h2><p>.Net类库中的很多事件都是已经定制好的，所以他们也就有相应的一个委托，在编写关联事件处理程序——也就是当有事件发生时我们要执行的方法的时候我们需要和这个委托有相同的签名</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br></code></pre></td></tr></table></figure><blockquote><p>编写在<strong>Idol.cs</strong>中的偶像搞事事件，与IdolBehaviour偶像行为委托关联</p></blockquote><h2 id="4-3-编写事件处理程序"><a href="#4-3-编写事件处理程序" class="headerlink" title="4.3 编写事件处理程序"></a>4.3 编写事件处理程序</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>&#125;<br><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>&#123;<br>    print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>的两个事件处理程序函数</p></blockquote><h2 id="4-4-生成委托实例"><a href="#4-4-生成委托实例" class="headerlink" title="4.4 生成委托实例"></a>4.4 生成委托实例</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br>IdolBehaviour myIdolBehaviour=<span class="hljs-keyword">new</span> IdolBehaviour();<br></code></pre></td></tr></table></figure><blockquote><p>这步可以省略<br>我们在声明event delegate时并没有给它分配内存，使用时直接赋值或添加即可</p></blockquote><h2 id="4-5-订阅事件"><a href="#4-5-订阅事件" class="headerlink" title="4.5 订阅事件"></a>4.5 订阅事件</h2><p>把这个委托实例添加到产生事件对象的事件列表中去，这个过程又叫订阅事件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberA.cs</span><br><span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += LikeIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= LikeIdol;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//SubscriberB.cs</span><br><span class="hljs-comment">//OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>    Idol.IdolDoSomethingHandler += HateIdol;<br>&#125;<br><span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    Idol.IdolDoSomethingHandler -= HateIdol;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>分别编写在<strong>SubscriberA.cs</strong>与<strong>SubscriberB.cs</strong>中用于事件订阅</p></blockquote><h2 id="4-6-事件触发"><a href="#4-6-事件触发" class="headerlink" title="4.6 事件触发"></a>4.6 事件触发</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//Idol.cs</span><br><span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>&#123;<br>    IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>别编写在<strong>Idol.cs</strong>中需要触发事件的地方，Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</p></blockquote><h2 id="4-7-代码汇总"><a href="#4-7-代码汇总" class="headerlink" title="4.7 代码汇总"></a>4.7 代码汇总</h2><p>结果以上6个步骤后，一个自定义事件就完成了，代码汇总如下：</p><blockquote><p><strong>Idol.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Idol</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IdolBehaviour</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> behaviour</span>)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">event</span> IdolBehaviour IdolDoSomethingHandler;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//Idol 决定搞事了, 如果他还有粉丝的话, 就必须全部都通知到</span><br>        <span class="hljs-keyword">if</span> (IdolDoSomethingHandler != <span class="hljs-literal">null</span>)<br>        &#123;<br>            IdolDoSomethingHandler(<span class="hljs-string">&quot;Idol give up writing.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberA.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberA</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= LikeIdol;<br>    &#125;<br><br>    <span class="hljs-comment">// 粉丝A是一个脑残粉</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LikeIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will support you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>SubscriberB.cs</strong></p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SubscriberB</span> : <span class="hljs-title">MonoBehaviour</span> <br>&#123;<br>    <span class="hljs-comment">// OnEnable在该脚本被启用时调用,你可以把它看做路转粉的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//粉丝通过订阅偶像来获取偶像的咨询, 并在得到讯息后执行相应的动作</span><br>        Idol.IdolDoSomethingHandler += HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// OnEnable在该脚本被禁用时调用,你可以把它看做粉转路的开端</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        Idol.IdolDoSomethingHandler -= HateIdol;<br>    &#125;<br>    <span class="hljs-comment">// 粉丝B是一个无脑黑</span><br>    <span class="hljs-comment">// &lt;param name=&quot;idolAction&quot;&gt;&lt;/param&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HateIdol</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> idolAction</span>)</span><br><span class="hljs-function"></span>    &#123;<br>        print(idolAction + <span class="hljs-string">&quot; I will hate you forever!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-事件产生和实现的流程"><a href="#5-事件产生和实现的流程" class="headerlink" title="5.事件产生和实现的流程"></a>5.事件产生和实现的流程</h1><ol><li><p>定义A为产生事件的实例，a为A产生的一个事件</p></li><li><p>定义B为接收事件的实例，b为处理事件的方法</p></li><li><p>A由于用户(程序编写者或程序使用者)或者系统产生一个a事件(例如点击一个Button，产生一个Click事件)</p></li><li><p>A通过事件列表中的委托对象将这个事件通知给B</p></li><li><p>B接到一个事件通知(实际是B.b利用委托来实现事件的接收)</p></li><li><p>调用B.b方法完成事件处理</p></li></ol><h1 id="6-参考网站"><a href="#6-参考网站" class="headerlink" title="6. 参考网站"></a>6. 参考网站</h1><ul><li><a href="https://www.jb51.net/article/133032.htm">https://www.jb51.net/article/133032.htm</a></li><li> <a href="https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/">https://fgrain.github.io/2021/03/14/UnityEvent%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>语言学习</category>
      
      <category>C#</category>
      
      <category>C#高级特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的事件函数</title>
    <link href="/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2021/03/20/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Unity中的脚本组织不像传统的游戏循环，有一个持续进行的主循环并在循环体中处理游戏逻辑。</p><p>相对的，Unity 会在特定的事件发生时，调用脚本中特定的函数，然后执行逻辑的任务就交给了该脚本函数，函数执行完毕后，执行的权力重新还给Unty。</p><p>这些特定的函数通常被称为事件函数，因为是在特定事件发生时由引擎层调用的。</p><h1 id="2-必然事件"><a href="#2-必然事件" class="headerlink" title="2.必然事件"></a>2.必然事件</h1><table><thead><tr><th>事件函数</th><th>作用</th></tr></thead><tbody><tr><td>Awake</td><td>脚本实例被创建时调用（用于游戏对象的初始化，注意Awake的执行早于所有脚本的Start函数）</td></tr><tr><td>Start</td><td>Update函数第一次运行之前调用（用于游戏对象的初始化）</td></tr><tr><td>Reset</td><td>用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个最常用的默认值。</td></tr><tr><td>Update</td><td>每帧调用一次（用于更新游戏场景和状态）</td></tr><tr><td>FixedUpdate</td><td>每个固定物理时间间隔调用一次（用于物理引擎的参数更新）</td></tr><tr><td>LateUpdate</td><td>每帧调用一次，在Update之后（用于更新游戏场景和状态，和相机有关的更新一般放在这里）</td></tr></tbody></table><h2 id="2-1-Updata与FixedUpdate的区别"><a href="#2-1-Updata与FixedUpdate的区别" class="headerlink" title="2.1 Updata与FixedUpdate的区别"></a>2.1 Updata与FixedUpdate的区别</h2><ul><li><p>FixedUpdate</p><p>物理更新的事件函数，物理引擎也会按照物理帧更新，机制和<strong>Update函数</strong>类似，但是更新的时机完全不同。</p><p>它在每一次物理更新时被调用。</p></li><li><p>Updata</p><p>帧更新函数，每帧调用一次。</p></li></ul><blockquote><p>要认识到，物理更新的频率和时机与Update函数是相对独立的。尽可能在FixedUpdate函数中进行物理相关的操作，在Update函数中进行其他操作，只有选择正确的函数才能让游戏效果尽可能准确。</p></blockquote><h3 id="2-1-1-帧率"><a href="#2-1-1-帧率" class="headerlink" title="2.1.1 帧率"></a>2.1.1 帧率</h3><p>每一帧所经历的时间并不是一个固定值，所以通过<strong>Updata函数</strong>控制物体移动的速度将不会是稳定的。</p><p>主要是因为硬件负载的原因，引擎默认会按照每秒60帧运行游戏，但是当负载增大时，帧率可能会下降，无法达到60帧，这时可能就只有30帧，帧率降低了一半，每帧的时间增加了一倍。物体的运动由于帧率降低而变慢了。实践中一般不允许这种情况的发生。</p><p>解决方案是将两帧之间的间隔<strong>Time.deltaTime</strong>考虑进去。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExampleScript</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> distancePerSecond;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        transform.Translate(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>，distancePerSecond*Time.deltaTime);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:通过乘以Time.deltaTime的运算，物体的移动不再以“每帧距离”为准，而变成了“每秒距离”。</p><p>物体移动的距离将根据每帧时间的长短而变化，从而在时间上看起来移动是匀速的。</p></blockquote><h3 id="2-1-2-物理帧率"><a href="#2-1-2-物理帧率" class="headerlink" title="2.1.2 物理帧率"></a>2.1.2 物理帧率</h3><p>与主更新函数Update不同，Unity的物理系统必须以固定的时间间隔工作，因为只有固定的时间间隔才能保证物理模拟的准确性。就算当前负载很高、帧率很低，Unity也会尽可能保证物理刷新的频率，因为如果物理刷新帧率无法保证，就可能出现不可预料的计算结果。</p><p>在主菜单的工程选项的TimeManager中可以修改物理更新的时间间隔。<br>在脚本中使用Time. fixedDeltaTime可以获得物理更新间隔。</p><p>较小的物理更新间隔会带来更高的更新频率，更准确、更细腻的运算结果，但是也会极大地增加硬件负担。<br>fixedDeltaTime 的默认值为0.02，当对物理运算的准确性非常在意时，可以考虑适当减小这个值。</p><h1 id="3-事件响应函数"><a href="#3-事件响应函数" class="headerlink" title="3. 事件响应函数"></a>3. 事件响应函数</h1><table><thead><tr><th>函数名称</th><th>作用</th></tr></thead><tbody><tr><td>OnMouseEnter</td><td>鼠标移入GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseOver</td><td>鼠标停留在GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseExit</td><td>鼠标移出GUI控件或者碰撞体时调用</td></tr><tr><td>OnMouseDown</td><td>鼠标在GUI控件或者碰撞体上按下时调用</td></tr><tr><td>OnMouseUp</td><td>鼠标按键释放时调用</td></tr><tr><td>OnTriggerEnter</td><td>与其他碰撞体进入触发器时调用</td></tr><tr><td>OnTriggerExit</td><td>与其他碰撞体离开触发器时调用</td></tr><tr><td>OnTriggerStay</td><td>当其他碰撞体停留在触发器时调用</td></tr><tr><td>OnCollisionEnter</td><td>当碰撞体或者刚体与其他碰撞体或者刚体接触时调用</td></tr><tr><td>OnCollisionExit</td><td>当碰撞体或者刚体与其他碰撞体或者刚体停止接触时调用</td></tr><tr><td>OnCollisionStay</td><td>当碰撞体或者刚体与其他碰撞体或者刚体保持接触时调用</td></tr><tr><td>OnControllerColliderHit</td><td>当控制器移动时与碰撞体发生碰撞时调用</td></tr><tr><td>OnDestroy</td><td>脚本销毁时调用</td></tr><tr><td>OnGUI</td><td>渲染GUI和处理GUI消息时调用</td></tr><tr><td>OnBecameVisible</td><td>对于任意一个相机可见时调用</td></tr><tr><td>OnBecameInVisible</td><td>对于任意一个相机不可见时调用</td></tr><tr><td>OnEnable</td><td>对象启用或者激活时调用</td></tr><tr><td>OnDisable</td><td>对象禁用或者取消激活时调用</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameObject类</title>
    <link href="/2021/03/20/GameObject%E7%B1%BB/"/>
    <url>/2021/03/20/GameObject%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>GameObject 类是Unity场景中所有实体的基类。</p><p>一个GameObject对象通常由多个组件component组成，且至少含有一个transform组件。</p><p>详细可见<a href="https://blog.csdn.net/a1256242238/article/details/73189101">https://blog.csdn.net/a1256242238/article/details/73189101</a></p><h1 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h1><ul><li><p><code>public GameObject();</code></p></li><li><p><code>public GameObject(string name);</code></p></li><li><p><code>public GameObject(string name,params Type[] components);</code></p></li></ul><h1 id="3-常用成员变量"><a href="#3-常用成员变量" class="headerlink" title="3. 常用成员变量"></a>3. 常用成员变量</h1><table><thead><tr><th>变量名</th><th>作用</th></tr></thead><tbody><tr><td>name</td><td>继承于父类Object，对象的名称</td></tr><tr><td>tag</td><td>游戏对象的标签tag</td></tr><tr><td>layer</td><td>游戏对象所在的层layer，范围为[0…31]</td></tr><tr><td>activeSelf</td><td>游戏对象自身的激活状态</td></tr><tr><td>transform</td><td>游戏对象上的Transform组件，设置对象位置、旋转、缩放</td></tr><tr><td>rigidbody</td><td>游戏对象上的Rigidbody组件，设置物理引擎的刚体属性</td></tr><tr><td>camera</td><td>游戏对象上的Camera组件，设置相机属性</td></tr><tr><td>light</td><td>游戏对象上的Light组件，设置灯光属性</td></tr><tr><td>animation</td><td>游戏对象上的Animation组件，设置动画属性</td></tr><tr><td>renderer</td><td>游戏对象上的Renderer组件，渲染物体模型</td></tr><tr><td>audio</td><td>游戏对象上的AudioSource组件，设置声音属性</td></tr></tbody></table><h1 id="4-常用成员函数"><a href="#4-常用成员函数" class="headerlink" title="4.常用成员函数"></a>4.常用成员函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Find</td><td>静态函数，根据名称查找游戏对象</td></tr><tr><td>FindWithTag</td><td>静态函数，根据标签查找第一个符合条件的游戏对象</td></tr><tr><td>FindGameObjectsWithTag</td><td>静态函数，根据标签查找所有符合条件的游戏对象</td></tr><tr><td>CreatePrimitive</td><td>静态函数，创建一个基本形体的游戏对象（如正方体，球体等）</td></tr><tr><td>SetActive</td><td>激活/取消激活游戏对象</td></tr><tr><td>GetComponent</td><td>获取游戏对象</td></tr><tr><td>GetComponentInChildren</td><td>获取游戏对象或其子对象上指定类型的第一个组件</td></tr><tr><td>GetComponents</td><td>获取游戏对象上指定类型的所有组件</td></tr><tr><td>AddComponent</td><td>为游戏对象添加指定组件</td></tr><tr><td>SendMessage</td><td>调用游戏对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>SendMessageUpwards</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>BroadcastMessage</td><td>调用游戏对象及其所有父对象上所有MonoBehaviour的指定名称方法</td></tr><tr><td>CompareTag</td><td>比较游戏对象的标签</td></tr></tbody></table><h1 id="5-继承自Object类的常用函数"><a href="#5-继承自Object类的常用函数" class="headerlink" title="5. 继承自Object类的常用函数"></a>5. 继承自Object类的常用函数</h1><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>Destroy</td><td>删除一个游戏物体、组件或资源</td></tr><tr><td>DestroyImmediate</td><td>立即销毁物体obj，强烈建议使用Destroy替代</td></tr><tr><td>Instantiate</td><td>克隆原始物体，并返回克隆的物体</td></tr><tr><td>DontDestroyOnLoad</td><td>加载新场景的时候使目标不被自动销毁</td></tr><tr><td>FindObjectOfType</td><td>返回Type类型第一个激活的加载的物体</td></tr></tbody></table><h2 id="5-1-Instantiate创建物体"><a href="#5-1-Instantiate创建物体" class="headerlink" title="5.1 Instantiate创建物体"></a>5.1 Instantiate创建物体</h2><p><strong>Instantiate函数</strong>专门用来创建一个新的物体，但是要提供一个预制体或者已经存在的游戏物体作为模板。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> Gameobject enemy;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//以enemy为模板生成5个敌人</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-number">1</span><span class="hljs-number">-0</span>; <span class="hljs-number">1</span>&lt;<span class="hljs-number">5</span>; <span class="hljs-number">1</span>++)<br>    &#123;<br>        Instantiate(enemy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以用已经存在的物体作为模板，更常见的方式是使用预制体作为模板。</p><p>创建的物体将会具有和原物体一样的组件、参数。</p><h2 id="5-2-Destroy销毁物体"><a href="#5-2-Destroy销毁物体" class="headerlink" title="5.2 Destroy销毁物体"></a>5.2 Destroy销毁物体</h2><p>可以用Destroy函数来销毁游戏物体或者组件。</p><p>例如，下面的代码会在导弹产生碰撞时销毁该导弹，第二个参数0.5f表示在0.5秒之后才执行销毁动作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span> (<span class="hljs-params">Collision otherobj</span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (other0bj.gameObject.tag == <span class="hljs-string">&quot;Missile&quot;</span>)<br>    &#123;<br>        Destroy (gameObject,<span class="hljs-number">0.5f</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意:由于销毁游戏物体和销毁脚本都是使用Destoy函数，所以经常 会出现误删除组件的情况。</p><p>如以下代码：</p><p><code>Destroy (this);</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在脚本中访问其他游戏物体</title>
    <link href="/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/"/>
    <url>/2021/03/20/%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E6%B8%B8%E6%88%8F%E7%89%A9%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在实际的游戏开发中，脚本不仅会对当前挂载的物体进行操作，还可能会引用其他物体。<br>例如，正在追逐玩家角色的敌人角色会-直保留着对玩家角色的引用， 以便随时确定玩家角色的位置。<br>访问其他游戏物体的方法非常多，使用非常灵活，可以根据不同的情况采用不同的方式。</p><h1 id="2-常用的4种访问操作"><a href="#2-常用的4种访问操作" class="headerlink" title="2.常用的4种访问操作"></a>2.常用的4种访问操作</h1><h2 id="2-1-用属性查看器指定参数访问"><a href="#2-1-用属性查看器指定参数访问" class="headerlink" title="2.1 用属性查看器指定参数访问"></a>2.1 用属性查看器指定参数访问</h2><p>Unity中获得其他物体最简单、最直接的方式就是为脚本添加一个<code>publi Gamebiet</code>变量，不需要设置初始值。<br>代码如下:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>player变量会显示在检视窗口中，默认值为空。</p><p>现在将任何物体或预制体拖曳到player变量的文本框中，就为player变量赋予了初始值。之在脚本中就可以随意使用Player这个游戏物体。<br>如下所示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> GameObject player;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>    &#123;<br>        <span class="hljs-comment">//读取player的位置并设置本物体的位置在它后方</span><br>        transform.position=player.transform.position-Vector3.forward*<span class="hljs-number">10f</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，上面说的引用其他物体时，变量类型不仅可以是<strong>GameObject</strong>或一个组件，也可以将戏物体拖到这个变量上，只要被拖曳的物体确实具有这个组件就可以。</p><p><code>public Transform playerTransform;</code></p><p>简单地说，可以用何一个组件来指代游戏物体本身。<br>这是因为组件实体具有“被游戏物体挂载”这样的性质，所通过一个游戏物体可以获得它上面的任何一个组件，通过任何一个组件也可以获得挂载该组件游戏物体。这个对应关系是明确的，因此上面的变量类型可以是组件类型，也可以将游戏物体直接拖上去。</p><p>用变量将物体联系起来的做法非常有用，特别是这种联系是持续存在、不易变化的。还可用一个数组或者列表来保存多个游戏物体。</p><blockquote><p>如果被引用的物体是游戏运行时才动态添加的，或者被引用的物体会随着游戏进行而变化事先拖曳的方式就不可行了，需要动态指定物体，下面将详细说明。</p></blockquote><h2 id="2-2-用父子关系查找子物体"><a href="#2-2-用父子关系查找子物体" class="headerlink" title="2.2 用父子关系查找子物体"></a>2.2 用父子关系查找子物体</h2><p>有时需要管理一系列同类型的游戏物体，例如一批敌人、一批寻路点、 多个障碍物等。<br>如果这时候需要对这些物体进行统一的管理或操作，就需要在脚本中用数组或容器来管理它们。</p><p>使用属性查看器指定参数访问的方法，可以将每个物体拖动到检视窗口中，但是这样做不仅低效，而且容易误操作，在物体增加、减少时还需要再次手动操作。</p><p>所以，在这种情况下是不合适的，可以用父子关系查找子物体的方法来遍历所有子物体。<br>在具体实现时，要用父物体的变换组件来查找子物体。</p><blockquote><p>物体的父子关系访问的属性都在变换组件中，而不在GameObject对象中</p></blockquote><p>以下是遍历所有子物体的例子:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaypointManager</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br><span class="hljs-keyword">public</span> Transform[] waypoints;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>waypoints = <span class="hljs-keyword">new</span> Transform[transform.childCount];<br><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">foreach</span> (Transform t <span class="hljs-keyword">in</span> transform)<br>&#123;<br>waypoints[i++] = t;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以使用<strong>transform.Find</strong>方法指定查找某个子物体，代码如下。</p><p><code>transform.Find (&quot;Gun&quot;);</code></p><blockquote><p>由于<strong>Find函数</strong>的效率不好估计，可能会遍历所有物体才能查找到指定物体，所以如果可以在<strong>Start函数</strong>中使用，就不要在<strong>Updata函数</strong>中使用。因为<strong>start函数</strong>只执行一次而<strong>updata函数</strong>每帧都会执行。</p></blockquote><h2 id="2-3-用标签或名称查找物体"><a href="#2-3-用标签或名称查找物体" class="headerlink" title="2.3 用标签或名称查找物体"></a>2.3 用标签或名称查找物体</h2><p>使用<strong>GameObject.Find方法</strong>可以通过名称查找游戏物体。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.Find (<span class="hljs-string">&quot;ObjectName&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要用标签查找物体，那么就要用到<strong>GameObject.FindWithTag方法</strong> 或<strong>GameObject.FindGameObjectWithTag方法</strong>。</p><p>代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#">GameObject player;<br>GameObject[] enemies;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span><br><span class="hljs-function"></span>&#123;<br>    player = GameObject.FindWithTag(<span class="hljs-string">&quot;Player&quot;</span>);<br>    enemies =GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Enemy&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
      <tag>Unity常用操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYSQL语句大全</title>
    <link href="/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/"/>
    <url>/2021/03/15/MYSQL%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="MYSQL语句大全"><a href="#MYSQL语句大全" class="headerlink" title="MYSQL语句大全"></a>MYSQL语句大全</h1><h2 id="0-相关知识"><a href="#0-相关知识" class="headerlink" title="0 相关知识"></a>0 相关知识</h2><ul><li><p><a href="https://blog.csdn.net/chaoyue1861/article/details/80468773">MYSQL逻辑架构</a></p></li><li><p><a href="https://blog.csdn.net/GitChat/article/details/78787837?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">MYSQL底层原理</a></p></li><li><p><a href="https://blog.csdn.net/m0_38075425/article/details/82256315?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">MySQL底层架构原理，工作流程和存储引擎的数据结构讲解</a></p></li></ul><h2 id="1-用户管理操作"><a href="#1-用户管理操作" class="headerlink" title="1 用户管理操作"></a>1 用户管理操作</h2><h3 id="1-1-添加用户"><a href="#1-1-添加用户" class="headerlink" title="1.1 添加用户"></a>1.1 添加用户</h3><ul><li><code> create user username identified by &#39;password&#39;;</code></li></ul><p>参数：用户名：username 密码：password</p><blockquote><p>用户数据存储在mysql.user表内</p></blockquote><h3 id="1-2-用户授权"><a href="#1-2-用户授权" class="headerlink" title="1.2 用户授权"></a>1.2 用户授权</h3><ul><li><code>grant privilegesCode on dbName.tableName to username@host identified by &#39;password&#39;;</code></li></ul><p>将Dbname数据库的所有操作权限都授权给了用户username。</p><p>参数：</p><p><strong>privilegesCode</strong> 权限类型<br>常用的权限类型</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>all privileges</td><td>所有权限</td></tr><tr><td>select</td><td>读取权限</td></tr><tr><td>delete</td><td>删除权限</td></tr><tr><td>update</td><td>更新权限</td></tr><tr><td>create</td><td>创建权限</td></tr><tr><td>drop</td><td>删除数据库、数据表权限</td></tr></tbody></table><p><strong>dbName.tableName</strong> 授权的库或特定表</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>授予该数据库服务器所有数据库的权限</td></tr><tr><td>dbName.*</td><td>授予dbName数据库所有表的权限</td></tr><tr><td>dbName.dbTable</td><td>授予数据库dbName中dbTable表的权限</td></tr></tbody></table><p><strong>username@’host’</strong> 授予的用户以及允许该用户登录的IP地址<br>| 参数         | 含义                 |<br>| ————– | ———————- |<br>| localhost | 只允许该用户在本地登录，不能远程登录 |<br>| % | 允许在除本机之外的任何一台机器远程登录 |<br>| 192.168.52.32 | 具体的IP表示只允许该用户从特定IP登录 |</p><ul><li><p><code> flush privileges;</code></p><p>刷新权限变更</p></li><li><p><code> show grants for &#39;username&#39;;</code></p></li></ul><p>查看用户的已有权限</p><blockquote><p>用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush privileges;<br></code></pre></td></tr></table></figure><p>上面的语句将zhangsanDb数据库的所有操作权限都授权给了用户zhangsan</p></blockquote><ul><li><p><code>REVOKE DELETE ON *.* FROM &#39;test&#39;@&#39;localhost&#39;;</code> </p><p>取消该用户的删除权限</p></li></ul><blockquote><p>用户权限数据存储在mysql.db表内</p></blockquote><h3 id="1-3-修改密码"><a href="#1-3-修改密码" class="headerlink" title="1.3 修改密码"></a>1.3 修改密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update mysql.user set password &#x3D; password(&#39;newpassword&#39;) where user &#x3D; &#39;username&#39; and host &#x3D; &#39;%&#39;; <br>flush privileges;<br></code></pre></td></tr></table></figure><h3 id="1-4-删除用户"><a href="#1-4-删除用户" class="headerlink" title="1.4 删除用户"></a>1.4 删除用户</h3><ul><li><code>drop user zhangsan@&#39;%&#39;;</code></li></ul><h3 id="1-5-常用命令组"><a href="#1-5-常用命令组" class="headerlink" title="1.5 常用命令组"></a>1.5 常用命令组</h3><p><strong>创建用户并授予指定数据库全部权限：适用于Web应用创建MySQL用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user zhangsan identified by &#39;zhangsan&#39;;<br>grant all privileges on zhangsanDb.* to zhangsan@&#39;%&#39; identified by &#39;zhangsan&#39;;<br>flush  privileges;<br></code></pre></td></tr></table></figure><p>创建了用户zhangsan，并将数据库zhangsanDB的所有权限授予zhangsan。如果要使zhangsan可以从本机登录，那么可以多赋予localhost权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on zhangsanDb.* to zhangsan@&#39;localhost&#39; identified by &#39;zhangsan&#39;;<br></code></pre></td></tr></table></figure><h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2 数据库操作"></a>2 数据库操作</h2><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td><code> show database;</code></td><td>查看所有的数据库</td></tr><tr><td><code>create database DBname;</code></td><td>创建该数据库</td></tr><tr><td><code>drop DBname;</code></td><td>删除该数据库</td></tr><tr><td><code>use DBname;</code></td><td>使用调用该数据库</td></tr></tbody></table><h2 id="3-表操作"><a href="#3-表操作" class="headerlink" title="3 表操作"></a>3 表操作</h2><h3 id="3-1-表的基础操作"><a href="#3-1-表的基础操作" class="headerlink" title="3.1 表的基础操作"></a>3.1 表的基础操作</h3><ul><li><p><code>show tables;</code><br>查看所有的表</p></li><li><p><code>SHOW TABLE STATUS;</code><br>查看所有的表信息（包括视图）</p></li><li><p><code> create table TBname(mode);</code></p><p>创建一个表</p><blockquote><p>例如<br><code>create table n(id INT, name VARCHAR(10));</code></p></blockquote></li><li><p><code> create table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的表</p></li><li><p><code>create table TBname like TBname;</code><br>新创建的表与一个存在的表的数据结构类似</p></li><li><p><code>create temporay table TBname(mode);</code><br>创建一个临时表</p><blockquote><p>临时表将在你连接MySQL期间存在。当断开连接时，MySQL将自动删除表并释放所用的空间。也可手动删除。</p></blockquote></li></ul><ul><li><p><code>create temporary table TBname select * from TBname;</code><br>直接将查询结果导入或复制到新创建的临时表</p></li><li><p><code> drop table if exists TBname;</code><br>删除一个存在表</p></li><li><pre><code>alter table TBname rename TBname;或rename TBname to TBname;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  更改存在表的名称<br><br>  <br>  <br>- ``` <br>  <span class="hljs-keyword">desc</span> TBname;<br>  describe TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">in</span> TBname;<br>  <span class="hljs-keyword">show</span> <span class="hljs-keyword">columns</span> <span class="hljs-keyword">from</span> TBname;<br>  <span class="hljs-keyword">explain</span> TBname;<br></code></pre></td></tr></table></figure>查看表的结构(以上五条语句效果相同）</code></pre></li><li><p><code> show create table TBname;</code><br>查看表的创建语句</p><h3 id="3-2-表的结构操作"><a href="#3-2-表的结构操作" class="headerlink" title="3.2 表的结构操作"></a>3.2 表的结构操作</h3></li></ul><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td><code> alter table TBname add Fieldname mode;</code></td><td>添加字段</td></tr><tr><td><code>alter table TBname drop Fieldname;</code></td><td>删除字段</td></tr><tr><td><code>alter table TBname change Fieldname mode;</code></td><td>更改字段属性</td></tr><tr><td><code>alter table TBname change Fieldname Fieldname mode;</code></td><td>更改字段名与属性</td></tr></tbody></table><h3 id="3-3-表的数据操作"><a href="#3-3-表的数据操作" class="headerlink" title="3.3 表的数据操作"></a>3.3 表的数据操作</h3><ul><li><p>增加数据</p><p><code>INSERT INTO n VALUES (1, &#39;tom&#39;, &#39;23&#39;), (2, &#39;john&#39;, &#39;22&#39;);</code></p><p><code>INSERT INTO n SELECT * FROM n;</code>  把数据复制一遍重新插入</p></li><li><p>删除数据</p><p><code>DELETE FROM n WHERE id = 2;</code></p></li><li><p>更改数据</p><p><code>UPDATE n SET name = &#39;tom&#39; WHERE id = 2;</code></p></li><li><p>数据查找</p><p><code>SELECT * FROM n WHERE name LIKE &#39;%h%&#39;;</code></p></li><li><p>数据排序(反序)</p><p><code>SELECT * FROM n ORDER BY name, id DESC ;</code></p></li></ul><blockquote><p>增删改查请看：<a href="https://www.cnblogs.com/heyangblog/p/7624645.html">https://www.cnblogs.com/heyangblog/p/7624645.html</a></p></blockquote><h2 id="4-键"><a href="#4-键" class="headerlink" title="4 键"></a>4 键</h2><h3 id="4-1-添加主键"><a href="#4-1-添加主键" class="headerlink" title="4.1 添加主键"></a>4.1 添加主键</h3><ul><li><p><code>ALTER TABLE TBname ADD PRIMARY KEY (id);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT pk_n PRIMARY KEY (id);</code>  </p><p>添加主键的同时自定义键名</p></li></ul><h3 id="4-2-删除主键"><a href="#4-2-删除主键" class="headerlink" title="4.2 删除主键"></a>4.2 删除主键</h3><ul><li><code> ALTER TABLE TBname DROP PRIMARY KEY ;</code></li></ul><h3 id="4-3-添加外键"><a href="#4-3-添加外键" class="headerlink" title="4.3 添加外键"></a>4.3 添加外键</h3><ul><li><p><code>ALTER TABLE TBname ADD FOREIGN KEY (id) REFERENCES TBname(id);</code>   </p><p>自动生成键名m_ibfk_1</p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT fk_id FOREIGN KEY (id) REFERENCES TBname(id); </code>  </p><p>使用定义的键名fk_id</p></li></ul><h3 id="4-4-删除外键"><a href="#4-4-删除外键" class="headerlink" title="4.4 删除外键"></a>4.4 删除外键</h3><ul><li>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</li></ul><h3 id="4-5-修改外键"><a href="#4-5-修改外键" class="headerlink" title="4.5 修改外键"></a>4.5 修改外键</h3><ul><li><p>ALTER TABLE TBname DROP FOREIGN KEY <code>fk_id</code>;</p><p>ADD CONSTRAINT fk_id2 FOREIGN KEY (id) REFERENCES TBname(id); </p><p>删除之后从新建</p></li></ul><h3 id="4-6-添加唯一键"><a href="#4-6-添加唯一键" class="headerlink" title="4.6 添加唯一键"></a>4.6 添加唯一键</h3><ul><li><p><code> ALTER TABLE TBname ADD UNIQUE (name);</code></p></li><li><p><code> ALTER TABLE TBname ADD UNIQUE u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD UNIQUE INDEX u_name (name);</code></p></li><li><p><code>ALTER TABLE TBname ADD CONSTRAINT u_name UNIQUE (name);</code></p></li><li><p><code>CREATE UNIQUE INDEX u_name ON TBname(name);</code></p></li></ul><h3 id="4-7-添加索引"><a href="#4-7-添加索引" class="headerlink" title="4.7 添加索引"></a>4.7 添加索引</h3><ul><li><p><code>ALTER TABLE TBname ADD INDEX (age);</code></p></li><li><p><code>ALTER TABLE TBname ADD INDEX i_age (age);</code></p></li><li><p><code>CREATE INDEX i_age ON TBname(age);</code></p></li></ul><h3 id="4-8-删除索引或唯一键"><a href="#4-8-删除索引或唯一键" class="headerlink" title="4.8 删除索引或唯一键"></a>4.8 删除索引或唯一键</h3><ul><li><p><code>DROP INDEX u_name ON n;</code></p></li><li><p><code>DROP INDEX i_age ON n;</code></p></li></ul><h2 id="5-视图"><a href="#5-视图" class="headerlink" title="5 视图"></a>5 视图</h2><h3 id="5-1-创建视图"><a href="#5-1-创建视图" class="headerlink" title="5.1 创建视图"></a>5.1 创建视图</h3><ul><li><p><code>CREATE VIEW v AS SELECT id, name FROM n;</code></p></li><li><p><code>CREATE VIEW v(id, name) AS SELECT id, name FROM n;</code></p></li></ul><h3 id="5-2查看视图"><a href="#5-2查看视图" class="headerlink" title="5.2查看视图"></a>5.2查看视图</h3><ul><li><p><code>SELECT * FROM v;</code></p></li><li><p><code>DESC v;</code></p></li></ul><blockquote><p>与表操作类似</p></blockquote><h3 id="5-3查看创建视图语句"><a href="#5-3查看创建视图语句" class="headerlink" title="5.3查看创建视图语句"></a>5.3查看创建视图语句</h3><ul><li><code>SHOW CREATE VIEW v;</code></li></ul><h3 id="5-4-更改视图"><a href="#5-4-更改视图" class="headerlink" title="5.4 更改视图"></a>5.4 更改视图</h3><ul><li><p><code>CREATE OR REPLACE VIEW v AS SELECT name, age FROM n;</code></p></li><li><p><code>ALTER VIEW v AS SELECT name FROM n ;</code></p></li></ul><h3 id="5-5-删除视图"><a href="#5-5-删除视图" class="headerlink" title="5.5 删除视图"></a>5.5 删除视图</h3><ul><li><code>DROP VIEW IF EXISTS v;</code></li></ul><h2 id="6-联接"><a href="#6-联接" class="headerlink" title="6 联接"></a>6 联接</h2><h3 id="6-1-内联接"><a href="#6-1-内联接" class="headerlink" title="6.1 内联接"></a>6.1 内联接</h3><ul><li><code>SELECT * FROM m INNER JOIN n ON m.id = n.id;</code></li></ul><h3 id="6-2-外连接"><a href="#6-2-外连接" class="headerlink" title="6.2 外连接"></a>6.2 外连接</h3><ul><li><code>SELECT * FROM m LEFT JOIN n ON m.id = n.id;</code>左外连接</li><li><code>SELECT * FROM m RIGHT JOIN n ON m.id = n.id;</code>右外连接</li></ul><h3 id="6-3-交叉联接"><a href="#6-3-交叉联接" class="headerlink" title="6.3 交叉联接"></a>6.3 交叉联接</h3><ul><li><p><code>SELECT * FROM m CROSS JOIN n;</code>  标准写法</p></li><li><p><code>SELECT * FROM m, n;</code></p></li></ul><h3 id="6-4-类似全连接full-join的联接用法"><a href="#6-4-类似全连接full-join的联接用法" class="headerlink" title="6.4 类似全连接full join的联接用法"></a>6.4 类似全连接full join的联接用法</h3><ul><li><pre><code>SELECT id,name FROM mUNIONSELECT id,name FROM n;<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs sql">## <span class="hljs-number">7</span> 函数<br><br>### <span class="hljs-number">7.1</span> 聚合函数<br><br><span class="hljs-operator">|</span> 语句                               <span class="hljs-operator">|</span> 含义   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">---------------------------------- | ------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">count</span>(id) <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> n;  <span class="hljs-operator">|</span> 总数   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 总和   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">avg</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 平均值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">max</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最大值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(age) <span class="hljs-keyword">AS</span> all_age <span class="hljs-keyword">FROM</span> n; <span class="hljs-operator">|</span> 最小值 <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.2</span> 数学函数<br><br><span class="hljs-operator">|</span> 语句                              <span class="hljs-operator">|</span> 含义                                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">--------------------------------- | ------------------------------------------------------ |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">abs</span>(<span class="hljs-number">-5</span>);                   <span class="hljs-operator">|</span> 绝对值                                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> bin(<span class="hljs-number">15</span>), oct(<span class="hljs-number">15</span>), hex(<span class="hljs-number">15</span>); <span class="hljs-operator">|</span> 二进制，八进制，十六进制                               <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> pi();                      <span class="hljs-operator">|</span> 圆周率<span class="hljs-number">3.141593</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ceil</span>(<span class="hljs-number">5.5</span>);                 <span class="hljs-operator">|</span> 大于x的最小整数值<span class="hljs-number">6</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">floor</span>(<span class="hljs-number">5.5</span>);                <span class="hljs-operator">|</span> 小于x的最大整数值<span class="hljs-number">5</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> greatest(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>); <span class="hljs-operator">|</span> 返回集合中最大的值<span class="hljs-number">9</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> least(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>);    <span class="hljs-operator">|</span> 返回集合中最小的值<span class="hljs-number">1</span>                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">mod</span>(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>);                  <span class="hljs-operator">|</span> 余数<span class="hljs-number">2</span>                                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand();                    <span class="hljs-operator">|</span> 返回０到１内的随机值，每次不一样                       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rand(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 提供一个参数(种子)使RAND()随机数生成器生成一个指定的值 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>);          <span class="hljs-operator">|</span> 四舍五入<span class="hljs-number">1415</span>                                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);       <span class="hljs-operator">|</span> 四舍五入三位数<span class="hljs-number">1415.142</span>                                 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> round(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);      <span class="hljs-operator">|</span> 四舍五入整数位数<span class="hljs-number">1420</span>                                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">3</span>);    <span class="hljs-operator">|</span> 截短为<span class="hljs-number">3</span>位小数<span class="hljs-number">1415.141</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">truncate</span>(<span class="hljs-number">1415.1415</span>, <span class="hljs-number">-1</span>);   <span class="hljs-operator">|</span> 截短为<span class="hljs-number">-1</span>位小数<span class="hljs-number">1410</span>                                     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">-5</span>);                  <span class="hljs-operator">|</span> 符号的值负数<span class="hljs-number">-1</span>                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> sign(<span class="hljs-number">5</span>);                   <span class="hljs-operator">|</span> 符号的值正数<span class="hljs-number">1</span>                                          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">9</span>);                   <span class="hljs-operator">|</span> 平方根<span class="hljs-number">3</span>                                                <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.3</span> 字符串函数<br><br><span class="hljs-operator">|</span> 语句                                        <span class="hljs-operator">|</span> 含义                                                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------- | ------------------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>);         <span class="hljs-operator">|</span> 连接字符串<span class="hljs-operator">-</span>apple                                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> concat_ws(<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;le&#x27;</span>); <span class="hljs-operator">|</span> 连接用<span class="hljs-string">&#x27;,&#x27;</span>分割字符串<span class="hljs-operator">-</span>a,p,p,le                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">insert</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;IN&#x27;</span>);       <span class="hljs-operator">|</span> 将字符串<span class="hljs-string">&#x27;chinese&#x27;</span>从<span class="hljs-number">3</span>位置开始的<span class="hljs-number">2</span>个字符替换为<span class="hljs-string">&#x27;IN&#x27;</span><span class="hljs-operator">-</span>chINese <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">left</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">4</span>);                  <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>左边的<span class="hljs-number">4</span>个字符<span class="hljs-operator">-</span>chin                   <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">right</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);                 <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>右边的<span class="hljs-number">3</span>个字符<span class="hljs-operator">-</span>ese                    <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>);             <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的子字符串<span class="hljs-operator">-</span>inese       <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">-3</span>);            <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>倒数第三个字符之后的子字符串<span class="hljs-operator">-</span>ese     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">substring</span>(<span class="hljs-string">&#x27;chinese&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>);          <span class="hljs-operator">|</span> 返回字符串<span class="hljs-string">&#x27;chinese&#x27;</span>第三个字符之后的两个字符<span class="hljs-operator">-</span><span class="hljs-keyword">in</span>          <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">trim</span>(<span class="hljs-string">&#x27; chinese &#x27;</span>);                   <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese&#x27;</span>             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ltrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27;chinese &#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> rtrim(<span class="hljs-string">&#x27; chinese &#x27;</span>);                  <span class="hljs-operator">|</span> 切割字符串<span class="hljs-string">&#x27; chinese &#x27;</span>两边的空字符<span class="hljs-operator">-</span><span class="hljs-string">&#x27; chinese&#x27;</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> repeat(<span class="hljs-string">&#x27;boy&#x27;</span>, <span class="hljs-number">3</span>);                    <span class="hljs-operator">|</span> 重复字符<span class="hljs-string">&#x27;boy&#x27;</span>三次<span class="hljs-operator">-</span><span class="hljs-string">&#x27;boyboyboy&#x27;</span>                           <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> reverse(<span class="hljs-string">&#x27;chinese&#x27;</span>);                  <span class="hljs-operator">|</span> 反向排序<span class="hljs-operator">-</span><span class="hljs-string">&#x27;esenihc&#x27;</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> length(<span class="hljs-string">&#x27;chinese&#x27;</span>);                   <span class="hljs-operator">|</span> 返回字符串的长度<span class="hljs-number">-7</span>                                      <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">upper</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>), <span class="hljs-built_in">lower</span>(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> ucase(<span class="hljs-string">&#x27;chINese&#x27;</span>), lcase(<span class="hljs-string">&#x27;chINese&#x27;</span>);  <span class="hljs-operator">|</span> 大写小写 CHINESE    chinese                             <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;i&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-3</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">position</span>(<span class="hljs-string">&#x27;e&#x27;</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">&#x27;chinese&#x27;</span>);          <span class="hljs-operator">|</span> 返回<span class="hljs-string">&#x27;i&#x27;</span>在<span class="hljs-string">&#x27;chinese&#x27;</span>的第一个位置<span class="hljs-number">-5</span>                        <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abd&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数小于第二个返回负数<span class="hljs-operator">-</span> <span class="hljs-number">-1</span>            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> strcmp(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;abb&#x27;</span>);                <span class="hljs-operator">|</span> 比较字符串，第一个参数大于第二个返回正数<span class="hljs-operator">-</span> <span class="hljs-number">1</span>             <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.4</span> 时间函数<br><br><span class="hljs-operator">|</span> 语句                                                         <span class="hljs-operator">|</span> 含义                                         <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-comment">------------------------------------------------------------ | -------------------------------------------- |</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">current_date</span>, <span class="hljs-built_in">current_time</span>, now();                    <span class="hljs-operator">|</span> <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span>   <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span>    <span class="hljs-number">2018</span><span class="hljs-number">-01</span><span class="hljs-number">-13</span> <span class="hljs-number">12</span>:<span class="hljs-number">33</span>:<span class="hljs-number">43</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">hour</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">minute</span>(<span class="hljs-built_in">current_time</span>), <span class="hljs-keyword">second</span>(<span class="hljs-built_in">current_time</span>); <span class="hljs-operator">|</span> <span class="hljs-number">12</span>  <span class="hljs-number">31</span>   <span class="hljs-number">34</span>                                  <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">year</span>(<span class="hljs-built_in">current_date</span>), <span class="hljs-keyword">month</span>(<span class="hljs-built_in">current_date</span>), week(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">2018</span>    <span class="hljs-number">1</span>   <span class="hljs-number">1</span>                                <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> quarter(<span class="hljs-built_in">current_date</span>);                                <span class="hljs-operator">|</span> <span class="hljs-number">1</span>                                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> monthname(<span class="hljs-built_in">current_date</span>), dayname(<span class="hljs-built_in">current_date</span>);       <span class="hljs-operator">|</span> January  Saturday                            <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">SELECT</span> dayofweek(<span class="hljs-built_in">current_date</span>), dayofmonth(<span class="hljs-built_in">current_date</span>), dayofyear(<span class="hljs-built_in">current_date</span>); <span class="hljs-operator">|</span> <span class="hljs-number">7</span>   <span class="hljs-number">13</span>  <span class="hljs-number">13</span>                                   <span class="hljs-operator">|</span><br><br>### <span class="hljs-number">7.5</span> 控制流函数<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> if(<span class="hljs-number">3</span><span class="hljs-operator">&gt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>), if(<span class="hljs-number">3</span><span class="hljs-operator">&lt;</span><span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>);`    <br><br>  t f<br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> ifnull(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;t&#x27;</span>), ifnull(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;t&#x27;</span>);`    <br><br>  t <span class="hljs-number">2</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> isnull(<span class="hljs-number">1</span>), isnull(<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">0</span>);`    <br><br>   <span class="hljs-number">0</span> <span class="hljs-number">1</span> 是<span class="hljs-keyword">null</span>返回<span class="hljs-number">1</span>，不是<span class="hljs-keyword">null</span>返回<span class="hljs-number">0</span><br><br><span class="hljs-operator">-</span> `<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">nullif</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);`    <br><br>  <span class="hljs-keyword">null</span> a 参数相同或成立返回<span class="hljs-keyword">null</span>，不同或不成立则返回第一个参数<br><br><span class="hljs-operator">-</span> ```<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-number">2</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;first&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;second&#x27;</span><br>         <span class="hljs-keyword">WHEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;third&#x27;</span><br>         <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;other&#x27;</span><br>         <span class="hljs-keyword">END</span> ;     <br></code></pre></td></tr></table></figure>second&gt; 这一块不是完全看不懂吗！</code></pre></li></ul><h1 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h1><table><thead><tr><th>语句</th><th>含义</th></tr></thead><tbody><tr><td>SELECT database();</td><td>当前数据库名-test</td></tr><tr><td>SELECT connection_id();</td><td>当前用户id-306</td></tr><tr><td>SELECT user();</td><td>当前用户-root@localhost</td></tr><tr><td>SELECT version();</td><td>当前mysql版本</td></tr><tr><td>SELECT found_rows();</td><td>返回上次查询的检索行数</td></tr></tbody></table><h2 id="8-存储过程"><a href="#8-存储过程" class="headerlink" title="8 存储过程"></a>8 存储过程</h2><h3 id="8-1-创建存储过程"><a href="#8-1-创建存储过程" class="headerlink" title="8.1 创建存储过程"></a>8.1 创建存储过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">DELIMITER <span class="hljs-comment">//    # 无参数</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> ;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_2</span><span class="hljs-params">(<span class="hljs-keyword">IN</span> id INT)</span>    # <span class="hljs-title">in</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SELECT</span> * <span class="hljs-title">FROM</span> <span class="hljs-title">test</span> <span class="hljs-title">WHERE</span> <span class="hljs-title">a</span> = <span class="hljs-title">id</span>;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_3</span><span class="hljs-params">(<span class="hljs-keyword">OUT</span> sum INT)</span>    # <span class="hljs-title">out</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">sum</span> = <span class="hljs-params">(<span class="hljs-keyword">SELECT</span> count(*)</span> <span class="hljs-title">FROM</span> <span class="hljs-title">test</span>);</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">getDates_4</span><span class="hljs-params">(INOUT i INT)</span>    # <span class="hljs-title">inout</span>参数</span><br><span class="hljs-function">  <span class="hljs-title">BEGIN</span></span><br><span class="hljs-function">    <span class="hljs-title">SET</span> <span class="hljs-title">i</span> = <span class="hljs-title">i</span> + 1;</span><br>  <span class="hljs-keyword">END</span> <span class="hljs-comment">//</span><br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="8-2-删除存储过程"><a href="#8-2-删除存储过程" class="headerlink" title="8.2 删除存储过程"></a>8.2 删除存储过程</h3><ul><li><code>DROP PROCEDURE IF EXISTS getDates;</code></li></ul><h3 id="8-3-修改存储过程的特性"><a href="#8-3-修改存储过程的特性" class="headerlink" title="8.3 修改存储过程的特性"></a>8.3 修改存储过程的特性</h3><ul><li><code>ALTER PROCEDURE getDates MODIFIES SQL DATA ;</code></li></ul><h3 id="8-4-查看存储过程"><a href="#8-4-查看存储过程" class="headerlink" title="8.4 查看存储过程"></a>8.4 查看存储过程</h3><ul><li><p><code>SHOW PROCEDURE STATUS LIKE &#39;getDates&#39;;</code>    </p><p> 状态</p></li><li><p><code>SHOW CREATE PROCEDURE getDates_3;</code> </p><p> 语句</p></li></ul><h3 id="8-5-调用存储过程"><a href="#8-5-调用存储过程" class="headerlink" title="8.5 调用存储过程"></a>8.5 调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> getDates();<br><span class="hljs-keyword">CALL</span> getDates_2(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">CALL</span> getDates_3(<span class="hljs-variable">@s</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@s</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">CALL</span> getDates_4(<span class="hljs-variable">@i</span>);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@i</span>;    # <span class="hljs-variable">@i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="9-数据库安全"><a href="#9-数据库安全" class="headerlink" title="9 数据库安全"></a>9 数据库安全</h2><h3 id="9-1-数据库备份"><a href="#9-1-数据库备份" class="headerlink" title="9.1 数据库备份"></a>9.1 数据库备份</h3><ul><li><pre><code>mysqldump -u root -p db_name &gt; file.sqlmysqldump -u root -p db_name table_name &gt; file.sql</code></pre><h3 id="9-2数据库还原"><a href="#9-2数据库还原" class="headerlink" title="9.2数据库还原"></a>9.2数据库还原</h3></li><li><code>mysql -u root -p &lt; C:\file.sql</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>数据库</tag>
      
      <tag>MYSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>向量基础知识</title>
    <link href="/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/02/21/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在数学中，几何向量（也称为欧几里得向量，通常简称向量、矢量），指具有大小和方向的量。</p><p>向量可以形象化地表示为带箭头的线段。</p><p>箭头所指：代表向量的方向；线段长度：代表向量的大小。</p><p>标量：只有大小,没有方向。</p><h1 id="2-向量的运算"><a href="#2-向量的运算" class="headerlink" title="2. 向量的运算"></a>2. 向量的运算</h1><h2 id="2-1-基础运算"><a href="#2-1-基础运算" class="headerlink" title="2.1 基础运算"></a>2.1 基础运算</h2><table><thead><tr><th>运算</th><th>描述</th></tr></thead><tbody><tr><td>加减</td><td>各个分量分别相加减</td></tr><tr><td>数乘</td><td>向量与标量的乘数，可以对向量的长度进行缩放，如果标量&gt;0，向量的方向不变，如果&lt;0,向量的方向为反方向</td></tr></tbody></table><h2 id="2-2-点乘（点积）"><a href="#2-2-点乘（点积）" class="headerlink" title="2.2 点乘（点积）"></a>2.2 点乘（点积）</h2><p>两个向量点乘得到一个标量 ，数值等于两个向量长度相乘后再乘以二者夹角的余弦值 。<br>如果两个向量a,b均 为单位 向量 ,那么a.b等于向量b在向量a方向上的投影的长度</p><p>点乘后得到的是一个值</p><ul><li><p>若结果 == 0，则 两向量 互垂直 </p></li><li><p>若结果 &lt; 0 ，则 两向量夹角大于90°</p></li><li><p>若结果 &gt;0 ，则两向量夹角小于 90°</p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%82%B9%E4%B9%98.png" srcset="/img/loading.gif" alt="点乘"></p></li></ul><blockquote><p>两个单位向量的点积得到两个向量的夹角的cos值，通过它可以知道两个向量的相似性。</p></blockquote><blockquote><p>利用点积可判断一个多边形是否面向摄像机还是背向摄像机。</p></blockquote><blockquote><p>如果点积越大，说明夹角越小，则物理离光照的轴线越近，光照越强。</p></blockquote><h2 id="2-3-叉乘"><a href="#2-3-叉乘" class="headerlink" title="2.3 叉乘"></a>2.3 叉乘</h2><p>两个向量的叉乘得到一个新的向量，新向量垂直于原来两个向量，并且长度等于原向量长度相乘后再乘以夹角的正弦值，类似左手坐标系Z。</p><p>在Unity3D里面。两个向量的点乘所得到的是两个向量的余弦值，也就是-1 到1之间，0表示垂直，-1表示相反，1表示相同方向。 </p><p>两个向量的叉乘所得到的是两个向量所组成的面的垂直向量，分两个方向。 </p><p><img src="/images/%E5%90%91%E9%87%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8F%89%E4%B9%98.png" srcset="/img/loading.gif" alt="叉乘"></p><blockquote><p>简单的说，点乘判断角度，叉乘判断方向。 </p><p>形象的说当一个敌人在你身后的时候，叉乘可以判断你是往左转还是往右转更好的转向敌人，点乘得到你当前的面朝向的方向和你到敌人的方向的所成的角度大小。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>向量</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transform类</title>
    <link href="/2021/02/19/Transform%E7%B1%BB/"/>
    <url>/2021/02/19/Transform%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><strong>Transform</strong>组件是Unity3D的重点之一，主要用于控制物体的旋转、移动、缩放。</p><p><strong>Unity</strong>规定所有游戏物体都必须<strong>有且只有一个</strong>变换组件(<strong>Transform</strong>)且<strong>不能删除</strong>。</p><p>变换组件(<strong>Transform</strong>)实现了Unity的父子关系功能。</p><p>那么接下来我们将详细学习下<strong>Transform</strong>类所包含的成员变量和成员函数。</p><h1 id="2-父子关系"><a href="#2-父子关系" class="headerlink" title="2. 父子关系"></a>2. 父子关系</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>父子关系是Uniy中重要的基本概念之一。<br>当一个物体是另一个物体的父物体时，子物体会严格地随着父物体起移动、 旋转、缩放。<br>可以将父子关系理解为你的手臂与身体的关系，当身体移动时，手臂也定会跟着一 起移动， 且手臂还可以有自己下一级的子物体，比如手掌就是手名臂的子物体、手指是手掌的子物体等。</p><blockquote><p>在unity中带有local字样的属性也就意味着其数值是相对于父物体的。</p></blockquote><h2 id="2-2-底层原理与规则"><a href="#2-2-底层原理与规则" class="headerlink" title="2.2 底层原理与规则"></a>2.2 底层原理与规则</h2><p>规则：</p><ul><li>任何物体都可以有多个子物体，但是每个物体都只能有一个父物体。</li></ul><p>原理：</p><p>这种父子关系组成一个树状的层级结构，最基层的那个物体是唯一不具有父物体的物体，它被称为根节点。</p><p>由于物体的移动、旋转、缩放与父子关系密切相关，且游戏物体和变换组件是一一对应的。所以在Unity中，游戏物体的层级结构完全可以理解为变换组件的层级结构。父子关系的操作在脚本中确实是在变换组件上进行的。<br>子物体的变换组件的参数其实是相对父物体的值，再次考虑之前身体和手臂的例子，无论身体如何移动，手臂和身体的连接处是固定不变的。</p><h2 id="2-3-关于父子物体的一些现象"><a href="#2-3-关于父子物体的一些现象" class="headerlink" title="2.3 关于父子物体的一些现象"></a>2.3 关于父子物体的一些现象</h2><h3 id="2-3-1-position："><a href="#2-3-1-position：" class="headerlink" title="2.3.1 position："></a>2.3.1 position：</h3><ul><li><p>改变父物体的position，父物体连同子物体一起移动；</p></li><li><p>改变子物体的position，父物体不随子物体移动。</p></li><li><p>当子物体的position设置为（0，0，0）时，子物体与父物体中心点重合。</p></li></ul><h3 id="2-3-2-rotation："><a href="#2-3-2-rotation：" class="headerlink" title="2.3.2 rotation："></a>2.3.2 rotation：</h3><p>介绍两个位于unity快捷工具栏右侧的选项：<strong>Pivot</strong>与<strong>Local</strong></p><ul><li><p><strong>Poivt</strong></p><p>用于调节物体轴心点，有两个子选项</p><ul><li><p>Pivot    父物体的中心点</p></li><li><p>Center 当前父子物体的中心点</p></li></ul></li><li><p><strong>Local</strong><br>用于调节当前被选中物体的坐标轴，有两个子选项</p><ul><li><p>Local    自身坐标系</p></li><li><p>World  世界坐标系</p></li></ul></li></ul><h3 id="2-3-3-Scale"><a href="#2-3-3-Scale" class="headerlink" title="2.3.3 Scale:"></a>2.3.3 Scale:</h3><p><strong>子物体的真实缩放比例Scale=子物体Scale比例×父物体Scale比例</strong></p><p>可以通过下述代码在unity脚本中直接查看：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#">Vector3 _truthScale = <span class="hljs-keyword">this</span>.transform.LossyScale;<span class="hljs-comment">//此属性为只读属性</span><br></code></pre></td></tr></table></figure><h2 id="2-4-坐标系的选择"><a href="#2-4-坐标系的选择" class="headerlink" title="2.4 坐标系的选择"></a>2.4 坐标系的选择</h2><p>局部坐标与世界坐标各有各的适用情况：</p><ul><li><p>在搭建场景时，我们更喜欢使用局部坐标系<br>比如移动一个房屋时，屋子里所有的东西都会跟着一起移动;</p></li><li><p>而在编写游戏逻辑时，更多的时候需要获得物体在空间中的实际位置。<br>比如我们要将摄像机对准人物的眼睛，这时候眼睛和人物的相对坐标就没有太大价值，而应当让摄像机对准眼睛在世界坐标系中的位置。</p></li></ul><p>所以，在脚本系统中，变换组件的大部分操作都提供了两类操作方式，分别是世界坐标系的和局部坐标系的，我们可以根据需求进行使用。</p><h2 id="2-5-关于父子物体使用的小技巧"><a href="#2-5-关于父子物体使用的小技巧" class="headerlink" title="2.5 关于父子物体使用的小技巧"></a>2.5 关于父子物体使用的小技巧</h2><p>在处理美工交过来的模型时，推荐将模型拉入一个空的gameobject，形成父子物体关系，组件只给空的gameobject上。</p><p>这样就可以防止日后更换模型时需要重新上组件的情况。</p><p>空物体通常用来管理和控制多个相互之间无关联的游戏物体。</p><h1 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3. 成员变量"></a>3. 成员变量</h1><table><thead><tr><th>position</th><th>在世界空间坐标transform的位置。</th></tr></thead><tbody><tr><td>localPosition</td><td>相对于父级的变换的位置。  如果该变换没有父级，那么等同于Transform.position。</td></tr><tr><td>eulerAngles</td><td>世界坐标系中的旋转（欧拉角）。</td></tr><tr><td>localEulerAngles</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>right</td><td>世界坐标系中的右方向。  （世界空间坐标变换的红色轴。也就是x轴。）</td></tr><tr><td>up</td><td>世界坐标系中的上方向。  （在世界空间坐标变换的绿色轴。也就是y轴。）</td></tr><tr><td>forward</td><td>世界坐标系中的前方向。  （在世界空间坐标变换的蓝色轴。也就是z轴。）</td></tr><tr><td>rotation</td><td>世界坐标系中的旋转（四元数）。</td></tr><tr><td>localRotation</td><td>相对于父级的变换旋转角度。</td></tr><tr><td>localScale</td><td>相对于父级的缩放比例。</td></tr><tr><td>parent</td><td>父对象Transform组件。</td></tr><tr><td>worldToLocalMatrix</td><td>矩阵变换的点从世界坐标转为自身坐标（只读）。</td></tr><tr><td>localToWorldMatrix</td><td>矩阵变换的点从自身坐标转为世界坐标（只读）。</td></tr><tr><td>root</td><td>对象层级关系中的根对象的Transform组件。</td></tr><tr><td>childCount</td><td>子对象数量。</td></tr><tr><td>lossyScale</td><td>全局缩放比例（只读）。</td></tr></tbody></table><h1 id="4-成员函数"><a href="#4-成员函数" class="headerlink" title="4. 成员函数"></a>4. 成员函数</h1><h2 id="4-1-LookAt函数"><a href="#4-1-LookAt函数" class="headerlink" title="4.1 LookAt函数"></a>4.1 LookAt函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void LookAt(Transform target);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition);</td></tr><tr><td>public void  LookAt(Vector3 worldPosition, Vector3 worldUp = Vector3.up);</td></tr><tr><td>public void  LookAt(Transform target, Vector3 worldUp = Vector3.up);</td></tr></tbody></table><p>旋转物体，使物体的z轴指向<strong>target/worldPosition</strong>，对于<strong>worldUp</strong>的描述是，在完成上面的旋转之后，继续旋转自身，使得当前对象的正y轴朝向与worldUp所指向的朝向一致。</p><p>这里的朝向一致指的是新旋转后的y轴与<strong>worldUp</strong>在该对象初次旋转后的xy平面上的投影向量一致。之所以取投影是因为第一次旋转使物体的z轴指向<strong>target/worldPosition</strong>后，此时的<strong>worldUp</strong>向量可能不在xy平面上，要在z轴指向<strong>target/worldPosition</strong>前提下是y轴朝向与<strong>worldUp</strong>一致，只能取<strong>worldUp</strong>在xy平面上的投影。</p><blockquote><p>注意：使用<strong>worldPosition向量</strong>时要注意方向，一定是<strong>target-transform.position</strong>，顺序反了会使物体背向目标；若使用<strong>Transform</strong>作为参数，则不必注意。默认情况下，<strong>worldUp</strong>是<strong>Vector3.up</strong>（世界坐标系下的y轴）</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="4-2-Rotate函数"><a href="#4-2-Rotate函数" class="headerlink" title="4.2 Rotate函数"></a>4.2 Rotate函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 eulerAngles);</td></tr><tr><td>public void  Rotate(Vector3 eulerAngles, Space relativeTo = Space.Self);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle);</td></tr><tr><td>public void  Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo =  Space.Self);</td></tr></tbody></table><p>旋转一个欧拉角度，它按照zxy的顺序进行旋转，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public void  Rotate(Vector3 axis, float angle);</td></tr><tr><td>public void  Rotate(Vector3 axis, float angle,Space relativeTo = Space.Self);</td></tr></tbody></table><p>绕axis轴旋转angle角度，默认情况下局部坐标系下<strong>Space.Self</strong>。</p><p><strong>transform.rotation</strong>和<strong>Rotate</strong>有个区别：</p><ul><li><p>Rotate()方法是： 旋转多少度。</p><p>在原有的基础上累加，即旋转了多少角度。  又旋转了多少角度，是在原有的基础上在旋转</p></li><li><p>rotation属性是：  旋转到某个角度，就是是在update中每帧都执行。 </p><p> 但每次旋转到的角度都是5，所以是旋转到5度。一直都是。 </p></li></ul><p>比如你只想让他旋转到多少, 用rotation; 假如想让他一直转,可以用Rotate</p><p>rotation直接改变了数值, 以达到旋转效果</p><p>Rotate应用一个的旋转角度每秒1度慢慢的旋转物体</p><p>当然:rotation()还可以通过插值旋转</p><h2 id="4-3-RotateAround函数"><a href="#4-3-RotateAround函数" class="headerlink" title="4.3 RotateAround函数"></a>4.3 RotateAround函数</h2><p>让物体以某一点为轴心成圆周运动。</p><p><code>public void RotateAround (point : Vector3, axis : Vector3, angle : float) : void</code></p><p>让物体以<strong>point</strong>为中心，绕<strong>axis</strong>为轴向旋转<strong>angle</strong>度。保持原来与<strong>point</strong>的距离。</p><h2 id="4-4-TransformDirection函数"><a href="#4-4-TransformDirection函数" class="headerlink" title="4.4 TransformDirection函数"></a>4.4 TransformDirection函数</h2><table><thead><tr><th>函数的多种重载</th></tr></thead><tbody><tr><td>public Vector3  TransformDirection(Vector3 direction);</td></tr><tr><td>public Vector3  TransformDirection(float x, float y, float z);</td></tr></tbody></table><p>从自身坐标到世界坐标变换方向（这个强调的是方向）这个操作不会受到变换的缩放和位置的影响。</p><p>返回的向量与<strong>direction</strong>有同样的长度。</p><h2 id="4-5-InverseTransformDirection函数"><a href="#4-5-InverseTransformDirection函数" class="headerlink" title="4.5 InverseTransformDirection函数"></a>4.5 InverseTransformDirection函数</h2><table><thead><tr><th>重载的多种函数</th></tr></thead><tbody><tr><td>public Vector3  InverseTransformDirectionTransformDirection (direction : Vector3)  : Vector3</td></tr><tr><td>public Vector3  InverseTransformDirectionTransformDirection (x : float, y : float,  z : float) : Vector3</td></tr></tbody></table><p>与<strong>TransformDirection</strong>相反，从世界坐标转换到自身相对坐标。</p><h2 id="4-6-TransformPoint函数"><a href="#4-6-TransformPoint函数" class="headerlink" title="4.6 TransformPoint函数"></a>4.6 TransformPoint函数</h2><table><thead><tr><th>public Vector3  TransformPoint(Vector3 position);</th></tr></thead><tbody><tr><td>public Vector3  TransformPoint(float x, float y, float z);</td></tr></tbody></table><p>变换位置从自身坐标到世界坐标。</p><p>注意，返回位置受缩放影响</p><h2 id="4-7-InverseTransformPoint函数"><a href="#4-7-InverseTransformPoint函数" class="headerlink" title="4.7 InverseTransformPoint函数"></a>4.7 InverseTransformPoint函数</h2><table><thead><tr><th>public  Vector3 InverseTransformPoint (position : Vector3)  : Vector3</th></tr></thead><tbody><tr><td>public  Vector3 InverseTransformPoint (x : float, y : float, z  : float) : Vector3</td></tr></tbody></table><p>把一个点从时间坐标转换到自身坐标的位置。</p><h2 id="4-8-TransformVector函数"><a href="#4-8-TransformVector函数" class="headerlink" title="4.8 TransformVector函数"></a>4.8 TransformVector函数</h2><table><thead><tr><th>public Vector3  TransformVector(Vector3 vector);</th></tr></thead><tbody><tr><td>public Vector3  TransformVector(float x, float y, float z);</td></tr></tbody></table><p>变换一个向量从局部坐标空间到世界坐标空间。</p><p>这个操作不受变换位置的影响，但是受缩放的影响</p><h2 id="4-9-Translate函数"><a href="#4-9-Translate函数" class="headerlink" title="4.9 Translate函数"></a>4.9 Translate函数</h2><table><thead><tr><th>public void  Translate(Vector3 translation);</th></tr></thead><tbody><tr><td>public void  Translate(Vector3 translation, Space relativeTo = Space.Self);</td></tr></tbody></table><p>沿着<strong>translation</strong>方向移动<strong>translation</strong>向量长度的距离。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(float x, float y, float z);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Space relativeTo = Space.Self);</td></tr></tbody></table><p>移动变换由x沿着x轴，y沿着y轴，z沿着z轴。</p><p>如果<strong>relativeTo</strong>留空或者设置为<strong>Space.Self</strong>，移动被应用相对于自身坐标系</p><table><thead><tr><th>public void  Translate(Vector3 translation, Transform relativeTo);</th></tr></thead><tbody><tr><td>public void  Translate(float x, float y, float z, Transform relativeTo);</td></tr></tbody></table><p>第一个参数的解释跟前面的一样，重点在移动<strong>relativeTo</strong>，解释为被应用相对于（relativeTo :Transform）的自身坐标系统。</p><p>日光相对于为<strong>null</strong>，则移动被应用相对于世界坐标系统</p><p>例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-comment">//相对于摄像机每秒1单位向右移动物体</span><br><br>transform.Translate(Vector3.right * Time.deltaTime, Camera.main.transform);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-DetachChildren函数"><a href="#4-10-DetachChildren函数" class="headerlink" title="4.10 DetachChildren函数"></a>4.10 DetachChildren函数</h2><p><code>public void DetachChildren () : void</code></p><p>把自身所有的子物体的父物体都设成世界，也就是跟自己的所有子物体接触父子关系。</p><h2 id="4-11-Find-函数"><a href="#4-11-Find-函数" class="headerlink" title="4.11 Find 函数"></a>4.11 <strong>Find</strong> <strong>函数</strong></h2><p><code>public Transform Find (name : string) : Transform</code></p><p>找到一个名字是name的物体并返回</p><p>如果没有找到则返回null。如果字符串被/隔离，函数则会像文件路径一样逐级下查。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// The magical rotating finger</span><br><br><span class="hljs-function">function <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span> &#123;<br><br>aFinger = transform.Find(<span class="hljs-string">&quot;LeftShoulder/Arm/Hand/Finger&quot;</span>);<br><br>aFinger.Rotate(Time.deltaTime*<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-12-IsChildOf函数"><a href="#4-12-IsChildOf函数" class="headerlink" title="4.12 IsChildOf函数"></a>4.12 IsChildOf函数</h2><p><code>public bool IsChildOf (parent : Transform) : bool</code></p><p>如果物体是<strong>parent</strong>的父子层级关系下的一员，返回<strong>true</strong>;</p><h1 id="5-组件使用注意事项"><a href="#5-组件使用注意事项" class="headerlink" title="5. 组件使用注意事项"></a>5. 组件使用注意事项</h1><h2 id="5-1-非等比缩放的问题"><a href="#5-1-非等比缩放的问题" class="headerlink" title="5.1 非等比缩放的问题"></a>5.1 非等比缩放的问题</h2><p>某些组件不完全支持非等比缩放，在非等比缩放的情况下可能会出现意想不到的结果。<br>因为当该游戏物体具有一个球体或者胶囊体的外壳，而这些外壳的大小是通过一个半径参数指定的。<br>在物体或者父物体被拉伸或压扁的时候，这些组件的球体范围并不会跟着压扁成椭球体，它们实际上仍然是球体或胶囊体。<br>所以当物体中具有这类组件时，由于组件形状和物体形状不一致，可能会导致穿透模型被意外阻挡等情况发生。</p><p>例如，碰撞体、角色控制器这些组件和灯光、音源。</p><p>这些问题不致命，但是会引起奇怪的bug。</p><h2 id="5-2-其它注意事项"><a href="#5-2-其它注意事项" class="headerlink" title="5.2 其它注意事项"></a>5.2 其它注意事项</h2><ul><li>当为一个物体添加子物体时， 可以考虑先将父物体的位置设置为原点，这样子物体的局部坐标系就和世界坐标系重合，方便我们指定子物体的准确位置。</li><li>粒子系统不会受变换组件的缩放系数的影响。要改变- -个粒子的整体比例，还是需要在粒子系统中适当改变相关参数。</li><li>修改物体缩放比例时不仅会直接影响子物体的比例，还会影响子物体的实际位置(因为要保证相对位置不变)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MonoBehaviour基类</title>
    <link href="/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/"/>
    <url>/2021/02/19/MonoBehaviour%E5%9F%BA%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-脚本基类-MonoBehaviour"><a href="#Unity-脚本基类-MonoBehaviour" class="headerlink" title="Unity 脚本基类 MonoBehaviour"></a>Unity 脚本基类 MonoBehaviour</h1><h2 id="1-MonoBehaviour-简介"><a href="#1-MonoBehaviour-简介" class="headerlink" title="1. MonoBehaviour 简介"></a>1. MonoBehaviour 简介</h2><p><strong>MonoBehaviour</strong> 是 <strong>Unity</strong> 中所有脚本的基类。</p><p>如果你使用<strong>JS</strong>的话，脚本会自动继承<strong>MonoBehaviour</strong>。</p><p>如果使用<strong>C#**的话，你需要显式继承</strong>MonoBehaviour**。</p><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h2><p>下面用一张图来更形象地说明一下这几个类的在<strong>MonoBehaviour</strong>的<em>生命周期</em>中是如何被调用的：<br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125028717" srcset="/img/loading.gif" alt="这里写图片描述"></p><h2 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h2><h3 id="3-1-不可重写函数："><a href="#3-1-不可重写函数：" class="headerlink" title="3.1 不可重写函数："></a>3.1 不可重写函数：</h3><h4 id="3-1-1-Invoke函数"><a href="#3-1-1-Invoke函数" class="headerlink" title="3.1.1 Invoke函数"></a>3.1.1 Invoke函数</h4><p><code>function Invoke (methodName : string, time : float) : void</code><br>在 <strong>time</strong> 秒之后，调用 <strong>methodName</strong> 方法；</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">example</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><span class="hljs-keyword">public</span> Rigidbody projectile;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchProjectile</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Rigidbody instance = Instantiate(projectile);<br>    instance.velocity = Random.insideUnitSphere * <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Invoke(<span class="hljs-string">&quot;LaunchProjectile&quot;</span>, <span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-InvokeRepeating"><a href="#3-1-2-InvokeRepeating" class="headerlink" title="3.1.2 InvokeRepeating"></a>3.1.2 InvokeRepeating</h4><p><code>function InvokeRepeating (methodName : string, time : float, repeatRate : float) : void</code><br>从第一次调用开始,每隔<strong>repeatRate</strong>时间调用一次.</p><h4 id="3-1-3-CancelInvoke"><a href="#3-1-3-CancelInvoke" class="headerlink" title="3.1.3 CancelInvoke"></a>3.1.3 CancelInvoke</h4><p><code>function CancelInvoke () : void</code><br>取消这个<strong>MonoBehaviour</strong>上的所有调用<strong>Invoke</strong>。</p><h4 id="3-1-4-IsInvoking"><a href="#3-1-4-IsInvoking" class="headerlink" title="3.1.4 IsInvoking"></a>3.1.4 IsInvoking</h4><p><code>function IsInvoking (methodName : string) : bool</code><br>某指定函数是否在等候调用。</p><h4 id="3-1-5-StartCoroutine"><a href="#3-1-5-StartCoroutine" class="headerlink" title="3.1.5 StartCoroutine"></a>3.1.5 StartCoroutine</h4><p><code>function StartCoroutine (routine : IEnumerator) : Coroutine</code><br>一个协同程序在执行过程中,可以在任意位置使用 <strong>yield</strong> 语句。</p><p><strong>yield</strong> 的返回值控制何时恢复协同程序向下执行。</p><p>协同程序在对象自有帧执行过程中堪称优秀。协同程序在性能上没有更多的开销。</p><p><strong>StartCoroutine</strong>函数是立刻返回的,但是<strong>yield</strong>可以延迟结果。直到协同程序执行完毕。</p><h4 id="3-1-6-StopCoroutine-StopAllCoroutines"><a href="#3-1-6-StopCoroutine-StopAllCoroutines" class="headerlink" title="3.1.6 StopCoroutine / StopAllCoroutines"></a>3.1.6 StopCoroutine / StopAllCoroutines</h4><h3 id="3-2-可重写函数："><a href="#3-2-可重写函数：" class="headerlink" title="3.2 可重写函数："></a>3.2 可重写函数：</h3><p>可重写函数会在游戏中发生某些事件的时候被调用。</p><p>我们在<strong>Unity</strong>中最常用到的几个可重写函数是这几个：</p><table><thead><tr><th align="left">可重写函数</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>Awake</code></td><td>当一个脚本被实例化时，<strong>Awake</strong> 被调用。我们大多在这个类中完成成员变量的初始化。</td></tr><tr><td align="left"><code>Start</code></td><td>仅在 <strong>Update</strong> 函数第一次被调用前调用。因为它是在<strong>Awake</strong> 之后被调用的，我们可以把一些需要依赖 <strong>Awake</strong> 的变量放在<strong>Start</strong>里面初始化。 同时我们还大多在这个类中执行 <strong>StartCoroutine</strong> 进行一些协程的触发。要注意在用C#写脚本时，必须使用 <strong>StartCoroutine</strong> 开始一个协程，但是如果使用的是 <strong>JavaScript</strong>，则不需要这么做。</td></tr><tr><td align="left"><code>Update</code></td><td>当开始播放游戏帧时（此时，<strong>GameObject</strong> 已实例化完毕），其 **Update **在 每一帧 被调用。</td></tr><tr><td align="left"><code>LateUpdate</code></td><td><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。</td></tr><tr><td align="left"><code>FixedUpdate</code></td><td>当 <strong>MonoBehaviour</strong>启用时，其 <strong>FixedUpdate</strong> 在每一固定帧被调用</td></tr><tr><td align="left"><code>OnEnable</code></td><td>当对象变为可用或激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDisable</code></td><td>当对象变为不可用或非激活状态时此函数被调用</td></tr><tr><td align="left"><code>OnDestroy</code></td><td>当 <strong>MonoBehaviour</strong> 将被销毁时，这个函数被调用</td></tr></tbody></table><h4 id="3-2-1-Update"><a href="#3-2-1-Update" class="headerlink" title="3.2.1 Update"></a>3.2.1 Update</h4><p>当 <strong>MonoBehaviour</strong> 实例化完成之后，<strong>Update</strong> 在每一帧被调用。</p><p>所以Update函数可以用来实现用户输入、角色移动和角色行动等功能。</p><p>基本上大部分游戏逻辑都离不开Update函数。</p><p>Unity 提供了非常多的基本方法来读取输入、查找某个游戏物体、查找组件、修改组件信息等，这些方法都可以在Update函数中使用，用来完成实际的游戏功能。</p><h4 id="3-2-2-LateUpdate"><a href="#3-2-2-LateUpdate" class="headerlink" title="3.2.2 LateUpdate"></a>3.2.2 LateUpdate</h4><p><strong>LateUpdate</strong> 是在所有 <strong>Update</strong> 函数调用后被调用。这可用于调整脚本执行顺序。</p><p>例如:当物体在Update里移动时，跟随物体的相机可以在<strong>LateUpdate</strong>里实现。</p><h4 id="3-2-3-FixedUpdate"><a href="#3-2-3-FixedUpdate" class="headerlink" title="3.2.3 FixedUpdate"></a>3.2.3 FixedUpdate</h4><p>处理 <strong>Rigidbody</strong> 时，需要用<strong>FixedUpdate</strong>代替<strong>Update</strong>。</p><p>例如:给刚体加一个作用力时，你必须应用作用力在<strong>FixedUpdate</strong>里的固定帧，而不是<strong>Update</strong>中的帧。(两者帧长不同)</p><h4 id="3-2-4-Awake"><a href="#3-2-4-Awake" class="headerlink" title="3.2.4 Awake"></a>3.2.4 Awake</h4><p><strong>Awake</strong> 用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次。<strong>Awake</strong> 在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如 <strong>GameObject.FindWithTag</strong> 这样的函数搜索它们。</p><p>每个游戏物体上的<strong>Awke</strong>以随机的顺序被调用。因此，你应该用<strong>Awake</strong>来设置脚本间的引用，并用<strong>Start</strong>来传递信息<strong>Awake</strong>总是在<strong>Start</strong>之前被调用。它不能用来执行协同程序。</p><p>C#和Boo用户注意：<strong>Awake</strong> 不同于构造函数，物体被构造时并没有定义组件的序列化状态。<strong>Awake</strong>像构造函数一样只被调用一次。</p><h4 id="3-2-5-Start"><a href="#3-2-5-Start" class="headerlink" title="3.2.5 Start"></a>3.2.5 Start</h4><p><strong>Start</strong>在<strong>behaviour</strong>的生命周期中只被调用一次。<br>它和 <strong>Awake</strong> 的不同是，<strong>Start</strong> 只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。<strong>Awake</strong> 总是在<strong>Start</strong>之前执行。</p><p>Start函数适合用来做一些初始化工作。<br>对有经验的程序编写者来说，要注意脚本组件通常不使用构造函数来做初始化，因为构造函数可控制性较差，会导致调用时机和预想的不一致。 所以最好的方式是遵循Unity的设计惯例。</p><h4 id="3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag"><a href="#3-2-6-OnMouseEnter-／OnMouseOver-／-OnMouseExit-／-OnMouseDown-／-OnMouseUp-／-OnMouseDrag" class="headerlink" title="3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag"></a>3.2.6 OnMouseEnter ／OnMouseOver ／ OnMouseExit ／ OnMouseDown ／ OnMouseUp ／ OnMouseDrag</h4><p>当鼠标进入 ／ 悬浮 ／ 移出 ／ 点击 ／ 释放 ／ 拖拽<strong>GUIElement</strong>(GUI元素)或<strong>Collider</strong>(碰撞体)中时调用<strong>OnMouseEnter</strong>。</p><h4 id="3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay"><a href="#3-2-7-OnTriggerEnter／OnTriggerExit／OnTriggerStay" class="headerlink" title="3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay"></a>3.2.7 OnTriggerEnter／OnTriggerExit／OnTriggerStay</h4><p>当<strong>Collider</strong>(碰撞体)进入 ／ 退出 ／ 停留在 <strong>trigger</strong>(触发器)时调用<strong>OnTriggerEnter</strong>。</p><p><strong>OnTriggerStay</strong> 将会在每一帧被调用。</p><h4 id="3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay"><a href="#3-2-8-OnCollisionEnter／OnCollisionExit／OnCollisionStay" class="headerlink" title="3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay"></a>3.2.8 OnCollisionEnter／OnCollisionExit／OnCollisionStay</h4><p>当此<strong>collider/rigidbody</strong>触发另一个<strong>rigidbody/collider</strong>时，被调用。</p><p><strong>OnCollisionStay</strong> 将会在每一帧被调用。</p><h2 id="4-脚本与GameObject的关系"><a href="#4-脚本与GameObject的关系" class="headerlink" title="4. 脚本与GameObject的关系"></a>4. 脚本与GameObject的关系</h2><p>被显式添加到 <strong>Hierarchy</strong> 中的 <strong>GameObject</strong> 会被最先实例化，<strong>GameObject</strong> 被实例化的顺序是从下往上。<strong>GameObject</strong> 被实例化的同时，加载其组件 <strong>component</strong> 并实例化，如果挂载了脚本组件，则实例化脚本组件时，将调用脚本的 <strong>Awake</strong> 方法，组件的实例化顺序是也是从下往上。在所有显式的 <strong>GameObject</strong> 及其组件被实例化完成之前，游戏不会开始播放帧。</p><p>当 <strong>GameObject</strong> 实例化工作完成之后，将开始播放游戏帧。每个脚本的第一帧都是调用 <strong>Start</strong> 方法，其后每一帧调用 <strong>Update</strong>，而且每个脚本在每一帧中的调用顺序是从下往上。</p><blockquote><p>总结：被挂载到 <strong>GameObject</strong> 下面的脚本会被实例化成 <strong>GameObject</strong> 的一个成员。</p></blockquote><h3 id="4-1-脚本变量的引用"><a href="#4-1-脚本变量的引用" class="headerlink" title="4.1 脚本变量的引用"></a>4.1 脚本变量的引用</h3><p>在脚本中声明另一个脚本的变量。在 <strong>ClassA</strong> 中建立一个 <strong>public</strong> 的变量类型是 <strong>ClassB</strong>。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-1-非同一个-GameObject-的脚本引用"><a href="#4-1-1-非同一个-GameObject-的脚本引用" class="headerlink" title="4.1.1 非同一个 GameObject 的脚本引用"></a>4.1.1 非同一个 GameObject 的脚本引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125148891" srcset="/img/loading.gif" alt="这里写图片描述"><br><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125157563" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，如果 <strong>classA</strong> 中的成员 <strong>B</strong> 想要引用由 <strong>GameObjectB</strong> new 出来的 <strong>classB</strong> 对象，只需要将 <strong>GameObjectB</strong> 拖拽到 <strong>GameObjectA</strong> 中 <strong>classA</strong> 脚本即可。</p><h4 id="4-1-2-同一个-GameObject-中互相引用"><a href="#4-1-2-同一个-GameObject-中互相引用" class="headerlink" title="4.1.2 同一个 GameObject 中互相引用"></a>4.1.2 同一个 GameObject 中互相引用</h4><p>情况如下：</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125328273" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>此时，发现没法通过拖拽的方式建立 <strong>classA</strong> 和 <strong>classB</strong> 的引用。因为 <strong>Unity</strong> 编辑器里面的拖拽绑定方式是 <strong>GameObject</strong> 级别的。</p><p>那么此时如何解决互相引用的问题呢？此时，需要用到 <strong>gameObject</strong> 这个变量。</p><p>被挂载到 <strong>GameObject</strong> 中的脚本，被实例化时，其内部继承自 <strong>Monobehavior</strong> 的 <strong>gameObject</strong> 成员会绑定所挂载的 <strong>GameObject</strong> 对象。可以注意到，在本例中，<strong>classA</strong> 和 <strong>classB</strong> 都是同一个 <strong>GameObject</strong> 下的组件，所以通过 <strong>GetComponent</strong> 便可以获得另一个脚本变量的引用。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// class A</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classA</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classB b;<br><br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>        b = gameObject.GetComponent (<span class="hljs-string">&quot;ClassB&quot;</span>) <span class="hljs-keyword">as</span> ClassB;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// class B</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">classB</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-keyword">public</span> classA a;<br>    <span class="hljs-comment">// Use this for initialization</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> (<span class="hljs-params"></span>)</span> &#123;<br>       a = gameObject.GetComponent (<span class="hljs-string">&quot;ClassA&quot;</span>) <span class="hljs-keyword">as</span> ClassA;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> (<span class="hljs-params"></span>)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-父子关系的-GameObject-中引用"><a href="#4-1-3-父子关系的-GameObject-中引用" class="headerlink" title="4.1.3 父子关系的 GameObject 中引用"></a>4.1.3 父子关系的 GameObject 中引用</h4><p>把问题引申一步,还是那两个脚本<strong>ClassA</strong>,<strong>ClassB</strong>,不过这回不是绑在同一个<strong>GameObject</strong>上面，而是分辨绑定在两个<strong>GameObject</strong>：Parent(ClassA),Child(ClassB)</p><p><img src="/images/MonoBehaviour%E5%9F%BA%E7%B1%BB/20170327125418710" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>首先还是来尝试拖拽，虽然无法在Unity的编辑器中通过拖拽互相引用脚本(Componet),不过绑定 <strong>GameObject</strong> 是可以的。所以只需要建立两个<strong>public</strong>的变量，然后类型都是 <strong>GameObject</strong>，在Unity里面互相拖拽引用,最后在 <strong>Start</strong> 函数时候通过已经绑定好的 <strong>gameObject</strong> 调用其 <strong>GetComponent</strong> 方法即可。</p><p>的确，这个方法是可行，不过有个更好的方法就是使用 <strong>Transform</strong>。<strong>Transform</strong> 是一个很特殊的<strong>Component</strong>，其内部保留着 <strong>GameObject</strong>之间的显示树结构.所以就上面的例子来说，当要从 <strong>Child</strong> 访问到 <strong>Parent</strong>，只需要在 <strong>Child</strong> 对应的脚本里面写 <code>transform.parent.gameObject.GetComponent() </code>即可</p><p>返过来就相对麻烦一点,因为无法保证一个<strong>parent</strong>只有一个<strong>child</strong>，所以无法简单的使用 <strong>transform.child.gameObject</strong>这样访问, 但是Unity给我们提供了一个很方便的函数，那就是<strong>Find</strong>。</p><p>需要注意的是<strong>Find</strong>只能查找其<strong>Child</strong>,举个复杂点的例子</p><p><strong>Parent-&gt;ChildA-&gt;ChildB-&gt;ChildC</strong></p><p>当在 <strong>Patent</strong> 中想要找到 <strong>ChildC</strong>中的一个<strong>Component</strong>时候，调用 <code>transform.Find(“ChildA/ChildB/ChildC”).gameObject;</code></p><h2 id="5-普通类与继承MonoBehaviour类的区别："><a href="#5-普通类与继承MonoBehaviour类的区别：" class="headerlink" title="5. 普通类与继承MonoBehaviour类的区别："></a>5. 普通类与继承MonoBehaviour类的区别：</h2><ul><li><p>1.继承<strong>MonoBehaviour</strong>的类不需要创建它的实例，也不能自己创建(用new)，因为从<strong>MonoBehaviour</strong>继承过来的类Unity会自动创建实例，并且调用被重载的函数(Awake，Start…..)。</p><p>如果用new会出现警告，警告说的很明显，就是如果继承了MonoBehaviour就不允许你用new创建，你可以用添加组件的方式替代，或者根本没有基类(不继承MonoBehaviour的普通类)，但是好像并不影响程序，这点很奇怪。</p></li><li><p>2.不继承MonoBehaviour不能使用Invoke，Coroutine，print以及生命周期函数等。</p></li><li><p>3.不继承MonoBehaviour不能挂在到Inspector上，也就是说不能当组件使用也不能看到一些数据。</p></li></ul><h2 id="6-MonoBehaviour-的那些坑"><a href="#6-MonoBehaviour-的那些坑" class="headerlink" title="6. MonoBehaviour 的那些坑"></a>6. MonoBehaviour 的那些坑</h2><ul><li><strong>私有（private）</strong>和<strong>保护（protected）</strong>变量只能在<strong>专家模式</strong>中显示。属性不被序列化或显示在检视面板。</li><li>不要使用<strong>命名空间（namespace）</strong></li><li>记得使用 缓存组件查找， 即在<strong>MonoBehaviour</strong>的长远方法中经常被访问的组件最好在把它当作一个私有成员变量存储起来。</li><li>在游戏里经常出现需要检测敌人和我方距离的问题，这时如果要寻找所有的敌人，显然要消耗的运算量太大了，所以最好的办法是将攻击范围使用<strong>Collider</strong>表示，然后将<strong>Collider</strong>的<strong>isTrigger</strong>设置为<strong>True</strong>。最后使用<strong>OnTriggerEnter</strong>来做攻击范围内的距离检测，这样会极大提升程序性能。</li></ul><blockquote><p>整理自: <a href="https://blog.csdn.net/hihozoo/article/details/66970467">https://blog.csdn.net/hihozoo/article/details/66970467</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>基础</category>
      
      <category>常用类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客中添加音乐播放器</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是介绍基于网易云iframe插件在hexo博客中加装音乐播放器的方法，无需安装任何额外插件。</p><h1 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2.安装步骤"></a>2.安装步骤</h1><ol><li><p>在网易云音乐中打开你想要插入的音乐页面，点击 <strong>生成外联播放器</strong>。</p></li><li><p>在网页中调整好播放器插件后，复制下方的HTML代码。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">330</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=1488285208&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打开本地架设hexo博客的文件夹，寻找正在使用主题文件夹下的layout文件夹。</p><p>例如我在使用的fluid主题的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">F:\MyBlog\node_modules\hexo-theme-fluid\layout<br></code></pre></td></tr></table></figure></li><li><p>在layout文件夹下寻找你想要添加音乐播放器位置的ejs文件。</p><p>例如我想放在所有页面的页脚，则ejs文件的路径是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\layout\_partial\footer.ejs<br></code></pre></td></tr></table></figure></li><li><p>打开ejs文件(可以用vscode或者记事本)，找到生成相关位置html文件的代码。</p><p>这些ejs文件相当于是生成html文件的模板。</p></li><li><p>将复制来的HTML代码加上div加进相关的位置</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-center mt-5 py-3&quot;</span>&gt;</span>//原本的页脚生成代码<br>--------------------------------------------------------<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;music-player&quot;</span>&gt;</span>//复制来的外链播放器插件代码<br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginwidth</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">marginheight</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">530</span> <span class="hljs-attr">height</span>=<span class="hljs-string">86</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//music.163.com/outchain/player?type=2&amp;id=572328440&amp;auto=1&amp;height=66&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;&gt;</span><br>---------------------------------------------------------<br>  //原本的页脚生成代码<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;footer-content&quot;</span>&gt;</span><br>  &lt;%- theme.footer.content %&gt;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> &lt;%- partial(&#x27;_partial/statistics.ejs&#x27;) %&gt;<br> &lt;%- partial(&#x27;_partial/beian.ejs&#x27;) %&gt;<br> &lt;% if(theme.web_analytics.cnzz) &#123; %&gt;<br>  *<span class="hljs-comment">&lt;!-- cnzz Analytics Icon --&gt;</span>*<br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cnzz_stat_icon_&lt;%- theme.web_analytics.cnzz %&gt;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br> &lt;% &#125; %&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>清理服务器缓存后再重新部署，音乐播放器就出现在对应位置了！</p></li></ol><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h1><blockquote><p>音乐不能是网易云里的VIP音乐，它是不会给你播的</p></blockquote><blockquote><p>当页面转换或者刷新时，播放器状态将被重置，目前还没有办法解决</p></blockquote><h1 id="4-其它的实现方法"><a href="#4-其它的实现方法" class="headerlink" title="4.其它的实现方法"></a>4.其它的实现方法</h1><p>在hexo框架的基础下，还可以用音乐播放插件<strong>Aplayer</strong>来实现。</p><p>相关链接：<a href="https://aplayer.js.org/#/zh-Hans/"><strong>Aplayer</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown快速入门</title>
    <link href="/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2021/02/18/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言。</p><p>本博客中的所有文章都是用.md文件编写的，而且很多企业也在在鼓励使用这种编辑方式。</p><h1 id="1-基本符号：-gt"><a href="#1-基本符号：-gt" class="headerlink" title="1.基本符号：* - +. &gt;"></a>1.基本符号：* - +. &gt;</h1><p>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</p><h1 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h1><p>分别表示h1-h6,只到h6，而且h1下面会有一条横线。</p><p>有两种方法，一种是只在前面加#，另一种是闭合式标签，两者效果相同。</p><p>例如：</p><p>方法一：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 </span><br><span class="hljs-section">## 二级标题 </span><br><span class="hljs-section">### 三级标题 </span><br><span class="hljs-section">#### 四级标题 </span><br><span class="hljs-section">##### 五级标题 </span><br><span class="hljs-section">###### 六级标题</span><br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 一级标题 # </span><br><span class="hljs-section">## 二级标题 ## </span><br><span class="hljs-section">### 三级标题 ### </span><br><span class="hljs-section">#### 四级标题 #### </span><br><span class="hljs-section">##### 五级标题 ##### </span><br><span class="hljs-section">###### 六级标题 #####</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h1><h2 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//形式一 <br><span class="hljs-bullet">+</span> a <br><span class="hljs-bullet">+</span> b <br><span class="hljs-bullet">+</span> c <br>//形式二<br><span class="hljs-bullet">-</span> d <br><span class="hljs-bullet">-</span> e <br><span class="hljs-bullet">-</span> f <br>//形式三 <br><span class="hljs-bullet">*</span> g <br><span class="hljs-bullet">*</span> h <br><span class="hljs-bullet">*</span> i<br></code></pre></td></tr></table></figure><p>以上三种形式，效果其实都是一样的：</p><ul><li>a </li><li>b </li><li>c </li></ul><ul><li>d </li><li>e </li><li>f </li></ul><ul><li>g </li><li>h </li><li>i</li></ul><h2 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//正常形式<br><span class="hljs-bullet">1.</span> abc<br><span class="hljs-bullet">2.</span> bcd<br><span class="hljs-bullet">3.</span> cde<br>//错序效果<br><span class="hljs-bullet">2.</span> fgh<br><span class="hljs-bullet">3.</span> ghi<br><span class="hljs-bullet">5.</span> hij<br></code></pre></td></tr></table></figure><p>效果如下：</p><ol><li><p>abc</p></li><li><p>bcd</p></li><li><p>cde</p></li><li><p>fgh</p></li><li><p>ghi</p></li><li><p>hij</p></li></ol><blockquote><p>注意，数字后面的点只能是英文的点，有序列表的序号是根据第一行列表的数字顺序来的，错序列表的序号本来是序号是乱的， 但是还是显示 4 5 6</p></blockquote><h1 id="4-引用说明区块"><a href="#4-引用说明区块" class="headerlink" title="4.引用说明区块"></a>4.引用说明区块</h1><p>对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。</p><h2 id="4-1-正常形式"><a href="#4-1-正常形式" class="headerlink" title="4.1 正常形式"></a>4.1 正常形式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 引用内容、说明内容。</span><br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>引用内容、说明内容。<br>在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</p></blockquote><h2 id="4-2-嵌套区块"><a href="#4-2-嵌套区块" class="headerlink" title="4.2 嵌套区块"></a>4.2 嵌套区块</h2><p>这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 一级引用 </span><br>&gt;&gt; 二级引用 <br>&gt;&gt;&gt; 三级引用 <br>&gt;&gt;&gt;&gt; 四级引用 <br>&gt;&gt;&gt;&gt;&gt; 五级引用 <br>&gt;&gt;&gt;&gt;&gt;&gt; 六级引用<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>一级引用 </p><blockquote><p>二级引用 </p><blockquote><p>三级引用 </p><blockquote><p>四级引用 </p><blockquote><p>五级引用 </p><blockquote><p>六级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5. 代码块"></a>5. 代码块</h1><p>在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。</p><h2 id="5-1-少量代码，单行使用，直接用-包裹起来就行了"><a href="#5-1-少量代码，单行使用，直接用-包裹起来就行了" class="headerlink" title="5.1 少量代码，单行使用，直接用`包裹起来就行了"></a>5.1 少量代码，单行使用，直接用`包裹起来就行了</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`shaoliangdaima,danhangshiyong`</span> <br></code></pre></td></tr></table></figure><p>效果如下：</p><p><code>shaoliangdaima,danhangshiyong</code></p><h2 id="5-2大量代码，需要多行使用，用-包裹起来"><a href="#5-2大量代码，需要多行使用，用-包裹起来" class="headerlink" title="5.2大量代码，需要多行使用，用```包裹起来"></a>5.2大量代码，需要多行使用，用```包裹起来</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">​<span class="hljs-code">```</span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong     </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong    </span><br><span class="hljs-code">daliangdaima,xuyaoduohangshiyong   </span><br><span class="hljs-code">​```</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong     <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong    <br><span class="hljs-built_in">daliangdaima,</span>xuyaoduohangshiyong   <br></code></pre></td></tr></table></figure><h1 id="6-链接"><a href="#6-链接" class="headerlink" title="6.链接"></a>6.链接</h1><h2 id="6-1行内式"><a href="#6-1行内式" class="headerlink" title="6.1行内式"></a>6.1行内式</h2><p>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">烤麸的博客</span>](<span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot;</span>), 是烤麸自己学习用的博客<br></code></pre></td></tr></table></figure><h2 id="6-2参数式"><a href="#6-2参数式" class="headerlink" title="6.2参数式"></a>6.2参数式</h2><p>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/&quot;烤麸的博客&quot; </span><br>[烤麸的博客]是烤麸自己学习用的博客。 <br>//参数定义的其他写法 <br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ &#x27;烤麸的博客&#x27; </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">https://mycroftcooper.github.io/ (烤麸的博客) </span><br>[<span class="hljs-symbol">烤麸的博客</span>]: <span class="hljs-link">&lt;https://mycroftcooper.github.io/&gt; &quot;烤麸的博客&quot;</span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果都是一样的，如下：</p><p><a href="https://mycroftcooper.github.io/%22%E7%83%A4%E9%BA%B8%E7%9A%84%E5%8D%9A%E5%AE%A2%22">烤麸的博客</a>, 是烤麸自己学习用的博客</p><h1 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h1><h2 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1 行内式"></a>7.1 行内式</h2><p>和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）</p><blockquote><p>注意的是[]前要加上!</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">markdown快速入门示例图.png</span>](<span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-2-参数式"><a href="#7-2-参数式" class="headerlink" title="7.2 参数式"></a>7.2 参数式</h2><p>图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-symbol">markdown快速入门示例图.png</span>]: <span class="hljs-link">/markdown快速入门/markdown快速入门示例图.png &quot;markdown快速入门示例图.png&quot; ![markdown快速入门示例图.png] </span><br></code></pre></td></tr></table></figure><p>以上两种方式其效果图都是一样的，如下：</p><p><img src="/images/MarkDown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" srcset="/img/loading.gif" alt="markdown快速入门示例图"></p><h1 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8. 分割线"></a>8. 分割线</h1><p>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">--- - - - ------ *** * * * ****** ___ _ _ _ ______<br></code></pre></td></tr></table></figure><p>以上代码的效果均为：</p><hr><h1 id="9-其他"><a href="#9-其他" class="headerlink" title="9. 其他"></a>9. 其他</h1><h2 id="9-1-强调字体"><a href="#9-1-强调字体" class="headerlink" title="9.1 强调字体"></a>9.1 强调字体</h2><p>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*md*</span>   <span class="hljs-strong">**md**</span> <span class="hljs-emphasis">_md_</span>   <span class="hljs-strong">__md__</span><br></code></pre></td></tr></table></figure><p>效果：<br><em>md</em><br><strong>md</strong><br><em>md</em><br><strong>md</strong></p><h2 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h2><p>基本上和js转义一样,\加需要转义的字符</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\\ <br>\<span class="hljs-emphasis">* </span><br><span class="hljs-emphasis">\+ </span><br><span class="hljs-emphasis">\- </span><br><span class="hljs-emphasis">\` </span><br><span class="hljs-emphasis">\_</span><br></code></pre></td></tr></table></figure><h2 id="9-3-删除线"><a href="#9-3-删除线" class="headerlink" title="9.3 删除线"></a>9.3 删除线</h2><p>用~~把需要显示删除线的字符包裹起来</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">~~删除~~<br></code></pre></td></tr></table></figure><p>效果：</p><p><del>删除</del></p><h1 id="十、表格"><a href="#十、表格" class="headerlink" title="十、表格"></a>十、表格</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">//例子一 <br>|123|234|345| <br>|:-|:-:|-:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子二 <br>|123|234|345| <br>|:---|:---:|---:| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>|abc|bcd|cde| <br>//例子三 <br>123|234|345 <br>:-|:-:|-: <br>abc|bcd|cde <br>abc|bcd|cde <br>abc|bcd|cde<br></code></pre></td></tr></table></figure><p>上面三个例子的效果一样，由此可得：</p><ol><li><p>表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的</p></li><li><p>分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中</p></li></ol><p>效果如下：</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>整理自：<a href="https://www.jianshu.com/p/399e5a3c7cc5">https://www.jianshu.com/p/399e5a3c7cc5</a></p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>博客使用手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客使用手册</title>
    <link href="/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2021/02/18/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>本篇文章是关于hexo框架下博客的使用方法总结，以便更好的学习与使用博客整理笔记。</p><h1 id="2-写作"><a href="#2-写作" class="headerlink" title="2. 写作"></a>2. 写作</h1><p>要创建新帖子或新页面，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] <span class="hljs-string">&quot;title&quot;</span><br></code></pre></td></tr></table></figure><p>其中<code>[layout]</code>是可选参数<code>布局</code>，<code>布局</code>分为以下几种：</p><table><thead><tr><th align="left">布局</th><th align="left">保存路径</th><th>用途</th></tr></thead><tbody><tr><td align="left">post</td><td align="left">source/_posts</td><td>创建新文章</td></tr><tr><td align="left">page</td><td align="left">source</td><td>创建新页面</td></tr><tr><td align="left">draft</td><td align="left">source/_drafts</td><td>创建新草稿</td></tr></tbody></table><p>该指令可以增加附加选项：</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--path</code></td><td align="left">发布路径。自定义帖子的路径。</td></tr><tr><td align="left"><code>-r</code>， <code>--replace</code></td><td align="left">替换当前帖子（如果存在）。</td></tr><tr><td align="left"><code>-s</code>， <code>--slug</code></td><td align="left">文章缩略名，自定义帖子的URL。</td></tr></tbody></table><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-文档名称"><a href="#2-1-文档名称" class="headerlink" title="2.1 文档名称"></a>2.1 文档名称</h2><p>默认情况下，Hexo使用帖子标题作为其文件名。您可以在<code>_config.yml</code>中编辑<code>new_post_name</code>设置以更改默认文件名。</p><p>例如，<code>:year-:month-:day-:title.md</code>在文件名前加上创建日期。</p><p>您可以使用以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">帖子标题（小写，空格用连字符代替）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">创建年份，例如 <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">创建的月份（前导零），例如 <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">创建的月份（无前导零），例如 <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">创建日期（前导零），例如 <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">创建日期（无前导零），例如 <code>7</code></td></tr></tbody></table><h2 id="2-2-文档头"><a href="#2-2-文档头" class="headerlink" title="2.2 文档头"></a>2.2 文档头</h2><p>当新建.md文档后，打开文档可以看见如下文件头：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">title: hexo博客使用手册<br>date: 2021-02-18 14:11:04<br>tags: 博客使用手册<br>categories: 博客使用手册<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title:</code></td><td align="left">帖子标题</td></tr><tr><td align="left"><code>date:</code></td><td align="left">创建日期</td></tr><tr><td align="left"><code>tags:</code></td><td align="left">帖子所属标签</td></tr><tr><td align="left"><code>categories:</code></td><td align="left">帖子所属分类(需要手动添加)</td></tr></tbody></table><p>当想要新增标签与分类时，直接创建新的文档后在文件头填写参数即可。</p><p>多个标签时使用：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">tags:</span>  <br><br>- [tag1]<br><br>- [tag2]<br></code></pre></td></tr></table></figure><p>含父子分类时，将父类写在前，子类写在后:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">categories: <br><span class="hljs-bullet">-</span> [categorie1]<br><span class="hljs-bullet">-</span> [categorie2]<br></code></pre></td></tr></table></figure><h2 id="2-3-添加图片"><a href="#2-3-添加图片" class="headerlink" title="2.3 添加图片"></a>2.3 添加图片</h2><p>关于图片和图片路径的设置，有以下教程。</p><p>事先声明，所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p><p>首先在 <code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p><p>然后打开Typora的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p><p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" alt="插入图片设置"></p><p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p><p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p><p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。</p><p><strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！</strong></p><h2 id="2-4-草稿"><a href="#2-4-草稿" class="headerlink" title="2.4 草稿"></a>2.4 草稿</h2><p><code>draft</code>布局初始化的帖子将保存到该<code>source/_drafts</code>文件夹中。</p><p>您可以使用<code>publish</code>命令将草稿移至<code>source/_posts</code>文件夹。</p><p><code>publish</code>命令与<code>new</code>命令相似。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>默认不显示草稿。</p><p>您可以在运行Hexo时添加选项<code>--draft</code>，也可以在<code>_config.yml</code>中启用<code>render_drafts</code>设置以渲染草稿。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --draft<br></code></pre></td></tr></table></figure><p>显示草稿（存储在<code>source/_drafts</code>文件夹中）。</p><h2 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h2><p>创建帖子时，Hexo将基于文件<code>scaffolds</code>夹中的相应模板文件来构建文件。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new photo <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>当您运行此命令时，Hexo将尝试在<code>scaffolds</code>文件夹中查找<code>photo.md</code>，并基于该文件构建帖子。模板中提供以下占位符：</p><table><thead><tr><th align="left">占位符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件创建日期</td></tr></tbody></table><h2 id="2-6-支持的格式"><a href="#2-6-支持的格式" class="headerlink" title="2.6 支持的格式"></a>2.6 支持的格式</h2><p>只要安装了相应的渲染器插件，Hexo支持帖子就可以以任何格式编写。、</p><p>本博客支持的编写格式：<code>markdown</code>，<code>ejs</code>。</p><h1 id="3-服务器指令"><a href="#3-服务器指令" class="headerlink" title="3. 服务器指令"></a>3. 服务器指令</h1><h2 id="3-1-init-安装指令"><a href="#3-1-init-安装指令" class="headerlink" title="3.1 init 安装指令"></a>3.1 init 安装指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init [folder]<br></code></pre></td></tr></table></figure><p>将hexo框架文件安装到当前/指定文件夹内。</p><h2 id="3-2-server-本地服务器启动指令"><a href="#3-2-server-本地服务器启动指令" class="headerlink" title="3.2 server 本地服务器启动指令"></a>3.2 server 本地服务器启动指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server 或 $ hexo s<br></code></pre></td></tr></table></figure><p>启动本地服务器。默认情况下，该位置为<code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>， <code>--port</code></td><td align="left">覆盖默认端口</td></tr><tr><td align="left"><code>-s</code>， <code>--static</code></td><td align="left">仅提供静态文件</td></tr><tr><td align="left"><code>-l</code>， <code>--log</code></td><td align="left">启用记录器。覆盖记录器格式。</td></tr></tbody></table><h2 id="3-3-deploy-部署指令"><a href="#3-3-deploy-部署指令" class="headerlink" title="3.3 deploy 部署指令"></a>3.3 deploy 部署指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy 或 $ hexo d<br></code></pre></td></tr></table></figure><p>部署您的网站。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>， <code>--generate</code></td><td align="left">部署前生成</td></tr></tbody></table><h2 id="3-4-clean-清除缓存指令"><a href="#3-4-clean-清除缓存指令" class="headerlink" title="3.4 clean 清除缓存指令"></a>3.4 clean 清除缓存指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean <br></code></pre></td></tr></table></figure><p>清除缓存文件（<code>db.json</code>）和生成的文件（<code>public</code>）。</p><h2 id="3-5-version查看版本指令"><a href="#3-5-version查看版本指令" class="headerlink" title="3.5 version查看版本指令"></a>3.5 version查看版本指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo version 或 $ hexo v<br></code></pre></td></tr></table></figure><p>显示版本信息。</p><h2 id="3-6-选项"><a href="#3-6-选项" class="headerlink" title="3.6 选项"></a>3.6 选项</h2><h3 id="3-6-1-安全模式"><a href="#3-6-1-安全模式" class="headerlink" title="3.6.1 安全模式"></a>3.6.1 安全模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --safe<br></code></pre></td></tr></table></figure><p>禁用加载插件和脚本。如果在安装新插件后遇到问题，请尝试此操作。</p><h3 id="3-6-2-调试模式"><a href="#3-6-2-调试模式" class="headerlink" title="3.6.2 调试模式"></a>3.6.2 调试模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --debug<br></code></pre></td></tr></table></figure><p>将详细消息记录到终端和<code>debug.log</code>。如果遇到Hexo任何问题，请尝试此操作。如果看到错误，请<a href="https://github.com/hexojs/hexo/issues/new">提出GitHub问题</a>。</p><h3 id="3-6-3-静音模式"><a href="#3-6-3-静音模式" class="headerlink" title="3.6.3 静音模式"></a>3.6.3 静音模式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --silent<br></code></pre></td></tr></table></figure><p>静音输出到终端。</p><h3 id="3-6-4-自定义配置文件路径"><a href="#3-6-4-自定义配置文件路径" class="headerlink" title="3.6.4 自定义配置文件路径"></a>3.6.4 自定义配置文件路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml<br></code></pre></td></tr></table></figure><p>使用自定义配置文件（而不是<code>_config.yml</code>）。</p><p>还接受以逗号分隔的JSON或YAML配置文件列表，该列表会将文件合并为一个<code>_multiconfig.yml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --config custom.yml，custom2.json<br></code></pre></td></tr></table></figure><h3 id="3-6-5-自定义CWD"><a href="#3-6-5-自定义CWD" class="headerlink" title="3.6.5 自定义CWD"></a>3.6.5 自定义CWD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo --cwd / path / to / cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录的路径。</p>]]></content>
    
    
    <categories>
      
      <category>博客使用手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客使用手册</tag>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
